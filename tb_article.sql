/*
 Navicat Premium Data Transfer

 Source Server         : 154.8.230.202腾讯云
 Source Server Type    : MySQL
 Source Server Version : 50739
 Source Host           : 154.8.230.202:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 50739
 File Encoding         : 65001

 Date: 26/10/2022 21:35:45
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for tb_article
-- ----------------------------
DROP TABLE IF EXISTS `tb_article`;
CREATE TABLE `tb_article`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL COMMENT '作者',
  `category_id` int(11) NULL DEFAULT NULL COMMENT '文章分类',
  `article_cover` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '文章缩略图',
  `article_title` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '标题',
  `article_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '内容',
  `type` tinyint(1) NOT NULL DEFAULT 0 COMMENT '文章类型 1原创 2转载 3翻译',
  `original_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '原文链接',
  `is_top` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否置顶 0否 1是',
  `is_delete` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否删除  0否 1是',
  `status` tinyint(1) NOT NULL DEFAULT 1 COMMENT '状态值 1公开 2私密 3评论可见',
  `create_time` datetime NOT NULL COMMENT '发表时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 300 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_article
-- ----------------------------
INSERT INTO `tb_article` VALUES (54, 1, 187, 'https://static.talkxj.com/articles/3dffb2fcbd541886616ab54c92570de3.jpg', '测试文章', '恭喜你成功运行博客，开启你的文章之旅吧。', 1, '', 0, 0, 1, '2022-01-24 23:33:56', NULL);
INSERT INTO `tb_article` VALUES (55, 1, 187, 'null&time=767228', '2022-10-26', 'q1111', 1, '', 0, 0, 1, '2022-10-26 16:28:32', '2022-10-26 16:50:02');
INSERT INTO `tb_article` VALUES (56, 1, 199, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=205850', '2022-10-26', '## 自语\n- 大家好，我是一枚刚入门的后端开发工程师👨🏻‍💻，在读研究生，目前主攻Java后端开发.\n- 我希望用代码改变世界,我也在改变世界,自豪脸😏\n- 目前正走在成为一个~~厉害~~(Zhuang Bi)程序猿的路上. 前途很艰辛, 但是我会坚持!\n- 生活不止有撸码和工作, 也有诗和远方. 在快乐中生活, 在快乐中工作, 爱家人, 爱自己\n\n**子曰：生而知之者，上也；学而知之者，次也；困而学之，又其次也；困而不学，民斯为下矣。\n人生得意须尽欢，莫使金樽空对月。\n少小须勤学，文章可立身。满朝朱紫贵，尽是读书人。**\n\n## 技能\n- 语言：Java, JavaScript, HTML, CSS\n- 数据库：MySQL, Redis, Oracle\n- 开发框架：Spring, Spring Boot, Spring Cloud Alibaba, MyBatis, Shiro, JQuery，Bootstrap，Layui，Vue\n- 交互协议：TCP/IP，Netty，MQTT，WebSocket\n- 中间件：Kafka, Zookeeper,MyCat\n- 构建工具： Maven, Tomcat\n- 环境： Centos, Linux, Git,Eclipse, Intellij IDEA\n## 学习\n- 有道是学无止境，Java 后端开发的路很难走，但是既然走了这条路，那就得一直走下去。\n- Java 相关的技术栈很多，学起来很不容易，最近两年的行情也是优胜劣汰，希望自己能够快速成长起来。\n- 夯实基础，学习源码。\n- 初识**知识图谱**，希望在这条路上也有所成长。\n\n++问渠哪得清如许？为有源头活水来。++\n> 要问为什么方塘的水会如此清澈？是由于有永不枯竭的源头为它源源不断地输送活水啊。\n诗句常用来比喻知识是不断更新和发展的，需要不断积累，就像水源头一样，在人生的学习中不断地学习、运用和探索，才能使自己永葆先进和活力。\n\n## 博客\n- 期望：平时生活和工作一种记录, 希望之后回过头再来看自己的博客也会有所收获或感想\n- 技术、感想与生活\n- 对生活和学习的一个记录\n- 希望自己越来越强大，为了自己所爱的人\n\n## 分享\n\n最喜欢的一首诗，与你共勉：\n\n> **大鹏一日同风起，抟摇直上九万里。\n 假令风歇时下来，犹能簸却沧溟水。\n 世人见我恒殊调，闻余大言皆冷笑。\n 宣父犹能畏后生，丈夫未可轻年少。**', 1, '', 0, 0, 1, '2022-10-26 16:50:49', NULL);
INSERT INTO `tb_article` VALUES (57, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8275', 'Hello Halo', '<h2 id=\"hello-halo\">Hello Halo</h2>\n<p>如果你看到了这一篇文章，那么证明你已经安装成功了，感谢使用 <a href=\"https://halo.run\">Halo</a> 进行创作，希望能够使用愉快。</p>\n<h2 id=\"相关链接\">相关链接</h2>\n<ul>\n<li>官网：<a href=\"https://halo.run\">https://halo.run</a></li>\n<li>社区：<a href=\"https://bbs.halo.run\">https://bbs.halo.run</a></li>\n<li>主题仓库：<a href=\"https://halo.run/s/themes\">https://halo.run/s/themes</a></li>\n<li>开源地址：<a href=\"https://github.com/halo-dev/halo\">https://github.com/halo-dev/halo</a></li>\n</ul>\n<p>在使用过程中，有任何问题都可以通过以上链接找寻答案，或者联系我们。</p>\n<blockquote>\n<p>这是一篇自动生成的文章，请删除这篇文章之后开始你的创作吧！</p>\n</blockquote>\n', 1, '', 0, 0, 1, '2020-04-24 18:38:38', '2022-05-21 18:21:34');
INSERT INTO `tb_article` VALUES (58, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3217', '关于我', '<h2 id=\"%E8%87%AA%E8%AF%AD\" tabindex=\"-1\">自语</h2>\n<ul>\n<li>大家好，我是一枚刚入门的后端开发工程师👨🏻‍💻，在读研究生，目前主攻Java后端开发.</li>\n<li>我希望用代码改变世界,我也在改变世界,自豪脸😏</li>\n<li>目前正走在成为一个<s>厉害</s>(Zhuang Bi)程序猿的路上. 前途很艰辛, 但是我会坚持!</li>\n<li>生活不止有撸码和工作, 也有诗和远方. 在快乐中生活, 在快乐中工作, 爱家人, 爱自己</li>\n</ul>\n<p><strong>子曰：生而知之者，上也；学而知之者，次也；困而学之，又其次也；困而不学，民斯为下矣。<br />\n人生得意须尽欢，莫使金樽空对月。<br />\n少小须勤学，文章可立身。满朝朱紫贵，尽是读书人。</strong></p>\n<h2 id=\"%E6%8A%80%E8%83%BD\" tabindex=\"-1\">技能</h2>\n<ul>\n<li>语言：Java, JavaScript, HTML, CSS</li>\n<li>数据库：MySQL, Redis, Oracle</li>\n<li>开发框架：Spring, Spring Boot, Spring Cloud Alibaba, MyBatis, Shiro, JQuery，Bootstrap，Layui，Vue</li>\n<li>交互协议：TCP/IP，Netty，MQTT，WebSocket</li>\n<li>中间件：Kafka, Zookeeper,MyCat</li>\n<li>构建工具： Maven, Tomcat</li>\n<li>环境： Centos, Linux, Git,Eclipse, Intellij IDEA</li>\n</ul>\n<h2 id=\"%E5%AD%A6%E4%B9%A0\" tabindex=\"-1\">学习</h2>\n<ul>\n<li>有道是学无止境，Java 后端开发的路很难走，但是既然走了这条路，那就得一直走下去。</li>\n<li>Java 相关的技术栈很多，学起来很不容易，最近两年的行情也是优胜劣汰，希望自己能够快速成长起来。</li>\n<li>夯实基础，学习源码。</li>\n<li>初识<strong>知识图谱</strong>，希望在这条路上也有所成长。</li>\n</ul>\n<p><ins>问渠哪得清如许？为有源头活水来。</ins></p>\n<blockquote>\n<p>要问为什么方塘的水会如此清澈？是由于有永不枯竭的源头为它源源不断地输送活水啊。<br />\n诗句常用来比喻知识是不断更新和发展的，需要不断积累，就像水源头一样，在人生的学习中不断地学习、运用和探索，才能使自己永葆先进和活力。</p>\n</blockquote>\n<h2 id=\"%E5%8D%9A%E5%AE%A2\" tabindex=\"-1\">博客</h2>\n<ul>\n<li>期望：平时生活和工作一种记录, 希望之后回过头再来看自己的博客也会有所收获或感想</li>\n<li>技术、感想与生活</li>\n<li>对生活和学习的一个记录</li>\n<li>希望自己越来越强大，为了自己所爱的人</li>\n</ul>\n<h2 id=\"%E5%88%86%E4%BA%AB\" tabindex=\"-1\">分享</h2>\n<p>最喜欢的一首诗，与你共勉：</p>\n<blockquote>\n<p><strong>大鹏一日同风起，抟摇直上九万里。<br />\n假令风歇时下来，犹能簸却沧溟水。<br />\n世人见我恒殊调，闻余大言皆冷笑。<br />\n宣父犹能畏后生，丈夫未可轻年少。</strong></p>\n</blockquote>\n', 1, '', 0, 0, 1, '2020-10-07 12:41:27', '2022-08-02 11:19:04');
INSERT INTO `tb_article` VALUES (59, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5189', 'Springboot多模块配置详细教程+源码案例+所遇到的坑', '<h3 id=\"springboot多模块配置详细教程\">Springboot多模块配置详细教程</h3>\n<blockquote>\n<p>这两天参考了下若依大神的后台管理项目，感觉程序的健壮性是真的强大，本人佩服的五体投地，很多程序设计技巧规范非常值得我去学习，其中第一个便是Springboot的多模块化配置，也正好项目中需要，所以特地学习一下，但是实际操作中遇到了很多问题，特此记录一下。</p>\n</blockquote>\n<h6 id=\"进行多模块配置的好处maven多模块项目通常由一个父模块和若干个子模块构成每个模块都对应着一个pomxml它们之间通过继承和聚合也称作多模块相互关联多模块适用于一些比较大的项目通过合理的模块拆分实现代码的复用便于维护和管理\">进行多模块配置的好处：maven多模块项目通常由一个父模块和若干个子模块构成，每个模块都对应着一个pom.xml。它们之间通过继承和聚合（也称作多模块）相互关联。多模块适用于一些比较大的项目，通过合理的模块拆分，实现代码的复用，便于维护和管理。</h6>\n<p>在开始动手之前，我们先捋一捋每个模块的作用，清楚需求做事才有目的。之后再说如何创建：<br />\n<img src=\"https://img-blog.csdnimg.cn/20191231180812711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n首先，如上图所示，我这里分了四个子模块和一个父模块。</p>\n<p>其中ww_system模块主要放entity、service、serviceImpl、mapper等文件。<br />\nww_common主要放一些公共的工具类，<br />\nww_blog是我的前台controller控制器<br />\nww_admin 是系统的web启动入口，包括系统后台controller都在这。是整个系统启动的入口。</p>\n<p>有心的朋友可以再单独把service也单独抽出来做一个模块，不过我觉得没有必要，用了mybatisplus之后service和mapper就很少写了。</p>\n<h3 id=\"如何创建\">如何创建？</h3>\n<h4 id=\"1创建父模块\">1，创建父模块</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20191231181705863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n父模块的创建和平常我们创建Springboot项目没法不同，一步一步来就行了，不过既然是父模块，那么它显然是不需要src目录的，所以创建后直接删掉它就行。其他的东西爱删不删，<strong>留下pom文件就行。</strong></p>\n<h4 id=\"2创建子模块\">2，创建子模块。</h4>\n<p>创建子模块的时候不要直接在左上角new -&gt;project来创建。要选择我们刚创建好的父模块项目，在它上面右击创建new module。<br />\n<img src=\"https://img-blog.csdnimg.cn/20191231182055709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n然后一直下一步就行，这里还没有什么要注意的地方，按照这种方式在父模块上右键创建其余的另外三个子模块。</p>\n<h4 id=\"3重点配置依赖\">3，重点：配置依赖</h4>\n<p>都创建好之后就是重点了，要配置我们几个模块之间的关联关系，<br />\n大致思路就是：所有的子模块都继承父模块<br />\nww_admin和ww_blog两个带控制器的模块要引用ww_system和ww_common公共模块。<br />\n公共模块ww_common不依赖任何模块，只补充它所需要的jar包坐标就行</p>\n<p>然后，父模块pom中不需要配置build打包配置</p>\n<h6 id=\"父模块pom文件内容\">父模块pom文件内容：</h6>\n<p><strong>注意模块引用和modules标签！！！！</strong></p>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.macw&lt;/groupId&gt;\n    &lt;artifactId&gt;wwblog&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n\n    &lt;name&gt;wwblog&lt;/name&gt;\n    &lt;url&gt;http://www.henaumcw.top&lt;/url&gt;\n    &lt;description&gt;马超伟●个人博客系统&lt;/description&gt;\n\n    &lt;properties&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n        &lt;macw.version&gt;1.0.0&lt;/macw.version&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n        &lt;shiro.version&gt;1.4.2&lt;/shiro.version&gt;\n        &lt;thymeleaf.extras.shiro.version&gt;2.0.0&lt;/thymeleaf.extras.shiro.version&gt;\n        &lt;druid.version&gt;1.1.14&lt;/druid.version&gt;\n    &lt;/properties&gt;\n\n    &lt;modules&gt;\n        &lt;module&gt;ww_admin&lt;/module&gt;\n        &lt;module&gt;ww_blog&lt;/module&gt;\n        &lt;module&gt;ww_system&lt;/module&gt;\n        &lt;module&gt;ww_common&lt;/module&gt;\n    &lt;/modules&gt;\n    &lt;packaging&gt;pom&lt;/packaging&gt;\n\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;!-- SpringBoot的依赖配置--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;\n                &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n                &lt;type&gt;pom&lt;/type&gt;\n                &lt;scope&gt;import&lt;/scope&gt;\n            &lt;/dependency&gt;\n            &lt;!--thymeleaf依赖--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n                &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--阿里数据库连接池 --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n                &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;\n                &lt;version&gt;${druid.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!-- 阿里JSON解析器 --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n                &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n                &lt;version&gt;${fastjson.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--系统模块--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.macw&lt;/groupId&gt;\n                &lt;artifactId&gt;ww_system&lt;/artifactId&gt;\n                &lt;version&gt;${macw.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--博客前台模块--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.macw&lt;/groupId&gt;\n                &lt;artifactId&gt;ww_blog&lt;/artifactId&gt;\n                &lt;version&gt;${macw.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--系统后台入口模块--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.macw&lt;/groupId&gt;\n                &lt;artifactId&gt;ww_admin&lt;/artifactId&gt;\n                &lt;version&gt;${macw.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--公共模块--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.macw&lt;/groupId&gt;\n                &lt;artifactId&gt;ww_common&lt;/artifactId&gt;\n                &lt;version&gt;${macw.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.1&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;source&gt;${java.version}&lt;/source&gt;\n                    &lt;target&gt;${java.version}&lt;/target&gt;\n                    &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n    &lt;!--配置阿里云国内镜像--&gt;\n    &lt;repositories&gt;\n        &lt;repository&gt;\n            &lt;id&gt;public&lt;/id&gt;\n            &lt;name&gt;aliyun nexus&lt;/name&gt;\n            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;\n            &lt;releases&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n            &lt;/releases&gt;\n        &lt;/repository&gt;\n    &lt;/repositories&gt;\n&lt;/project&gt;\n\n</code></pre>\n<h6 id=\"ww-systempom文件内容\">ww_system:pom文件内容：</h6>\n<p>注意parent标签和模块引用</p>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;wwblog&lt;/artifactId&gt;\n        &lt;groupId&gt;com.macw&lt;/groupId&gt;\n        &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;groupId&gt;com.macw&lt;/groupId&gt;\n    &lt;artifactId&gt;ww_system&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;name&gt;ww_system&lt;/name&gt;\n    &lt;description&gt;系统模块&lt;/description&gt;\n    &lt;dependencies&gt;\n        &lt;!-- Mysql驱动包 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- 通用工具--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.macw&lt;/groupId&gt;\n            &lt;artifactId&gt;ww_common&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--Mybatis plus--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;\n            &lt;version&gt;3.3.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-extension&lt;/artifactId&gt;\n            &lt;version&gt;3.3.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;\n            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;\n            &lt;version&gt;2.3.28&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n\n</code></pre>\n<h6 id=\"ww-common模块pom文件内容\">ww_common模块pom文件内容：</h6>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;wwblog&lt;/artifactId&gt;\n        &lt;groupId&gt;com.macw&lt;/groupId&gt;\n        &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;groupId&gt;com.macw&lt;/groupId&gt;\n    &lt;artifactId&gt;ww_common&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;name&gt;ww_common&lt;/name&gt;\n    &lt;description&gt;公共模块&lt;/description&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- Spring框架基本的核心工具 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- SpringWeb模块 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;${lombo.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n\n</code></pre>\n<h6 id=\"ww-admin模块pom文件内容\">ww_admin模块pom文件内容：</h6>\n<p><strong>注意这里的模块引用和build标签内容</strong></p>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;wwblog&lt;/artifactId&gt;\n        &lt;groupId&gt;com.macw&lt;/groupId&gt;\n        &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;groupId&gt;com.macw&lt;/groupId&gt;\n    &lt;artifactId&gt;ww_admin&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;name&gt;ww_admin&lt;/name&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n    &lt;description&gt;系统后台●总后台web服务入口模块&lt;/description&gt;\n  \n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- SpringBoot集成thymeleaf模板 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- spring-boot-devtools --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n            &lt;optional&gt;true&lt;/optional&gt; &lt;!-- 表示依赖不会传递 --&gt;\n        &lt;/dependency&gt;\n\n        &lt;!--公共模块--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.macw&lt;/groupId&gt;\n            &lt;artifactId&gt;ww_common&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;!--博客前台--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.macw&lt;/groupId&gt;\n            &lt;artifactId&gt;ww_blog&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;!--系统模块--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.macw&lt;/groupId&gt;\n            &lt;artifactId&gt;ww_system&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;3.3.0&lt;/version&gt;\n        &lt;/dependency&gt;\n\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;fork&gt;true&lt;/fork&gt; &lt;!-- 如果没有该配置，devtools不会生效 --&gt;\n                &lt;/configuration&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;repackage&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n        &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n\n</code></pre>\n<h4 id=\"4-启动入口配置\">4 启动入口配置</h4>\n<p>启动入口只在ww_admin下配置Application启动类就行了，其他模块下不需要。<br />\n需要注意的是启动类一定要放在模块的根目录下，<br />\n我之前就是放在了模块目录下然后就导致了bean注入失败等的许多错误，需要加上@ComponentScan等好几个来进行包扫描，及其麻烦</p>\n<p>所以最好的就是放在根目录下，如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20191231185137914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n如果遇到bean注释失败的错误，那么别问其他，就去找你的包扫描吧，肯定是路径的问题。我就在这里栽了好久好久。<br />\n添加控制器和连接池之后的目录大致是这样的<br />\n<img src=\"https://img-blog.csdnimg.cn/20191231185515837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n由于篇幅限制上面pom文件中删掉了很多与这篇文章讲解无用的依赖。如果报错或无法启动请参考本项目源码：<a href=\"https://gitee.com/macw/wwblog.git\">https://gitee.com/macw/wwblog.git</a></p>\n<p>今天先更新到这，其他有问题闲来再更新</p>\n', 1, '', 0, 0, 1, '2020-04-25 08:33:11', '2022-05-21 18:21:18');
INSERT INTO `tb_article` VALUES (60, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5863', 'centos7系统运行、停止java程序常用命令，springboot打包运行', '<p>﻿</p>\n<h4 id=\"对于spring-boot导出的jar包程序\">对于Spring Boot导出的jar包程序</h4>\n<p>当连接的远程服务器执行的时候，一旦关闭了当前终端，程序也被迫停止运行了。这显然是不行的<br />\n我想要的是让它常驻后台执行，不受启动其终端关闭与否的影响。</p>\n<h5 id=\"解决办法\">解决办法</h5>\n<p>在jar包文件所在的目录执行以下命令：</p>\n<pre><code> nohup java -jar springboot-0.0.1-SNAPSHOT.jar  &gt;nohup 2&gt;&amp;1 &amp;\n</code></pre>\n<p>nohup: 不挂断的执行命令，忽略所有的挂断信号。 运行后台命令 最后加 &amp;<br />\n在jar目录下会生成一个nohup.out文件，默认的log输出到这里了。</p>\n<h5 id=\"命令解释\">命令解释</h5>\n<p>以上命令是不输出启动日志的，运行后会只输出一个运行的进程号。<br />\n想要输出启动日志可以这样：</p>\n<pre><code>java -jar xx.jar &gt; log.file 2&gt;&amp;1 &amp;\n</code></pre>\n<p><strong>这里启动信息就输出到了日志文件上，注意的是log文件需要先创建chmod授权</strong><br />\n可以给日志一个777授权，测试阶段无所谓：</p>\n<pre><code>chmod 777 -R /home/logs\n</code></pre>\n<h5 id=\"21含义\">2&gt;&amp;1含义</h5>\n<p>&amp; 1 更准确的说是文件描述符 1,<br />\n而1 一般代表的就是STDOUT_FILENO,实际上这个操作就是一个dup2(2)调用<br />\n.他标准输出到all_result ,然后复制标准输出到文件描述符2(STDERR_FILENO)， 其后果就是文件描述符1和2指向同一个文件表项,也可以说错误的输出被合并了<br />\n.其中0表示键盘输入 1表示屏幕输出 2表示错误输出.把标准出错重定向到标准输出,然后扔到/DEV/NULL下面去。通俗的说，就是把所有标准输出和标准出错都扔到垃圾桶里面。<br />\n|值|含义  |<br />\n|--|--|<br />\n| 0 |标准输入（一般是键盘）  |<br />\n|1|标准输出（一般是显示屏，准确的说是用户终端控制台）|<br />\n|2|标准错误（出错信息输出）|</p>\n<p>最后一个&amp; ， 是让该命令在后台执行</p>\n<h4 id=\"查看进程\">查看进程</h4>\n<p><strong>查看全部进程</strong></p>\n<pre><code>ps -ef \n</code></pre>\n<p><strong>查看java进程</strong></p>\n<pre><code>ps -ef |grep java\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20200106122724191.png\" alt=\"在这里插入图片描述\" /><br />\n如图所示：<br />\n第一个进程是我jar包启动进程，第二个是java的查找进程不用管<br />\n前面的那个root是当前用户，第一个数字403是当前进程号<br />\n<strong>杀死当前进程</strong></p>\n<pre><code>kill -9 403\n</code></pre>\n<p><strong>只查询当前jar包程序的进程号：</strong></p>\n<pre><code>pgrep -f \'java -jar springboot-0.0.1-SNAPSHOT.jar\'\n</code></pre>\n<p>如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20200106123205274.png\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 15:30:30', '2022-05-21 18:21:05');
INSERT INTO `tb_article` VALUES (61, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=9366', 'SpringBoot在自定义实现类中调用service层等Spring其他层报错为null的解决办法', '<p>﻿## 背景：<br />\n使用Springboot整合Netty写了一个TCP实现客户端服务端通信接收主板信息，然后需要将设备实时发送的检测数据等关键信息存储到数据库，也是为了能最快利用mybatis框架实现数据访问，然后在TCP服务器消息处理时，需要写数据库，直接调用DAO层，编译报错。改为调用Service层，编译正常，运行到调用的地方，报空指针异常，跟踪到异常位置，发现service为空，也就是按照之前controller层通过<br />\n@Autowired注入service层失效。<br />\n解决方案：</p>\n<h2 id=\"1不要用mybatis使用原生的jdbc连接数据库进行存储\">1.不要用mybatis,使用原生的jdbc连接数据库进行存储</h2>\n<p>代码如下：</p>\n<pre><code class=\"language-java\">blic class MessageHandler extends ChannelInboundHandlerAdapter {\n	private static Logger logger = LoggerFactory.getLogger(MessageHandler.class);\n	/**\n	 * 本方法用于读取客户端发送的信息\n	 * @param ctx\n	 * @param msg\n	 * @throws Exception\n	 */\n	@Override\n	public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n    System.out.println(&quot;输出接收过来的信息： &quot;+msg);\n        //将msg进行入库操作\n        //基础的jdbc连接操作，这里省去基础的连接方法\n        String str;\n        // 传递sql语句\n        Statement stt;\n        Connection conn = null;\n        String sql = &quot;insert into test_db(datas) values (\'&quot;+msg+&quot;\')&quot;;  //写SQL\n        try {\n            conn = mysqlimages.getConn();  //一个连接数据库的方法，这就不贴了，很简单的\n            //获取Statement对象\n            stt = conn.createStatement();\n            //执行sql语句\n            stt.executeUpdate(sql);\n            logger.info(&quot;&gt;&gt;&gt;插入数据库成功&quot;);\n            str = Const.SECCESS;\n        }catch (Exception e) {\n            logger.error(&quot;&lt;&lt;&lt;插入数据错误--&quot;+e.getMessage());\n            str = Const.ERROR;\n        }\n</code></pre>\n<p>这种方法可以实现，但是不推荐，本来这里数据量就大，再用jdbc没有连接池将会造成业务阻塞netty本身的worker工作线程。<br />\n所以推荐使用下一种方法：</p>\n<h2 id=\"2使用postconstruct静态初始化spring的成员变量\">2.使用@PostConstruct静态初始化spring的成员变量</h2>\n<p>代码如下：<br />\nchannelRead方法：</p>\n<pre><code class=\"language-java\">	//调用线程池处理大数据量问题\n	ExecutorService executor = Executors.newFixedThreadPool(5);\n    int num=0;\n    \n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        System.out.println();\n        log.info(&quot;加载客户端报文......&quot;);\n        log.info(&quot;【&quot; + ctx.channel().id() + &quot;】&quot; + &quot; :&quot; + msg);\n        /**\n         *  下面可以解析数据，保存数据，生成返回报文，将需要返回报文写入write函数\n         */\n        num++;\n        System.out.println(num);//输出当前已经接收过来的条数\n        //引入异步业务线程池的方式，避免长时间业务耗时业务阻塞netty本身的worker工作线程\n        executor.submit(new Callable&lt;Object&gt;() {\n            @Override\n            public Object call() throws Exception {\n                log.info(&quot;收到服务端发来的方法请求了--------------------------------------------&quot;);\n                ServerHandler handler = new ServerHandler();//这个类在下面\n                handler.test(msg.toString());\n                return null;\n            }\n        });\n        //响应客户端\n        this.channelWrite(ctx.channel().id(), msg);\n    }\n\n\n@Component \npublic class ServerHandler extends IoHandlerAdapter {\n\n    @Autowired\n    private ITest2StaticService test2StaticService;// 注入service方法\n\n    private static ServerHandler serverHandler;\n\n    @PostConstruct //通过@PostConstruct实现初始化bean之前进行的操作\n    //在初始化的时候初始化静态对象和它的静态成员变量healthDataService，原理是拿到service层bean对象，静态存储下来，防止被释放。\n    public void init() {\n        serverHandler = this;\n        serverHandler.test2StaticService = this.test2StaticService;\n        // 初使化时将已静态化的testService实例化\n    }\n\n    //测试调用\n    public void test(String msg) {\n        Test2Static test2Static = new Test2Static();\n        test2Static.setBb(Double.valueOf(msg));\n        test2Static.setCreateTime(LocalDateTime.now());\n        System.out.println(&quot;1111111111111111&quot;);\n        boolean b = serverHandler.test2StaticService.save(test2Static);\n        System.out.println(&quot;---! &quot;+b);\n    }\n\n}\n\nIoHandlerAdapter类 所用到的maven坐标：\n  &lt;!-- https://mvnrepository.com/artifact/org.apache.mina/mina-core --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.mina&lt;/groupId&gt;\n            &lt;artifactId&gt;mina-core&lt;/artifactId&gt;\n            &lt;version&gt;2.1.3&lt;/version&gt;\n        &lt;/dependency&gt;\n\n\n</code></pre>\n<p><strong>2.说明：</strong></p>\n<p>将需要调用Spring的Service层的类通过@Component注解为组件加载；<br />\n同样通过@Autowired获取Service层的Bean对象；<br />\n为类声明一个静态变量，方便下一步存储bean对象；<br />\n<strong>划重点：通过注解@PostConstruct ，在初始化的时候初始化静态对象和它的静态成员变量healthDataService，原理是拿到service层bean对象，静态存储下来，防止被释放。</strong></p>\n<p>找了好久，终于找到这个方法，本来以为很简单，却总是怎么也写不进去数据库。调用service一直为空，可困扰我好久。<br />\n特此记录。。。。。。。。。。。。。。。。。</p>\n<p><strong>那些浪费的时间，都是丢在真理路上的金子~~~~!</strong></p>\n', 1, '', 0, 0, 1, '2020-04-25 15:34:08', '2022-05-21 18:20:49');
INSERT INTO `tb_article` VALUES (62, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=2984', 'java实现微信第三方登录流程源码详解，所遇到的坑', '<p>﻿&gt; 昨天在写一个手机版的web项目，要在微信客户端使用微信第三方登录，想着也没啥，看看就看看吧，但是可恶的微信官方文档给我画了很大的一个坑，特此记录</p>\n<h6 id=\"二次更新说明一下我这个是用我微信网页授权就是在微信客户端点开链接或菜单能弹出微信授权登录框的功能\">二次更新，说明一下我这个是用我微信网页授权，就是在微信客户端点开链接或菜单能弹出微信授权登录框的功能！</h6>\n<p><img src=\"https://img-blog.csdnimg.cn/20191219191009275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n前期准备工作我就不多说了，无非就是公众平台账号，填写相关资料耐心等待审核就好。</p>\n<p>这里要注意一点的是，网站应用创建好之后的<strong>授权回调域填写顶级域名就好</strong>，之前我一直写的二级域名，测试的时候回调总是过不来，后来回来看文档，微信说的就是，<strong>该域名下的所有页面都 可以回调</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20191219100843364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n创建好网站应用之后我们来看微信提供的接口文档</p>\n<p><a href=\"https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html\">微信开放平台第三方登录接口文档地址</a></p>\n<h4 id=\"第一步请求code\">第一步：请求CODE</h4>\n<p>根据官方文档，请求code这里要按照响应的参数进行拼接，参数就按照官方提供的，需要注意的是appid是你用哪个公众号登录就用哪个公众号的appid，<strong>这里不是开放平台的网站应用appid</strong></p>\n<p>然后另一个坑，redirect_uri，一定要用urlEncode对链接进行处理，这个链接是用户打开这个链接同意登录之后会跳转的地址，我们要跳转到后台对回调的信息就行处理，所以就要回调到我们域名下的controller控制器方法中，并且一定是要外网可访问。比如：<a href=\"http://www.test.com/callback\">www.test.com/callback</a><br />\n把链接进行Encode处理，<a href=\"http://www.jsons.cn/urlencode/\">这里提供一个 encode在线解码工具</a></p>\n<p>拼接好路径之后再微信客户端打开就应该会显示某某公众号的授权登录页面了，如果报错那就是路径没有拼接正确</p>\n<p>请求code的控制器如下所示：<br />\n参数是我自己的，换成你的参数就好</p>\n<pre><code class=\"language-java\">    @RequestMapping(&quot;/getCode&quot;)\n    public void getCode(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        //拼接url\n        StringBuilder url = new StringBuilder();\n        url.append(&quot;https://open.weixin.qq.com/connect/oauth2/authorize?&quot;);\n        //微信开放平台的appid\n        url.append(&quot;appid=&quot; + WeixinConfig.appId);\n        //转码\n        try {\n        	//回调地址 ,回调地址要进行Encode转码\n            String redirect_uri = URLEncoder.encode(WeixinConfig.REDIRECT_URI, &quot;utf-8&quot;);\n            System.out.println(&quot;redirect_uri==&quot; + redirect_uri);\n            url.append(&quot;&amp;redirect_uri=&quot; + redirect_uri);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        url.append(&quot;&amp;response_type=code&quot;);\n        url.append(&quot;&amp;scope=snsapi_userinfo&quot;);\n        url.append(&quot;&amp;state=&quot; + request.getSession().getId());\n        url.append(&quot;#wechat_redirect&quot;);\n        System.out.println(&quot;url===&quot; + url.toString());\n//        return &quot;redirect:&quot; + url.toString();\n        String s = url.toString();\n        response.sendRedirect(s);\n    }\n</code></pre>\n<p>返回说明</p>\n<p>用户允许授权后，将会重定向到redirect_uri的网址上，并且带上code和state参数</p>\n<p><strong>第二步：通过code换取网页授权access_token</strong></p>\n<p><strong>第三步：刷新access_token（如果需要）</strong></p>\n<p><strong>第四步：拉取用户信息(需scope为 snsapi_userinfo)</strong></p>\n<p>这三步我们应该在上面授权回调方法中调用，起初我在想每一个方法都要返回一个json，那么是不是我要三个控制器方法才行？，怎样才能在一个控制器里调用三个方法呢？</p>\n<p>感谢大神提供的发送GET请求的工具类：</p>\n<pre><code class=\"language-java\">public static JSONObject doGetJson(String url) throws Exception, IOException {\n        JSONObject jsonObject = null;\n        //初始化httpClient\n        DefaultHttpClient client = new DefaultHttpClient();\n        //用Get方式进行提交\n        HttpGet httpGet = new HttpGet(url);\n        //发送请求\n        HttpResponse response = client.execute(httpGet);\n\n        //获取数据\n        HttpEntity entity = response.getEntity();\n        //格式转换\n        if (entity != null) {\n            String result = EntityUtils.toString(entity, &quot;UTF-8&quot;);\n            jsonObject = JSONObject.fromObject(result);\n        }\n        //释放链接\n        httpGet.releaseConnection();\n        return jsonObject;\n    }\n</code></pre>\n<p>最后附上我的授权回调方法：</p>\n<pre><code class=\"language-java\">  /**\n     * 微信 授权登录回调\n     **/\n    @RequestMapping(&quot;/callback&quot;)\n    public void callback(String code, String state, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        System.out.println(&quot;====&quot; + code + &quot;===&quot; + state + &quot;====&quot;);\n        logger.debug(&quot;code===&quot; + code);\n        logger.debug(&quot;state===&quot; + state);\n        if (StringUtils.isNotEmpty(code)) {\n            logger.debug(&quot;sssssssss====&quot; + code);\n            StringBuilder url = new StringBuilder();\n            url.append(&quot;https://api.weixin.qq.com/sns/oauth2/access_token?&quot;);\n            //微信公众平台的AK和SK\n            url.append(&quot;appid=&quot; + WeixinConfig.appId);\n            url.append(&quot;&amp;secret=&quot; + WeixinConfig.appSecret);\n            //这是微信回调给你的code\n            url.append(&quot;&amp;code=&quot; + code);\n            url.append(&quot;&amp;grant_type=authorization_code&quot;);\n            System.out.println(&quot;url.toString()===&quot; + url.toString());\n            logger.debug(&quot;url.toString()===&quot; + url.toString());\n\n            JSONObject jsonObject = AuthUtil.doGetJson(url.toString());\n            logger.debug(&quot;jsonObject================&quot;+jsonObject);\n            //解析jsonStr的字符串\n            //1.获取微信用户的openid\n            String openid = jsonObject.getString(&quot;openid&quot;);\n\n            //2.获取获取access_token\n            String access_token = jsonObject.getString(&quot;access_token&quot;);\n\n            logger.debug(&quot;openid===&quot; + openid);\n            logger.debug(&quot;access_token===&quot; + access_token);\n\n            String infoUrl = &quot;https://api.weixin.qq.com/sns/userinfo?access_token=&quot; + access_token + &quot;&amp;openid=&quot; + openid\n                    + &quot;&amp;lang=zh_CN&quot;;\n            logger.debug(&quot;infoUrl===&quot; + infoUrl);\n\n            //3.获取微信用户信息\n            JSONObject userInfo = AuthUtil.doGetJson(infoUrl);\n            logger.debug(&quot;userInfo======================&quot;+userInfo);\n            //至此拿到了微信用户的所有信息,剩下的就是业务逻辑处理部分了\n            //保存openid和access_token到session\n            if (openid==null){\n                logger.debug(&quot;-------------------------微信授权回调，获取用户信息失败！=============================&quot;);\n                response.sendRedirect(&quot;http://m.huerdai.net/html/Program-error.html&quot;);\n                return;\n            }\n            request.getSession().setAttribute(&quot;openid&quot;, openid);\n            request.getSession().setAttribute(&quot;access_token&quot;, access_token);\n\n            logger.debug(&quot;openid===&quot; + openid);\n            logger.debug(&quot;access_token===&quot; + access_token);\n\n            String sessionid = getRequest().getSession().getId();\n            //去数据库查询有没有这个 openid\n            CustomerInfo customerInfoServiceOne = iCustomerInfoService.getOne(new QueryWrapper&lt;CustomerInfo&gt;().eq(&quot;openid&quot;, openid));\n            //如果没有这一个用户，则创建\n            if (customerInfoServiceOne == null) {\n                CustomerInfo customerInfo = new CustomerInfo();\n              	//省略实体set方法\n                boolean save = registerService.register(customerInfo);\n                if (save) {\n                    logger.debug(&quot;首次认证:http://m.huerdai.net&quot;);\n                    redisTemplate.opsForValue().set(sessionid, customerInfoServiceOne.getCustomerId());\n//                    response.sendRedirect(&quot;http://m.huerdai.net/index.html&quot;);\n                    response.sendRedirect(&quot;http://m.huerdai.net/html/bind-tel.html&quot;);\n                    return;\n                } else {\n                    logger.debug(&quot;认证失败！&quot;);\n                    response.sendRedirect(&quot;http://m.huerdai.net/error.html&quot;);\n                    return;\n                }\n            } else {\n                //已经授权过，没有绑定手机号，也是直接跳转到首页\n                redisTemplate.opsForValue().set(sessionid, customerInfoServiceOne.getCustomerId());\n                if (customerInfoServiceOne.getMobilePhone() == null) {\n                    logger.debug(&quot;已经授权过，没有绑定手机号，也是直接跳转到首页&quot;);\n                    //并且将用户信息存到Redis中\n//                    response.sendRedirect(&quot;http://m.huerdai.net/index.html&quot;);\n                    response.sendRedirect(&quot;http://m.huerdai.net/html/bind-tel.html&quot;);\n                    return;\n                } else {\n                    //已经授权过，并且已经绑定手机号\n                    logger.debug(&quot;有openid的跳转http://m.huerdai.net222222&quot;);\n                    response.sendRedirect(&quot;http://m.huerdai.net/index.html&quot;);\n                    return;\n                }\n\n            }\n\n        } else {\n            logger.debug(&quot;code获取失败！====&quot; + code);\n            // return new ModelAndView(&quot;redirect:http://m.huerdai.net/error.html&quot;);\n            response.sendRedirect(&quot;http://m.huerdai.net/error.html&quot;);\n        }\n    }\n</code></pre>\n<p>到这里就微信登录并且获取用户信息就算完成了，</p>\n<p>然后我遇到一个问题就是用户首次登录进来的时候会报openid找不到异常，第二次进来就好了，也没有其他报错信息，期待有大佬路过指正问题原因，感激不尽！</p>\n<p>这之间其他的一些问题异常和容易碰到的坑以后有时间再总结！</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:35:49', '2022-05-21 18:20:38');
INSERT INTO `tb_article` VALUES (63, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8946', 'Springboot自定义注解实现操作日志管理', '<p>﻿## 操作日志的记录</p>\n<p><strong>为什么要有日志？</strong><br />\n因为我们不光要记录代码的运行，如（logback log4j），而且还应该记录用户的行为，这叫做<strong>业务运行日志</strong></p>\n<blockquote>\n<p>例如：记录 zhangsan 在项目中 调用了哪个方法， 什么时间调用的 。访问的ip地址，  访问了哪些数据，做了什么操作，以此当程序出现问题的时候更利于我们进行错误的排查！</p>\n</blockquote>\n<p><strong>业务运行日志的作用</strong></p>\n<ol>\n<li>记录用户的行为 用于后续的分析</li>\n<li>记录用户的所有的操作</li>\n</ol>\n<p><strong>业务运行日志最常用的使用场景：记录管理员所有的行为操作， 可以用于业务分析，事故恢复</strong></p>\n<h3 id=\"日志实现的思路\">日志实现的思路</h3>\n<h4 id=\"1我们需要记录哪些数据--存入数据库\">1.我们需要记录哪些数据  存入数据库</h4>\n<p>这里列出一个我所用的表结构，如下所示：</p>\n<table>\n<thead>\n<tr><th>字段</th><th>含义</th></tr>\n</thead>\n<tbody>\n<tr><td>log_id</td><td>主键</td></tr>\n<tr><td>log_date</td><td>时间</td></tr>\n<tr><td>log_content</td><td>操作内容  例如：查询全部菜单信息  添加用户数据</td></tr>\n<tr><td>log_name_id</td><td>用户的id</td></tr>\n<tr><td>log_ip</td><td>用户的ip地址</td></tr>\n<tr><td>log_type</td><td>操作类型</td></tr>\n</tbody>\n</table>\n<h4 id=\"2在项目中什么位置记录\">2.在项目中什么位置记录</h4>\n<blockquote>\n<p>日志记录是一个数据库的添加操作 是一段代码</p>\n</blockquote>\n<p><strong>通常，我们在Controller方法进行后置增强</strong><br />\n如下图所示，我们在需要记录操作的controller上使用aop配置一个切入点，以此来记录用户所进行的操作<br />\n<img src=\"https://img-blog.csdnimg.cn/20191211145643492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"3如何实现记录功能\">3.如何实现记录功能</h4>\n<p>实现方式：AOP</p>\n<h4 id=\"4aop日志记录-具体代码实现\">4.Aop日志记录 具体代码实现</h4>\n<p>aop的使用流程，这里使用注解式aop来实现<br />\n具体步骤：</p>\n<ol>\n<li>\n<p>设置切入点</p>\n<ol>\n<li>可以切在方法上</li>\n<li>可以切在注解上\n<pre><code>@Transactional 事务注解 注解加在类上 aop 切在注解上\n</code></pre>\n</li>\n</ol>\n</li>\n<li>\n<p>写增强 日志记录增强</p>\n<ol>\n<li>获取日志的相关信息<br />\n用户的id  ip地址，  时间，  操作的描述，  类型等信息</li>\n<li>将日志对象 添加到数据库</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"增强方法的编写\">增强方法的编写</h4>\n<p><strong>增强方法中获取session</strong><br />\n因为我们是通过aop来获取用户的请求的，所以就需要通过当前的请求拿到session，进而去获取用户的信息。<br />\n<img src=\"https://img-blog.csdnimg.cn/20191211150342156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>但是，操作的描述如何获取呢？</strong></p>\n<pre><code>比如 执行的方法不同  描述是不一样的\nlogin             管理员登录\nselectAllMenu  查询了所有的菜单\n</code></pre>\n<p>解决方案：<strong>使用自定义注解：</strong></p>\n<ol>\n<li>\n<p>在 目标 方法上添加自定义注解 （@Log） 如下</p>\n</li>\n<li>\n<p>在增强中获取注解(@Log)的value 和 type</p>\n</li>\n</ol>\n<p><strong>代码实现</strong></p>\n<p>自定义日志注解<br />\n<img src=\"https://img-blog.csdnimg.cn/20191211151108554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<pre><code class=\"language-java\">import java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * 元注解：加在自定义注解上的注解\n * @Target 定义注解可以添加的位置 METHOD 方法上 type 类上\n * @Retention RUNTIME 运行时  不管编译 还是 运行 这个注解都可以用\n *\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface LogAnnotation {\n    /**\n     * 写法类似于接口的方法 后面可以通过default 关键字给默认值\n     * 用法类似于属性\n     * @return\n     */\n    String value() default &quot;&quot;;\n    String type() default &quot;&quot;;\n}\n</code></pre>\n<p><strong>这里要注意什么是元注解，和 注解属性的定义方式</strong></p>\n<h5 id=\"2-在目标方法上使用注解\">2. 在目标方法上使用注解</h5>\n<p><img src=\"https://img-blog.csdnimg.cn/20191211150853141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n3. 在增强方法中获取注解的value 和 type<br />\n<img src=\"https://img-blog.csdnimg.cn/20191211151652465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<pre><code class=\"language-java\">        /**\n         * 操作的描述\n         *\n         * 执行的方法不同  描述是不一样的\n         * login         管理员登录\n         * selectAllGuru 查询了所有的上师\n         *\n         * 获取注解的值\n         */\n//        1.通过连接点获取方法签名 被切入方法的所有信息\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n//        2.获取被切入方法对象\n        Method method = signature.getMethod();\n//        3.获取方法上的注解\n        LogAnnotation annotation = method.getAnnotation(LogAnnotation.class);\n//        4.获取注解的值\n        String value = annotation.value();\n</code></pre>\n<h2 id=\"完整的aop的代码实现\">完整的aop的代码实现</h2>\n<pre><code class=\"language-java\">package com.tourism.hu.config;\n\n/**\n * @author 马超伟\n * @PROJECT_NAME: fzll\n * @Description:\n * @date 15:29\n * @Copyright: All rights Reserved, Designed By Huerdai  \n * Copyright:    Copyright(C) 2019-2020\n * Company       Huerdai Henan LTD.\n */\n\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.tourism.hu.entity.CustomerInfo;\nimport com.tourism.hu.entity.CustomerLoginLog;\nimport com.tourism.hu.service.ICustomerInfoService;\nimport com.tourism.hu.service.ICustomerLoginLogService;\nimport com.tourism.hu.util.IpAddressUtil;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\n\nimport javax.annotation.Resource;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpSession;\nimport java.lang.reflect.Method;\nimport java.time.LocalDateTime;\n\n/*** @Aspect 标记当前类为功能增强类 切面类 *\n *  @Configuration 标记当前类为配置类 这个注解包含了@Component的功能\n */\n@Aspect\n@Configuration\npublic class LogAop {\n\n    private  Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Resource\n    private ICustomerInfoService iCustomerInfoService;\n\n    @Resource\n    private RedisTemplate redisTemplate;\n\n    @Resource\n    private ICustomerLoginLogService iCustomerLoginLogService;\n\n    /**\n     * JoinPoint 连接点 就是切入点 通过这个对象可以获取切入点的相关所有信息 例如：被切入的方法和注解\n     *\n     * @param joinPoint ** 切入点的设置 切注解 @annotation *\n     */\n    @After(&quot;@annotation(com.tourism.hu.config.Log)&quot;)\n    public void logAfter(JoinPoint joinPoint) {\n    	//new 一个日志的实体，用来保存日志信息\n        CustomerLoginLog loginLog = new CustomerLoginLog();\n        // 1.获取日志相关的信息  用户的id session  ip  时间  操作的描述  类型  ctrl+H\n        /**\n         * 获取用户id\n         * 为什么不能装配session？因为服务器有多个session\n         * 通过 ServletRequestAttributes 可以获取当前请求\n         * 当前请求可以获取当前会话的session\n         */\n         //获取用户的请求\n        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = requestAttributes.getRequest();\n        //得到session\n        HttpSession session = request.getSession();\n        String sessionid = session.getId();\n        //通过sessionid去获取用户信息\n        Object obj = redisTemplate.opsForValue().get(sessionid);\n        String customerId = &quot;&quot;;\n        if(obj!=null) {\n            customerId=obj.toString();\n        }\n        //拿到用户对象\n        CustomerInfo customerInfo = iCustomerInfoService.getOne(new QueryWrapper&lt;CustomerInfo&gt;().eq(&quot;id&quot;, customerId));\n        if (customerInfo!=null){\n        	//将用户的id 存入到日志实体中\n            loginLog.setCustomerId(customerInfo.getCustomerId());\n        }\n         loginLog.setLoginTime(LocalDateTime.now());\n        /**\n         * 获取用户的ip\n         * 通过工具类 ip\n         */\n        loginLog.setLoginIp(IpAddressUtil.getIp());\n\n        /**\n         * 操作的描述\n         * 执行的方法不同  描述是不一样的\n         * login         管理员登录\n         * 获取注解的值\n         */\n//        1.通过连接点获取方法签名 被切入方法的所有信息\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n//        2.获取被切入方法对象\n        Method method = signature.getMethod();\n//        3.获取方法上的注解\n        Log annotation = method.getAnnotation(Log.class);\n//        4.获取注解的值\n        String value = annotation.value();\n        loginLog.setLogContent(value);\n        // 获取注解的类型\n        String type = annotation.type();\n        if (type!=null){\n            loginLog.setLoginType(type);\n        }\n//        2.将日志对象 添加到数据库\n        System.out.println(loginLog);\n        logger.debug(&quot;loginLog====&quot;+loginLog);\n        boolean save = iCustomerLoginLogService.save(loginLog);\n        logger.debug(&quot;保存日志------&quot;+save);\n    }\n}\n\n</code></pre>\n<h4 id=\"所用到的工具类\">所用到的工具类</h4>\n<p>获取ip地址的工具类IpAddressUtil</p>\n<pre><code class=\"language-java\">  public static String getIp() {\n        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();\n        String ip = &quot;null&quot;;\n        try {\n            ip = request.getHeader(&quot;x-forwarded-for&quot;);\n            if (StringUtils.isEmpty(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getHeader(&quot;Proxy-Client-IP&quot;);\n            }\n            if (StringUtils.isEmpty(ip) || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);\n            }\n            if (StringUtils.isEmpty(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getHeader(&quot;HTTP_CLIENT_IP&quot;);\n            }\n            if (StringUtils.isEmpty(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);\n            }\n            if (StringUtils.isEmpty(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getRemoteAddr();\n            }\n        } catch (Exception e) {\n            logger.error(&quot;IPUtils ERROR &quot;, e);\n        }\n        //使用代理，则获取第一个IP地址\n        if(StringUtils.isNotEmpty(ip) &amp;&amp; ip.length() &gt; 15) {\n          if(ip.indexOf(&quot;,&quot;) &gt; 0) {\n              ip = ip.substring(0, ip.indexOf(&quot;,&quot;));\n          }\n      }\n        return ip;\n    }\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:36:30', '2022-05-21 18:20:19');
INSERT INTO `tb_article` VALUES (64, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=2285', 'Linux-Centos7,开放相应端口命令', '<p>﻿今天在配置阿里云服务器的时候，发现我明明已经开放了云服务器防火墙的8080端口，然而Tomcat还是无法访问，然后意思到可能是Linux系统的防火墙的8080端口可能还没有打开，于是查询总结了以下命令：</p>\n<h2 id=\"现在linux防火墙有两种服务\">现在Linux防火墙有两种服务</h2>\n<h2 id=\"--1service-firewalld\">- 1.service firewalld</h2>\n<h2 id=\"--2service-iptables\">- 2.service iptables</h2>\n<h4 id=\"一就firewalld来说\">一.就firewalld来说</h4>\n<ul>\n<li>查看开放的端口命令：</li>\n</ul>\n<pre><code>netstat -anp\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20191117124820976.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>查询防火墙状态</li>\n</ul>\n<pre><code>systemctl status firewalld\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20191117124948744.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>如果防火墙关闭了，就开启</li>\n</ul>\n<pre><code> systemctl start firewalld\n</code></pre>\n<ul>\n<li>查询对应端口号</li>\n</ul>\n<pre><code>firewall-cmd --query-port=8080/tcp\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2019111712524287.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>如果显示no，则开启</li>\n</ul>\n<pre><code>firewall-cmd --add-port=8080/tcp --permanent\n</code></pre>\n<p>注意这条命令是 --add,加入端口号，上面那个是query查询端口号<br />\n<img src=\"https://img-blog.csdnimg.cn/20191117125331279.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>然后重启防火墙</li>\n</ul>\n<pre><code>firewall-cmd --reload\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20191117125437520.png\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"二service-iptables\">二.service iptables</h2>\n<ol>\n<li>开放端口命令： /sbin/iptables -I INPUT -p tcp --dport 8085 -j ACCEPT<br />\n2.保存：/etc/rc.d/init.d/iptables save<br />\n3.重启服务：/etc/init.d/iptables restart<br />\n4.查看端口是否开放：/sbin/iptables -L -n</li>\n</ol>\n<h5 id=\"最后附上云服务器打开端口号的配置\">最后附上云服务器打开端口号的配置</h5>\n<p><img src=\"https://img-blog.csdnimg.cn/20191117125617767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 15:37:01', '2022-05-21 18:20:08');
INSERT INTO `tb_article` VALUES (65, 1, 8, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1893', '省市区管理sql数据表设计、以及全国省市区全部最新数据', '<p>﻿使用Mysql数据库，主要字段有：<br />\n区域主键、区域名称、区域上级标识、地名简称、区域等级、区域编码、邮政编码、组合名称、经度、维度、拼音，<br />\n其页面展示效果图如下：<br />\n<img src=\"https://img-blog.csdnimg.cn/2019101611124889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n建表sql为：</p>\n<pre><code class=\"language-sql\">CREATE TABLE `region`  (\n  `id` int(11) NOT NULL COMMENT \'区域主键\',\n  `name` varchar(40) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'区域名称\',\n  `pid` int(11) NULL DEFAULT NULL COMMENT \'区域上级标识\',\n  `sname` varchar(40) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'地名简称\',\n  `level` int(11) NULL DEFAULT NULL COMMENT \'区域等级\',\n  `citycode` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'区域编码\',\n  `yzcode` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'邮政编码\',\n  `mername` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'组合名称\',\n  `Lng` float NULL DEFAULT NULL COMMENT \'经度\',\n  `Lat` float NULL DEFAULT NULL COMMENT \'维度\',\n  `pinyin` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'拼音\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n\n</code></pre>\n<h3 id=\"插入全国最新数据地址库\">插入全国最新数据地址库：</h3>\n<p>由于CSDN篇幅限制，数据一篇放不下，<br />\nsql文件下载地址为：<a href=\"https://download.csdn.net/download/macwx/11869084\">https://download.csdn.net/download/macwx/11869084</a><br />\n下面只是部分数据，全部数据请下载文件，是CSDN篇幅限制不让我全部复制下来啊~~~~</p>\n<pre><code class=\"language-sql\">\nINSERT INTO `fz_region` VALUES (100000, \'中国\', 0, \'中国\', 0, \'\', \'\', \'中国\', 116.368, 39.9151, \'China\');\nINSERT INTO `fz_region` VALUES (110000, \'北京\', 100000, \'北京\', 1, \'\', \'\', \'中国,北京\', 116.405, 39.905, \'Beijing\');\nINSERT INTO `fz_region` VALUES (110100, \'北京市\', 110000, \'北京\', 2, \'010\', \'100000\', \'中国,北京,北京市\', 116.405, 39.905, \'Beijing\');\nINSERT INTO `fz_region` VALUES (110101, \'东城区\', 110100, \'东城\', 3, \'010\', \'100010\', \'中国,北京,北京市,东城区\', 116.41, 39.9316, \'Dongcheng\');\nINSERT INTO `fz_region` VALUES (110102, \'西城区\', 110100, \'西城\', 3, \'010\', \'100032\', \'中国,北京,北京市,西城区\', 116.36, 39.9305, \'Xicheng\');\nINSERT INTO `fz_region` VALUES (110105, \'朝阳区\', 110100, \'朝阳\', 3, \'010\', \'100020\', \'中国,北京,北京市,朝阳区\', 116.485, 39.9484, \'Chaoyang\');\nINSERT INTO `fz_region` VALUES (110106, \'丰台区\', 110100, \'丰台\', 3, \'010\', \'100071\', \'中国,北京,北京市,丰台区\', 116.286, 39.8585, \'Fengtai\');\nINSERT INTO `fz_region` VALUES (110107, \'石景山区\', 110100, \'石景山\', 3, \'010\', \'100043\', \'中国,北京,北京市,石景山区\', 116.223, 39.9056, \'Shijingshan\');\nINSERT INTO `fz_region` VALUES (110108, \'海淀区\', 110100, \'海淀\', 3, \'010\', \'100089\', \'中国,北京,北京市,海淀区\', 116.298, 39.9593, \'Haidian\');\nINSERT INTO `fz_region` VALUES (110109, \'门头沟区\', 110100, \'门头沟\', 3, \'010\', \'102300\', \'中国,北京,北京市,门头沟区\', 116.101, 39.9404, \'Mentougou\');\nINSERT INTO `fz_region` VALUES (110111, \'房山区\', 110100, \'房山\', 3, \'010\', \'102488\', \'中国,北京,北京市,房山区\', 116.143, 39.7479, \'Fangshan\');\nINSERT INTO `fz_region` VALUES (110112, \'通州区\', 110100, \'通州\', 3, \'010\', \'101149\', \'中国,北京,北京市,通州区\', 116.657, 39.9097, \'Tongzhou\');\nINSERT INTO `fz_region` VALUES (110113, \'顺义区\', 110100, \'顺义\', 3, \'010\', \'101300\', \'中国,北京,北京市,顺义区\', 116.654, 40.1302, \'Shunyi\');\nINSERT INTO `fz_region` VALUES (110114, \'昌平区\', 110100, \'昌平\', 3, \'010\', \'102200\', \'中国,北京,北京市,昌平区\', 116.231, 40.2207, \'Changping\');\nINSERT INTO `fz_region` VALUES (110115, \'大兴区\', 110100, \'大兴\', 3, \'010\', \'102600\', \'中国,北京,北京市,大兴区\', 116.341, 39.7267, \'Daxing\');\nINSERT INTO `fz_region` VALUES (110116, \'怀柔区\', 110100, \'怀柔\', 3, \'010\', \'101400\', \'中国,北京,北京市,怀柔区\', 116.632, 40.316, \'Huairou\');\nINSERT INTO `fz_region` VALUES (110117, \'平谷区\', 110100, \'平谷\', 3, \'010\', \'101200\', \'中国,北京,北京市,平谷区\', 117.121, 40.1406, \'Pinggu\');\nINSERT INTO `fz_region` VALUES (110228, \'密云县\', 110100, \'密云\', 3, \'010\', \'101500\', \'中国,北京,北京市,密云县\', 116.843, 40.3762, \'Miyun\');\nINSERT INTO `fz_region` VALUES (110229, \'延庆县\', 110100, \'延庆\', 3, \'010\', \'102100\', \'中国,北京,北京市,延庆县\', 115.975, 40.4567, \'Yanqing\');\nINSERT INTO `fz_region` VALUES (120000, \'天津\', 100000, \'天津\', 1, \'\', \'\', \'中国,天津\', 117.19, 39.1256, \'Tianjin\');\nINSERT INTO `fz_region` VALUES (120100, \'天津市\', 120000, \'天津\', 2, \'022\', \'300000\', \'中国,天津,天津市\', 117.19, 39.1256, \'Tianjin\');\nINSERT INTO `fz_region` VALUES (120101, \'和平区\', 120100, \'和平\', 3, \'022\', \'300041\', \'中国,天津,天津市,和平区\', 117.215, 39.1172, \'Heping\');\nINSERT INTO `fz_region` VALUES (120102, \'河东区\', 120100, \'河东\', 3, \'022\', \'300171\', \'中国,天津,天津市,河东区\', 117.226, 39.1232, \'Hedong\');\nINSERT INTO `fz_region` VALUES (120103, \'河西区\', 120100, \'河西\', 3, \'022\', \'300202\', \'中国,天津,天津市,河西区\', 117.223, 39.1096, \'Hexi\');\nINSERT INTO `fz_region` VALUES (120104, \'南开区\', 120100, \'南开\', 3, \'022\', \'300110\', \'中国,天津,天津市,南开区\', 117.151, 39.1382, \'Nankai\');\nINSERT INTO `fz_region` VALUES (120105, \'河北区\', 120100, \'河北\', 3, \'022\', \'300143\', \'中国,天津,天津市,河北区\', 117.197, 39.1482, \'Hebei\');\nINSERT INTO `fz_region` VALUES (120106, \'红桥区\', 120100, \'红桥\', 3, \'022\', \'300131\', \'中国,天津,天津市,红桥区\', 117.151, 39.1671, \'Hongqiao\');\nINSERT INTO `fz_region` VALUES (120110, \'东丽区\', 120100, \'东丽\', 3, \'022\', \'300300\', \'中国,天津,天津市,东丽区\', 117.314, 39.0863, \'Dongli\');\nINSERT INTO `fz_region` VALUES (120111, \'西青区\', 120100, \'西青\', 3, \'022\', \'300380\', \'中国,天津,天津市,西青区\', 117.009, 39.1412, \'Xiqing\');\nINSERT INTO `fz_region` VALUES (120112, \'津南区\', 120100, \'津南\', 3, \'022\', \'300350\', \'中国,天津,天津市,津南区\', 117.385, 38.9914, \'Jinnan\');\nINSERT INTO `fz_region` VALUES (120113, \'北辰区\', 120100, \'北辰\', 3, \'022\', \'300400\', \'中国,天津,天津市,北辰区\', 117.132, 39.2213, \'Beichen\');\nINSERT INTO `fz_region` VALUES (120114, \'武清区\', 120100, \'武清\', 3, \'022\', \'301700\', \'中国,天津,天津市,武清区\', 117.044, 39.3842, \'Wuqing\');\nINSERT INTO `fz_region` VALUES (120115, \'宝坻区\', 120100, \'宝坻\', 3, \'022\', \'301800\', \'中国,天津,天津市,宝坻区\', 117.31, 39.7176, \'Baodi\');\nINSERT INTO `fz_region` VALUES (120116, \'滨海新区\', 120100, \'滨海新区\', 3, \'022\', \'300451\', \'中国,天津,天津市,滨海新区\', 117.702, 39.0267, \'Binhaixinqu\');\nINSERT INTO `fz_region` VALUES (120221, \'宁河县\', 120100, \'宁河\', 3, \'022\', \'301500\', \'中国,天津,天津市,宁河县\', 117.826, 39.3305, \'Ninghe\');\nINSERT INTO `fz_region` VALUES (120223, \'静海县\', 120100, \'静海\', 3, \'022\', \'301600\', \'中国,天津,天津市,静海县\', 116.974, 38.9458, \'Jinghai\');\nINSERT INTO `fz_region` VALUES (120225, \'蓟县\', 120100, \'蓟县\', 3, \'022\', \'301900\', \'中国,天津,天津市,蓟县\', 117.408, 40.0457, \'Jixian\');\n\n\n\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:37:24', '2022-05-21 18:19:51');
INSERT INTO `tb_article` VALUES (66, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4348', 'Spring Boot 封装文件上传工具类', '<p>﻿springboot 实现文件的上传这里我用的是commins-io依赖：<br />\n坐标如下：</p>\n<pre><code class=\"language-java\"> &lt;dependency&gt;\n      &lt;groupId&gt;commons-io&lt;/groupId&gt;\n      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;\n      &lt;version&gt;2.4&lt;/version&gt;\n    &lt;/dependency&gt;\n</code></pre>\n<p>引入这个依赖之后就可以使用下面这个工具类进行文件上传的操作了：<br />\n如下：</p>\n<pre><code class=\"language-java\">package com.tourism.fzll.util;\n\nimport java.io.File;\nimport java.util.UUID;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\nimport org.springframework.web.multipart.MultipartFile;\n\npublic class FileUploadUtil {\n	\n	public static String upload(MultipartFile file) {\n		try {\n			String extName = file.getOriginalFilename();\n			// 获取文件后缀\n			if (extName.lastIndexOf(&quot;.&quot;) &lt;= 0) {\n				throw new RuntimeException(&quot;不支持该文件类型&quot;);\n			}\n			extName = extName.substring(extName.lastIndexOf(&quot;.&quot;));\n			String webUrl = getWebUrl();\n			String fileName = getFileName();\n			String sysPath = System.getProperty(&quot;catalina.home&quot;) + &quot;/webapps&quot;;\n			// 获取文件名字\n			fileName = getFileName() + extName;\n			// 获取文件地址\n			String filePath = &quot;/content/&quot; + fileName;\n			String Url = sysPath +&quot;/content/&quot;;\n			File file2 = new File(Url);\n			if (!file2.exists()) {\n				file2.mkdirs();\n			}\n			file.transferTo(new File(sysPath + filePath));\n			return webUrl + filePath;\n		} catch (Exception e) {\n			throw new RuntimeException(e);\n		}\n	}\n	/**\n	 * \n	 * @Title: upload \n	 * @Description: (将文件保存到指定的路径下) \n	 * @param file\n\n	 * @return  \n	 * @date 2019年9月30日 上午10:22:31\n	 * @author 马超伟\n	 */\n	public static String upload(MultipartFile file,String specifiedPath) {\n		try {\n			String extName = file.getOriginalFilename();\n			// 获取文件后缀\n			if (extName.lastIndexOf(&quot;.&quot;) &lt;= 0) {\n				throw new RuntimeException(&quot;不支持该文件类型&quot;);\n			}\n			extName = extName.substring(extName.lastIndexOf(&quot;.&quot;));\n			String fileName = getFileName();\n			// 获取文件名字\n			fileName = getFileName() + extName;\n			File file2 = new File(specifiedPath);\n			if (!file2.exists()) {\n				file2.mkdirs();\n			}\n			file.transferTo(new File(specifiedPath + File.separator+ fileName));\n			return fileName;\n		} catch (Exception e) {\n			throw new RuntimeException(e);\n		}\n	}\n\n	/**\n	 * 获取文件名\n	 * @return\n	 */\n	public static String getFileName() {\n		String uuid = UUID.randomUUID().toString();\n		uuid = uuid.replace(&quot;-&quot;, &quot;&quot;);\n		return uuid.toLowerCase();\n	}\n\n	public static String getWebUrl() {\n		HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();\n		return  request.getServletContext().getRealPath(&quot;/img&quot;);\n	}\n	\n	public static String getWebProUrl() {\n		HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();\n		return request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() +request.getContextPath();\n	}\n	\n}\n\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:37:53', '2021-08-30 10:00:30');
INSERT INTO `tb_article` VALUES (67, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3841', 'layui 树形表格 treeTable使用详细指南，不能折叠解决办法', '<p>﻿最近在写一个商品分类管理的功能，本来想用layui的树形组件来写，但发现layui原生的tree只能展示title，而分类的其他字段无法展示，这就有点不适用了，无意中看到一位大神自定义写的一个树形表格组件，正好满足我的要求，特此将使用方法以及其中遇到的一些坑记录下来。。。</p>\n<h3 id=\"首先看下treetable的\">首先看下treeTable的</h3>\n<p><a href=\"https://whvse.gitee.io/treetable-lay/\">演示地址</a></p>\n<p><a href=\"https://gitee.com/whvse/treetable-lay\">项目地址</a></p>\n<p>好了，如果看完演示到这里你觉得正好符合你的功能要求，就可以继续往下看了，</p>\n<p>虽然项目地址中已经把使用介绍的很详细了，但是我在这里要补充一下我遇到的坑：</p>\n<h2 id=\"使用方法\">使用方法</h2>\n<h4 id=\"1引入模块\">1，引入模块</h4>\n<p>打开项目地址，将整个项目下载下来，项目中其他文件可以参考，我们主要用的就是treetable-lay这个文件夹的内容。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190925170811464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n下载好项目后把treetable-lay放在我们自己项目的任意位置，但是尽量和layui文件夹放一块，好找！<br />\n下面是我放的位置，如图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190925171552808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"2初始化模块配置\">2，初始化模块配置</h4>\n<p>要扩展layui的模块使用我们引入的js模块，注意base路径是treetable-lay文件夹所在的父路径，这里出错会报404，extend内容最好不要改。<br />\n下面我先每个重点注意事项单独列出来，最后放完整代码。</p>\n<pre><code class=\"language-java\">   layui.config({\n        base: \'${pageContext.request.contextPath}/layuiadmin/modules/\' //   资源所在路径\n    }).extend({\n        treetable: \'treetable-lay/treetable\'\n    }).use([\'treetable\', \'table\', \'layer\'], function () {\n        var treetable = layui.treetable;\n        var layer = layui.layer;\n        var table = layui.table;\n        var $ = layui.jquery;\n});\n</code></pre>\n<p>如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/201909251720347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"3动态渲染表格\">3，动态渲染表格</h4>\n<p>数据是从后台查询出来，数据格式不需要做处理，只需要查询所有就行了，官方文档给了json格式，我自己也做了一个简单的封装，一会儿再说json格式。</p>\n<p>这里要注意的是treeIdName和treePidName这两个属性，要对应自己查询出来的id和pid。支持自定义这点非常好</p>\n<pre><code class=\"language-java\"> &lt;%--树形表格--%&gt;\n &lt;table class=&quot;layui-table&quot; id=&quot;Lay_category_treeTable&quot; lay-filter=&quot;Lay_category_treeTable&quot;&gt;&lt;/table&gt;\n    \n    //js如下：\n    layui.use([\'treetable\', \'table\', \'layer\'], function () {\n        var treetable = layui.treetable;\n        var layer = layui.layer;\n        var table = layui.table;\n        var $ = layui.jquery;\n\n        var re;\n        // 渲染表格\n        var renderTable = function () {\n            layer.load(3);    //这里好像是要加载几层 ，我的是3层，就写了个3，\n            re = treetable.render({\n                elem: \'#Lay_category_treeTable\',\n                url: \'${basepath}/goodscategory/selectTreeTable\',\n                treeColIndex: 1,          // 树形图标显示在第几列\n                treeSpid: 0,             // 最上级的父级id\n                treeIdName: \'classId\',       // 	id字段的名称\n                treePidName: \'parentId\',    // 	pid字段的名称\n                treeDefaultClose: true,     //是否默认折叠\n                page: false,\n                //treeLinkage: true,      //父级展开时是否自动展开所有子级\n                cols: [[\n                    {type: \'numbers\'},\n                    {title: &quot;分类名称&quot;, field: &quot;className&quot;,align:&quot;left&quot;},\n                    {title: &quot;分类编码&quot;, field: &quot;classCode&quot;},\n                    //  {title: &quot;分类层级&quot;, field: &quot;classIdLevel&quot;},\n                    {title: &quot;分类状态&quot;, field: &quot;classIdStatus&quot;,templet: \'#classIdStatusTpl\'},\n                    {title: &quot;创建人&quot;, field: &quot;createUser&quot;},\n                    {\n                        title: &quot;创建时间&quot;,\n                        field: &quot;createTime&quot;,\n                        templet: \'&lt;div&gt;{{# if(d.createTime!=null){ }} {{ layui.util.toDateString(d.createTime,\\\'yyyy-MM-dd HH:mm:ss\\\')  }} {{# } }}&lt;/div&gt;\'\n                    },\n                    {title: &quot;更新人员&quot;, field: &quot;updateUser&quot;},\n                    {\n                        title: &quot;更新时间&quot;,\n                        field: &quot;updateTime&quot;,\n                        templet: \'&lt;div&gt;{{# if(d.updateTime!=null){ }} {{ layui.util.toDateString(d.updateTime,\\\'yyyy-MM-dd HH:mm:ss\\\')  }} {{# } }}&lt;/div&gt;\'\n                    },\n                    {title: &quot;操作&quot;, templet: &quot;#updateAndDelete&quot;}\n                ]],\n                done: function () {\n                    layer.closeAll(\'loading\');\n                }\n            })\n        };\n</code></pre>\n<p>可以使用url传递数据，也可以使用data传递数据，如果使用url传递数据，参数是where字段，<br />\n跟layui数据表格的使用方式一致。</p>\n<h4 id=\"4参数说明这里直接复制官方的\">4，参数说明，（这里直接复制官方的）</h4>\n<p>layui数据表格的所有参数都可以用，除此之外treetable新增的参数有：</p>\n<table>\n<thead>\n<tr><th>参数</th><th>类型</th><th>是否必填</th><th>描述</th><th> </th></tr>\n</thead>\n<tbody>\n<tr><td>treeColIndex</td><td>int</td><td>是</td><td>树形图标显示在第几列</td><td> </td></tr>\n<tr><td>treeSpid</td><td>object</td><td>是</td><td>最上级的父级id</td><td> </td></tr>\n<tr><td>treeIdName</td><td>string</td><td>否</td><td>id字段的名称</td><td> </td></tr>\n<tr><td>treePidName</td><td>string</td><td>否</td><td>pid字段的名称</td><td> </td></tr>\n<tr><td>treeDefaultClose</td><td>boolean</td><td>否</td><td>是否默认折叠</td><td> </td></tr>\n<tr><td>treeLinkage</td><td>boolean</td><td>否</td><td>父级展开时是否自动展开所有子级</td><td> </td></tr>\n</tbody>\n</table>\n<p> <strong>treeColIndex</strong></p>\n<p> 树形图标（箭头和文件夹、文件的图标）显示在第几列， 索引值是cols数组的下标。</p>\n<p> <strong>treeSpid</strong></p>\n<p> 最上级的父级id，比如你可以规定pid为0或-1的是最顶级的目录。</p>\n<p> <strong>treeIdName</strong></p>\n<p> treetable是以id和pid字段来渲染树形结构的，如果你的数据没有id和pid字段，你可以指定id和pid字段的名称。</p>\n<p> <strong>treePidName</strong></p>\n<p> pid在你的数据字段中的名称。</p>\n<p> <strong>treeDefaultClose</strong></p>\n<p> 默认是全部展开的，如果需要默认全部关闭，加上treeDefaultClose:true即可。</p>\n<p> <strong>treeLinkage</strong></p>\n<p> 父级展开时是否自动展开所有子级</p>\n<h4 id=\"注意事项\">注意事项</h4>\n<ul>\n<li>不能使用分页功能，即使写了page:true，也会忽略该参数。</li>\n<li>不能使用排序功能，不要开启排序功能。</li>\n<li>table.reload()不能实现刷新，请参考demo的刷新。</li>\n<li>除了文档上写的treetable.xxx的方法之外，其他数据表格的方法都使用table.xxx。</li>\n<li>建议删除和修改请求完后台之后请刷新（重新渲染）表格，最好不要使用obj.delete方式删除。</li>\n</ul>\n<h4 id=\"5其他方法\">5，其他方法</h4>\n<p>这里除了layui的方法新增的方法有展开所有，折叠所有，刷新表格 ，三种方法，使用方法如下：</p>\n<pre><code class=\"language-java\"> &lt;div class=&quot;layui-btn-group&quot;&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-expand&quot;&gt;全部展开&lt;/button&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-fold&quot;&gt;全部折叠&lt;/button&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-refresh&quot;&gt;刷新表格&lt;/button&gt;\n &lt;/div&gt;\n\n	 renderTable();   //这个就是上面的渲染表格 var renderTable = function () {...}\n        //展开所有\n        $(\'#btn-expand\').click(function () {\n            //alert(0)\n            treetable.expandAll(\'#Lay_category_treeTable\');\n        });\n        //折叠所有\n        $(\'#btn-fold\').click(function () {\n           // alert(1)\n            treetable.foldAll(\'#Lay_category_treeTable\');\n        });\n        //刷新表格\n        $(\'#btn-refresh\').click(function () {\n            renderTable();\n        });\n\n</code></pre>\n<h4 id=\"6content图标\">6，content图标。</h4>\n<p>图标这个从gitee码云的源码上看吧，不再详细说，也没啥可说的。</p>\n<h2 id=\"7我遇到的坑\">7，我遇到的坑</h2>\n<p>我照着他给的教程一步步弄下来页面也显示出来了，但就是不能折叠，不管是我用折叠方法还是点那个三角图片还是设置为默认折叠，就是不管用，<br />\n不能折叠，可把我给气坏了。<br />\n苦思冥想找不到问题，最后我去研究treetable.js这个文件</p>\n<p>发现其中有一段代码他给注释掉了，如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190925174505180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n然后我把注释的这一段代码打开，哎，好了，展开折叠正常了，不知道什么原因，不知道有没有其他人遇到过。。。</p>\n<h5 id=\"最后分享一下我写的不成熟的这个页面的功能汇总做个记录\">最后，分享一下我写的不成熟的这个页面的功能汇总，做个记录：</h5>\n<p>主要功能有，树形表格展示，添加，修改，删除，批量删除，搜索，layui时间日期自定义格式列，表格全部展开、折叠、刷新表格等功能，有兴趣的看下吧~~<br />\n效果图如下所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190925175823787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>全部代码在这~：</strong></p>\n<pre><code class=\"language-java\">&lt;%--\n  Created by IntelliJ IDEA.\n  User: Administrator\n  Date: 2019/9/23\n  Time: 13:25\n  To change this template use File | Settings | File Templates.\n--%&gt;\n\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;\n&lt;%@ include file=&quot;../meta.jsp&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;商品分类管理&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;${basepath}layuiadmin/layui/css/layui.css&quot; media=&quot;all&quot;&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;${basepath}layuiadmin/modules/treetable-lay/treetable.css&quot;&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;${basepath}js/jquery-1.12.0.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;${basepath}js/cookies.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;${basepath}layuiadmin/layui/layui.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;${basepath}layuiadmin/modules/treetable-lay/treetable.js&quot;&gt;&lt;/script&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n        .layui-table-cell {\n            height: auto;\n            line-height: 30px;\n        }\n\n    &lt;/style&gt;\n\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=&quot;layui-card-body&quot;&gt;\n    &lt;div style=&quot;padding-bottom: 10px;&quot; id=&quot;LAY_lay_add&quot;&gt;\n        &lt;button type=&quot;button&quot; class=&quot;layui-btn layui-btn-danger&quot; onclick=&quot;doMultiDelete()&quot;&gt;\n            &lt;i class=&quot;layui-icon layui-icon-delete&quot;&gt;&lt;/i&gt; 批量删除\n        &lt;/button&gt;\n        &lt;button class=&quot;layui-btn layuiadmin-btn-role &quot; data-type=&quot;add&quot; onclick=&quot;toOpenAddLayer()&quot;&gt;\n            &lt;i class=&quot;layui-icon layui-icon-add-circle-fine&quot;&gt;&lt;/i&gt; 添加\n        &lt;/button&gt;\n        &amp;nbsp;\n        &lt;div class=&quot;layui-input-inline&quot; style=&quot;width: 200px;&quot;&gt;\n            &lt;input type=&quot;text&quot; name=&quot;search&quot; id=&quot;Lay_toSearch_input&quot; placeholder=&quot;请输入分类名称&quot; autocomplete=&quot;off&quot;\n                   class=&quot;layui-input&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;layui-input-inline&quot; style=&quot;width: 100px;&quot;&gt;\n            &lt;button type=&quot;button&quot; class=&quot;layui-btn layui-btn-normal&quot; id=&quot;btn-search&quot;&lt;%-- onclick=&quot;doSearch()&quot;--%&gt;&gt;\n                &lt;i class=&quot;layui-icon layui-icon-search&quot;&gt;&lt;/i&gt; 搜索\n            &lt;/button&gt;\n        &lt;/div&gt;\n        &amp;nbsp;\n        &lt;div class=&quot;layui-btn-group&quot;&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-expand&quot;&gt;全部展开&lt;/button&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-fold&quot;&gt;全部折叠&lt;/button&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-refresh&quot;&gt;刷新表格&lt;/button&gt;\n        &lt;/div&gt;\n        &lt;%--\n                &lt;button type=&quot;button&quot; class=&quot;layui-btn layui-btn-normal  change-icon&quot;&gt;随机更换小图标&lt;/button&gt;\n        --%&gt;\n    &lt;/div&gt;\n\n    &lt;%--树形表格--%&gt;\n    &lt;table class=&quot;layui-table&quot; id=&quot;Lay_category_treeTable&quot; lay-filter=&quot;Lay_category_treeTable&quot;&gt;&lt;/table&gt;\n\n    &lt;%--树形菜单--%&gt;\n    &lt;div id=&quot;Lay_category_tree&quot; lay-filter=&quot;Lay_category_tree&quot;&gt;&lt;/div&gt;\n\n    &lt;%--Table表格--%&gt;\n    &lt;%-- &lt;table id=&quot;Lay_back_table&quot; lay-filter=&quot;Lay_back_table&quot;&gt;&lt;/table&gt;--%&gt;\n\n\n&lt;/div&gt;\n\n&lt;script type=&quot;text/html&quot; id=&quot;updateAndDelete&quot;&gt;\n    &lt;button type=&quot;button&quot; class=&quot;layui-btn  layui-btn-normal&quot; onclick=&quot;toOpenUpdateLayer(\'{{d.classId}}\')&quot;&gt;\n        &lt;i class=&quot;layui-icon layui-icon-edit&quot;&gt;&lt;/i&gt;修改\n    &lt;/button&gt;\n    &lt;button type=&quot;button&quot; class=&quot;layui-btn layui-btn-danger&quot; onclick=&quot;doDelete(\'{{d.classId}}\')&quot;&gt;\n        &lt;i class=&quot;layui-icon layui-icon-delete&quot;&gt;&lt;/i&gt; 删除\n    &lt;/button&gt;\n&lt;/script&gt;\n\n&lt;%--弹出层--%&gt;\n\n&lt;form id=&quot;addForm&quot; class=&quot;layui-form&quot;&gt;\n    &lt;div class=&quot;layui-form&quot; lay-filter=&quot;layuiconfig-form-role&quot; id=&quot;layuiconfig-form-role&quot;\n         style=&quot;padding: 20px 30px 0 0;display: none&quot;&gt;\n        &lt;div class=&quot;layui-form-item&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;分类名称&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;input name=&quot;className&quot; id=&quot;className&quot; class=&quot;layui-input&quot;&gt;\n                &lt;input name=&quot;classId&quot; id=&quot;classId&quot; lay-type=&quot;hide&quot; type=&quot;hidden&quot; class=&quot;layui-input&quot;&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;layui-form-item&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;分类编码&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;input name=&quot;classCode&quot; id=&quot;classCode&quot; class=&quot;layui-input&quot;&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;layui-form-item&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;分类状态&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;input type=&quot;checkbox&quot; lay-skin=&quot;switch&quot; lay-text=&quot;启用|禁用&quot; value=&quot;1&quot; checked name=&quot;classIdStatus&quot;\n                       id=&quot;classIdStatus&quot; class=&quot;layui-input&quot;&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=&quot;layui-form-item&quot; id=&quot;Lay_select_Level&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;请选择分类级别&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;select name=&quot;classIdLevel&quot; lay-verify=&quot;required&quot; lay-filter=&quot;classIdLevel&quot;&gt;\n                    &lt;option value=&quot;&quot;&gt;&lt;/option&gt;\n                    &lt;option value=&quot;1&quot; selected&gt;一级分类&lt;/option&gt;\n                    &lt;option value=&quot;2&quot;&gt;二级分类&lt;/option&gt;\n                    &lt;option value=&quot;3&quot;&gt;三级分类&lt;/option&gt;\n                &lt;/select&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n\n        &lt;div class=&quot;layui-form-item&quot; style=&quot;display: none&quot; id=&quot;Lay_One_Level&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;请选择所属的一级分类&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;select name=&quot;parentId&quot; id=&quot;parentId&quot;  lay-filter=&quot;parent_classIdLevel_One&quot;&gt;\n                    &lt;option value=&quot;&quot;&gt;&lt;/option&gt;\n                &lt;/select&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=&quot;layui-form-item&quot; style=&quot;display: none&quot; id=&quot;Lay_Two_Level&quot; &gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;请选择所属的二级分类&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;select name=&quot;parentId2&quot; id=&quot;Two_parentId&quot;  lay-filter=&quot;parent_classIdLevel_Two&quot;&gt;\n                    &lt;option value=&quot;&quot;&gt;&lt;/option&gt;\n                &lt;/select&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n\n        &lt;div class=&quot;layui-form-item&quot; style=&quot;text-align: right&quot;&gt;\n            &lt;button class=&quot;layui-btn &quot; lay-submit lay-filter=&quot;LAY-sysconfig-submit&quot; id=&quot;LAY-sysconfig-submit&quot;&gt;确认添加\n            &lt;/button&gt;\n            &lt;button lay-submit lay-filter=&quot;updateSubmitBtn&quot; class=&quot;layui-btn&quot; id=&quot;updateSubmitBtn&quot;&gt;确认修改&lt;/button&gt;\n\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/form&gt;\n\n&lt;script type=&quot;text/html&quot; id=&quot;classIdStatusTpl&quot;&gt;\n    {{#  if(d.classIdStatus==1){ }}\n    启用\n    {{#  } else { }}\n    &lt;i style=&quot;color: red;&quot;&gt;禁用&lt;/i&gt;\n    {{#  } }}\n&lt;/script&gt;\n\n&lt;script type=&quot;text/javascript&quot;&gt;\n\n    layui.config({\n        base: \'${pageContext.request.contextPath}/layuiadmin/modules/\' //   资源所在路径\n    }).extend({\n        treetable: \'treetable-lay/treetable\'\n    }).use([\'treetable\', \'table\', \'layer\'], function () {\n        var treetable = layui.treetable;\n        var layer = layui.layer;\n        var table = layui.table;\n        var $ = layui.jquery;\n\n        var re;\n\n        // 渲染表格\n        var renderTable = function () {\n            layer.load(3);\n            re = treetable.render({\n                elem: \'#Lay_category_treeTable\',\n                url: \'${basepath}/goodscategory/selectTreeTable\',\n                treeColIndex: 1,          // 树形图标显示在第几列\n                treeSpid: 0,             // 最上级的父级id\n                treeIdName: \'classId\',       // 	id字段的名称\n                treePidName: \'parentId\',    // 	pid字段的名称\n                treeDefaultClose: true,     //是否默认折叠\n                page: false,\n                //treeLinkage: true,      //父级展开时是否自动展开所有子级\n                cols: [[\n                    {type: \'numbers\'},\n                    {title: &quot;分类名称&quot;, field: &quot;className&quot;,align:&quot;left&quot;},\n                    {title: &quot;分类编码&quot;, field: &quot;classCode&quot;},\n                    //  {title: &quot;分类层级&quot;, field: &quot;classIdLevel&quot;},\n                    {title: &quot;分类状态&quot;, field: &quot;classIdStatus&quot;,templet: \'#classIdStatusTpl\'},\n                    {title: &quot;创建人&quot;, field: &quot;createUser&quot;},\n                    {\n                        title: &quot;创建时间&quot;,\n                        field: &quot;createTime&quot;,\n                        templet: \'&lt;div&gt;{{# if(d.createTime!=null){ }} {{ layui.util.toDateString(d.createTime,\\\'yyyy-MM-dd HH:mm:ss\\\')  }} {{# } }}&lt;/div&gt;\'\n                    },\n                    {title: &quot;更新人员&quot;, field: &quot;updateUser&quot;},\n                    {\n                        title: &quot;更新时间&quot;,\n                        field: &quot;updateTime&quot;,\n                        templet: \'&lt;div&gt;{{# if(d.updateTime!=null){ }} {{ layui.util.toDateString(d.updateTime,\\\'yyyy-MM-dd HH:mm:ss\\\')  }} {{# } }}&lt;/div&gt;\'\n                    },\n                    {title: &quot;操作&quot;, templet: &quot;#updateAndDelete&quot;}\n                ]],\n                done: function () {\n                    layer.closeAll(\'loading\');\n                }\n\n            })\n        };\n\n        renderTable();\n        //展开所有\n        $(\'#btn-expand\').click(function () {\n            //alert(0)\n            treetable.expandAll(\'#Lay_category_treeTable\');\n        });\n        //折叠所有\n        $(\'#btn-fold\').click(function () {\n           // alert(1)\n            treetable.foldAll(\'#Lay_category_treeTable\');\n        });\n        //刷新表格\n        $(\'#btn-refresh\').click(function () {\n            renderTable();\n        });\n\n        $(\'#btn-search\').click(function () {\n            var keyword = $(\'#Lay_toSearch_input\').val();\n            //alert(keyword);\n           // var searchName = $(\'#Lay_toSearch_input\').val();\n            var searchCount = 0;\n            $(\'#Lay_category_treeTable\').next(\'.treeTable\').find(\'.layui-table-body tbody tr td\').each(function () {\n                $(this).css(\'background-color\', \'transparent\');\n                var text = $(this).text();\n                if (keyword != \'\' &amp;&amp; text.indexOf(keyword) &gt;= 0) {\n                    $(this).css(\'background-color\', \'rgba(250,230,160,0.5)\');\n                    if (searchCount == 0) {\n                        treetable.expandAll(\'#Lay_category_treeTable\');\n                        $(\'html,body\').stop(true);\n                        $(\'html,body\').animate({scrollTop: $(this).offset().top - 150}, 500);\n                    }\n                    searchCount++;\n                }\n            });\n            if (keyword == \'\') {\n                layer.msg(&quot;请输入搜索内容&quot;, {icon: 5});\n            } else if (searchCount == 0) {\n                layer.msg(&quot;没有匹配结果&quot;, {icon: 5});\n            }\n        });\n    });\n\n\n    //这是一棵树，\n    layui.use([\'table\', \'tree\', &quot;layer&quot;, \'jquery\', \'form\'], function () {\n        var table = layui.table;\n        var layer = layui.layer;\n        var form = layui.form;\n        var tree = layui.tree;\n        var $ = layui.jquery;\n\n        $.ajax({\n            url: &quot;${pageContext.request.contextPath}/goodscategory/selectTree&quot;,\n            success: function (data) {\n                //console.log(data);\n                //渲染\n                var inst1 = tree.render({\n                    elem: \'#Lay_category_tree\',  //绑定元素\n                    data: data.data,\n                    showCheckbox: true\n                    // accordion:true\n                });\n            }\n        });\n    });\n\n\n    //搜索操作\n    function doSearch() {\n        //1.获取到输入框中输入的内容\n        var searchName = $(\'#Lay_toSearch_input\').val();\n        //发送请求，并且接收数据\n        layui.use(\'table\', function () {\n            var table = layui.table;\n            table.reload(\'Lay_back_table\', {\n                where: {&quot;platform&quot;: searchName}\n            });\n        });\n    }\n\n    //执行编辑修改\n    function toOpenUpdateLayer(classId) {\n        //alert(classId);\n        //1.获取当前行数据===》发送ajax请求，获取当前行数据\n        $.ajax({\n            url: &quot;${pageContext.request.contextPath}/goodscategory/selectOne&quot;,\n            data: &quot;aid=&quot; + classId,\n            success: function (data) {\n                $(&quot;#className&quot;).val(data.className);\n                $(&quot;#classId&quot;).val(data.classId);\n                $(&quot;#classCode&quot;).val(data.classCode);\n                // $(&quot;#classIdStatus&quot;).val(data.classIdStatus);\n                $(&quot;#classIdStatus&quot;).selected(data.classIdStatus);\n\n            }\n        });\n\n        //2.把数据填充到修改弹出层中==&gt;弹出层显示\n        layui.use([\'layer\', \'form\', \'table\'], function () {\n            var form = layui.form;\n            var layer = layui.layer;\n            var table = layui.table;\n            var $ = layui.jquery;\n\n            $(&quot;#Lay_select_Level&quot;).hide();\n            layer.open({\n                title: &quot;修改配置&quot;,\n                content: $(&quot;#layuiconfig-form-role&quot;),\n                type: 1,\n                maxmin: true,\n                area: [\'500px\', \'480px\'],\n                end:function(){\n                    window.location.reload();\n                }\n            });\n\n            $(&quot;#LAY-sysconfig-submit&quot;).hide();\n            $(&quot;#updateSubmitBtn&quot;).show();\n\n            //3.提交表单\n            form.on(&quot;submit(updateSubmitBtn)&quot;, function (data) {\n                // console.log(data);\n                $.ajax({\n                    url: &quot;${pageContext.request.contextPath}/goodscategory/updateGoods&quot;,\n                    data: data.field,\n                    type: &quot;post&quot;,\n                    //4.接收后台修改响应回来的数据；关闭弹出层、提示修改信息、刷新table\n                    success: function (data) {\n                        //1.关闭掉添加弹出层\n                        layer.closeAll(\'page\');\n                        //2.提示修改成功\n                        layer.alert(&quot;修改&quot; + data.msg+&quot;，请点击右上角刷新表格后生效！&quot;, {time: 3000});\n                        //刷新table\n                      //  table.reload(&quot;Lay_category_treeTable&quot;);\n                    }\n                });\n                return false;//阻止跳转；\n            })\n        });\n\n    }\n\n    //执行添加\n    function toOpenAddLayer() {\n        layui.use([&quot;form&quot;, &quot;layer&quot;, &quot;table&quot;], function () {\n            var form = layui.form;\n            var layer = layui.layer;\n            var table = layui.table;\n\n            layer.open({\n                title: &quot;添加配置&quot;,\n                content: $(&quot;#layuiconfig-form-role&quot;),\n                type: 1,\n                maxmin: true,\n                area: [\'500px\', \'480px\'],\n                end: function () {\n                    window.location.reload();\n                }\n            });\n\n            $(&quot;#updateSubmitBtn&quot;).hide();\n            $(&quot;#LAY-sysconfig-submit&quot;).show();\n\n            form.on(\'select(classIdLevel)\', function (data) {\n                //console.log(data.elem); //得到select原始DOM对象\n                console.log(&quot;data.value = &quot;+data.value); //得到被选中的值\n                //console.log(data.othis); //得到美化后的DOM对象\n                if(data.value == 1){\n                    // alert(1);\n                    $(&quot;#Lay_One_Level&quot;).hide();\n                    $(&quot;#Lay_Two_Level&quot;).hide();\n                }\n                if (data.value == 2) {\n                    // alert(2);\n                    $(&quot;#Lay_One_Level&quot;).show();\n                    $(&quot;#Lay_Two_Level&quot;).hide();\n                    $.ajax({\n                        url: \'${basepath}goodscategory/selectOneLevel\',\n                        dataType: \'json\',\n                        type: \'post\',\n                        success: function (data) {\n                            $.each(data, function (index, item) {\n                                //console.log(&quot;000 &quot; + index);\n                                //console.log(&quot;111 &quot; + item);\n                                $(\'#parentId\').append(new Option(item.className, item.classId));//往下拉菜单里添加元素\n                            });\n                            form.render();//菜单渲染 把内容加载进去\n                        }\n                    })\n                }\n                if (data.value == 3) {\n                    // alert(3);\n                    $(&quot;#Lay_One_Level&quot;).hide();\n                   // form.on(\'select(parent_classIdLevel_One)\', function (data2){\n                        $(&quot;#Lay_Two_Level&quot;).show();\n                        $.ajax({\n                            url: \'${basepath}goodscategory/selectTwoLevel\',\n                            dataType: \'json\',\n                            type: \'post\',\n                            success: function (data) {\n                                $.each(data, function (index, item) {\n                                    //console.log(&quot;000 &quot; + index);\n                                    //console.log(&quot;111 &quot; + item);\n                                    $(\'#Two_parentId\').append(new Option(item.className, item.classId));//往下拉菜单里添加元素\n                                });\n                                form.render();//菜单渲染 把内容加载进去\n                            }\n                        })\n                   // })\n                }\n            });\n\n            //当点击提交按钮的时候，会进入到这个函数\n            form.on(&quot;submit(LAY-sysconfig-submit)&quot;, function (data) {\n                 console.log(data.field);\n                $.ajax({\n                    url: &quot;${pageContext.request.contextPath}/goodscategory/addGoodsCategory&quot;,\n                    data: data.field,\n                    type: &quot;post&quot;,\n                    success: function (data) {\n                        //1.关闭掉添加弹出层\n                        layer.closeAll(\'page\');\n                        //2.提示添加成功\n                        layer.alert(&quot;添加&quot; + data.msg, {time: 3000});\n                        //3.刷新table\n                        table.reload(&quot;Lay_back_table&quot;);\n\n                    }\n                });\n                return false;//阻止跳转；\n            })\n        })\n    }\n\n    function doDelete(classId) {\n       // alert(classId);\n        //确认；如果点击确认删除；否则不删除\n        layui.use([\'layer\', \'table\'], function () {\n            var table = layui.table;\n            var layer = layui.layer;\n\n            layer.confirm(\'确定要删除吗？\', {icon: 3, title: \'确认删除\'}, function (index) {\n                $.ajax({\n                    url: &quot;${pageContext.request.contextPath}/goodscategory/deletecl&quot;,\n                    data: &quot;aid=&quot; + classId,\n                    success: function (data) {\n                        layer.alert(&quot;删除&quot; + data.msg, {time: 2000});\n                        // table.reload(&quot;Lay_back_table&quot;);\n                        layer.close(index);\n                    }\n                })\n            });\n        });\n    }\n\n    function doMultiDelete() {\n        //获取到选中的内容的id===》table模块中找方法\n        layui.use([\'layer\', \'table\'], function () {\n            var table = layui.table;\n            var layer = layui.layer;\n            //获取到选中的数据\n            var checkStatus = table.checkStatus(\'Lay_back_table\'); //idTest 即为基础参数 id 对应的值\n            // console.log(checkStatus.data);//获取选中行的数据\n            var data = checkStatus.data;\n\n            if (data.length == 0) {\n                layer.alert(&quot;请选中要删除的数据&quot;);\n            } else {\n                layer.confirm(&quot;确定要删除选中的所有数据&quot;, function (index) {\n                    //把所有选中的数据的id封装到一个数组中\n                    var ids = new Array(data.length);\n                    for (var i = 0; i &lt; ids.length; i++) {\n                        ids[i] = data[i].id;\n                    }\n                    console.log(&quot;ids===&quot; + ids);\n                    //执行删除操作\n                    $.ajax({\n                        url: &quot;${pageContext.request.contextPath}/prefixThird/deleteMany&quot;,\n                        data: &quot;ids=&quot; + ids,\n                        success: function (data) {\n                            //删除确认框关闭掉\n                            layer.close(index);\n                            //删除提示\n                            layer.alert(&quot;删除&quot; + data.msg+&quot;，请点击右上角刷新表格后生效！&quot;, {time: 2000});\n                            //刷新table\n                            // table.reload(&quot;Lay_back_table&quot;);\n                            // renderTable();\n                        }\n                    })\n                });\n            }\n        });\n    }\n\n\n&lt;/script&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:38:19', '2022-05-21 18:19:34');
INSERT INTO `tb_article` VALUES (68, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3748', 'CSDN-markdown编辑器 使用大全（备份记录快捷键使用方法）', '<p>﻿@<a href=\"这里写自定义目录标题\">TOC</a></p>\n<h1 id=\"欢迎使用markdown编辑器\">欢迎使用Markdown编辑器</h1>\n<p>你好！ 这是你第一次使用 <strong>Markdown编辑器</strong> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</p>\n<h2 id=\"新的改变\">新的改变</h2>\n<p>我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：</p>\n<ol>\n<li><strong>全新的界面设计</strong> ，将会带来全新的写作体验；</li>\n<li>在创作中心设置你喜爱的代码高亮样式，Markdown <strong>将代码片显示选择的高亮样式</strong> 进行展示；</li>\n<li>增加了 <strong>图片拖拽</strong> 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；</li>\n<li>全新的 <strong>KaTeX数学公式</strong> 语法；</li>\n<li>增加了支持<strong>甘特图的mermaid语法[^1]</strong> 功能；</li>\n<li>增加了 <strong>多屏幕编辑</strong> Markdown文章功能；</li>\n<li>增加了 <strong>焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置</strong> 等功能，功能按钮位于编辑区域与预览区域中间；</li>\n<li>增加了 <strong>检查列表</strong> 功能。<br />\n[^1]: <a href=\"https://mermaidjs.github.io/\">mermaid语法说明</a></li>\n</ol>\n<h2 id=\"功能快捷键\">功能快捷键</h2>\n<p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br />\n重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br />\n加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br />\n斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br />\n标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br />\n无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br />\n有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br />\n检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br />\n插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br />\n插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br />\n插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd><br />\n查找：<kbd>Ctrl/Command</kbd> + <kbd>F</kbd><br />\n替换：<kbd>Ctrl/Command</kbd> + <kbd>G</kbd></p>\n<h2 id=\"合理的创建标题有助于目录的生成\">合理的创建标题，有助于目录的生成</h2>\n<p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br />\n输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br />\n以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p>\n<h2 id=\"如何改变文本的样式\">如何改变文本的样式</h2>\n<p><em>强调文本</em> <em>强调文本</em></p>\n<p><strong>加粗文本</strong> <strong>加粗文本</strong></p>\n<p>==标记文本==</p>\n<p><del>删除文本</del></p>\n<blockquote>\n<p>引用文本</p>\n</blockquote>\n<p>H~2~O is是液体。</p>\n<p>2<sup>10</sup> 运算结果是 1024.</p>\n<h2 id=\"插入链接与图片\">插入链接与图片</h2>\n<p>链接: <a href=\"https://mp.csdn.net\">link</a>.</p>\n<p>图片: <img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw\" alt=\"Alt\" /></p>\n<p>带尺寸的图片: ![Alt](<a href=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw\">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw</a> =30x30)</p>\n<p>居中的图片: <img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center\" alt=\"Alt\" /></p>\n<p>居中并且带尺寸的图片: ![Alt](<a href=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center\">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center</a> =30x30)</p>\n<p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p>\n<h2 id=\"如何插入一段漂亮的代码片\">如何插入一段漂亮的代码片</h2>\n<p>去<a href=\"https://mp.csdn.net/configure\">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.</p>\n<pre><code class=\"language-javascript\">// An highlighted block\nvar foo = \'bar\';\n</code></pre>\n<h2 id=\"生成一个适合你的列表\">生成一个适合你的列表</h2>\n<ul>\n<li>项目\n<ul>\n<li>项目\n<ul>\n<li>项目</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>项目1</li>\n<li>项目2</li>\n<li>项目3</li>\n</ol>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;计划任务</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;完成任务</li>\n</ul>\n<h2 id=\"创建一个表格\">创建一个表格</h2>\n<p>一个简单的表格是这么创建的：<br />\n项目     | Value<br />\n-------- | -----<br />\n电脑  | $1600<br />\n手机  | $12<br />\n导管  | $1</p>\n<h3 id=\"设定内容居中居左居右\">设定内容居中、居左、居右</h3>\n<p>使用<code>:---------:</code>居中<br />\n使用<code>:----------</code>居左<br />\n使用<code>----------:</code>居右<br />\n| 第一列       | 第二列         | 第三列        |<br />\n|:-----------:| -------------:|:-------------|<br />\n| 第一列文本居中 | 第二列文本居右  | 第三列文本居左 |</p>\n<h3 id=\"smartypants\">SmartyPants</h3>\n<p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：<br />\n|    TYPE   |ASCII                          |HTML<br />\n|----------------|-------------------------------|-----------------------------|<br />\n|Single backticks|<code>\'Isn\'t this fun?\'</code>            |\'Isn\'t this fun?\'            |<br />\n|Quotes          |<code>&quot;Isn\'t this fun?&quot;</code>            |&quot;Isn\'t this fun?&quot;            |<br />\n|Dashes          |<code>-- is en-dash, --- is em-dash</code>|-- is en-dash, --- is em-dash|</p>\n<h2 id=\"创建一个自定义列表\">创建一个自定义列表</h2>\n<p>Markdown<br />\n:  Text-to-HTML conversion tool</p>\n<p>Authors<br />\n:  John<br />\n:  Luke</p>\n<h2 id=\"如何创建一个注脚\">如何创建一个注脚</h2>\n<p>一个具有注脚的文本。<a href=\"注脚的解释\">^2</a></p>\n<h2 id=\"注释也是必不可少的\">注释也是必不可少的</h2>\n<p>Markdown将文本转换为 HTML。</p>\n<p>*[HTML]:   超文本标记语言</p>\n<h2 id=\"katex数学公式\">KaTeX数学公式</h2>\n<p>您可以使用渲染LaTeX数学表达式 <a href=\"https://khan.github.io/KaTeX/\">KaTeX</a>:</p>\n<p>Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\forall<br />\nn\\in\\mathbb N$ 是通过欧拉积分</p>\n<p>$$<br />\n\\Gamma(z) = \\int_0<sup z-1=\"\">\\infty t</sup>e^{-t}dt,.<br />\n$$</p>\n<blockquote>\n<p>你可以找到更多关于的信息 <strong>LaTeX</strong> 数学表达式<a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\">here</a>.</p>\n</blockquote>\n<h2 id=\"新的甘特图功能丰富你的文章\">新的甘特图功能，丰富你的文章</h2>\n<div class=\"mermaid\">\ngantt\n        dateFormat  YYYY-MM-DD\n        title Adding GANTT diagram functionality to mermaid\n        section 现有任务\n        已完成               :done,    des1, 2014-01-06,2014-01-08\n        进行中               :active,  des2, 2014-01-09, 3d\n        计划一               :         des3, after des2, 5d\n        计划二               :         des4, after des3, 5d\n</div>\n<ul>\n<li>关于 <strong>甘特图</strong> 语法，参考 <a href=\"https://mermaidjs.github.io/\">这儿</a>,</li>\n</ul>\n<h2 id=\"uml-图表\">UML 图表</h2>\n<p>可以使用UML图表进行渲染。 <a href=\"https://mermaidjs.github.io/\">Mermaid</a>. 例如下面产生的一个序列图：</p>\n<div class=\"mermaid\">\nsequenceDiagram\n张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?\n李四--&gt;&gt;王五: 你最近怎么样，王五？\n李四--x 张三: 我很好，谢谢!\n李四-x 王五: 我很好，谢谢!\nNote right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.\n\n李四--&gt;&gt;张三: 打量着王五...\n张三-&gt;&gt;王五: 很好... 王五, 你怎么样?\n</div>\n<p>这将产生一个流程图。:</p>\n<div class=\"mermaid\">\ngraph LR\nA[长方形] -- 链接 --&gt; B((圆))\nA --&gt; C(圆角长方形)\nB --&gt; D{菱形}\nC --&gt; D\n</div>\n<ul>\n<li>关于 <strong>Mermaid</strong> 语法，参考 <a href=\"https://mermaidjs.github.io/\">这儿</a>,</li>\n</ul>\n<h2 id=\"flowchart流程图\">FLowchart流程图</h2>\n<p>我们依旧会支持flowchart的流程图：</p>\n<div class=\"mermaid\">\nflowchat\nst=&gt;start: 开始\ne=&gt;end: 结束\nop=&gt;operation: 我的操作\ncond=&gt;condition: 确认？\n\nst-&gt;op-&gt;cond\ncond(yes)-&gt;e\ncond(no)-&gt;op\n</div>\n<ul>\n<li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href=\"http://adrai.github.io/flowchart.js/\">这儿</a>.</li>\n</ul>\n<h2 id=\"导出与导入\">导出与导入</h2>\n<h3 id=\"导出\">导出</h3>\n<p>如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <strong>文章导出</strong> ，生成一个.md文件或者.html文件进行本地保存。</p>\n<h3 id=\"导入\">导入</h3>\n<p>如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，<br />\n继续你的创作。</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:38:37', '2020-04-25 15:38:37');
INSERT INTO `tb_article` VALUES (69, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4582', 'git从入门配置到常用基本命令，傻瓜式操作一步步命令总结', '<p>﻿### 1，git的下载安装<br />\n下载地址：<a href=\"https://git-scm.com/download/win\">git官方下载地址https://git-scm.com/download/win</a></p>\n<p>安装，双击安装包，一直不停的下一步就安装好了。</p>\n<p>检验是否安装成功：在电脑的任何位置 右键 Git Bash Here （打开Git命令窗口）</p>\n<h3 id=\"2配置本地git\">2，配置本地git</h3>\n<p>name是你自己的名字<br />\n邮箱要是你在github或者码云上注册的邮箱</p>\n<pre><code class=\"language-git\">git config --global user.name &quot;Your Name&quot;  \ngit config --global user.email &quot;email@example.com&quot;\n</code></pre>\n<h3 id=\"3基本命令\">3，基本命令</h3>\n<p>1，在自己电脑上创建一个文件夹，就是版本库<br />\n创建一个本地版本库  写一个文档  交给git管理（添加到本地版本库）</p>\n<p>2，进入文件夹内部， 右键 Git Bash Here （打开Git命令窗口）输入</p>\n<pre><code>git init \n</code></pre>\n<p>命令。初始化本地版本库。如果你的电脑不显示这个文件夹，请打开显示隐藏的项目，</p>\n<p>3，随便创建一个txt文件，添加test.tx文件到本地版本库</p>\n<p>添加当前文件夹 所有的文件 到暂存区</p>\n<pre><code>git add .\n</code></pre>\n<p>添加指定的文件</p>\n<pre><code>git add test.txt\n</code></pre>\n<p>将暂存区文件提交到本地版本库</p>\n<pre><code class=\"language-git\">git commit -m &quot;v1.0 写版本描述信息 必须写&quot;\n</code></pre>\n<p>查看所有的版本信息</p>\n<pre><code>git log   #查看日志 所有的版本信息\ngit reflog   #查看日志 所有的版本信息\n</code></pre>\n<p>区别</p>\n<ol>\n<li>git log 只显示当前版本 和 之前的所有的版本</li>\n<li>git reflog 显示所有版本 和 所有的操作信息</li>\n</ol>\n<p>更新文件，添加第二个版本</p>\n<pre><code>git add . \ngit commit -m &quot;v2.0 写版本信息 必须写&quot; \n</code></pre>\n<p>回到第一个版本</p>\n<pre><code>   git reset --hard HEAD^   ^回退一个版本 ^^回退100个版本\n   git reset --hard HEAD~100 回退100个版本\n</code></pre>\n<p>再从版本1 回到 版本2</p>\n<pre><code>git reset --hard 版本的编号（不需要写全 5 6位数字就可以）\n</code></pre>\n<p>如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826204103589.png\" alt=\"在这里插入图片描述\" /></p>\n<h3 id=\"版本库的结构\">版本库的结构</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20190826204236680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>查看当前版本库和工作区的文件状态</strong></p>\n<p>git status</p>\n<ol>\n<li>文件 显示红色 文件中有修改  没有做添加 也没有提交<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826204404213.png\" alt=\"在这里插入图片描述\" /></li>\n<li>文件 显示绿色 文件添加了 位于暂存区 没有提交<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826204445349.png\" alt=\"在这里插入图片描述\" /></li>\n<li>没有文件需要提交<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826204509671.png\" alt=\"在这里插入图片描述\" /></li>\n</ol>\n<p><strong>版本撤销</strong></p>\n<p>git checkout  版本撤销</p>\n<ol>\n<li>文件没有添加到暂存区 红色状态  会删除所有新增的内容</li>\n<li>文件添加到暂存区之后 新增的内容是撤销不了的</li>\n</ol>\n<h2 id=\"本地git-集成码云\">本地git 集成码云</h2>\n<ol>\n<li>注册码云</li>\n<li>在本地电脑执行命令生成SSH公钥 输入命令一直回车<br />\n获取公钥命令，然后一直回车就好</li>\n</ol>\n<pre><code>       ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot; \n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190826205114559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\nid_rea是秘钥，不要轻易给别人<br />\nid_rea.pub 公钥，给谁无所谓</p>\n<p>3，在码云配置公钥<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826205234866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>仓库相关的操作</strong></p>\n<ol>\n<li>创建一个仓库<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826205324719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n将整个仓库 克隆（下载） 到本地<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826205347200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></li>\n</ol>\n<p>复制 SSH 连接<br />\n在本地执行克隆的命令</p>\n<pre><code>git clone 粘贴你负责的ssh连接\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190826205439777.png\" alt=\"在这里插入图片描述\" /><br />\n<strong>将之前测试的本地文件推送到远程仓库：</strong></p>\n<pre><code>git add .\ngit commit -m &quot;v2.0 test&quot;\ngit push\n</code></pre>\n<p>在远程写一个文件  更新到本地</p>\n<pre><code>git pull\n</code></pre>\n<h2 id=\"分支的使用\">分支的使用</h2>\n<h5 id=\"常用分支命令\">常用分支命令</h5>\n<pre><code>查看分支,查看当前拥有多少个分支\n	git branch  \n\n创建分支 \n	git branch 要创建的分支的名称  \n\n切换分支 \n	git checkout 要去往的分支名称\n</code></pre>\n<p><strong>删除分支</strong>,慎用，不要轻易删除分支<br />\ngit branch -d 分支名<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826210311773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" />	<br />\n<strong>开发的时候用到的dev分支</strong></p>\n<pre><code>git checkout -b dev // 创建并切换到dev分支\n\ngit push --set-upstream origin dev // 将dev分支推送到远程仓库\n</code></pre>\n<p><strong>合并dev分支至master</strong></p>\n<pre><code>git checkout master // 切换到master分支\n\ngit merge dev // 合并dev分支到当前分支（master）\n</code></pre>\n<h5 id=\"在idea中使用git遇到的一个问题\">在idea中使用Git遇到的一个问题</h5>\n<p>报错：</p>\n<blockquote>\n<p>Push rejected: Push to origin/master was rejected</p>\n</blockquote>\n<p>意思是git拒绝合并两个不相干的东西<br />\n此时你需要在打开Git Bash，然后进入相应的目录，然后敲git命令</p>\n<pre><code>$ git pull origin master --allow-unrelated-histories\n</code></pre>\n<p>出现类似于这种信息就说明pull成功了：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190827191650505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n然后再执行push命令。就可以成功了！</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:39:22', '2022-05-21 18:19:23');
INSERT INTO `tb_article` VALUES (70, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=493', 'SpringBoot集成shiro认证，实现Shiro认证的登录操作', '<p>﻿### 什么是Shiro权限管理？</p>\n<blockquote>\n<p>Apache Shiro 是 Java 的一个安全框架。目前，使用 Apache Shiro 的人越来越多，因为它相 当简单，对比<br />\nSpring Security，可能没有 Spring Security 做的功能强大，但是在实际工作时<br />\n可能并不需要那么复杂的东西，所以使用小而简单的 Shiro 就足够了。对于它俩到底哪个 好，这个不必纠结，能更简单的解决项目问题就好了。</p>\n</blockquote>\n<p>权限管理分为认证和授权</p>\n<h1 id=\"认证\">认证</h1>\n<h4 id=\"认证的基本概念\">认证的基本概念</h4>\n<p>身份认证：校验用户是不是系统合法用户的过程（比如登录操作）</p>\n<blockquote>\n<p><strong>身份认证，就是判断一个用户是否为合法用户的处理过程</strong>。</p>\n<p><strong>最常用的简单身份认证方式是系统通过核对用户输入的用户名和密码，看其是否与系统中存储的该用户的用户名和密码是否一致，来判断用户身份是否正确。</strong></p>\n<p>对于采用指纹等系统，则出示指纹；对于硬件Key等刷卡系统，则需要刷卡。通过二维码等等都是认证的过程</p>\n</blockquote>\n<h4 id=\"认证基本的对象\">认证基本的对象</h4>\n<h5 id=\"subject-主体\">Subject 主体</h5>\n<p>官方给出的解释是这样的：</p>\n<blockquote>\n<p>Without question, the most important concept in Apache Shiro is the Subject. ‘Subject’ is just a security term that means a security-specific ‘view’ of an application user. A Shiro Subject instance represents both security state and operations for a single application user.<br />\n翻译过来就是：<br />\n毫无疑问，<strong>shiro中最重要的概念就是subject（主体）</strong>。subject是一个虚拟的用户对象（就是相当于我们之前的User Admin对象等）。</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20190825173535988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>使用Subject的之后的流程变化</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190825173552565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>其实，<br />\n<strong>Subject可以认为就是Admin  User这些类</strong><br />\n另外subject中还有两个重要概念：</p>\n<blockquote>\n<p><strong>Credential 凭证信息  就是密码的意思</strong></p>\n<p><strong>Principal 身份信息 就是账号的意思</strong></p>\n</blockquote>\n<p>扩展阅读：（看一下官方的解释为什么叫Subject而不叫User）</p>\n<blockquote>\n<p>We originally wanted to call it ‘User’ since that “just makes sense”, but we decided against it: too many applications have existing APIs that already have their own User classes/frameworks, and we didn’t want to conflict with those. Also, in the security world, the term ‘Subject’ is actually the recognized nomenclature.<br />\n翻译如下：<br />\n我们最初是想把它叫做User的，这样很容易理解，但是大部分的应用程序都已经有了User类，为了不和这些原有的api发生冲突，我们最后决定不这么做。</p>\n</blockquote>\n<h4 id=\"认证的登录操作案例springboot集成shiro\">认证的登录操作案例：SpringBoot集成shiro</h4>\n<p>下面开始使用Shiro实现带认证的登录操作</p>\n<h6 id=\"导入依赖\">导入依赖</h6>\n<pre><code class=\"language-xml\">&lt;!--shiro相关依赖--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;\n    &lt;version&gt;1.3.2&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;\n    &lt;version&gt;1.3.2&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;\n    &lt;version&gt;1.3.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h5 id=\"第一个demo\">第一个demo</h5>\n<p>基本思路</p>\n<blockquote>\n<p>用户输入的账号密码  和 数据库中存储的账号密码 比对</p>\n<p>注意：shiro 默认不支持连接数据库  默认通过配置文件获取数据<br />\n所以我们要重写Realm中的方法，实现对数据库的连接</p>\n</blockquote>\n<ol>\n<li>接收用户输入的账号密码,</li>\n<li>要重写Realm中的方法，实现对数据库的连接和数据获取</li>\n<li>写Springboot的配置类，创建并将重写的Realm设置放进去安全管理器， 将安全管理器 和Subject建立联系</li>\n<li>将用户输入的账号密码给Subject</li>\n<li>调用Subject的login方法完成登录</li>\n</ol>\n<p><strong>代码实现流程</strong></p>\n<h6 id=\"重写realm的代码\">重写Realm的代码</h6>\n<pre><code class=\"language-java\">package com.macw.realm;\n\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.macw.entity.Admin;\nimport com.macw.mapper.AdminMapper;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.*;\nimport org.apache.shiro.realm.AuthenticatingRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Resource;\n\n/**\n * @author maCw\n * @version 1.0\n * @date 2019/8/22 16:13\n */\n\npublic class MyRealm extends AuthenticatingRealm {\n\n    @Resource\n    private AdminMapper adminMapper;\n    /**\n     * 记录日志\n     */\n    Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        //1，获取令牌中的数据，账号\n        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;\n        String username = token.getUsername();\n        //2，通过账号查询获取数据库中对应的账号信息\n        Admin admin = adminMapper.selectOne(new QueryWrapper&lt;Admin&gt;().eq(&quot;username&quot;, username));\n        logger.info(&quot;---&quot;+admin);\n        Subject subject = SecurityUtils.getSubject();\n        //将查询的对象放进去subject自带的session中去\n        subject.getSession().setAttribute(&quot;admins&quot;, admin);\n        //如果有数据，对象为非null，说明查询到了数据，封装account返回\n        if (admin != null){\n            SimpleAccount simpleAccount = new SimpleAccount(admin.getUsername(), admin.getPassword(), this.getName());\n            return simpleAccount;\n        }else {\n            //如果对象为空，return null就会抛出账户不存在异常\n            return null;\n        }\n    }\n}\n\n</code></pre>\n<h5 id=\"在springboot中配置shiro\">在SpringBoot中配置shiro</h5>\n<pre><code class=\"language-java\">package com.macw.config;\n\nimport com.macw.realm.MyRealm;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.spring.web.ShiroFilterFactoryBean;\nimport org.apache.shiro.web.config.WebIniSecurityManagerFactory;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.Map;\n\n\n/**\n * @Configuration 标记当前类为配置类  相当于spring.xml\n */\n@Configuration\npublic class ShiroConfig {\n\n    /**\n     * @Bean 声明创建对象  并把对象放在工厂中  相当于bean标签\n     * 如果形参类型对应的对象在工厂中有  会自动装配上\n     * @return\n     */\n    @Bean\n    public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultSecurityManager defaultSecurityManager){\n        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\n        /**\n         * 过滤器链 过滤拦截规则 哪些页面拦截  哪些页面不拦截\n         */\n        Map map = new HashMap();\n        /**\n         * anon 代表匿名可访问 就是不用登录就可以访问  登录页面  登录的url\n         * authc 认证可访问 代表登录后才能访问\n         *\n         * 支持通配符*\n         * 注意拦截规则 一个一个配置\n         */\n        map.put(&quot;/login.jsp&quot;,&quot;anon&quot;);\n        map.put(&quot;/login/*&quot;,&quot;anon&quot;);\n\n        map.put(&quot;/main/*&quot;, &quot;authc&quot;);\n        map.put(&quot;/guru/*&quot;, &quot;authc&quot;);\n        map.put(&quot;/menu/*&quot;, &quot;authc&quot;);\n\n        shiroFilterFactoryBean.setFilterChainDefinitionMap(map);\n\n        /**\n         * 设置安全管理器，将创建的安全管理器放进shiroFilterFactoryBean过滤工厂里面\n         */\n        shiroFilterFactoryBean.setSecurityManager(defaultSecurityManager);\n        return shiroFilterFactoryBean;\n    }\n\n    /**\n     * 创建安全管理器,并将自定义的Realm放进去管理器\n     * @return\n     */\n    @Bean\n    public DefaultSecurityManager getDefaultSecurityManager(MyRealm myRealm){\n        DefaultSecurityManager defaultSecurityManager = new DefaultWebSecurityManager();\n//        需要赋值一个Realm\n        defaultSecurityManager.setRealm(myRealm);\n        return defaultSecurityManager;\n    }\n\n    /**\n     * 创建自定义的Realm\n     */\n    @Bean\n    public MyRealm getMyRealm(){\n        return new MyRealm();\n    }\n}\n</code></pre>\n<p>如果引用到其他项目的话这里需要修改的是 拦截规则  和  自定义的Realm</p>\n<h5 id=\"修改原来的登录方法\">修改原来的登录方法</h5>\n<p>在控制器里的登录方法中修改：</p>\n<pre><code class=\"language-java\">    /**\n     * 使用shiro登录\n     * @param username\n     * @param password\n     * @return\n     */\n    @RequestMapping(&quot;adminLogin&quot;)\n    public String adminLogin(String username,String password){\n//        1.将用户输入的账号密码 封装在token中\n        UsernamePasswordToken token = new UsernamePasswordToken(username, password);\n\n//        2.获取Subject\n        Subject subject = SecurityUtils.getSubject();\n\n//        3.通过Subject 的login方法 完成登录\n        try {\n            subject.login(token);\n            //到这里如果没有异常说明登录成功，\n            return &quot;redirect:/main/main.jsp&quot;;\n        }catch (Exception e){\n            //有异常说明登录失败，重定向到登录页面\n            return &quot;redirect:/login.jsp&quot;;\n        }\n    }\n</code></pre>\n<h5 id=\"shiro中session的使用\">shiro中Session的使用</h5>\n<p><strong>方案1：HttpSession</strong></p>\n<p><strong>方案2：shiro中的session</strong></p>\n<pre><code>Session session1 = SecurityUtils.getSubject().getSession();\n</code></pre>\n<p>注意：方案1  和 方案2 都可以 使用  但是只能使用一种方案  不要混合使用</p>\n<h4 id=\"登录认证总结\">登录认证总结</h4>\n<p><strong>认证：登录，身份认证，校验用户是不是系统合法用户的过程</strong></p>\n<p><strong>主体Subject：就是Admin，User这些类，但是和之前自己定义的User Admin稍以后区别，Subject不仅封装用户和认证相关的数据（账号密码），还封装了和认证相关的方法（login方法）</strong></p>\n<p><strong>Credential 凭证信息  就是密码的意思</strong></p>\n<p><strong>Principal 身份信息 就是账号的意思</strong></p>\n<p><strong>重写Realm中的方法</strong></p>\n<ol>\n<li>\n<p><strong>为什么要重写Realm中的方法</strong></p>\n<p><strong>默认不支持连接数据库  默认的实现是查询配置文件</strong></p>\n</li>\n<li>\n<p><strong>解决方案</strong></p>\n<p><strong>shiro默认的doGetAuthenticationInfo方法是查询配置文件，由于这个方法是父类的一个抽象方法，通过继承和多态，可以继承父类，覆盖这个方法（在方法中写入我们新的方法实现 连接数据库 查询数据库中的账号信息）</strong></p>\n</li>\n</ol>\n<p><strong>集成项目的基本流程</strong></p>\n<ol>\n<li>\n<p>写shiro的配置类（创建对象）</p>\n<p><strong>注意：拦截规则 和 自定义的Realm 需要根据自己项目的情况调整</strong></p>\n</li>\n<li>\n<p>修改原来的登录方法</p>\n</li>\n</ol>\n', 1, '', 0, 0, 1, '2020-04-25 15:39:42', '2022-05-21 18:18:00');
INSERT INTO `tb_article` VALUES (71, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5206', '详解Redis，Redis缓存，Redis分布式锁', '<p>﻿</p>\n<h3 id=\"1redis基本知识\">1、Redis基本知识</h3>\n<h4 id=\"简介\">简介</h4>\n<p>Redis是一个支持网络、基于内存、可选持久性的NoSql数据库，目前在很多的系统中都使用了Redis，尤其是在实现缓存功能的时候应用的尤其广泛（缓存功能也是很多人对Redis的认识），那么Redis到底有哪些优点和缺点，为什么会被广泛应用呢？</p>\n<h4 id=\"redis的优点\">Redis的优点</h4>\n<p>Redis的第一个优点就是<strong>速度快</strong>，Redis使用C语言实现，基于内存，数据的读写效率非常的高，这也是为什么很多系统的缓存功能使用Redis来实现，<em><strong>但是需要明确的是Redis是一个数据库，缓存只是它的一项应用而已。</strong></em></p>\n<p>Redis的第二个优点是<strong>单线程模型</strong>，所谓单线程模型就是每一个请求都会有一个全新的线程来进行处理，这一点类似于Struts2，每一个请求都会有一个新的线程来进行处理。这样做的好处就是避免了线程频繁切换带来的系统开销，同时也避免了让人头疼的多线程问题。</p>\n<p>Redis的第三个优点就是使用了<strong>非阻塞I/O</strong> （NIO），不在网络上浪费时间，进一步提高了效率。</p>\n<p>Redis的第四个优点就是支持多种的<strong>数据类型</strong>，并且每一种数据类型都提供了丰富的操作命令，适用于很多特殊的场景，并且支持自定义命令创建个性化的操作命令。</p>\n<h2 id=\"2redis持久化机制\">2、redis持久化机制</h2>\n<p>redis服务器宕机，内存数据是会丢失了，为了保证数据不丢失需要对数据做备份，所备份就是持久化，Redis的持久化即将内存中的数据同步到硬盘，主要包括两种方式RDB、AOF。</p>\n<p><strong>RDB持久化机制，(默认使用)</strong>：做当前内存数据的全本快照，<br />\n将内存中的数据以快照的方式写入到二进制文件dump.rdb,<br />\n在redis.conf中可以设置发起快照保存的条件。在指定的时间内如果有超过指定数量的key被修改，则会发起快照保存。</p>\n<p>这种方式在数据的实时性上不高，在突然断电的情况下，可能会出现部分数据的丢失，即最后一次快照之后在内存中发生修改的数据。</p>\n<p>简单来说：RDB就是将redis上的所有数据做个备份，存储的是二进制的数据。</p>\n<p><strong>AOF持久化机制，(默认是关闭)</strong>：</p>\n<p>AOF是将Redis内存数据库中更改的数据都记录到指定的文件appendonly.aof。在redis.conf中可以进行写磁盘的相关设置。</p>\n<p>在突然断电的情况下，由于在appendonly.aof中保存了最后一次写磁盘之后redis内存发生数据修改的指令，所以在这个Redis重启后，基本不会发生数据丢失，比RDB具有更好的数据安全性。</p>\n<p>appendfsync always   接收到更改数据的命令，立即将其记录到appendonly.aof中，能保证数据持久化，数据完全不丢失，但效率相对最低。</p>\n<p>appendfsync everysec   每秒钟将redis内存数据修改的命令记录到appendonly.aof中，在性能和持久化上做了折中。因频繁执行磁盘操作，在仅存在单个Master执行写操作时，效率可能存在问题。但在多个Master执行写操作的Redis集群中，效率会提升。</p>\n<p>appendfsync no  依赖于操作系统，因不会频繁执行磁盘操作而性能最好，但redis内存数据修改持久化没有保证，无法保证数据可靠性</p>\n<p><strong>如何开启AOF持久化：</strong><br />\n将redis.conf文件中 appendonly 改成 yes ，自动创建appendonly.aof，该文件存储的客户端执行过<strong>增删改操作的命令</strong></p>\n<br/>\n<h3 id=\"3-redis的数据结构\">3、 Redis的数据结构</h3>\n<p>redis数据库存储数据使用的key-value，键值对方式存储<br />\nkey是string类型 value的数据结构支持5个string、set、sorted_set、list、hash<br />\n<img src=\"https://img-blog.csdnimg.cn/20190820092223845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"4redis-的常用命令\">4、Redis 的常用命令</h4>\n<h5 id=\"string可以存数字\">String(可以存数字)</h5>\n<p>可以实现原子性的自增（数据安全）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820092339194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>这是最基本的类型了，没啥可说的，就是普通的set和get，做简单的k-v缓存</p>\n<h5 id=\"hash\">hash</h5>\n<p>这个是类似map的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在redis里，然后每次读写缓存的时候，可以就操作hash里的某个字段。</p>\n<pre><code>key=150\n\n\n\nvalue={\n\n “id”: 150,\n\n “name”: “zhangsan”,\n\n “age”: 20\n\n}\n\n</code></pre>\n<p>hash类的数据结构，主要是用来存放一些对象，把一些简单的对象给缓存起来，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值</p>\n<pre><code>value={\n\n “id”: 150,\n\n “name”: “zhangsan”,\n\n “age”: 21\n\n}\n\n</code></pre>\n<h5 id=\"list\">list</h5>\n<p>有序列表，这个是可以玩儿出很多花样的</p>\n<p>微博，某个大v的粉丝，就可以以list的格式放在redis里去缓存</p>\n<pre><code>key=某大v\n\nvalue=[zhangsan, lisi, wangwu]\n\nkey=书名\n\nvalue=[评论1, 评论2, 评论3]\n</code></pre>\n<p>比如可以通过list存储一些列表型的数据结构，类似粉丝列表了、文章的评论列表了之类的东西</p>\n<p>比如可以通过<strong>lrange命令</strong>，就是从某个元素开始读取多少个元素，可以基于list实现分页查询，这个很棒的一个功能，基于redis实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走</p>\n<p>比如可以搞个简单的消息队列，从list头怼进去，从list尾巴那里弄出来</p>\n<h5 id=\"set\">set</h5>\n<p>无序集合，自动去重</p>\n<p>直接基于set将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于jvm内存里的HashSet进行去重，但是如果你的某个系统部署在多台机器上呢？</p>\n<p>得基于redis进行全局的set去重</p>\n<p>可以基于set玩儿交集、并集、差集的操作，比如交集吧，可以把两个人的粉丝列表整一个交集，看看俩人的共同好友是谁？对吧</p>\n<p>把两个大v的粉丝都放在两个set中，对两个set做交集</p>\n<h5 id=\"sorted-set-跳表\">sorted set 跳表</h5>\n<p>排序的set，去重但是可以排序，写进去的时候给一个分数，自动根据分数排序，这个可以玩儿很多的花样，最大的特点是有个分数可以自定义排序规则</p>\n<p>比如说你要是想根据时间对数据排序，那么可以写入进去的时候用某个时间作为分数，人家自动给你按照时间排序</p>\n<p>排行榜：将每个用户以及其对应的什么分数写入进去，zadd board score username，接着zrevrange board 0 99，就可以获取排名前100的用户；zrank board username，可以看到用户在排行榜里的排名</p>\n<p><strong>总结：优先掌握 String 即可</strong><br />\n<br/></p>\n<h4 id=\"5数据失效时间\">5、数据失效时间</h4>\n<p>场景：</p>\n<p>手机验证码登录  手机验证码注册</p>\n<p>验证码后台生成  Redis</p>\n<ol>\n<li>集中存储</li>\n<li>可以设置过期时间</li>\n</ol>\n<pre><code>验证码  \n\nkey = 手机号 \nvalue = 验证码  \n\n设置3分钟过期\n</code></pre>\n<p>Redis中可以设置数据的存活时间</p>\n<p>命令</p>\n<pre><code>expire key 存活时间的秒\nttl key 查看key对应的数据的存活时间.\npexipre key 存活时间的毫秒\npttl key 查看key对应的数据的存活时间,毫秒单位\n</code></pre>\n<p><strong>expire key 存活时间的秒</strong></p>\n<p>失效的原理</p>\n<ol>\n<li>\n<p><strong>定期随机删除+惰性删除</strong></p>\n<pre><code>key  \n1    1分钟\n2    1分钟  \n3    1分钟\n4    1分钟\n5\n6\n\nredis 每过100ms 随机抽取一定数量的设置了失效时间的key 将过期的删除\n\n有些key过期了 每次都没有随机到  就一直删不掉  怎么办？\n\n惰性删除 get key 的时候 先判断 key是否过期 如果过期 返回数据为空\n\n</code></pre>\n<p>定期随机删除  例如100ms</p>\n<p>查询的时候 先检查key</p>\n</li>\n<li>\n<p><strong>内存淘汰机制</strong></p>\n<p>如果redis的内存占用过多的时候，此时会进行内存淘汰，有如下一些策略：</p>\n<p>redis 10个key，现在已经满了，redis需要删除掉5个key</p>\n<p>1个key，最近1分钟被查询了100次</p>\n<p>1个key，最近10分钟被查询了50次</p>\n<p>1个key，最近1个小时被查询了1次</p>\n<ol>\n<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了</li>\n<li><strong>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</strong></li>\n<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊</li>\n<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）</li>\n<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key</li>\n<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除</li>\n</ol>\n<p>LRU算法  扩展视野</p>\n</li>\n</ol>\n<br/>\n<h4 id=\"6redis的基本应用\">6、Redis的基本应用！！！</h4>\n<h5 id=\"二级缓存\">二级缓存</h5>\n<ol>\n<li>\n<p>为什么要做缓存</p>\n</li>\n<li>\n<p>缓存的选择（二级缓存）</p>\n</li>\n<li>\n<p>二级缓存的基本概念</p>\n<ol>\n<li>是什么</li>\n<li>如何开启</li>\n</ol>\n</li>\n<li>\n<p>二级缓存的缺点</p>\n</li>\n<li>\n<p>使用Redis集成二级缓存的步骤</p>\n<ol>\n<li>实现cache接口</li>\n</ol>\n</li>\n</ol>\n<p><strong>缓存的作用</strong></p>\n<ol>\n<li>数据从内存获取,提升数据获取速度.</li>\n<li>减轻了数据库读操作的访问压力(数据基本不变)</li>\n</ol>\n<p><strong>MyBatis二级缓存机制(开启)</strong></p>\n<p>机制：</p>\n<ol>\n<li>\n<p>Java本地缓存空间.(jar)</p>\n</li>\n<li>\n<p>mybaits事务提交后操作缓存</p>\n</li>\n<li>\n<p>Mybatis根据Mapper文件的namespace划分多个缓存空间.</p>\n</li>\n<li>\n<p>mybatis会将查询语句执行结果,缓存在 sql所在mapper文件对应的namespace对应的缓存空间中.</p>\n<p>会将执行的查询sql(对sql处理后产生的对象)作为key.</p>\n</li>\n<li>\n<p>MyBatis执行DML,在事务提交之后,默认清空当前sql所在的mapper文件对应的namespace对应的缓存空间中</p>\n<p>A Mapper   User表  脏读</p>\n<p>B Mapper   User表  删除  缓存清空</p>\n<p>缓存空间融合</p>\n<ol>\n<li><strong>所有关于User表的操作都写在一个Mapper中</strong></li>\n<li>Mapper配置 融合缓存空间（基本没有人使用）</li>\n<li>第三方的缓存空间\n<ol>\n<li>ehcache</li>\n<li><strong>Redis</strong></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093046989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>MyBatis缓存实现原理(源码)</strong></p>\n<p><code>org.apache.ibatis.cache.impl.PerpetualCache.class</code></p>\n<ol>\n<li>\n<p>根据namepace划分缓存空间(id)</p>\n</li>\n<li>\n<p>MyBatis二级缓存本质是一个Map结构</p>\n<p>key :和执行的sql先关</p>\n<p>value:查询结果相关</p>\n</li>\n<li>\n<p>存放数据的功能: select语句(key)----查询结果(value)</p>\n</li>\n<li>\n<p>获得数据的功能: 根据key</p>\n</li>\n<li>\n<p>清空缓存的功能: clear</p>\n</li>\n<li>\n<p>MyBatis管理每个缓存,使用Map管理 key:id(namespace)  value:PerpetualCache</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093242240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>MyBatis缓存的问题?(缓存数据量不能太多)</strong></p>\n<ol>\n<li>mybatis缓存在tomcat的jvm内部分配的缓存空间.</li>\n<li>缓存数据过多,挤占java运行期间需要的内存.</li>\n</ol>\n<p>解决办法:</p>\n<p>将Mybatis的二级缓存空间转移到Redis数据库中</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093258936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>Mybatis二级缓存空间划分</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093309465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>Redis缓存空间的划分设计</strong></p>\n<p>核心:</p>\n<ol>\n<li>每个缓存空间是一个map</li>\n<li>每个缓存空间对应一个namespace.(管理多个cache空间)</li>\n</ol>\n<p>方案:</p>\n<ol>\n<li>将mybatis的namespace作为redis的key</li>\n<li>将key对应的value作为hash数据结构使用.(替换PerpetualCache)</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093323489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>自定义Redis缓存实现</strong></p>\n<p><strong>自定义缓存实现类</strong></p>\n<ol>\n<li>\n<p>自定义MyBatis二级缓存</p>\n<ol>\n<li>自定缓存类实现Cache接口</li>\n<li>导入redis操作相关的工具(jar,JedisUtil,jedis.properties)</li>\n<li>必须具备如下功能:</li>\n</ol>\n</li>\n<li>\n<p>根据namepace划分缓存空间(id)</p>\n</li>\n<li>\n<p>MyBatis二级缓存本质是一个Map结构</p>\n<p>key :和执行的sql先关</p>\n<p>value:查询结果相关</p>\n</li>\n<li>\n<p>存放数据的功能: select语句(key)----查询结果(value)</p>\n</li>\n<li>\n<p>获得数据的功能: 根据key</p>\n</li>\n<li>\n<p>清空缓存的功能: clear</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093345829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>使用自定义的缓存</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093414993.png\" alt=\"在这里插入图片描述\" /></p>\n<h5 id=\"session共享\">Session共享</h5>\n<p><strong>为何要实现session共享？</strong></p>\n<p>nginx负载均衡,希望兼顾权重的按照硬件性能分配访问压力的优势,又想保证多个tomcat使用同一个session应该怎么解决？<br />\n<img src=\"https://img-blog.csdnimg.cn/20190820093754832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>ip_hash</li>\n<li>session复制</li>\n<li>Redis</li>\n</ol>\n<p><strong>解决方案</strong></p>\n<p>使用redis管理负载均衡中多个tomcat的session.(Redis共享session)</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093811946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>如何实现Redis管理Session</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093611617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>配置步骤</strong></p>\n<ol>\n<li>tomcat使用redis管理session的jar</li>\n</ol>\n<p>将jar拷贝tomcat中lib</p>\n<ol start=\"2\">\n<li>配置tomcat的session管理方式为RedisSessionManager</li>\n</ol>\n<pre><code class=\"language-xml\">1. tomcat 配置文件context.xml\n\n&lt;!--注册session管理工具--&gt;\n&lt;Manager className=&quot;session管理工具全类名&quot;\n         host=&quot;redis的ip地址&quot;\n         port=&quot;端口&quot;\n         maxInactiveInterval=&quot;session存活时间 秒 1800&quot; 秒\n         /&gt;\n\n&lt;!--将session管理工具使用在tomcat操作过程中--&gt;\n&lt;Valve className=&quot;RedisSessionHandlerValve在tomcat中使用session管理工具&quot;/&gt;\n</code></pre>\n<p><strong>重启两个tomcat</strong></p>\n<h4 id=\"缓存问题\">缓存问题</h4>\n<ol>\n<li>\n<p>缓存穿透</p>\n</li>\n<li>\n<p>缓存雪崩</p>\n<pre><code>User\n\n根据主键查询 \n\nkey\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n1W  -id  缓存中都没有 \n\n2000个查询  每秒 可以认为是安全的\n</code></pre>\n</li>\n</ol>\n<h5 id=\"缓存穿透\">缓存穿透</h5>\n<p>缓存击穿  大量不存在的key攻击</p>\n<p>只需要极少的空间就可以判断一个元素是不是在一个集合之内，这正好是我们所需要的场景啊：判断key是否存在<br />\n<img src=\"https://img-blog.csdnimg.cn/2019082009405750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n解决方案</p>\n<ol>\n<li>\n<p>空值缓存 （非恶意攻击）</p>\n<pre><code>key  value\n-1   null\n</code></pre>\n</li>\n<li>\n<p>布隆过滤器</p>\n<p>可以判断key是否在数据库中存在</p>\n<p>缺点：可能会判断出错 概率不高 但是会</p>\n</li>\n</ol>\n<h5 id=\"缓存雪崩\">缓存雪崩</h5>\n<p>微博</p>\n<pre><code>key = 鹿晗微博1  value = 相关信息 评论  追评 点赞 等\nkey = 鹿晗微博2  value = 相关信息 评论  追评 点赞 等\nkey = 鹿晗微博3  value = 相关信息 评论  追评 点赞 等\nkey = 鹿晗微博4  value = 相关信息 评论  追评 点赞 等\nkey = 鹿晗微博5  value = 相关信息 评论  追评 点赞 等\nkey = 吃瓜群众1 \nkey = 吃瓜群众2 \nkey = 吃瓜群众3 \nkey = 吃瓜群众4 \nkey = 吃瓜群众5\n\n上千万key 这些key一定会设置失效 失效时间设置的不合理  同一时间大量key过期了（500W）  如果发生在平时 无所谓\n不巧的是  上热搜了 突然间 大量的用户来访问 相关的信息\n</code></pre>\n<p>大量key同一时间失效 将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820094117131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>大量流量  且数据失效  导致不存在的数据每次请求都要到存储层去查询  一模一样的SQL   数据库崩溃</p>\n<ol>\n<li>合理的设置过期时间  单体架构</li>\n<li>分布式锁</li>\n<li>多级缓存</li>\n</ol>\n<p>分布式的锁，谁获得了这把锁，谁就可以访问数据库</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820094139437.png\" alt=\"在这里插入图片描述\" /></p>\n<p>大型项目中</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820094222330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>如果说用户查不到数据  降级服务</p>\n<ol>\n<li>先等着  两三秒</li>\n<li>能直接  返回固定数据</li>\n<li>等等</li>\n</ol>\n<h3 id=\"7redis-分布式锁\">7、Redis 分布式锁</h3>\n<h4 id=\"什么是分布式锁\">什么是分布式锁</h4>\n<p>一种逻辑处理</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820094239766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"redis-分布式锁\">Redis 分布式锁</h4>\n<p>分布式锁本质上要实现的目标就是在 Redis 里面占一个“茅坑”，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。</p>\n<p>占坑一般是使用 <strong>setnx(set if not exists) 指令</strong>，只允许被一个客户端占坑。先来先占， 用完了，再调用 del 指令释放茅坑。</p>\n<pre><code>// 这里的冒号:就是一个普通的字符，没特别含义，它可以是任意其它字符，不要误解\n&gt; setnx lock:codehole true\nOK\n... do something critical ...\n&gt; del lock:codehole\n(integer) 1\n</code></pre>\n<p>但是有个问题，如果逻辑执行到中间出现异常了，可能会导致 del 指令没有被调用，这样就会陷入死锁，锁永远得不到释放。</p>\n<p>于是我们在拿到锁之后，再给<strong>锁加上一个过期时间</strong>，比如 5s，这样即使中间出现异常也可以保证 5 秒之后锁会自动释放。</p>\n<pre><code>&gt; setnx lock:codehole true\nOK\n&gt; expire lock:codehole 5\n... do something critical ...\n&gt; del lock:codehole\n(integer) 1\n</code></pre>\n<p>但是以上逻辑还有问题。如果在 setnx 和 expire 之间服务器进程突然挂掉了，可能是因为机器掉电或者是被人为杀掉的，就会导致 expire 得不到执行，也会造成死锁。</p>\n<p>这种问题的根源就在于 setnx 和 expire 是两条指令而不是原子指令。如果这两条指令可以一起执行就不会出现问题。也许你会想到用 Redis 事务来解决。但是这里不行，因为 expire 是依赖于 setnx 的执行结果的，如果 setnx 没抢到锁，expire 是不应该执行的。事务里没有 if-else 分支逻辑，事务的特点是一口气执行，要么全部执行要么一个都不执行。</p>\n<p>为了解决这个疑难，Redis 开源社区涌现了一堆分布式锁的 library，专门用来解决这个问题。实现方法极为复杂，小白用户一般要费很大的精力才可以搞懂。如果你需要使用分布式锁，意味着你不能仅仅使用 Jedis 或者 redis-py 就行了，还得引入分布式锁的 library。</p>\n<p><strong>为了治理这个乱象，Redis 2.8 版本中作者加入了 set 指令的扩展参数，使得 setnx 和 expire 指令可以一起执行，彻底解决了分布式锁的乱象。从此以后所有的第三方分布式锁 library 可以休息了。</strong></p>\n<pre><code>&gt; set lock:codehole true ex 5 nx\nOK\n... do something critical ...\n&gt; del lock:codehole\n</code></pre>\n<p>上面这个指令就是 setnx 和 expire 组合在一起的原子指令，它就是分布式锁的奥义所在。</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:40:11', '2022-05-21 18:17:42');
INSERT INTO `tb_article` VALUES (72, 1, 4, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=342', 'Java随机生成【用户对象】：中文姓名、全国随机省市居住地、随机邮箱、手机号、注册时间工具类', '<p>﻿### 话不多说，先上工具类，下面再解释：<br />\nJava随机生成【用户对象】：<br />\n中文姓名、全国随机省市居住地、随机邮箱、手机号、注册时间<br />\nGenerateUserUtil.java工具类</p>\n<pre><code class=\"language-java\">package com.macw.util;\n\nimport com.macw.entity.User;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Random;\n\n/**\n * @author 超伟\n */\npublic class GenerateUserUtil {\n\n    private static final String place[][] = {\n            {&quot;北京&quot;, &quot;市辖区&quot;, &quot;市辖县&quot;},\n            {&quot;天津&quot;, &quot;市辖区&quot;, &quot;市辖县&quot;},\n            {&quot;安徽&quot;, &quot;安庆市&quot;, &quot;蚌埠市&quot;, &quot;亳州市&quot;, &quot;巢湖市&quot;, &quot;池州市&quot;, &quot;滁州市&quot;, &quot;阜阳市&quot;, &quot;合肥市&quot;, &quot;淮北市&quot;, &quot;淮南市&quot;, &quot;黄山市&quot;, &quot;六安市&quot;, &quot;马鞍山市&quot;, &quot;宿州市&quot;, &quot;铜陵市&quot;, &quot;芜湖市&quot;, &quot;宣城市&quot;},\n            {&quot;澳门&quot;, &quot;澳门&quot;},\n            {&quot;香港&quot;, &quot;香港&quot;},\n            {&quot;福建&quot;, &quot;福州市&quot;, &quot;龙岩市&quot;, &quot;南平市&quot;, &quot;宁德市&quot;, &quot;莆田市&quot;, &quot;泉州市&quot;, &quot;厦门市&quot;, &quot;漳州市&quot;},\n            {&quot;甘肃&quot;, &quot;白银市&quot;, &quot;定西市&quot;, &quot;甘南藏族自治州&quot;, &quot;嘉峪关市&quot;, &quot;金昌市&quot;, &quot;酒泉市&quot;, &quot;兰州市&quot;, &quot;临夏回族自治州&quot;, &quot;陇南市&quot;, &quot;平凉市&quot;, &quot;庆阳市&quot;, &quot;天水市&quot;, &quot;武威市&quot;, &quot;张掖市&quot;},\n            {&quot;广东&quot;, &quot;潮州市&quot;, &quot;东莞市&quot;, &quot;佛山市&quot;, &quot;广州市&quot;, &quot;河源市&quot;, &quot;惠州市&quot;, &quot;江门市&quot;, &quot;揭阳市&quot;, &quot;茂名市&quot;, &quot;梅州市&quot;, &quot;清远市&quot;, &quot;汕头市&quot;, &quot;汕尾市&quot;, &quot;韶关市&quot;, &quot;深圳市&quot;, &quot;阳江市&quot;, &quot;云浮市&quot;, &quot;湛江市&quot;, &quot;肇庆市&quot;, &quot;中山市&quot;, &quot;珠海市&quot;},\n            {&quot;广西&quot;, &quot;百色市&quot;, &quot;北海市&quot;, &quot;崇左市&quot;, &quot;防城港市&quot;, &quot;贵港市&quot;, &quot;桂林市&quot;, &quot;河池市&quot;, &quot;贺州市&quot;, &quot;来宾市&quot;, &quot;柳州市&quot;, &quot;南宁市&quot;, &quot;钦州市&quot;, &quot;梧州市&quot;, &quot;玉林市&quot;},\n            {&quot;贵州&quot;, &quot;安顺市&quot;, &quot;毕节地区&quot;, &quot;贵阳市&quot;, &quot;六盘水市&quot;, &quot;黔东南苗族侗族自治州&quot;, &quot;黔南布依族苗族自治州&quot;, &quot;黔西南布依族苗族自治州&quot;, &quot;铜仁地区&quot;, &quot;遵义市&quot;},\n            {&quot;海南&quot;, &quot;海口市&quot;, &quot;三亚市&quot;, &quot;省直辖县级行政区划&quot;},\n            {&quot;河北&quot;, &quot;保定市&quot;, &quot;沧州市&quot;, &quot;承德市&quot;, &quot;邯郸市&quot;, &quot;衡水市&quot;, &quot;廊坊市&quot;, &quot;秦皇岛市&quot;, &quot;石家庄市&quot;, &quot;唐山市&quot;, &quot;邢台市&quot;, &quot;张家口市&quot;},\n            {&quot;河南&quot;, &quot;安阳市&quot;, &quot;鹤壁市&quot;, &quot;焦作市&quot;, &quot;开封市&quot;, &quot;洛阳市&quot;, &quot;漯河市&quot;, &quot;南阳市&quot;, &quot;平顶山市&quot;, &quot;濮阳市&quot;, &quot;三门峡市&quot;, &quot;商丘市&quot;, &quot;新乡市&quot;, &quot;信阳市&quot;, &quot;许昌市&quot;, &quot;郑州市&quot;, &quot;周口市&quot;, &quot;驻马店市&quot;},\n            {&quot;黑龙江&quot;, &quot;大庆市&quot;, &quot;大兴安岭地区&quot;, &quot;哈尔滨市&quot;, &quot;鹤岗市&quot;, &quot;黑河市&quot;, &quot;鸡西市&quot;, &quot;佳木斯市&quot;, &quot;牡丹江市&quot;, &quot;七台河市&quot;, &quot;齐齐哈尔市&quot;, &quot;双鸭山市&quot;, &quot;绥化市&quot;, &quot;伊春市&quot;},\n            {&quot;湖北&quot;, &quot;鄂州市&quot;, &quot;恩施土家族苗族自治州&quot;, &quot;黄冈市&quot;, &quot;黄石市&quot;, &quot;荆门市&quot;, &quot;荆州市&quot;, &quot;十堰市&quot;, &quot;随州市&quot;, &quot;武汉市&quot;, &quot;咸宁市&quot;, &quot;襄樊市&quot;, &quot;孝感市&quot;, &quot;宜昌市&quot;},\n            {&quot;湖南&quot;, &quot;长沙市&quot;, &quot;常德市&quot;, &quot;郴州市&quot;, &quot;衡阳市&quot;, &quot;怀化市&quot;, &quot;娄底市&quot;, &quot;邵阳市&quot;, &quot;湘潭市&quot;, &quot;湘西土家族苗族自治州&quot;, &quot;益阳市&quot;, &quot;永州市&quot;, &quot;岳阳市&quot;, &quot;张家界市&quot;, &quot;株洲市&quot;},\n            {&quot;吉林&quot;, &quot;白城市&quot;, &quot;白山市&quot;, &quot;长春市&quot;, &quot;吉林市&quot;, &quot;辽源市&quot;, &quot;四平市&quot;, &quot;松原市&quot;, &quot;通化市&quot;, &quot;延边朝鲜族自治州&quot;},\n            {&quot;江苏&quot;, &quot;常州市&quot;, &quot;淮安市&quot;, &quot;连云港市&quot;, &quot;南京市&quot;, &quot;南通市&quot;, &quot;苏州市&quot;, &quot;宿迁市&quot;, &quot;泰州市&quot;, &quot;无锡市&quot;, &quot;徐州市&quot;, &quot;盐城市&quot;, &quot;扬州市&quot;, &quot;镇江市&quot;},\n            {&quot;江西&quot;, &quot;抚州市&quot;, &quot;赣州市&quot;, &quot;吉安市&quot;, &quot;景德镇市&quot;, &quot;九江市&quot;, &quot;南昌市&quot;, &quot;萍乡市&quot;, &quot;上饶市&quot;, &quot;新余市&quot;, &quot;宜春市&quot;, &quot;鹰潭市&quot;},\n            {&quot;辽宁&quot;, &quot;鞍山市&quot;, &quot;本溪市&quot;, &quot;朝阳市&quot;, &quot;大连市&quot;, &quot;丹东市&quot;, &quot;抚顺市&quot;, &quot;阜新市&quot;, &quot;葫芦岛市&quot;, &quot;锦州市&quot;, &quot;辽阳市&quot;, &quot;盘锦市&quot;, &quot;沈阳市&quot;, &quot;铁岭市&quot;, &quot;营口市&quot;},\n            {&quot;内蒙古&quot;, &quot;阿拉善盟&quot;, &quot;巴彦淖尔市&quot;, &quot;包头市&quot;, &quot;赤峰市&quot;, &quot;鄂尔多斯市&quot;, &quot;呼和浩特市&quot;, &quot;呼伦贝尔市&quot;, &quot;通辽市&quot;, &quot;乌海市&quot;, &quot;乌兰察布市&quot;, &quot;锡林郭勒盟&quot;, &quot;兴安盟&quot;},\n            {&quot;宁夏&quot;, &quot;固原市&quot;, &quot;石嘴山市&quot;, &quot;吴忠市&quot;, &quot;银川市&quot;, &quot;中卫市&quot;},\n            {&quot;青海&quot;, &quot;果洛藏族自治州&quot;, &quot;海北藏族自治州&quot;, &quot;海东地区&quot;, &quot;海南藏族自治州&quot;, &quot;海西蒙古族藏族自治州&quot;, &quot;黄南藏族自治州&quot;, &quot;西宁市&quot;, &quot;玉树藏族自治州&quot;},\n            {&quot;山东&quot;, &quot;滨州市&quot;, &quot;德州市&quot;, &quot;东营市&quot;, &quot;菏泽市&quot;, &quot;济南市&quot;, &quot;济宁市&quot;, &quot;莱芜市&quot;, &quot;聊城市&quot;, &quot;临沂市&quot;, &quot;青岛市&quot;, &quot;日照市&quot;, &quot;泰安市&quot;, &quot;威海市&quot;, &quot;潍坊市&quot;, &quot;烟台市&quot;, &quot;枣庄市&quot;, &quot;淄博市&quot;},\n            {&quot;山西&quot;, &quot;长治市&quot;, &quot;大同市&quot;, &quot;晋城市&quot;, &quot;晋中市&quot;, &quot;临汾市&quot;, &quot;吕梁市&quot;, &quot;朔州市&quot;, &quot;太原市&quot;, &quot;忻州市&quot;, &quot;阳泉市&quot;, &quot;运城市&quot;},\n            {&quot;陕西&quot;, &quot;安康市&quot;, &quot;宝鸡市&quot;, &quot;汉中市&quot;, &quot;商洛市&quot;, &quot;铜川市&quot;, &quot;渭南市&quot;, &quot;西安市&quot;, &quot;咸阳市&quot;, &quot;延安市&quot;, &quot;榆林市&quot;},\n            {&quot;四川&quot;, &quot;阿坝藏族羌族自治州&quot;, &quot;巴中市&quot;, &quot;成都市&quot;, &quot;达州市&quot;, &quot;德阳市&quot;, &quot;甘孜藏族自治州&quot;, &quot;广安市&quot;, &quot;广元市&quot;, &quot;乐山市&quot;, &quot;凉山彝族自治州&quot;, &quot;泸州市&quot;, &quot;眉山市&quot;, &quot;绵阳市&quot;, &quot;内江市&quot;, &quot;南充市&quot;, &quot;攀枝花市&quot;, &quot;遂宁市&quot;, &quot;雅安市&quot;, &quot;宜宾市&quot;, &quot;资阳市&quot;, &quot;自贡市&quot;},\n            {&quot;西藏&quot;, &quot;阿里地区&quot;, &quot;昌都地区&quot;, &quot;拉萨市&quot;, &quot;林芝地区&quot;, &quot;那曲地区&quot;, &quot;日喀则地区&quot;, &quot;山南地区&quot;},\n            {&quot;新疆&quot;, &quot;阿克苏地区&quot;, &quot;阿勒泰地区&quot;, &quot;巴音郭楞蒙古自治州&quot;, &quot;博尔塔拉蒙古自治州&quot;, &quot;昌吉回族自治州&quot;, &quot;哈密地区&quot;, &quot;和田地区&quot;, &quot;喀什地区&quot;, &quot;克拉玛依市&quot;, &quot;克孜勒苏柯尔克孜自治州&quot;, &quot;塔城地区&quot;, &quot;吐鲁番地区&quot;, &quot;乌鲁木齐市&quot;, &quot;伊犁哈萨克自治州&quot;, &quot;自治区直辖县级行政区划&quot;},\n            {&quot;云南&quot;, &quot;保山市&quot;, &quot;楚雄彝族自治州&quot;, &quot;大理白族自治州&quot;, &quot;德宏傣族景颇族自治州&quot;, &quot;迪庆藏族自治州&quot;, &quot;红河哈尼族彝族自治州&quot;, &quot;昆明市&quot;, &quot;丽江市&quot;, &quot;临沧市&quot;, &quot;怒江僳僳族自治州&quot;, &quot;普洱市&quot;, &quot;曲靖市&quot;, &quot;文山壮族苗族自治州&quot;, &quot;西双版纳傣族自治州&quot;, &quot;玉溪市&quot;, &quot;昭通市&quot;},\n            {&quot;浙江&quot;, &quot;杭州市&quot;, &quot;湖州市&quot;, &quot;嘉兴市&quot;, &quot;金华市&quot;, &quot;丽水市&quot;, &quot;宁波市&quot;, &quot;衢州市&quot;, &quot;绍兴市&quot;, &quot;台州市&quot;, &quot;温州市&quot;, &quot;舟山市&quot;},\n            {&quot;重庆&quot;, &quot;市辖区&quot;, &quot;市辖县&quot;, &quot;县级市&quot;},\n            {&quot;台湾&quot;, &quot;台北市&quot;, &quot;高雄市&quot;, &quot;基隆市&quot;, &quot;台中市&quot;, &quot;台南市&quot;, &quot;新竹市&quot;, &quot;嘉义市&quot;},\n    };\n\n    private static String base = &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;;\n    private static String firstName = &quot;赵钱孙李周吴郑王冯陈褚卫蒋沈韩杨朱秦尤许何吕施张孔曹严华金魏陶姜戚谢邹喻柏水窦章云苏潘葛奚范彭郎鲁韦昌马苗凤花方俞任袁柳酆鲍史唐费廉岑薛雷贺倪汤滕殷罗毕郝邬安常乐于时傅皮卞齐康伍余元卜顾孟平黄和穆萧尹姚邵湛汪祁毛禹狄米贝明臧计伏成戴谈宋茅庞熊纪舒屈项祝董梁杜阮蓝闵席季麻强贾路娄危江童颜郭梅盛林刁钟徐邱骆高夏蔡田樊胡凌霍虞万支柯咎管卢莫经房裘缪干解应宗宣丁贲邓郁单杭洪包诸左石崔吉钮龚程嵇邢滑裴陆荣翁荀羊於惠甄魏加封芮羿储靳汲邴糜松井段富巫乌焦巴弓牧隗山谷车侯宓蓬全郗班仰秋仲伊宫宁仇栾暴甘钭厉戎祖武符刘姜詹束龙叶幸司韶郜黎蓟薄印宿白怀蒲台从鄂索咸籍赖卓蔺屠蒙池乔阴郁胥能苍双闻莘党翟谭贡劳逄姬申扶堵冉宰郦雍却璩桑桂濮牛寿通边扈燕冀郏浦尚农温别庄晏柴瞿阎充慕连茹习宦艾鱼容向古易慎戈廖庚终暨居衡步都耿满弘匡国文寇广禄阙东殴殳沃利蔚越夔隆师巩厍聂晁勾敖融冷訾辛阚那简饶空曾毋沙乜养鞠须丰巢关蒯相查后江红游竺权逯盖益桓公万俟司马上官欧阳夏侯诸葛闻人东方赫连皇甫尉迟公羊澹台公冶宗政濮阳淳于仲孙太叔申屠公孙乐正轩辕令狐钟离闾丘长孙慕容鲜于宇文司徒司空亓官司寇仉督子车颛孙端木巫马公西漆雕乐正壤驷公良拓拔夹谷宰父谷粱晋楚阎法汝鄢涂钦段干百里东郭南门呼延归海羊舌微生岳帅缑亢况后有琴梁丘左丘东门西门商牟佘佴伯赏南宫墨哈谯笪年爱阳佟第五言福百家姓续&quot;;\n    private static String girl = &quot;秀娟英华慧巧美娜静淑惠珠翠雅芝玉萍红娥玲芬芳燕彩春菊兰凤洁梅琳素云莲真环雪荣爱妹霞香月莺媛艳瑞凡佳嘉琼勤珍贞莉桂娣叶璧璐娅琦晶妍茜秋珊莎锦黛青倩婷姣婉娴瑾颖露瑶怡婵雁蓓纨仪荷丹蓉眉君琴蕊薇菁梦岚苑婕馨瑗琰韵融园艺咏卿聪澜纯毓悦昭冰爽琬茗羽希宁欣飘育滢馥筠柔竹霭凝晓欢霄枫芸菲寒伊亚宜可姬舒影荔枝思丽 &quot;;\n    private static String boy = &quot;伟刚勇毅俊峰强军平保东文辉力明永健世广志义兴良海山仁波宁贵福生龙元全国胜学祥才发武新利清飞彬富顺信子杰涛昌成康星光天达安岩中茂进林有坚和彪博诚先敬震振壮会思群豪心邦承乐绍功松善厚庆磊民友裕河哲江超浩亮政谦亨奇固之轮翰朗伯宏言若鸣朋斌梁栋维启克伦翔旭鹏泽晨辰士以建家致树炎德行时泰盛雄琛钧冠策腾楠榕风航弘&quot;;\n    private static final String[] email_suffix = &quot;@gmail.com,@yahoo.com,@msn.com,@hotmail.com,@aol.com,@ask.com,@live.com,@qq.com,@0355.net,@163.com,@163.net,@263.net,@3721.net,@yeah.net,@googlemail.com,@126.com,@sina.com,@sohu.com,@yahoo.com.cn&quot;.split(&quot;,&quot;);\n    private static String[] sexs = {&quot;男&quot;, &quot;女&quot;};\n\n    private static int getNum(int start, int end) {\n        return (int) (Math.random() * (end - start + 1) + start);\n    }\n//    获得随机数的方法\n\n    private static int getRandom(int length) {\n        Random random = new Random();\n        return random.nextInt(length);\n    }\n\n\n    /**\n     * 返回Email\n     *\n     * @param lMin 最小长度\n     * @param lMax 最大长度\n     * @return\n     */\n    private static String getEmail(int lMin, int lMax) {\n        int length = getNum(lMin, lMax);\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i &lt; length; i++) {\n            int number = (int) (Math.random() * base.length());\n            sb.append(base.charAt(number));\n        }\n        sb.append(email_suffix[(int) (Math.random() * email_suffix.length)]);\n        return sb.toString();\n    }\n\n    /**\n     * 返回手机号码\n     */\n    private static String[] telFirst = &quot;134,135,136,137,138,139,150,151,152,157,158,159,130,131,132,155,156,133,153&quot;.split(&quot;,&quot;);\n\n    private static String getTel() {\n        int index = getNum(0, telFirst.length - 1);\n        String first = telFirst[index];\n        String second = String.valueOf(getNum(1, 888) + 10000).substring(1);\n        String third = String.valueOf(getNum(1, 9100) + 10000).substring(1);\n        return first + second + third;\n    }\n\n    /**\n     * 返回中文姓名\n     */\n    private static String name_sex = &quot;&quot;;\n\n    private static String getChineseName() {\n        int index = getNum(0, firstName.length() - 1);\n        String first = firstName.substring(index, index + 1);\n        int sex = getNum(0, 1);\n        String str = boy;\n        int length = boy.length();\n        if (sex == 0) {\n            str = girl;\n            length = girl.length();\n            name_sex = &quot;女&quot;;\n        } else {\n            name_sex = &quot;男&quot;;\n        }\n        index = getNum(0, length - 1);\n        String second = str.substring(index, index + 1);\n        int hasThird = getNum(0, 1);\n        String third = &quot;&quot;;\n        if (hasThird == 1) {\n            index = getNum(0, length - 1);\n            third = str.substring(index, index + 1);\n        }\n        return first + second + third;\n    }\n\n\n    /**\n     * 生成随机时间\n     *\n     * @param beginDate\n     * @param endDate\n     * @return\n     */\n    private static Date randomDate(String beginDate, String endDate) {\n\n        try {\n\n            SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);\n//构造开始日期 \n            Date start = format.parse(beginDate);\n//构造结束日期 \n            Date end = format.parse(endDate);\n\n//getTime()表示返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 \n\n            if (start.getTime() &gt;= end.getTime()) {\n\n                return null;\n\n            }\n\n            long date = random(start.getTime(), end.getTime());\n\n            return new Date(date);\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n\n        }\n\n        return null;\n\n    }\n\n    private static long random(long begin, long end) {\n\n        long rtn = begin + (long) (Math.random() * (end - begin));\n\n        //如果返回的是开始时间和结束时间，则递归调用本函数查找随机值 \n\n        if (rtn == begin || rtn == end) {\n\n            return random(begin, end);\n\n        }\n\n        return rtn;\n\n    }\n\n    /**\n     * 生成用户对象\n     *\n     * @return\n     */\n    public static User getUser() {\n        User cmfzUser = new User();\n        cmfzUser.setUserName(getChineseName());\n        cmfzUser.setUserNickname(&quot;大圣&quot;);\n        cmfzUser.setUserTelphone(getTel());\n        cmfzUser.setUserPassword(&quot;123456&quot;);\n        cmfzUser.setUserStatus(0);\n        cmfzUser.setGuruId(1);\n        cmfzUser.setUserSex(sexs[getRandom(sexs.length)]);\n        String[] strings = place[getRandom(place.length)];\n        cmfzUser.setUserProvince(strings[0]);\n        cmfzUser.setUserCity(strings[getRandom(strings.length)]);\n        cmfzUser.setUserAutograph(&quot;岁月静好&quot;);\n        cmfzUser.setUserImage(&quot;hhh.jpg&quot;);\n        cmfzUser.setUserCreateDate(randomDate(&quot;2019-03-01&quot;, &quot;2019-8-15&quot;));\n        return cmfzUser;\n    }\n\n}\n\n</code></pre>\n<p>这里我所创建的用户对象是：</p>\n<pre><code class=\"language-java\">\n/**\n * @author macw\n * @since 2019-08-13\n */\n@Data\n@EqualsAndHashCode(callSuper = false)\n@Accessors(chain = true)\n@TableName(&quot;cmfz_user&quot;)\npublic class User implements Serializable {\n\n    @TableId(value = &quot;user_id&quot;, type = IdType.AUTO)\n    @Excel(name = &quot;用户编号&quot;)\n    private Integer userId;\n    @Excel(name = &quot;手机号&quot;)\n    private String userTelphone;\n    @Excel(name = &quot;密码&quot;)\n    private String userPassword;\n    @Excel(name = &quot;头像&quot;)\n    private String userImage;\n    @Excel(name = &quot;用户昵称&quot;)\n    private String userNickname;\n    @Excel(name = &quot;用户名&quot;)\n    private String userName;\n    @Excel(name = &quot;性别&quot;)\n    private String userSex;\n    @Excel(name = &quot;个性签名&quot;)\n    private String userAutograph;\n    @Excel(name = &quot;省份&quot;)\n    private String userProvince;\n    @Excel(name = &quot;城市&quot;)\n    private String userCity;\n    @Excel(name = &quot;所属小组&quot;)\n    private Integer guruId;\n    @Excel(name = &quot;用户状态&quot;,replace = {&quot;男_1&quot;,&quot;女_0&quot;})\n    private Integer userStatus;\n    @TableField(&quot;user_create_date&quot;)\n    @Excel(name = &quot;注册时间&quot;)\n    private Date userCreateDate;\n    @TableField(exist = false)\n    private Integer count;\n\n}\n\n</code></pre>\n<p>然后就可以直接调用生成十万条用户数据了！<br />\n调用测试类如下：</p>\n<pre><code class=\"language-java\">  @Test\n    public void test1(){\n        SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n        long start = System.currentTimeMillis();\n        System.out.println(&quot;-----&quot;+date);\n        int insert = 0;\n        for (int i = 0; i &lt; 10000; i++) {\n            User user = GenerateUserUtil.getUser();\n            insert += userMapper.insert(user);\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;成功添加： &quot;+insert+&quot; 条数据，所用时间：&quot;+(end-start)+&quot;ms&quot;);\n    }\n</code></pre>\n<p>如此，就可轻轻松松向数据库添加十万条数据了，</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:40:35', '2022-05-21 18:17:29');
INSERT INTO `tb_article` VALUES (73, 1, 8, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=6612', 'MySQL数据库4种常用优化方式，sql语句书写优化规范', '<p>﻿<strong>MySQL数据库优化</strong></p>\n<p><a href=\"#引言\">1. 引言</a></p>\n<p><a href=\"#数据库优化手段\">2. 数据库优化手段</a></p>\n<p><a href=\"#优化储备知识\">3. 优化储备知识</a></p>\n<p><a href=\"#慢查询\">3.1 慢查询</a></p>\n<p><a href=\"#执行计划\">3.2 执行计划</a></p>\n<p><a href=\"#索引优化\">4. 索引优化</a></p>\n<p><a href=\"#索引语法\">4.1 索引语法</a></p>\n<p><a href=\"#索引应用场景\">4.2 索引应用场景</a></p>\n<p><a href=\"#查询缓存\">5. 查询缓存</a></p>\n<p><a href=\"#sql优化\">6. SQL优化</a></p>\n<p><a href=\"#读写分离\">7. 读写分离</a></p>\n<p><a href=\"#centos中linux的安装\">7.1 CentOS中linux的安装</a></p>\n<p><a href=\"#mysql主从复制\">7.2 MySQL主从复制</a></p>\n<p><a href=\"#读写分离基于mycat实现\">7.3 读写分离(基于MyCat实现)</a></p>\n<h1 id=\"引言\">引言</h1>\n<p>实际项目中，我们的数据往往存储在数据库中，但是由于数据库本身是持久化存储，数据的查询速度受到磁盘IO瓶颈的限制，同时，随着数据量的增长，数据的查询也会因为单表数据量的巨大，影响查询速度。所以我们需要对数据库进行优化，提高系统的响应效率。</p>\n<h1 id=\"数据库优化手段\">数据库优化手段</h1>\n<ol>\n<li>\n<p>索引优化。</p>\n</li>\n<li>\n<p>添加查询缓存。</p>\n</li>\n<li>\n<p>优化数据库SQL语句。</p>\n</li>\n<li>\n<p>数据库Cluster(搭建数据库集群环境)。</p>\n</li>\n</ol>\n<h1 id=\"优化储备知识\">优化储备知识</h1>\n<h2 id=\"31-慢查询\">3.1 慢查询</h2>\n<blockquote>\n<p>慢查询就是查看我们每条sql语句查询所用的时间，<br />\n开启慢查询的目的是将我们每次查询所用的时间记录在日志里进行观察检测，如果检测到查询的时间到达超过一定的预定时间（比如查询时间超过1秒的语句），将被记录下来进行优化！</p>\n</blockquote>\n<ol>\n<li>查看慢查询的信息状态</li>\n</ol>\n<blockquote>\n<p>show variables like \'%quer%\';</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818165456174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>开启慢查询</li>\n</ol>\n<blockquote>\n<p>set global slow_query_log=on;</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818170417988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>修改慢查询最短时间为1s</li>\n</ol>\n<blockquote>\n<p>set GLOBAL long_query_time = 1;</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818170539243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>查看MySQL执行过的慢查询SQL语句。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818170706476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"32-执行计划\">3.2 执行计划</h2>\n<p>补充： 数据库查询优化中需要了解MySQL执行计划命令，查看sql的执行效率</p>\n<p>进行一条查询语句，点下左上角的解释看语句解释：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190818170730136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"索引优化\">索引优化</h1>\n<h2 id=\"41-索引语法\">4.1 索引语法</h2>\n<ol>\n<li>索引的作用</li>\n</ol>\n<blockquote>\n<p>加快以索引字段为条件的查询效率。</p>\n</blockquote>\n<ol>\n<li>创建索引</li>\n</ol>\n<blockquote>\n<p>create index  索引名字 on 表(字段)</p>\n</blockquote>\n<ol>\n<li>删除索引</li>\n</ol>\n<blockquote>\n<p>drop index  索引名字</p>\n</blockquote>\n<ol>\n<li>查询某张表创建了哪些索引</li>\n</ol>\n<blockquote>\n<p>Show index from 表名;</p>\n</blockquote>\n<ol>\n<li>索引的特点</li>\n</ol>\n<blockquote>\n<p>①索引会占用存储空间，虽然比较少，但是也占用了。</p>\n</blockquote>\n<blockquote>\n<p>②MySQL会自动为primary 主键列和unique 唯一列自动增加索引。</p>\n</blockquote>\n<blockquote>\n<p>③MySQL数据库对数据做DML操作时，需要同时做维护索引的操作。</p>\n</blockquote>\n<blockquote>\n<p><strong>隐含之意，就是索引会降低数据库增删改的效率。</strong></p>\n</blockquote>\n<ol>\n<li>使用原则：</li>\n</ol>\n<blockquote>\n<p>一般会对sql中的where条件字段或者order by字段建立索引。</p>\n</blockquote>\n<h2 id=\"42-索引应用场景\">4.2 索引应用场景</h2>\n<p>实际项目中，如果从业务角度出发，发现经常会用到某个字段，对表数据进行查询，或者根据经常用到某个字段的排序，则该数据是需要增加索引的。</p>\n<h1 id=\"在这里插入图片描述查询缓存\"><img src=\"https://img-blog.csdnimg.cn/20190818171131437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n查询缓存</h1>\n<ol>\n<li>在数据库操作对象DAO处增加查询缓存。</li>\n</ol>\n<blockquote>\n<p><em>参考Ehcache缓存，或者MyBatis+Ehcache整合方案、Hibernate二级缓存Ehcache。</em></p>\n</blockquote>\n<ol start=\"2\">\n<li>需要注意的问题是，要注意数据的一致性，所以缓存思路如下：</li>\n</ol>\n<blockquote>\n<p>① 只对查询结果进行缓存</p>\n</blockquote>\n<blockquote>\n<p>②<br />\n缓存结果存放要以业务逻辑相关为划分单位。比如，如果是单表，则可以创建一个缓存区域，与该表对应，如果业务中涉及到表连接操作，要将查询结果缓存在这多张表的查询结果都要缓存在对应的一个缓存区域中。</p>\n</blockquote>\n<ol start=\"3\">\n<li>\n<p>当执行增删改的时候，为了避免出现脏数据。</p>\n</li>\n<li>\n<p>基于以上的特点，缓存原则是对那些查询需求远大于增删改需求的数据，进行缓存。</p>\n</li>\n</ol>\n<blockquote>\n<p>例如：新闻网站的首页数据、电商的类别数据等。</p>\n</blockquote>\n<h1 id=\"sql优化\">SQL优化</h1>\n<ol>\n<li>\n<p>尽量不要在要给在SQL语句的where子句中使用函数，这样会使索引失效。</p>\n</li>\n<li>\n<p>如果已经确定查询结果只有一条数据（当表中数据的该字段是唯一的），在查询SQL末尾增加<br />\nlimit    1，这样MySQL的查询执行引擎在找到1条数据之后就会停止搜索，提高效率。（mysql5.6之后有效）<br />\n例如：</p>\n</li>\n</ol>\n<blockquote>\n<p>select * from t_department where department_name = \'研发部\' limit 1;</p>\n</blockquote>\n<ol start=\"3\">\n<li>\n<p>模糊查询尽量使用右模糊：‘xx%’，这样可以利用上索引，而使用‘%xx’这种模糊查询会导致该查询字段上的索引失效。</p>\n</li>\n<li>\n<p>如果非要使用表连接，最好要保证连接的两个字段都是创建了索引的。</p>\n</li>\n<li>\n<p>查询的时候最好用什么数据查询什么数据，避免使用select<br />\n*,原因是数据库访问往往是远程通过网络来访问，这也就意味着，查询结果也是通过网络来传输的，如果查询了额外的无用的数据，他们会额外占用网络带宽，数据传输效率也会降低。</p>\n</li>\n<li>\n<p>尽量使用非空 not<br />\nnull，可以使用‘’空串代替null。因为‘’不占用空间，null会占用空间的。</p>\n</li>\n<li>\n<p>使用!= 或者&lt;&gt; 数据库会放弃索引。</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/2019081817164678.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"6\">\n<li>在SQL语句中不要有运算，否则MySQL会放弃索引。（mysql在执行查询时，会自动过滤当前语句，当效率大于使用索引时，则默认不使用索引）</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818171706234.png\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>\n<p>对于百万级以上的表数据，如果要做表连接查询，一定要对表先分页，然后对分页结果再做表连接。</p>\n</li>\n<li>\n<p>尽量避免大事务操作，这样会降低系统的并发能力。在满足实际业务的前提下，尽量缩短事务的边界。</p>\n</li>\n<li>\n<p>Where子句多条件and连接的情况，要把精确条件放在最先执行的位置，提高效率。Oracle中是从右至左。MySQL中是从左至右。<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081817175944.jpg\" alt=\"在这里插入图片描述\" /></p>\n</li>\n</ol>\n<h1 id=\"mysql集群环境之------读写分离主从复制\">MySql集群环境之------读写分离、主从复制</h1>\n<p>搭建MySQL的集群环境来优化查询<br />\n详细的使用搭建步骤可参考我之前文章：</p>\n<p><a href=\"https://blog.csdn.net/MacWx/article/details/98778719\"> Centos 7使用MyCat搭建 MySQL-读写分离</a></p>\n<a href=\"https://blog.csdn.net/MacWx/article/details/98777361\">\nCentos 7搭建MySQL-主从复制</a>\n', 1, '', 0, 0, 1, '2020-04-25 15:40:58', '2022-05-21 18:17:14');
INSERT INTO `tb_article` VALUES (74, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=9608', 'POI简介，以及使用POI技术实现Excel文件的导入导出案例', '<p>﻿### 1、什么是POI？<br />\nApache POI 是 Apache 软件基金会的开放源码函式库，POI 提供 API 给 Java 程序对<br />\nMicrosoft Office 格式档案读和写的功能。</p>\n<p><strong>常用的两种java操作Excel技术POi和JXL的对比：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190814211200494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>POI 和 JXL 对 Excel 抽象出来的对象对比</strong><br />\n|                  |       POI        |   JXL    |<br />\n| :--------------: | :--------------: | :------: |<br />\n|    Excel 文档    |   HSSFWorkbook   | Workbook |<br />\n|  Excel 的工作表  |    HSSFSheet     |  Sheet   |<br />\n|    Excel 的行    |     HSSFRow      |    无    |<br />\n| Excel 中的单元格 |     HSSFCell     |   Cell   |<br />\n|    Excel 字体    |     HSSFFont     |          |<br />\n| Excel 单元格样式 |  HSSFCellStyle   |          |<br />\n|    Excel 颜色    |    HSSFColor     |          |<br />\n|    合并单元格    | CellRangeAddress |          |</p>\n<h3 id=\"2使用poi实现excel的导入导出\">2、使用POI实现Excel的导入导出</h3>\n<p>先来回忆一下window使用Excel和POi对Excel抽象出来的对象</p>\n<ol>\n<li>创建一个Excel文件 HSSFWorkbook</li>\n<li>创建一张工作表 HSSFSheet</li>\n<li>选中一行  HSSFRow</li>\n<li>选中一个单元格  HSSFCell</li>\n<li>在单元格中写入数据</li>\n<li>保存</li>\n</ol>\n<h4 id=\"第一个demo-excel导出\">第一个demo Excel导出</h4>\n<p><strong>1，导入POI依赖</strong></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;\n    &lt;artifactId&gt;poi&lt;/artifactId&gt;\n    &lt;version&gt;3.11&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p><strong>2，POI工具类实现导出</strong><br />\n案例1：</p>\n<pre><code class=\"language-java\">package com.macw;\n\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\nimport org.junit.Test;\n\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class PoiTest {\n\n    @Test\n    public void test1() throws IOException {\n//        1.创建一个文件对象\n        HSSFWorkbook hssfWorkbook = new HSSFWorkbook();\n\n//        2.创建一个表对象 通过文件对象创建表对象\n        HSSFSheet sheet = hssfWorkbook.createSheet(&quot;表名：excel数据表&quot;);\n\n//        3.获取行对象 下标从0开始\n        HSSFRow row = sheet.createRow(0);\n\n//        4.获取第1个单元格  下标从0开始\n        HSSFCell cell = row.createCell(0);\n\n//        5.在单元格中写入数据\n        cell.setCellValue(&quot;Hello Wolld&quot;);\n\n//        6.保存在磁盘中 流  文件名的后缀必须有.xls\n        hssfWorkbook.write(new FileOutputStream(&quot;E://demo.xls&quot;));\n    }\n}\n```java\n案例2：\n模拟从数据库查到的所有用户及用户信息导出到excel文件中\n</code></pre>\n<pre><code>@RequestMapping(&quot;/exportAll&quot;)\npublic void exportAll(HttpServletResponse resp){\n    //模拟从数据库查到的所有用户及用户信息\n    List&lt;User&gt; users = new ArrayList&lt;User&gt;();\n    User user = new User(&quot;1&quot;,&quot;张三 1&quot;,&quot;2019-8-10&quot;);\n    User user1 = new User(&quot;2&quot;,&quot;张三 2&quot;,&quot;2019-8-10&quot;);\n    User user2 = new User(&quot;3&quot;,&quot;张三 3&quot;,&quot;2019-8-10&quot;);\n    User user3 = new User(&quot;4&quot;,&quot;张三 4&quot;,&quot;2019-8-10&quot;);\n    User user4 = new User(&quot;5&quot;,&quot;张三 5&quot;,&quot;2019-8-10&quot;);\n    User user5 = new User(&quot;6&quot;,&quot;张三 6&quot;,&quot;2019-8-10&quot;);\n    User user6 = new User(&quot;7&quot;,&quot;张三 7&quot;,&quot;2019-8-10&quot;);\n    User user7 = new User(&quot;8&quot;,&quot;张三 8&quot;,&quot;2019-8-10&quot;);\n    users.add(user);\n    users.add(user1);\n    users.add(user2);\n    users.add(user3);\n    users.add(user4);\n    users.add(user5);\n    users.add(user6);\n    users.add(user7);\n    //创建工作薄\n    HSSFWorkbook workbook = new HSSFWorkbook();\n    //创建工作表\n    HSSFSheet sheet = workbook.createSheet(&quot;用户信息&quot;);\n    //设置列宽 第一个参数：列索引 第二个参数：列宽\n    sheet.setColumnWidth(2, 4500);\n    //创建导出样式\n    HSSFCellStyle cellStyle = workbook.createCellStyle();\n    //创建字体\n    HSSFFont font = workbook.createFont();\n    //设置字体颜色\n    font.setColor(HSSFFont.COLOR_RED);\n    //设置加粗\n    font.setBold(true);\n   \n    //设置字体\n    font.setFontName(&quot;宋体&quot;);\n    //设置居中\n    cellStyle.setAlignment(CellStyle.ALIGN_CENTER);\n    //管理字体样式\n    cellStyle.setFont(font);\n    //创建标题栏\n    HSSFRow row = sheet.createRow(0);\n    HSSFCell cell = null;\n    String[] titles = {&quot;编号&quot;,&quot;真实姓名&quot;,&quot;出生年月&quot;};\n    for (int i = 0; i &lt; titles.length; i++) {\n        cell = row.createCell(i);\n        cell.setCellValue(titles[i]);\n    //标题行使用样式\n        cell.setCellStyle(cellStyle);\n    }\n    for (int i = 1; i &lt;= users.size(); i++) {\n         //创建数据行对象\n        row = sheet.createRow(i);\n        //数据行第一列设值\n        cell = row.createCell(0);\n        cell.setCellValue(users.get(i-1).getUserId());\n        //数据行第二列设值\n        cell = row.createCell(1);\n        cell.setCellValue(users.get(i-1).getRealname());\n        //数据行第三列设值\n        cell = row.createCell(2);\n        cell.setCellValue(users.get(i-1).getDharmaName());\n    }\n    String fileName = &quot;用户报表(&quot;+new\n            SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date())+&quot;).xls&quot;;\n    //处理中文下载名乱码\n    try {\n        fileName = new  String(fileName.getBytes(&quot;utf-8&quot;),&quot;utf-8&quot;);\n        //设置 response\n        resp.setContentType(&quot;application/vnd.ms-excel&quot;);\n        resp.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename=&quot;+fileN\n                ame);\n       \n        workbook.write(resp.getOutputStream());\n        workbook.close();\n    } catch (Exception e) {\n    // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n}\n</code></pre>\n<h3 id=\"3poi导入\">3、POI导入</h3>\n<pre><code class=\"language-java\"> @RequestMapping(&quot;/uploadIn&quot;)\n    @ResponseBody\n    public Map uploadIn(MultipartFile multipartFile) throws IOException {\n        //输出文件名\n        logger.info(&quot;----------文件名为： &quot;+multipartFile.getOriginalFilename());\n        //1，获取流对象\n        InputStream inputStream = multipartFile.getInputStream();\n\n//        2.通过poi解析流 得到 Excel文件对象\n        HSSFWorkbook workbook = new HSSFWorkbook(inputStream);\n\n//        3.通过对象获取数据 得到表\n        HSSFSheet sheet = workbook.getSheetAt(0);\n\n//        4.通过表 得到行\n        int lastRowNum = sheet.getLastRowNum();\n        //定义计数器，计算批量导入多少条数据\n        int sum = 0;\n        for (int i = 1; i &lt;= lastRowNum; i++) {\n            Guru guru = new Guru();\n            HSSFRow row = sheet.getRow(i);\n//            获取单元格\n            double guruId = row.getCell(0).getNumericCellValue();\n            guru.setGuruId((int) guruId);\n\n            guru.setGuruName(row.getCell(1).getStringCellValue());\n            guru.setGuruImage(row.getCell(2).getStringCellValue());\n            guru.setGuruNickname(row.getCell(3).getStringCellValue());\n            guru.setGuruStatus((int) row.getCell(4).getNumericCellValue());\n            System.out.println(guru);\n			//执行添加的SQL\n            int insert = guruMapper.insert(guru);\n            //统计添加成功的条数\n            sum+=insert;\n        }\n        Map map = new HashMap();\n        map.put(&quot;flag&quot;, sum+&quot;&quot;);\n        return map;\n    }\n</code></pre>\n<p>页面代码：</p>\n<pre><code class=\"language-html\">&lt;div id=&quot;insertFile&quot; class=&quot;easyui-dialog&quot; data-options=&quot;closed:true&quot;&gt;\n    &lt;form id=&quot;insertFileForm&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;\n        上传Excel文件：&lt;input class=&quot;easyui-filebox&quot; name=&quot;multipartFile&quot;\n                         data-options=&quot;required:true,missingMessage:\'请选择文件\'&quot;/&gt;&lt;br/&gt;&lt;br/&gt;\n        &lt;a href=&quot;javascript:void(0)&quot; class=&quot;easyui-linkbutton&quot; iconCls=&quot;icon-save&quot; onClick=&quot;insertFileConfirm()&quot;&gt;上传&lt;/a&gt;\n    &lt;/form&gt;\n&lt;/div&gt;\n\n\njs代码：\n\n //批量上传的文件提交\n    function insertFileConfirm() {\n        $(&quot;#insertFileForm&quot;).form(&quot;submit&quot;, {\n            url: &quot;${pageContext.request.contextPath}/guru/uploadIn&quot;,\n            success: function (data) {\n               console.log(data);\n                alert(&quot;成功添加：&quot;+data.flag+&quot; 条数据&quot;);\n                $(&quot;#insertFile&quot;).dialog(&quot;close&quot;);\n                $(&quot;#guruManager&quot;).datagrid(&quot;reload&quot;);\n            }\n        })\n    }\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:41:41', '2022-05-21 18:16:54');
INSERT INTO `tb_article` VALUES (75, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5323', 'Maven仓库 一键自动删除失效jar包，没事儿点点_', '<p>﻿因为网路等各种原因，使用maven仓库下载jar包可能会下载失败，或者下载一半停止，</p>\n<p>下载失效的jar包会严重影响我们程序的运行，<br />\n看着明明没问题，但是一运行就报错，而且还很难找到错误问题原因，</p>\n<p><strong>所以及时得清理失效的jar包会使我们从程序减少出错的可能；</strong></p>\n<p>如何清理失效的jar包呢，<br />\n失效的jar在我们的maven仓库 都有一个.lastUpdated结尾的后缀，、</p>\n<p>只要是有这个后缀的文件夹里面的jar包就都是失效的，</p>\n<p>下面说一个使用windows的批处理清理带.lastUpdated结尾的失效jar包的解决办法：</p>\n<p>新建一个记事本，输入一下命名：</p>\n<pre><code>@echo  off\nrem create by sunhao(sunhao.java@gmail.com)\nrem crazy coder\nset REPOSITORY_PATH=D:\\Maven\\repository\nrem 正在搜索...\nfor /f &quot;delims=&quot; %%i in (\'dir /b /s &quot;%REPOSITORY_PATH%\\*lastUpdated*&quot;\') do (\n    del /s /q %%i\n)\nrem 搜索完毕\npause\n</code></pre>\n<p>其中的：<br />\n<strong>set REPOSITORY_PATH=D:\\Maven\\repository</strong><br />\n改为你的本地仓库路径地址</p>\n<p><strong>然后将这个txt文件另存为：删除失效jar包工具没事儿点点.bat<br />\n一定要是.bat结尾的批处理文件才行啊，</strong></p>\n<p>然后就可以把 这个东西发送到桌面快捷方式，闲着没事就点点清理jar包</p>\n<p>如果双击不运行的话就右键以管理员身份打开~</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:41:44', '2022-05-21 18:16:24');
INSERT INTO `tb_article` VALUES (76, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5584', 'Redis持久化机制RDB 和AOF', '<p>﻿## redis持久化机制</p>\n<p>redis服务器宕机，内存数据是会丢失了，为了保证数据不丢失需要对数据做备份，所备份就是持久化，Redis的持久化即将内存中的数据同步到硬盘，主要包括两种方式RDB、AOF。</p>\n<p><strong>RDB持久化机制，(默认使用)</strong>：做当前内存数据的全本快照，<br />\n将内存中的数据以快照的方式写入到二进制文件dump.rdb,<br />\n在redis.conf中可以设置发起快照保存的条件。在指定的时间内如果有超过指定数量的key被修改，则会发起快照保存。</p>\n<p>这种方式在数据的实时性上不高，在突然断电的情况下，可能会出现部分数据的丢失，即最后一次快照之后在内存中发生修改的数据。</p>\n<p>简单来说：RDB就是将redis上的所有数据做个备份，存储的是二进制的数据。</p>\n<p><strong>AOF持久化机制，(默认是关闭)</strong>：</p>\n<p>AOF是将Redis内存数据库中更改的数据都记录到指定的文件appendonly.aof。在redis.conf中可以进行写磁盘的相关设置。</p>\n<p>在突然断电的情况下，由于在appendonly.aof中保存了最后一次写磁盘之后redis内存发生数据修改的指令，所以在这个Redis重启后，基本不会发生数据丢失，比RDB具有更好的数据安全性。</p>\n<p>appendfsync always   接收到更改数据的命令，立即将其记录到appendonly.aof中，能保证数据持久化，数据完全不丢失，但效率相对最低。</p>\n<p>appendfsync everysec   每秒钟将redis内存数据修改的命令记录到appendonly.aof中，在性能和持久化上做了折中。因频繁执行磁盘操作，在仅存在单个Master执行写操作时，效率可能存在问题。但在多个Master执行写操作的Redis集群中，效率会提升。</p>\n<p>appendfsync no  依赖于操作系统，因不会频繁执行磁盘操作而性能最好，但redis内存数据修改持久化没有保证，无法保证数据可靠性</p>\n<p><strong>如何开启AOF持久化：</strong><br />\n将redis.conf文件中 appendonly 改成 yes ，自动创建appendonly.aof，该文件存储的客户端执行过<strong>增删改操作的命令</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190811162518765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"什么是aof重写\">什么是AOF重写？</h2>\n<p>当命令存储了一定程度的时候，有一些命令可能是已经无效的了<br />\n例如set usernname xx  del usename,添加一条数据，后又删除，所以这两条命令备份的备份的时候就都是无效的<br />\n所有redis会对AOF文件进行优化，把一些没有对于数据恢复没有意义的命令优化掉<br />\n默认AOF是关闭的，需要在redis.conf中进行开启<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081116254741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 15:41:47', '2022-05-21 18:16:11');
INSERT INTO `tb_article` VALUES (77, 1, 5, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=528', 'Mybatis中$ {} 和 # {}的区别，动态SQL之if、where、set、trim、foreach标签的使用', '<p>﻿## 一．Mapper文件的补充细节</p>\n<p><strong>a)	Xml的特殊字符</strong><br />\n在mapper文件中，小于号用&amp; lt;代替， 大于号用 &amp; gt;代替</p>\n<pre><code>i.	&lt;   &amp;lt;  \nii.	&gt;  &amp;gt; \n</code></pre>\n<p><strong>b)	$ {} 和 # {}的区别</strong><br />\ni.	使用上，$ {}要获取的参数值，对应的参数必须使用Param注解<br />\nii.	底层上，<br />\n${}使用字符串拼接<br />\n#{}使用?占位符</p>\n<ol>\n<li>字符串拼接，可以拼接表名 列名 sql关键字</li>\n<li>?占位符，只能绑定数据，但可以避免sql注入攻击</li>\n</ol>\n<h2 id=\"二动态sql\">二．动态SQL</h2>\n<p>什么是动态SQL？就是能够根据不同的条件，产生不同 的SQL语句。</p>\n<blockquote>\n<p>比如我们常见的多条件搜索框，可以根据姓名、性别、年龄、工资范围等按照一定的条件进行搜素，<br />\n但如果我只输入姓名搜素呢，或者按照姓名+年龄进行搜素呢，这样排列组合情况就太多了，我们不可能一个条件去写一个SQL的，<br />\n所以就需要我们根据用户输入的条件来动态的生成一条SQL语句。</p>\n</blockquote>\n<p><strong>Mapper文件中动态SQL常用的几个标签</strong><br />\n&lt; if&gt; 作用：<br />\n满足条件时执行sql，不满足则不执行</p>\n<p>&lt; where&gt; 作用：</p>\n<ol>\n<li>会自动删除if动态sql产生的多余的and or前缀</li>\n<li>会在if动态sql语句前添加where关键字</li>\n</ol>\n<p>如下SQL语句所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728141308831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>&lt; set&gt;作用：<br />\n1.会自动if动态sql产生的多余的逗号后缀<br />\n2.会在if动态sql语句前添加set关键字</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190728141444363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>&lt; trim&gt;作用：<br />\n可以自定义前缀和后缀：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019072814165010.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>&lt; foreach&gt; 循环遍历，<br />\n常用来做批量删除的时候用</strong><br />\n如下图所示：<br />\ncollection:相当于集合名，<br />\nitem表示集合中的一个元素，<br />\nopen是循环之前要加的东西，<br />\nclose是循环结束的时候要加的东西，<br />\nseparator:元素间使用什么分隔。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728141835696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:17', '2022-05-21 18:15:56');
INSERT INTO `tb_article` VALUES (78, 1, 5, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=103', '简单理解什么是Spring中的IOC控制反转和DI依赖注入，Spring对象的三种创建方式', '<p>﻿IOC ：Inversion of Control     控制反转<br />\nDI  :  dependency Injection   依赖注入</p>\n<p>咋一听，控制反转、依赖注入，似乎很高大上的名字，概念比较抽象，但其实慢慢分析，转换成自己的话也不难理解：</p>\n<p><strong>IOC的理解：</strong></p>\n<p><em>在原始社会的时候，我们需要自己生火、自己挖井。这个时候主动权在自己手里。随着时代的发展我们现在有燃气公司和水利公司。我们现在想喝水直接扭水龙头水就流出来了，但是水这个来源的控制权交给自来水公司了，这个过程称之为控制反转</em></p>\n<p>对于Spring来说，以前自己创建的对象UserService service = new UserServiceImpl(),<br />\nservice.xxx()<br />\n而现在，对象的创建交给Spring工厂，用的时候去工厂中获取，<br />\nClassPathXmlApplicationContext ac = new ...;</p>\n<p>从之前自己创建对象，到现在交给Spring工厂创建对象，包括给属性赋值也交给Spring工厂来完成，这个由我们自己完成一些事情转移到Spring框架完成这些事情的过程，Spring称之为控制反转（IOC）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190728145347156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>DI (依赖注入):</strong></p>\n<p>如果我们站在spring工厂的角度，工厂创建需要的对象，并且还可以给程序员中的类的属性赋值，对象由工厂创建，最终由程序员使用，这就是spring的依赖注入<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728145414207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<blockquote>\n<p>IOC和DI实际上是等同的概念，如果要进行区分的话，IOC和DI可以理解为同一个东西的不同角度看法，IOC<br />\n站在程序员的角度，以前创建对象是我们自己new出来的，现在让容器自己创建，控制权交给了容器，对于<br />\n我们来说控制权反转了。<br />\nDI是站在容器的角度，从Spring角度来看，用到的所有的对象都是自己创建的，并且对象在创建的时候需要<br />\n依赖的参数也是容器注入的，而这种维持对象之间依赖关系的方式就是依赖注入。</p>\n</blockquote>\n<blockquote>\n<p>所以IOC和DI实际上都是指容器负责创建对象和维护对象之间依赖关系的这种行为。</p>\n</blockquote>\n<h3 id=\"说到这里再来分析一下spring创建对象的三种方式\">说到这里，再来分析一下Spring创建对象的三种方式：</h3>\n<p><strong>1，通过构造方法创建，采用默认的构造函数，</strong><br />\n也就是通过xml+bean标签，bean标签要写class的类的全限定名，其原理是通过java类的反射机制创建对象。<br />\nindex : 参数的索引,从0 开始<br />\nname: 参数名<br />\ntype:类型(区分开关键字和封装类int 和Integer)</p>\n<pre><code>&lt;bean id=&quot;peo&quot; class=&quot;com.macw.pojo.People&quot;&gt;\n&lt;!-- ref 引用另一个bean value 基本数据类型或String 等--&gt;\n    &lt;constructor-arg index=&quot;0&quot; name=&quot;id&quot; type=&quot;int&quot;  value=&quot;123&quot;&gt;&lt;/constructor-arg&gt;\n    &lt;constructor-arg index=&quot;1&quot; name=&quot;name&quot; type=&quot;java.lang.String&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>在早期Spring1.0版本，还没有注解的时候，Spring能够帮我们创建对象和管理对象，<br />\n但是没有注解每创建一个对象就要配置一个xml，其实还没有我们直接new一个对象来得快呢，</p>\n<p>但是为什么spring框架仍然有他的极大优势呢，因为他最重要的一个特性是能够帮我们管理对象，<br />\n自己new对象在类中多处调用会造成程序模块之间耦合性太强，不利于维护更新。而spring帮我们管理对象通过依赖注入声明的是管理对象的关系。</p>\n<p><strong>2、通过实例工厂创建对象<br />\n也就是 工厂设计模式：帮助创建类对象，一个工厂可以生产多个对象</strong></p>\n<pre><code>// 工厂，创建对象\npublic class StudentFactory {\n    // 实例方法创建对象\n    public Student getInstance() {\n        return new User(001,&quot;学生工厂：调用实例方法&quot;);\n    }\n\n    // 静态方法创建对象\n    public static Student getStaticInstance() {\n        return new Student(002,&quot; 学生工厂：调用静态方法&quot;);\n    }\n}\n\n配置文件：\n\n&lt;!-- # 3.1 工厂类，实例方法 --&gt;\n    &lt;!-- 先创建工厂 --&gt;\n    &lt;bean id=&quot;factory&quot; class=&quot;com.macw.StudentFactory&quot;&gt;&lt;/bean&gt;\n    &lt;!-- 在创建student对象，用factory方的实例方法 --&gt;\n    &lt;bean id=&quot;student2&quot; factory-bean=&quot;factory&quot; factory-method=&quot;getInstance&quot;&gt;&lt;/bean&gt;\n</code></pre>\n<p>其中： factory-bean=”factory”指定工厂。factory-method=”getInstance”指定工厂的哪个方法。</p>\n<p><strong>3.静态工厂创建对象，不需要创建工厂，快速创建对象</strong></p>\n<p>实现步骤：编写一个静态工厂（在方法上添加static）</p>\n<pre><code>public class StudentFactory{\n    public static Student newInstance(){\n        return new Student(001,&quot;studentTest&quot;);\n    }\n}\n\n在applicationContext.xml中\n&lt;bean  id = &quot;student2&quot;  class = &quot;com.macw.pojo.StudentFactory&quot;  factory-method = &quot;newInstance&quot;&gt;&lt;/bean&gt;\n\n</code></pre>\n<p>在spring2.0之后采用注解的形式开发，减少了大量 的xml配置文件，开发的形式变为xml+bean配置数据源，大量使用第三方框架，通过组件注解配置自己的类。</p>\n<p>spring3.0之后采用配置类+bean注解来创建对象，目的想取代xml配置文件，也就是springboot自动装配的底层原理</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:22', '2022-05-21 18:15:42');
INSERT INTO `tb_article` VALUES (79, 1, 6, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=924', '面试题：BeanFactory和FactoryBean有啥关系_', '<p>﻿没啥太大关系!</p>\n<p>BeanFactory(对象工厂)，他是spring框架中的工厂类，spring的工厂设计的比较复杂，BeanFactory被抽象成了一个接口，我们经常写代码叫做ClassPathXmlApplicationContext是BeanFactory的实现类</p>\n<p>FactoryBean也是一个接口，主要用于特殊对象的创建，例如Connectoin和SqlSession对象，由于他们是一个接口，这些对象的创建需要使用代码完成，所以需要一个类实现FactoryBean接口间接创建这些类的对象</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:26', '2022-05-21 18:15:29');
INSERT INTO `tb_article` VALUES (80, 1, 6, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7008', '使用代理模式实现Spring AOP的面向切面编程，动态代理的四种增强处理', '<p>﻿<strong>什么是代理类？</strong><br />\n代理就是代替我们去执行一些额外的工作。</p>\n<p><strong>目标类:只有核心功能的类</strong></p>\n<p>比如我们在写service的时候，<strong>调用dao方法是我们的核心业务</strong>，<strong>而service类中的日志记录，事务处理，异常处理等都属于额外的功能</strong>，每个service方法中都要写一次这些额外功能也会造成大量代码的冗余，</p>\n<p><strong>而面向切面编程的意思就是说把这些公共的、额外的代码功能抽取出来，每个service里面只写我们的核心业务</strong>，这样就提高了我们的开发效率。</p>\n<p><strong>为什么代理类和目标类要实现相同的接口？</strong><br />\n1.从代码的角度来说,代理类对象能够赋值给接口类型的变量<br />\n2.要保证代理类和目标类有相同的功能</p>\n<p>有了代理类:<br />\n程序员可以只关心核心功能</p>\n<p><strong>额外功能+目标类 =代理类</strong></p>\n<p>以上这种说法就是叫做静态代理，<br />\n静态代理就是在代码编译时,代理类已经存在<br />\n好处:程序员可以只关心核心功能<br />\n不好:多个代理类 ，    没有解决代码冗余的问题</p>\n<h2 id=\"什么是动态代理\">什么是动态代理？</h2>\n<p>运行时,动态创建出来代理对象<br />\nSpringAOP通过动态代理,让程序猿只关心核心代码,同时代码不再冗余</p>\n<p><strong>springAOP的开发步骤:</strong><br />\n1.写核心功能(目标类)<br />\n核心功能就是调用dao方法：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728174629656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2.配置目标类<br />\n要在SpringApplication.xml文件中配置目标类所在路径</p>\n<pre><code> &lt;!--配置目标类--&gt;\n    &lt;bean id=&quot;bookService&quot; class=&quot;com.macw.serviceImpl.bookServiceImpl&quot;&gt;\n        &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p><strong>3.写额外功能(增强处理)</strong><br />\n(公共功能:日志处理/事务处理/异常处理/性能分析....) 等</p>\n<p>前置增强(MethodBeforeAdvice):在核心功能之前执行的额外功能<br />\n后置增强:在核心功能之后执行的额外功能</p>\n<p>环绕增强:在核心功能之前以及之后执行的额外功能<br />\n异常增强:在核心功能发生异常时执行的额外功能</p>\n<p><strong>前置增强的配置使用：</strong><br />\n1，声明一个类，需要实现	MethodBeforeAdvice接口：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728175452663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2，spring配置文件中,配置声明的增强功能类</p>\n<pre><code>	&lt;!--额外功能--&gt;\n   &lt;bean id=&quot;myBeforeAdvice&quot; class=&quot;com.macw.advice.myBeforeAdvice&quot;&gt;&lt;/bean&gt;\n</code></pre>\n<p>3，在spring配置文件中,通过aop标签做配置(需要添加aop命名空间以及schema验证文档):<br />\n.在哪些方法上面做增强处理<br />\n.在需要增强处理的方法上面,加哪个增强处理<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728180128311.png\" alt=\"在这里插入图片描述\" /><br />\n4.让spring在运行的时候,帮我们创建代理对象()<br />\n<img src=\"https://img-blog.csdnimg.cn/2019072817590249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>详解advice<br />\nMethodBeforeAdvice前置增强的before方法</strong><br />\n实现MethodBeforeAdvice接口必须要要实现before方法，这个方法有三个参数，<br />\narg0：目标方法，<br />\narg1:目标方法参数，<br />\narg2:目标类，<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728180359181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2.AfterReturningAdvice:后置增强<br />\n<img src=\"https://img-blog.csdnimg.cn/2019072818044361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n3.ThrowsAdvice:异常增强<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728180513201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>4.MethodInterceptor:环绕增强,目标方法执行之前以及之后做的增强处理</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190728180541273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n总结：<br />\n<strong>Spring AOP:Aspect Oriented Program 面向切面编程</strong><br />\n几个重要概念：</p>\n<p>1.切入点:需要把增强处理加在的位置;service层的方法上面;需要在配置文件中配置<br />\n2.增强处理:额外功能(公共功能) ,通知/建议(advice)<br />\n3.目标类:核心功能所在的类(原始类)<br />\n4.切面:把增强处理,放在切入点的位置,形成的一个概念<br />\n5.编织/织入:把增强处理放置在切入点的过程</p>\n<p><strong>AOP使用场景:</strong><br />\n1.把功能内容抽取出来,形成advice;在配置文件中中做配置====&gt;程序猿只关心核心功能;解决冗余<br />\n2.在原有功能基础之上,做功能扩展===&gt;在不改变原有代码的基础上做功能扩展</p>\n<p>AOP实现:代理模式的使用</p>\n<p>代理类的产生原理<br />\n类加载ClassLoader<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728181445489.png\" alt=\"在这里插入图片描述\" /></p>\n<p>代理类的生成:由jdk动态代理生成<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728181529670.png\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"springaop实现原理\">SpringAOP实现原理:</h2>\n<p>1.底层通过字节码技术,把目标对象以及额外功能动态封装,生成代理对象  ==&gt;动态代理<br />\n使用了JDK动态代理以及cglib动态代理<br />\n2.为什么通过id得到的是代理对象<br />\nspring工厂创建对象之后,由BeanPostProcessor进行处理<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728181629605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:28', '2020-10-07 13:09:55');
INSERT INTO `tb_article` VALUES (81, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5296', 'idea新手好用的几个插件、让你快速掌握IDEA', '<p>﻿从Myeclipse突然转到idea，最让我们感到不顺手的就是快捷键的使用变了，</p>\n<p>习惯了一个东西再去接受另一个新事物是很难接受的，虽然我们可以让idea切换成eclipse的快捷键，</p>\n<p>但是仍然有很多功能的快捷键的我们所不知道的，</p>\n<p>所以我要推荐的第一个插件就是：</p>\n<h2 id=\"1key-promoter-x\">1、Key promoter X</h2>\n<blockquote>\n<p>显示点击某个功能选项的快捷键（如果有的话）<br />\n前期新手使用确实对idea的快捷键感到头疼，有了这个的话就能帮助我们很快的掌握各种快捷键<br />\n等到使用熟练之后再把这个关掉就好了</p>\n</blockquote>\n<p>Key Promoter (X)其实这里是指2个插件，分别为Key Promoter X 和Key Promoter ，主要功能差不多的，都是一个提示插件，当你在IDEA里面使用鼠标的时候，如果这个鼠标操作是能够用快捷键替代的，那么Key Promoter X会在右下角弹出一个提示框，Key Promoter 会在左上角弹出一个提示框告，<strong>并且当你想看看一个功能的快捷键的时候你只需要把鼠标放上去不动他就会提示你这个功能的快捷键是啥</strong>、<strong>或者告知你这个鼠标操作可以用什么快捷键替代</strong>。当然，对于Key Promoter X还有一个官方功能解释那就是用来统计你鼠标操作的次数，然后在一个窗口中展示出来。对于想完全使用快捷键在IDEA的，这个插件就很有用。</p>\n<p><strong>安装：</strong><br />\n安装这个插件很简单，只需要打开Settings,然后找到Plugins那一栏目,然后输入key promoter,点击install就行，安装好会让你重启生效，<br />\n<img src=\"https://img-blog.csdnimg.cn/20190730090501863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"idea安装插件\" /><br />\n这是我已经安装过了。<br />\n如果找不到，就直接到仓库里找即可。</p>\n<h2 id=\"2jrebel-for-intellij\">2，JRebel for IntelliJ</h2>\n<blockquote>\n<p>一款热部署插件，只要不是修改了项目的配置文件，用它都可以实现热部署。<br />\n在没有这个之前频繁的重启和reply搞得我烦不胜烦。而这个简直没有太方便，节省了大量的重启程序的等待时间<br />\n只不过是收费的，但是目前已经有好多破解方法了，不过功能确实很强大。算是开发必备神器了。</p>\n</blockquote>\n<p><strong>安装：</strong><br />\n安装和上面安装步骤一样，打开Settings,然后找到Plugins那一栏目,然后输入Jrebel,一般第一个就是,点击install安装重启就能用，安装好如下图所示会在setting下面出现JRebel的配置信息：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190730091920369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n我这个是已经激活过了，<br />\n激活流程可以参考这篇大神写的文章：<a href=\"https://blog.csdn.net/songfei_dream/article/details/90921505\">https://blog.csdn.net/songfei_dream/article/details/90921505</a></p>\n<p><strong>使用：</strong><br />\n这个安装完之后会在右上角启动哪里多两个启动项，如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/2019073010052628.png\" alt=\"在这里插入图片描述\" /><br />\n再次启动程序的时候我们就可以通过jrebel启动tomcat了，实现真正 的热部署。快捷键是crtl+F10</p>\n<h2 id=\"3mybatis-plugin\">3,Mybatis plugin</h2>\n<blockquote>\n<p>可以在mapper接口中和mapper的xml文件中来回跳转，就想接口跳到实现类那样简单。<br />\n这个是免费版的，有收费要破解的，不过功能都差不多</p>\n</blockquote>\n<p><strong>安装：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190730101011297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>效果：</strong><br />\n点击箭头就可以实现dao和mapper文件之间的跳转<br />\n<img src=\"https://img-blog.csdnimg.cn/2019073011004642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"4alibaba-java-coding--guidelines\">4、Alibaba java Coding  Guidelines</h2>\n<blockquote>\n<p>阿里巴巴java开发规范手册<br />\n规范代码，从小开始<br />\n这个插件会智能时时的提醒你哪里写的不规范，并且命名哪里不好，建议你怎样怎样改，等等。<br />\n开发必备，很重要，习惯一旦养成很难再修改的，从开始就要规范代码书写风格<br />\n<img src=\"https://img-blog.csdnimg.cn/20190731104714623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<h2 id=\"5装饰插件activate-power-mode\">5，装饰插件：activate-power-mode</h2>\n<blockquote>\n<p>这是一款让你在编码的时候，整个屏幕都为之颤抖的插件。<br />\n敲的越快，抖动越厉害，并且会统计你在不停歇的情况下一口气敲了多少次键盘<br />\n不过这个插件晃的我头晕，</p>\n</blockquote>\n<p><strong>效果</strong></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNzcyNzQzLzIwMTgwNC83NzI3NDMtMjAxODA0MTEyMzIxMzAzNzQtMjA4NzI3MTU1MC5naWY\" alt=\"在这里插入图片描述\" /><br />\n重点还是前4个好用哈，最后一个就是玩玩~</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:31', '2021-08-30 09:58:46');
INSERT INTO `tb_article` VALUES (82, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7213', 'Nginx搭建负载均衡详细操作', '<p>﻿</p>\n<p><strong>什么是负载均衡?</strong></p>\n<p>互联网早期，业务流量比较小并且业务逻辑比较简单，<strong>单台服务器</strong>便可以满足基本的需求；但随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台机器的性能问题以及单点问题凸显了出来，因此需要<strong>多台机器</strong>来进行性能的水平扩展以及避免单点故障。但是要如何将不同的用户的流量分发到不同的服务器上面呢？</p>\n<p>那么通过使用nginx搭建的负载均衡器即可解决该问题</p>\n<p>客户端的流量首先会到达负载均衡服务器，由负载均衡服务器通过一定的调度算法将流量分发到不同的应用服务器上面，同时负载均衡服务器也会对应用服务器做周期性的健康检查，当发现故障节点时便动态的将节点从应用服务器集群中剔除，以此来保证应用的高可用。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190801211348483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>搭建步骤以及准备条件：</strong></p>\n<ol>\n<li>搭建三台Linux服务器</li>\n<li>一台安装Nginx,另外两台各安装Tomcat</li>\n<li>对Nginx的/etc/nginx/conf.d/default.conf进行配置</li>\n<li>测试负载均衡</li>\n</ol>\n<p>这里我用的是使用Vmware创建三台Linux服务器，其中一台安装Nginx，为其使用dhclient分配ip为：192.168.248.128<br />\n另外两台安装jdk+Tomcat.，分别为其分配IP为：192.168.129和129.168.248.130.</p>\n<p>结果如下图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019080121244254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"详细操作\">详细操作：</h2>\n<h4 id=\"1克隆三台linux服务器\">1.克隆三台Linux服务器</h4>\n<p>​     1.1 以上图为例 dhclient 分配 ip地址</p>\n<p>​            安装tomcat的两台服务器ip分别为192.168.30.128、192.168.30.130</p>\n<p>​            安装的nginx的服务器ip为192.168.30.131</p>\n<h4 id=\"2安装jdk和tomcat\">2.安装JDK和Tomcat</h4>\n<p>在192.168.30.128、192.168.30.130上先安装JDK，在安装tomcat</p>\n<p>安装tomcat需要依赖JDK</p>\n<p>安装步骤参考之前的文章</p>\n<h4 id=\"3安装nginx\">3.安装Nginx</h4>\n<p>​    在192.168.30.131安装Nginx</p>\n<h4 id=\"4配置负载均衡\">4.配置负载均衡</h4>\n<p>在192.168.30.131安装Nginx的服务器上， 打开/etc/nginx/conf.d/default.conf文件</p>\n<pre><code>#新增\nupstream aa{\n    server 192.168.30.128:8080;\n    server 192.168.30.130:8080;\n}\n\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n        #新增一行\n        proxy_pass  http://aa;\n    }\n}\n\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190801212805182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"5关闭nginx上的安全组\">5.关闭Nginx上的安全组</h4>\n<p>使用  vi  /etc/selinux/config<br />\n编辑config文件，修改SELNUX=disabled<br />\n如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190801213601273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>注意：修改过安全组要把系统重启reboot下生效！<br />\n重启之后如果不能访问就要禁用掉防火墙：systemctl stop firewalld<br />\n并且开启Nginx：stystemctl start nginx</p>\n<h4 id=\"6测试\">6.测试</h4>\n<p>通过  <a href=\"http://192.168.30.131:80\">http://192.168.30.131:80</a> 访问Nginx,即可看到实际访问了tomcat</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190801212929871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"负载均衡的策略\">负载均衡的策略</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190801213815648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>\n<p>轮询 （默认）</p>\n<p>特点：一个一个挨着访问，tomcat服务器会被依次访问</p>\n</li>\n<li>\n<p>权重</p>\n<p>weight=数字越大权重越大，被访问的几率越高</p>\n<p>下边的配置上边的机器访问2次，下边的访问1次</p>\n</li>\n</ol>\n<p>​    <img src=\"https://img-blog.csdnimg.cn/20190801213027809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n​</p>\n<ol start=\"3\">\n<li>\n<p>ip黏着</p>\n<p>根据用户的ip,绑定到一台tomcat服务器<br />\n根据客户端用户的ip地址计算出一个可以被访问的tomcat服务器<br />\n如果客户端用户的ip地址不变，那么访问的tomcat就固定了</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190801213058161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>原理:把用户的ip进行hash处理(取用户ip的hash值),对tomcat总数量取模,然后根据得到的值,对应找到要访问的Tomcat</p>\n<h2 id=\"反向代理和正向代理的区别\">反向代理和正向代理的区别</h2>\n<p>代理如果在服务器端就是反向代理，如果放在客户端就是正向代理<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080121444414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"反向代理-和-负载均衡-的关系\">反向代理 和 负载均衡 的关系？</h2>\n<p>什么是负载均衡？ 搭建多个tomcat服务器，在用户访问量大的时候，可以访问不同的tomcat，减少某个tomcat的访问压力</p>\n<p>在nginx中如果想实现负载均衡，需要借助反向代理机制</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:36', '2021-08-30 09:58:33');
INSERT INTO `tb_article` VALUES (83, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3667', 'Centos7安装JDK和Tomcat详细步骤', '<p>﻿</p>\n<p><strong>安装步骤</strong></p>\n<ol>\n<li>将JDK安装包上传到/opt下</li>\n<li>解压</li>\n<li>配置JDK的环境变量</li>\n<li>使配置生效</li>\n<li>测试JDK是否安装成功</li>\n</ol>\n<h4 id=\"1上传jdk安装包到centos系统中的opt目录下\">1.上传JDK安装包到Centos系统中的/opt目录下</h4>\n<p>1.1 使用xftp软件和服务器建立传输</p>\n<p><img src=\"https://img-blog.csdnimg.cn/201908020841059.png\" alt=\"[外链图片转存失败(img-CtHs62Ir-1564705402590)(assets\\1563577470477.png)]\" /></p>\n<p>1.2 建立会话</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084124185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-aak5tZci-1564705402592)(assets\\1563577590105.png)]\" /></p>\n<p>1.3 填写连接会话的参数</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084201723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-CTZFFQe9-1564705402594)(assets\\1563578003459.png)]\" /><br />\n<img src=\"https://img-blog.csdnimg.cn/20190802084218687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-QoTSsKd0-1564705402598)(assets\\1563578266172.png)]\" /></p>\n<p>1.4 上传JDK的安装包到Linux系统中的/opt目录下</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084249307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-XJtwQDjf-1564705402601)(assets\\1563578083307.png)]\" /></p>\n<h4 id=\"2对上传后的jdk进行解压操作\">2.对上传后的JDK进行解压操作</h4>\n<p>2.1 进入/opt目录，查看上传后的JDK安装包</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084321703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-n0qkNEmT-1564705402603)(assets\\1563578357662.png)]\" /></p>\n<p>2.2 使用tar命令对安装包进行解压安装操作</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084348488.png\" alt=\"[外链图片转存失败(img-sWXS2ocl-1564705402604)(assets\\1563578725269.png)]\" /></p>\n<p>2.3 解压后查看结果</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084400475.png\" alt=\"​	[外链图片转存失败(img-0JMcmAyB-1564705402604)(assets\\1563578770033.png)]\" /></p>\n<p>2.4 对解压包进行重命名，此步骤不是必须的，主要是为了方便后边配置环境变量</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084415519.png\" alt=\"[外链图片转存失败(img-WRGm8lhb-1564705402605)(assets\\1563578859303.png)]\" /></p>\n<h4 id=\"3配置环境变量\">3.配置环境变量</h4>\n<p>3.1 编辑/etc/profile文件</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084429531.png\" alt=\"[外链图片转存失败(img-B4O5MFI5-1564705402605)(assets\\1563579105923.png)]\" /></p>\n<p>3.2 来到profile文件末尾，按i进入编辑模式</p>\n<p>3.3 增加JAVA_HOME和PATH两个环境变量</p>\n<pre><code># JAVA_HOME\nexport JAVA_HOME=/opt/jdk1.8\n# PATH\nexport PATH=$PATH:$JAVA_HOME/bin\n解释： $PATH是获取本身已经配置的path环境变量   \n      :(冒号)是分隔符的作用，相当于windows系统中配置的逗号\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084914896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-ZNrtSdAZ-1564705402606)(assets\\1563579389001.png)]\" /></p>\n<p>编辑完成保存退出</p>\n<p>3.4 使用source命令配置文件生效</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084942990.png\" alt=\"[外链图片转存失败(img-q9UO9DAk-1564705402607)(assets\\1563579423623.png)]\" /></p>\n<p>3.5 测试javac和java命令是否可用</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802085045546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-K7rZKudz-1564705402607)(assets\\1563579582383.png)]\" /></p>\n<p>使用java -version命令查看当前安装的jdk版本</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802085108870.png\" alt=\"[外链图片转存失败(img-VzAF0eDj-1564705402608)(assets\\1563579655693.png)]\" /></p>\n<p>到此，jdk1.8就算安装完成了，接下来安装tomcat</p>\n<h2 id=\"tomcat安装步骤\">Tomcat安装步骤：</h2>\n<ul>\n<li>上传tomcat到/opt下</li>\n<li>解压</li>\n<li>启动tomcat</li>\n<li>使用windows系统的浏览器访问Linux服务器的tomcat</li>\n</ul>\n<p><strong>1.上传tomcat到Linux系统的/opt目录下</strong><br />\n1.1 打开xftp连接到Linux系统上，将tomcat上传至/opt目录下<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085521524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>2.对于上传后的tomcat，进行解压安装</strong><br />\n2.1 查看上传后的tomcat，并且使用tar命令解压<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080208554144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2.2 查看解压后的tomcat<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085552895.png\" alt=\"在这里插入图片描述\" /><br />\n<strong>3.启动tomcat</strong><br />\n3.1 进入解压后的tomcat中bin子目录<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085615441.png\" alt=\"在这里插入图片描述\" /><br />\n3.2 执行./startup.sh命令启动tomcat<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085812211.png\" alt=\"在这里插入图片描述\" /><br />\n4.访问tomcat<br />\n4.1 在windows系统中打开浏览器输入 <a href=\"http://ip:8080\">http://ip:8080</a> 访问已经启动的tomcat<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085914846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>注意事项：如果不能访问就关闭linux系统的防火墙</strong><br />\nsystemctl stop firewalld<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085941311.png\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:12:15', '2020-10-07 13:06:41');
INSERT INTO `tb_article` VALUES (84, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8927', 'Centos7安装Nginx详细安装步骤', '<p>﻿</p>\n<h2 id=\"centos7安装nginx步骤\">Centos7安装Nginx步骤</h2>\n<ol>\n<li>手动配置nginx的yum仓库</li>\n<li>使用yum命令安装nginx</li>\n<li>启动nginx</li>\n<li>访问nginx</li>\n</ol>\n<h4 id=\"1指定nginx的yum仓库\">1.指定nginx的yum仓库</h4>\n<p>说明：centos系统中默认的yum仓库中没有nginx的安装包，<br />\n<strong>所以要想安装nginx需要单独指定它的仓库地址</strong></p>\n<p>1.1 将nginx.repo上传到Linux服务器下的/etc/yum.repos.d/下</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095154684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-Le4aM6gZ-1564710569597)(assets\\1563680660832.png)]\" /></p>\n<p>nginx.repo文件内容说明（了解）：</p>\n<p>name=     #一个描述，随意。<br />\nbaseurl=   #设置资源库的地址<br />\ngpkcheck=0 表示对从这个源下载的rpm包不进行校验  ， 1是校验；<br />\nenable=1 表示启用这个源 ， 0是禁用。</p>\n<pre><code class=\"language-xml\">[nginx]\nname=nginx repo\nbaseurl=http://nginx.org/packages/centos/7/x86_64/\ngpgcheck=0\nenabled=1\n</code></pre>\n<h4 id=\"2安装nginx\">2.安装nginx</h4>\n<p>2.1 使用yum install nginx 安装nginx</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095217158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-XwWjM2JW-1564710569604)(assets\\1563681894366.png)]\" /></p>\n<p>输入y</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095227875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-tPhk5gH7-1564710569604)(assets\\1563681901148.png)]\" /></p>\n<p>安装完成</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095238959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-xfGPm3C9-1564710569605)(assets\\1563681914220.png)]\" /></p>\n<p>可以查看whereis nginx查看安装位置</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095250383.png\" alt=\"[外链图片转存失败(img-sL0CGaE1-1564710569606)(assets\\1563681972621.png)]\" /></p>\n<p>nginx安装配置文件位置(重要):</p>\n<p>配置文件位置: /etc/nginx/nginx.conf</p>\n<p>配置文件路径: /etc/nginx/conf.d/default.conf (默认加载)</p>\n<h3 id=\"3启动nginx\">3.启动nginx</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095304135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-nrRDw8Jq-1564710569606)(assets\\1563682067852.png)]\" /></p>\n<p>启动Nginx<br />\nsystemctl start nginx<br />\n停止Nginx<br />\nsystemctl stop nginx<br />\n查看Nginx启动状态<br />\nsystemctl status nginx</p>\n<h4 id=\"4访问nginx\">4.访问nginx</h4>\n<p>在windows中打开浏览器输入<a href=\"http://ip:80\">http://ip:80</a></p>\n<p>说明：80是http协议的默认端口号，当端口号为80时可以省略不写</p>\n<p>[外链图片转存失败(img-vgBkRSr7-1564710569607)(assets\\1563711413922.png)]</p>\n<p><a href=\"p://ip:80\">p://ip:80</a></p>\n<p>说明：80是http协议的默认端口号，当端口号为80时可以省略不写</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095346272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存中...(img-vgBkRSr7-1564710569607)]\" /><br />\n到此，Centos7安装Nginx就完成啦</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:12:18', '2020-10-07 13:06:06');
INSERT INTO `tb_article` VALUES (85, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8038', 'Yum命令使用，使用yum安装vim案例演示yum的使用', '<p>﻿</p>\n<h4 id=\"何为yum-\">何为Yum ?</h4>\n<p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。</p>\n<p>基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>\n<p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>\n<blockquote>\n<p>简单说：从指定服务器自动下载并安装，使用简单方便</p>\n</blockquote>\n<p>1.安装指定的软件命令：yum install &lt;package_name&gt;</p>\n<p>2.更新指定的软件命令：yum update &lt;package_name&gt;</p>\n<p>3.删除软件包命令：yum remove &lt;package_name&gt;</p>\n<p>4.查找软件包 命令：yum search <keyword></p>\n<p>5.列出所有可安裝的软件清单命令：yum list</p>\n<h4 id=\"下边以vim的安装为例演示yum的使用\">下边以Vim的安装为例，演示Yum的使用</h4>\n<p>Vim是一个类似于Vi的著名的功能强大、高度可定制的文本编辑器，在Vi的基础上改进和增加了很多特性。</p>\n<p>1.1 使用Yum命令安装Vim</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095654938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-PZSCRNhs-1564710956716)(assets\\1563677444298.png)]\" /></p>\n<p>1.2 输入y，确定安装</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095716576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-cEviKAHX-1564710956718)(assets\\1563677490574.png)]\" /></p>\n<p>再输入一个y</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095725494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-IhB43gIF-1564710956718)(assets\\1563677545056.png)]\" /></p>\n<p>出现这个提示说明vim ，以及vim需要的依赖都安装完成</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095738125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-DdonWFH8-1564710956721)(assets\\1563677584819.png)]\" /></p>\n<p>1.3 通过vim命令修改某个文件，可以发现内容有颜色，说明vim已经正常安装并且可以使用了</p>\n<p>​      此处主要是为了介绍yum安装，vim的使用不再介绍，vim的基本使用和vi是一样</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095750451.png\" alt=\"[外链图片转存失败(img-Zc1KZtCS-1564710956723)(assets\\1563677748821.png)]\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/201908020958026.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-oXMPAesr-1564710956726)(assets\\1563677754841.png)]\" /></p>\n<h4 id=\"yum安装的原理介绍\">yum安装的原理介绍</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095812908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-wqcOkbSo-1564710956727)(assets\\1563679844231.png)]\" /></p>\n', 1, '', 0, 0, 1, '2020-09-29 17:24:57', '2020-12-19 17:11:42');
INSERT INTO `tb_article` VALUES (86, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8475', 'Spring boot 整合mybatis报错ClassNotFoundException_ org.mybatis.logging.LoggerFactory', '<p>﻿<strong>使用spring boot整合mybatis需要加入依赖：</strong></p>\n<pre><code>&lt;dependency&gt;\n      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n      &lt;version&gt;1.3.2&lt;/version&gt;\n    &lt;/dependency&gt;\n</code></pre>\n<p>这时候项目是没有任何问题的，正常运行！</p>\n<h2 id=\"但是\">但是</h2>\n<p>但是后来我使用<strong>Lombok</strong>和<strong>MyBatis-Plus</strong>进行开发，然后就引入了一个叫做<strong>mybatis-plus-boot-starter</strong>的依赖，再次运行测试的时候就一直报错：</p>\n<p>java.lang.IllegalStateException: Failed to load ApplicationContext</p>\n<p><strong>Caused by: java.lang.ClassNotFoundException: org.mybatis.logging.LoggerFactory</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190806202954276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n百度了一下其他人说是少了commons-logging 的jar包，我加上后依旧报错</p>\n<p>有人说是少了slf4j-api的jar包，我加上后也是依旧报错。</p>\n<p><strong>还有人说是少了mybatis-plus-boot-starter</strong>，到这里我似乎发现了什么，<br />\n<strong>使用mybatis-plus是让spring boot集成了mybatis，那么我在上面配置的mybatis-spring-boot-starter这个jar同样是集成mybatis的，这两个会不会有冲突？或者是因为这个jar导致了下面的mybatis-plus报错？</strong></p>\n<p>抱着试试的态度，我把mybatis-spring-boot-starter这个jar注释掉然后再运行，</p>\n<h2 id=\"然后就\">然后就，</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190806203918945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"大功告成\">大功告成！</h2>\n<p>后来我又测试，如果没有mybatis-plus提供的</p>\n<pre><code>   &lt;dependency&gt;\n        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n        &lt;version&gt;3.1.2&lt;/version&gt;\n    &lt;/dependency&gt;\n</code></pre>\n<p>这个依赖的话，同样会报ClassNotFoundException: org.mybatis.logging.LoggerFactory这个错！</p>\n<p>所以就能确定我的错误原因了！</p>\n<p>最后附一个lombok常用注解：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190806204243388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:12:32', '2020-10-07 13:05:32');
INSERT INTO `tb_article` VALUES (87, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=2874', 'Centos 7搭建MySQL-主从复制', '<p>﻿## 什么是主从复制?</p>\n<p>如果数据库服务器一旦宕机，我们的项目将无法运行，如果数据库服务器硬盘损坏还将面临数据丢失的问题!!!</p>\n<p><strong>将MySQL数据库主机的数据复制到MySQL从机上(备份)</strong></p>\n<p>原理：将MySQL主机的SQL语句以日志的方式记录下来，通过网络将日志文件复制到从机上，执行日志中的SQL语句同步主机的操作和数据</p>\n<p>搭建步骤</p>\n<ol>\n<li>创建三台Linux服务器</li>\n<li>分别安装MySQL数据库</li>\n<li>配置主节点（Mysql主机操作）</li>\n<li>配置从节点（Mysql从机操作）</li>\n</ol>\n<h4 id=\"1搭建三台linux服务器\">1.搭建三台Linux服务器</h4>\n<p>一台作为mysql数据库的主节点(master)</p>\n<p>另外两台作为mysql数据库的从节点(slave)</p>\n<h4 id=\"2分别安装mysql数据库\">2.分别安装mysql数据库</h4>\n<p>说明：可以先安装一台，然后在克隆两台</p>\n<p>2.1 上传mysql的yum源</p>\n<p>2.2 使用yum install 命令安装</p>\n<p>2.3 启动mysql数据库，修改密码，设置允许远程访问</p>\n<p>2.4 关闭防火墙</p>\n<p>或者上传rpm安装包离线安装</p>\n<p>可参考之前文章Linux上安装mysql教程：<br />\n<a href=\"https://blog.csdn.net/MacWx/article/details/98171109\">https://blog.csdn.net/MacWx/article/details/98171109</a></p>\n<h4 id=\"3配置主从\">3.配置主从</h4>\n<p>3.1 在主节点（也就是Mysql主机）</p>\n<p>vi /etc/my.cnf</p>\n<p>增加</p>\n<pre><code>server-id=132\nlog_bin\n\n#需要同步的数据库\nbinlog-do-db=baizhi\n#忽略(不需要)同步的数据库\nbinlog-ignore-db=mysql\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807193853293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-EzkAqLnM-1565177567068)(assets\\1563789758573.png)]\" /></p>\n<p>重启主节点的mysql数据库</p>\n<p>登录，查看主机状态</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194339252.png\" alt=\"[外链图片转存失败(img-KKS7eoUF-1565177567069)(assets\\1563789882250.png)]\" /></p>\n<p>3.2 从节点</p>\n<p>说明：如果是克隆的需要先删除从机上的/var/lib/mysql/auto.cnf文件</p>\n<pre><code>rm -f  /var/lib/mysql/auto.cnf\n</code></pre>\n<p>vi /etc/my.cnf</p>\n<p>增加</p>\n<pre><code>server-id=133\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2019080719440416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-R1q40Q0I-1565177567069)(assets\\1563789981959.png)]\" /></p>\n<p>重启mysql数据库       systemctl restart mysqld</p>\n<p>登录mysql数据库       mysql -uroot -p</p>\n<p>关闭从机状态              stop slave</p>\n<p>设置和主机建立连接</p>\n<p>语法</p>\n<pre><code>change master to master_host=\'主机ip地址\',master_user=主机用户名,master_password=主机密码,master_log_file=\'主机日志文件名\',master_log_pos=日志文件的位置\n</code></pre>\n<p>示例</p>\n<pre><code>change master to master_host=’192.168.152.133’,master_user=’root’,master_password=’123456’,master_log_file=’mysqld-bin.000001’,master_log_pos=241\n</code></pre>\n<p>查看从机状态              show slave status \\G;</p>\n<h4 id=\"4测试\">4.测试</h4>\n<p>在主节点创建一个叫做baizhi的数据库，然后在该数据库中创建一张表，添加一条测试数据</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194430611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-GOAwJ4fR-1565177567070)(assets\\1563868813155.png)]\" /></p>\n<p>在从节点查看</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194442918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-UwygxUPF-1565177567071)(assets\\1563868782868.png)]\" /></p>\n<p>看到我们在Mysql主机添加一条记录，从机也有了相应的记录，这就实现了mysql的主从复制！</p>\n', 1, '', 0, 0, 1, '2020-10-07 13:03:14', '2020-12-21 14:50:26');
INSERT INTO `tb_article` VALUES (88, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5796', 'Centos 7使用MyCat搭建 MySQL-读写分离', '<p>﻿</p>\n<h2 id=\"什么是读写分离\">什么是读写分离?</h2>\n<p>只有mysql的主机接收增删改SQL语句，从机接收查询语句，分担主机的查询压力</p>\n<p><strong>搭建步骤</strong></p>\n<ol>\n<li>新建一台Linux服务器、关闭防火墙</li>\n<li>上传mycat的安装包到服务器、解压安装</li>\n<li>配置mycat的环境变量</li>\n<li>修改mycat的server.xml和schema.xml配置文件</li>\n<li>启动mycat</li>\n<li>测试</li>\n</ol>\n<h4 id=\"1上传mycat安装包到-usr目录下\">1.上传mycat安装包到 /usr目录下</h4>\n<p>使用Shell上传文件<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807194804651.png\" alt=\"[外链图片转存失败(img-RxcePQqK-1565178387515)(assets\\1563939118812.png)]\" /></p>\n<h4 id=\"2解压安装\">2.解压安装</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194829867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-azuw4Fis-1565178387516)(assets\\1563939127063.png)]\" /></p>\n<h4 id=\"3配置环境变量\">3.配置环境变量</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194842945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-M3lz6kTq-1565178387517)(assets\\1563939234079.png)]\" /></p>\n<p>在profile文件中添加以下内容：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194853939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-0SxjIG8z-1565178387518)(assets\\1563939258590.png)]\" /></p>\n<p>使用source使profile生效</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019080719491061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-KlZcok9I-1565178387524)(assets\\1563939334854.png)]\" /><br />\n测试mycat命令已经可以正常使用！！！<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807195045279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"4修改mycat的配置文件\">4.修改mycat的配置文件</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195058987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-Y5sHEbse-1565178387525)(assets\\1563939427059.png)]\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195118274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-ggyxZ0dJ-1565178387525)(assets\\1563939587312.png)]\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195134837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-ukQkcW8t-1565178387526)(assets\\1563939932919.png)]\" /></p>\n<p>关闭防火墙</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195145851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-ZtqO2hDx-1565178387526)(assets\\1563939991140.png)]\" /></p>\n<p>测试<br />\n在windows主机上使用navicat连接mysql进行测试<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807195203899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-QsAmFHId-1565178387527)(assets\\1563940150731.png)]\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195304645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>连接成功后我们之后再进行增删改查操作就可以只连接mycat主机进行操作</strong>，mycat会自动的进行对mysql的主机接收增删改SQL语句，从机接收查询语句，分担主机的查询压力。</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:09', '2020-10-07 13:02:54');
INSERT INTO `tb_article` VALUES (89, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5177', 'Linux 常用基本命令总结', '<p>﻿## Linux 常用基本命令总结</p>\n<p>1.1  <strong>ls</strong><br />\n作用：查看目录下的所有文件</p>\n<p>ls -a    -后边的参数   命令可以跟参数<br />\n作用：可以查询被隐藏的文件<br />\n<strong>ls -l</strong><br />\n作用：查看文件的详细信息</p>\n<p>通常我们结合起来使用：<br />\n查询文件夹下的全部文件信息：<strong>ls -la</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203216430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\nr:可读权限<br />\nw：可写权限<br />\nx：可执行权限</p>\n<p>三个为一组，其中前三个为当前用户对该文件的权限<br />\n中间三个为root管理员用户的权限<br />\n最后三个是其他用户的权限</p>\n<p>例如，如果设置为只可读：r--<br />\n只可读写：rw-<br />\n等<br />\n1.2 <strong>cd  切换目录</strong></p>\n<p>绝对路径   以 /  开头<br />\n相对路径   从当前所在的目录开始</p>\n<p>cd .   一个.代表当前目录<br />\ncd ..   两个..代表上一级目录<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080720354164.png\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>1.3 mkdir</strong><br />\n作用：创建文件夹<br />\n用法： mkdir  文件夹名称(可以是相对或者绝对路径)<br />\nmkdir  a1  在当前文件夹中创建a1文件夹<br />\nmkdir -p a1/b1  创建b1文件夹，如果父文件夹不存在可以一并创建</p>\n<p><strong>1.4 touch</strong>   (了解)<br />\n作用：创建空白文件<br />\ntouch 1.txt  创建一个空白的1.txt文件</p>\n<p><strong>1.5 echo</strong><br />\n作用：打印<br />\necho hello   向控制台打印hello字符串</p>\n<p><strong>1.6  &gt;  &gt;&gt;</strong><br />\n作用：指定输出的文件<br />\necho hello &gt; 1.txt  向1.txt文件中输出hello<br />\n区别 &gt; 是覆盖原有文件的内容  &gt;&gt; 在原有文件中追加新的内容</p>\n<p><strong>1.7 cat</strong><br />\n作用：查看文件内容<br />\ncat  1.txt  在控制台打印1.txt文件中的内容</p>\n<p><strong>1.8 cp</strong><br />\n作用：复制<br />\n在tmp目录下创建一个文件1.txt<br />\n[root@localhost  tmp] cp  1.txt  /1.txt  将当前目录下的1.txt 复制到根目录下</p>\n<p><strong>1.9 mv</strong><br />\n作用：移动和重命名<br />\n[root@localhost  tmp] mv  1.txt  2.txt  将当前目录下的1.txt 重命名为2.txt<br />\n[root@localhost  tmp] mv  2.txt  /     将当前目录下的2.txt 移动到 跟目录下</p>\n<p><strong>2.0 rm</strong><br />\n作用：删除<br />\n有询问的删除!!<br />\nrm 文件名<br />\nrm -r 文件夹      -r 是递归<br />\n不带询问的删除 -f<br />\nrm -f 文件名    直接删除文件，不询问<br />\nrm -rf 文件夹    直接删除文件夹，不询问</p>\n<p><strong>2.2 pwd</strong><br />\n作用：打印当前所在的目录路径<br />\n可以获取当前路径进行复制使用<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080720355591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2.3 cat、more、less、head、tail</strong><br />\n作用：查看文件的内容<br />\ncat特点：展示文件中所有内容</p>\n<p>more和less 特点：分页展示文件中内容<br />\n回车往下一行 ，空格往下翻一页</p>\n<pre><code> more只能往下翻， less还可以通过键盘上的上下键 上下翻\n 使用less查看，使用q键退出查看\n</code></pre>\n<p>head特点：查看文件的前n行<br />\nhead  -n  5  /etc/profile  查看文件的前5行</p>\n<p>tail特点：查看文件的最后几行<br />\ntail的特殊作用：查看日志文件 tail -f xxx.txt  可以监听文件，打印出新生产的日志信息</p>\n<p><strong>2.3 tab键</strong>  （键盘上的一个快捷键）<br />\n作用：自动补全命令 文件路径等<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080720361717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2.4 grep</strong><br />\n作用：根据关键字查找<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203652730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>2.5 find</strong><br />\n作用：从系统中进行查找<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203702947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>2.6 systemctl  (system control)</strong><br />\n作用：开启、关闭、查看、重启系统的服务<br />\n语法：systemctl  start     服务名<br />\nsystemctl  restart   服务名<br />\nsystemctl  stop     服务名<br />\nsystemctl  status    服务名</p>\n<p>例如：以防火墙为例，进行服务器的开启，关闭等操作</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807203715174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>在centos6  services iptables stop  (了解)<br />\n重启虚拟机防火墙会自动开启</p>\n<p>在实际的阿里云服务器中可以不关闭防火墙，只开启指定端口(通过图形界面完成)</p>\n<p><strong>2.7 ps -ef</strong><br />\n作用：查看虚拟机正在运行的进程<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203737801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2.8 kill -9 进程id</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807203800657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n如果当前虚拟机ip丢失，dhclient命令又无法使用<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203811609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>3.0 tar 命令</strong><br />\n作用：对文件进行压缩和解压缩操作<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203821896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"2vi编辑器\">2.VI编辑器</h2>\n<p>作用：linux操作的一款编辑器，只能用键盘操作，无法使用鼠标</p>\n<p>使用 vi 文件名     进入vi编辑器<br />\n输入i、A、a、O、o都可进入编辑模式，进入编辑模式左下角会变成insert<br />\n按下Esc键盘左上角的退出键退出编辑模式<br />\n：冒号进入末行模式<br />\nq，不保存退出vi<br />\nq! ,不保存强制退出<br />\nwq保存退出vi<br />\nwq！，保存并强制退出</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019080720390785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"命令补充\">命令补充</h2>\n<p>权限相关：groupadd  组名<br />\nuseradd -g 组名 用户名<br />\npasswd 用户名<br />\nsu 用户名<br />\nchmod u=rwx,g=rwx,o=rwx 文件</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:13', '2020-10-07 13:01:43');
INSERT INTO `tb_article` VALUES (90, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1269', 'Redis数据库的介绍、安装、数据结构、常用命令', '<p>﻿## 1、 redis是什么呢？</p>\n<p>redis是非关系型数据库(nosql)，基于内存读写的数据库,采用key-value的方式存储数据<br />\n<strong>nosql：  not noly sql</strong> ，没有表的SQL</p>\n<p>在目前的企业开发中会用关系型数据库（Oracale+MySQL）+非关系型数据库(Redis 、MongoDB、Memcache)共同开发项目</p>\n<p><strong>为什么使用NoSQL</strong></p>\n<p>现在存在数据格式非常多样，不适合应用表格进行存储。<br />\n表格数据称之为 结构化数据<br />\n非表格数据称之为 半结构化 （kv json)  非结构化数据 音频 视频</p>\n<p>Redis是基于内存读写的数据库，<br />\n硬盘读取速度 大约几百M<br />\n内存读取速度 大约 上千M<br />\n所以Redis相对来说是要比关系型数据库要快很多</p>\n<p>Redis的应用场景：查询读取操作非常频繁的业务<br />\n例如：缓存</p>\n<h2 id=\"2redis的下载安装\">2、Redis的下载安装</h2>\n<p>Redis可从<br />\n<a href=\"https://redis.io/download\">https://redis.io/download</a><br />\n官网进行下载，有windows版和linux版，<br />\n都是下载直接解压就可使用<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807210547190.png\" alt=\"在这里插入图片描述\" /><br />\n解压后的目录如下：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807211247767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n不过需要注意的是：<br />\n在windows系统上，我们要修改redis.windows.conf这个文件，将appendonly no改为appendonly yes<br />\n因为redis是忘往内存上面存储数据的，改完这个可以使数据直接同步到硬盘上。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807211152164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n而启动的时候也不要双击redis-server.exe进行启动，因为这样启动是不能加载到redis.windows.conf这个配置文件的，<br />\n所以启动的时候我们要在redis解压的目录下进入cmd，<br />\n输入：redis-server  redis.windows.conf  启动redis服务<br />\n如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807211617774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n这样就启动了Redis服务，再双击redis-cli.exe就启动了Redis的客户端</p>\n<p>Linux系统下启动Redis服务要进到解压目录的src下，<br />\n输入./redis-server  ../redis.conf<br />\n进行启动，如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807212204837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"3redis的数据结构常用命令\">3、Redis的数据结构、常用命令</h2>\n<p><strong>redis数据库存储数据使用的key-value</strong><br />\n<strong>key是string类型  value的数据结构支持5个string、set、sorted_set、list、hash</strong></p>\n<p>value最大占用空间 1GB<br />\nredis支持的数据结构比较丰富、对不同的数据结构，还拥有不同的操作命令</p>\n<p>set、get、del<br />\nkeys *  打印所有的key</p>\n<p>基础命令 （key value）</p>\n<p>keys *</p>\n<p>命令的作用：显示redis中 所有的key<br />\nkeys  name*  name后面可以有0---多个任意字符<br />\nkeys  name?  name后面必须只存在一个字符</p>\n<p><strong>exists key</strong><br />\n判断 key是否存在 若返回 1 则存在 0 不存在</p>\n<p><strong>del key</strong><br />\n作用：删除 某一个key</p>\n<p><strong>help 命令</strong><br />\n帮助命令</p>\n<p><strong>flushall</strong> 清空所有数据库中的内容</p>\n<p>退出 <strong>exit|quit</strong> 退出redis的服务器</p>\n<h2 id=\"redis中值是字符串类型-string-数字\">Redis中值是字符串类型 （String 数字）</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213239589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>set</strong><br />\n用于设置 一个字符串类型的  key value</p>\n<p><strong>get</strong><br />\n根据key获取值</p>\n<p><strong>mset</strong><br />\n一次性设置多个 key value</p>\n<p>mget<br />\nstrlen<br />\nappend<br />\ngetrange 截取子串<br />\ngetrange name 0 3<br />\nsetex 设置一个key的存活有效期 (秒) psetex 作用与 setex 一致 但是毫秒<br />\nsetnx<br />\n如果当前没有这个key的话 那么 setnx等价于 set命令<br />\n如果当前存在这个key的话 那么 setnx不起作用<br />\ndecr 针对数字类型 做 -1操作 另外 desr key 数字 根据数字做减法操作<br />\nincr incrby incrbyfloat</p>\n<blockquote>\n<p>应用场景：缓存查询结果(json或者序列化) 用户访问记录 例如：通过记录ip-访问次数来显示ip的访问<br />\n统计粉丝数、点击次数、点赞</p>\n</blockquote>\n<h2 id=\"redis中值是set类型在这里插入图片描述\">Redis中值是set类型<img src=\"https://img-blog.csdnimg.cn/20190807213452727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></h2>\n<h2 id=\"c-list类型的数据操作的命令\">c) List类型的数据操作的命令</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213545465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\ni.	lpush 栈式结构<br />\nlpush name suns[2]<br />\nlpush name xiaohei[1]<br />\nlpush name xiaowb[0]<br />\nii.	lpushx 如果操作的key不存在 则不起作用<br />\n如果操作的key存在 则等同于lpush<br />\niii.	rpush 操作的内容 等效 java List<br />\n第一个操作的元素 就放置在第一个位置<br />\n依次类推<br />\n应用场景：关注列表、消息队列</p>\n<h2 id=\"hash类型的数据操作的命令\">hash类型的数据操作的命令</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213752596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"zset-sorted-set类型的数据操作的命令\">zset (sorted_set)类型的数据操作的命令</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213813240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"7-redis命令的补充部分\">7. Redis命令的补充部分</h2>\n<p>a)	只有set命令 可以操作 任意类型的数据</p>\n<p>b)	注意Redis中会有数据库概念 默认存在16数据库 0 ---- 15</p>\n<p>默认所使用的数据库 0 如果要选择使用别的数据库 select 编号</p>\n<p>注意：不同数据库所创建的key 相互隔离 互补干扰的。通过flushall 清空的是所有数据库中的key. 清空当前的数据库 flushdb这个命令<br />\n如何该表Redis中对于数据库的支持呢？编辑 redis.conf</p>\n<p>**	expire相关命令  （促销 秒杀  手机验证码倒计时 排行榜  Cache）**<br />\ni.	在Redis创建key value 默认都是持久化的 永久保存。<br />\nii.	可以通过expire 命令 指定 key 存活时间<br />\nexpire key seconds</p>\n<p><strong>查看某一个key的存活时常</strong><br />\npersist 作用 可以把 一个应用了expire命令key 再次转换持久化的key<br />\nexpireat key  unix 时间戳 毫秒数iii.</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213646467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:20', '2021-08-30 09:57:06');
INSERT INTO `tb_article` VALUES (91, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4671', '面试题：说一下HashMap和HashSet的实现原理？', '<p>﻿## HashMap 的实现原理：</p>\n<p><strong>HashMap是基于Hash算法实现的，</strong><br />\n我们通过put（key，value）存储数据，通过get（key）来获取数据</p>\n<p>当传入key时，HashMap会根据Key.hashCode()计算出Hash值，根据Hash值将value保存在bucket里	，。</p>\n<p><strong>当计算出相同的Hash值时，我们称之为Hash冲突</strong>，HashMap 的做法是用链表和红黑树存储相同Hash值的value，<br />\n当hash冲突的个数比较少时，使用链表存储，<br />\n否则使用红黑树。</p>\n<h2 id=\"hashset-的实现原理\">HashSet 的实现原理：</h2>\n<p>HashSet是基于HashMap实现的，HashSet 底层使用HashMap来保存所有元素，<br />\n因此HashSet 的实现比较简单，相关HashSet 的操作，基本上都是直接调用底层HashMap的相关方法来完成，HashSet不允许有重复的值，并且元素是无序的。</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:25', '2021-08-30 09:53:48');
INSERT INTO `tb_article` VALUES (92, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=9206', '多线程相关面试题_并行和并发的区别、线程和进程、线程的创建方式、运行状态', '<p>﻿<strong>1，并行和并发有什么区别</strong></p>\n<p>并行：多个处理器或多核处理器同时处理多个任务。<br />\n并发：多个任务在同一个CPU核上，按细分的时间片轮流（交替）执行，从逻辑上来看并发的任务是同时执行；</p>\n<p>简而言之：<br />\n并发=两个队列和一台处理器<br />\n并发=两个队列和两个处理器</p>\n<p><strong>2、线程和进程的区别</strong></p>\n<p>一个程序下至少有一个进程，<br />\n一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p>\n<p><strong>3.守护线程是什么?</strong></p>\n<p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在Java中垃圾回收线程就是特殊的守护线程。</p>\n<p><strong>4.创建线程有哪几种方式?</strong></p>\n<p>创建线程有三种方式:</p>\n<pre><code>  ●继承Thread重写run方法;\n\n  ●实现Runnable接口;\n\n  ●实现Callable接口。\n</code></pre>\n<p><strong>5.线程有哪些状态?线程的状态:</strong></p>\n<pre><code>   NEW尚未启动\n\n   RUNNABLE正在执行中\n\n   BLOCKED阻塞的(被同步锁或者I0锁阻塞)\n\n   WAITING永久等待状态\n\n  TIMED_ WAITING 等待指定的时间重新被唤醒的状态\n</code></pre>\n<p><strong>6，sleep（）和 wait（）的区别</strong></p>\n<p>类的不同，sleep（）来自Thred ，wait（）来着Object，<br />\n释放锁，sleep（）不释放锁，而wait（）释放锁<br />\n用法不同，sleep（）到时间会自动醒来，自动回复线程，而wait（）需要用notify（）/  notifyAll()来唤醒线程。</p>\n<p><strong>7，线程的run（）和start（）方法有什么区别</strong></p>\n<p>start（）方法用于启动线程，<br />\nrun（）方法用于执行线程的运行时代码，<br />\nrun（）可以重复使用，而start（）只能调用一次。</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:52', '2021-08-30 09:53:36');
INSERT INTO `tb_article` VALUES (93, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3715', 'tomcat集群环境下如何保证session一致性', '<p>﻿## 为什么集群环境下，会出现session不一致问题？</p>\n<p>答：使用nginx的负载均衡之后，不确定访问哪个tomcat，导致客户端存储的jsessionid携带到集群环境下的其他tomcat是无效的。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811142904838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>关于集群环境下，解决session不一致问题?</strong></p>\n<p>方式1：负载均衡的策略ip黏着：在nginx的default.conf配置<strong>ip_hash</strong>,这样客户端会固定的访问某一台服务器</p>\n<p>方式2：使用redis管理集群环境的session，session对象不在存储在tomcat服务器，而是redis数据库中,如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811143147501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>实现原理描述:</strong><br />\n客户端访问nginx，分配到tomcat-1服务器，创建session对象，jsessionid,将jsessionid作为key，session对象作为value存到redis数据库中，随着响应将jsessionid返回给客户端浏览器，该客户端浏览器向nginx在次发出请求，写cookie(包含jsessionid),到nginx后被分配到tomcat-2服务器，tomcat-2获取cookie中的jsessionid，去redis数据库查找对应的session对象并且返回使用</p>\n<h2 id=\"实现步骤\">实现步骤：</h2>\n<p>1.将下边三个jar上传到tomcat服务器中的lib目录下<br />\n要重写tomcat的session实现方法，将session管理到redis服务器中<br />\n如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811143509147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2. 修改tomcat中conf目录下的context.xml<br />\n原因1：我们上传的jar中的类，替换了tomcat中的代码，需要让tomcat知道我们的类叫什么名字<br />\n原因2：配置redis数据库所在服务器的ip地址和redis数据库的端口号</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190811143631510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n3. 重启tomcat服务<br />\n进入bin目录 ,先执行./shutdown.sh 再执行./startup.sh</p>\n<p>注意：以上操作集群中的tomcat(有几个就操作几个)都是相同的操作</p>\n<p>4，测试<br />\n做一个登陆页面，测试一下上面的操作有没有成功</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:58', '2020-12-21 14:52:10');
INSERT INTO `tb_article` VALUES (94, 1, 5, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1660', 'mybatis的二级缓存，以及如何利用redis优化mybatis缓存？', '<p>﻿学习redis，缓存是很重要的一块</p>\n<p><strong>1.1 为什么要使用缓存？</strong></p>\n<p>为mybatis增加缓存功能，可有利用减少数据库访问</p>\n<p>系统运行的瓶颈很重要的一个因素就是数据库，<br />\n减少数据库的访问压力，可以提高整个系统的吞吐量。</p>\n<p><strong>什么是缓存？</strong></p>\n<p>将SQL语句，以及对应的查询结果存在服务器内存中，这一块内存存储区域，被我们称之为缓存。</p>\n<p>如果之后再执行该同样的SQL语句，则直接从缓存中去取，不再去查询数据库，可减小数据库的访问压力。</p>\n<p><strong>缓存的核心使用思路</strong></p>\n<ol>\n<li>开启缓存</li>\n<li>缓存的作用范围 缓存中的数据可以使用的范围</li>\n<li>脏数据的处理<br />\n脏数据：缓存是数据库中热点数据的备份，当数据库中的热点数据发生变化时，缓存也要和数据库保持一致，否则相应的数据成为脏数据。</li>\n</ol>\n<h2 id=\"12-mybatis现有的缓存\">1.2 mybatis现有的缓存</h2>\n<p><strong>mybatis的缓存分成一级缓存和二级缓存</strong></p>\n<p>一级缓存也称之为SqlSession级别的缓存，默认开启，只一次查询有效，作用范围太小，意义不大。<br />\n脏数据的处理 ：执行增删改有可能造成脏数据，一旦执行增删改立刻清空缓存。</p>\n<p>二级缓存称之为SqlSessionFactory级别的缓存,<br />\n通常我们所说的缓存默认指的就是二级缓存。</p>\n<p>二级缓存使用步骤</p>\n<ol>\n<li>开启二级缓存 (如果和spring整合，默认已经开启)<br />\n若没有，要在mybatis-config.xml中配置一下信息：</li>\n</ol>\n<pre><code>&lt;settings&gt;\n	&lt;setting name = &quot;cacheEnabled&quot;  value=&quot;true&quot; /&gt; \n&lt;/settings&gt;\n</code></pre>\n<ol start=\"2\">\n<li>在mapper文件增加 &lt; cache/&gt;</li>\n</ol>\n<p>*Mapper.xml中配置：</p>\n<pre><code>&lt;cache /&gt;\n</code></pre>\n<p>只有添加了cache标签的mapper文件中的查询结果才会放置到对应的二级缓存中</p>\n<ol start=\"3\">\n<li>\n<p>将需要存储到缓存中的对象实现序列化接口</p>\n</li>\n<li>\n<p>二级缓存作用范围<br />\n同1个namespace下</p>\n</li>\n<li>\n<p>脏数据的处理<br />\n执行同1个namespace下的增删改，自动清空该namespace下的缓存</p>\n</li>\n</ol>\n<p>内置的二级缓存通常也不用。<br />\n内置的二级缓存本身有namespace的问题，并且不支持持久化。<br />\n所以平时主要用：Ehcache 独立的缓存组件，使用纯Java编写。<br />\n准备工作：引入相关jar包 ehcache-core.jar   mybatis-ehcache.jar</p>\n<p>使用步骤：</p>\n<ol>\n<li>开启 缓存，Config.xml中配置和上面一样</li>\n<li>mapper.xml中配置，cache标签要加一个type属性指向我们自定义的cache<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081115082521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></li>\n<li>src下添加ehcache.xml<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811150937127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\nEncache作用于整个项目中 。<br />\n对脏数据的处理：执行增删改，立刻清空缓存中的数据。</li>\n</ol>\n<p>注意：低版本的mybatis配合ehcache有问题，需要升级mybatis到3.2以上<br />\n另外ehcache.xml 需要添加updateCheck=”false” 禁用检查更新<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811151048191.png\" alt=\"在这里插入图片描述\" /></p>\n<p>说了这么多，</p>\n<h2 id=\"如何使用redis优化mybatis缓存\">如何使用redis优化mybatis缓存</h2>\n<p>mybatis已经实现了二级缓存，为什么使用redis对其优化？？？</p>\n<p>mybatis本身二级缓存的查询结果要存储在当前服务器的JVM虚拟机中，如果缓存的数据量过大会造成jvm服务器臃肿缓慢，大量占用内存空间。</p>\n<p>所以我们最好将缓存的数据从tomcat服务器上转移到redis服务器上，redis存取速度快，并且是一个独立进程和jvm没有关系。</p>\n<p><strong>实现步骤</strong></p>\n<ol>\n<li>添加jar包<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081115272444.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在mapper文件中，增加自定义二级缓存的实现类配置<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081115302038.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></li>\n<li>在src下，增加一个redis.properties配置文件，指明要连接redis数据库的ip和端口号<br />\n默认是连接本地的redis<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811153210940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n总结：为了减少mysql数据库的查询压力，借助mybatis二级缓存，让多用户共享查询结果<br />\n前提执行的SQL语句是相同的。但是项目运行过程中，发现二级缓存存储的数据量越来越大，大量占用了当前JVM的空间，为了解决这个问题，使用redis数据库存储缓存的数据</li>\n</ol>\n', 1, '', 0, 0, 1, '2020-10-07 12:56:29', '2022-05-21 18:13:56');
INSERT INTO `tb_article` VALUES (95, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=9302', 'spring boot 实现文件的上传下载', '<p>﻿## spring boot实现文件的上传，</p>\n<p>我是使用maven搭建的spring boot项目，页面集成的jsp。<br />\n页面结构如下：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811160646759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n准备工作：在webapp下新建一个目录叫upload</p>\n<p><strong>1，页面，upload.jsp</strong></p>\n<pre><code>&lt;body&gt;\n&lt;form method=&quot;post&quot; action=&quot;${pageContext.request.contextPath}/file/upload&quot; enctype=&quot;multipart/form-data&quot;&gt;\n    &lt;input type=&quot;file&quot; name=&quot;files&quot;&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n</code></pre>\n<p><strong>2) 控制器 ,FileController.java</strong></p>\n<pre><code>@Controller\n@RequestMapping(&quot;/file&quot;)\npublic class FileController {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RequestMapping(&quot;/upload&quot;)\n    public String upLoad(MultipartFile files, HttpSession session) throws IOException {\n        logger.info(&quot;upload 方法执行了&quot;);\n        //获取上传文件的路径\n        String realPath = session.getServletContext().getRealPath(&quot;upload&quot;);\n        System.out.println(&quot;--------&quot;+realPath);\n        //获取上传的文件名，\n        File file1 = new File(realPath, files.getOriginalFilename());\n        //执行文件上传复制\n        files.transferTo(file1);\n        //跳到下载页面\n        return &quot;/download.jsp&quot;;\n\n    }\n}\n</code></pre>\n<p><strong>3) 修改上传文件大小的限制，application.properties</strong></p>\n<pre><code>//配置tomcat端口号\nserver.port=8080\n//项目访问路径\nserver.servlet.context-path=/maven_springboot\n//jsp页面热部署\nserver.servlet.jsp.init-parameters.development=true\n//修改上传文件大小限制为10Mb\nspring.servlet.multipart.max-file-size=10485760\n\n</code></pre>\n<h2 id=\"2下载\">2，下载</h2>\n<p><strong>1) 页面 download.jsp</strong><br />\n这里的fileName应该是要从数据库读取出来，包括上传也是应该把上传的文件信息存到数据库，这里我就不写了。<br />\n就直接把文件写死了，</p>\n<pre><code>&lt;body&gt;\n&lt;a href=&quot;${pageContext.request.contextPath}/file/download?fileName=aaa.png&quot;&gt;下载&lt;/a&gt;\n&lt;/body&gt;\n</code></pre>\n<p><strong>2）控制器, FileController</strong></p>\n<pre><code> @RequestMapping(&quot;/download&quot;)\n    public void Download(String fileName, HttpServletResponse response,HttpSession session) throws Exception {\n   //设置下载响应头\n        response.setHeader(&quot;content-disposition&quot;,&quot;attachment;fileName&quot;+ URLEncoder.encode(fileName,&quot;UTF-8&quot;));\n    //获取文件路径\n        String uploadPath = session.getServletContext().getRealPath(&quot;upload&quot;);\n\n        File file = new File(uploadPath,fileName);\n        ServletOutputStream outputStream = response.getOutputStream();\n        FileUtils.copyFile(file,response.getOutputStream());\n\n    }\n</code></pre>\n<p>这里要用到一个jar包，commons-io包的FileUtils工具类，<br />\npom引入该依赖如下：</p>\n<pre><code> &lt;dependency&gt;\n      &lt;groupId&gt;commons-io&lt;/groupId&gt;\n      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;\n      &lt;version&gt;2.4&lt;/version&gt;\n    &lt;/dependency&gt;\n\n</code></pre>\n<p>如此，一个简单的上传下载demo就算完成了</p>\n', 1, '', 0, 0, 1, '2020-09-29 17:25:27', '2020-12-21 14:53:59');
INSERT INTO `tb_article` VALUES (96, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1515', 'Centos Linux系统使用vsftpd搭建ftp服务', '<p>﻿## Linux，Centos系统使用vsftpd搭建ftp服务</p>\n<h3 id=\"一安装vsftpd\">一、安装vsftpd</h3>\n<ol>\n<li>运行以下命令安装vsftpd。</li>\n</ol>\n<pre><code class=\"language-powershell\">yum install -y vsftpd\n</code></pre>\n<p>返回如下图所示界面时，表示安装成功。<br />\n<img src=\"https://img-blog.csdnimg.cn/20201011163459305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"2\">\n<li>运行以下命令设置FTP服务开机自启动。</li>\n</ol>\n<pre><code class=\"language-powershell\">systemctl enable vsftpd.service\n</code></pre>\n<ol start=\"3\">\n<li>启动FTP服务。</li>\n</ol>\n<pre><code class=\"language-powershell\">systemctl start vsftpd.service\n</code></pre>\n<ol start=\"4\">\n<li>运行以下命令查看FTP服务监听的端口。</li>\n</ol>\n<pre><code class=\"language-powershell\">netstat -antup | grep ftp\n</code></pre>\n<p>出现如下图所示界面，表示FTP服务已启动，监听的端口号为 21。此时，vsftpd默认已开启匿名访问功能，您无需输入用户名密码即可登录FTP服务器，但没有修改或上传文件的权限。<br />\n<img src=\"https://img-blog.csdnimg.cn/20201011163555146.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h3 id=\"二配置vsftpd\">二、配置vsftpd</h3>\n<blockquote>\n<p>vsftpd（very secure FTP<br />\ndaemon）是一款在Linux发行版中最受推崇的FTP服务器。vsftpd支持匿名访问和本地用户模式两种访问方式。匿名访问方式任何用户都可以访问搭建的FTP服务；本地用户模式只支持添加的本地用户访问搭建的FTP服务。</p>\n</blockquote>\n<ul>\n<li>说明: 匿名用户模式和本地用户模式只可同时配置一种。</li>\n</ul>\n<h4 id=\"21-匿名用户模式\">2.1 匿名用户模式</h4>\n<ol>\n<li>修改配置文件vsftpd.conf。</li>\n</ol>\n<pre><code class=\"language-powershell\">vim /etc/vsftpd/vsftpd.conf\n</code></pre>\n<p>按 i 键进入编辑模式，将匿名上传权限 anon_upload_enable=YES 的注释解开。<br />\n<img src=\"https://img-blog.csdnimg.cn/20201011163821978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"2\">\n<li>\n<p>按ESC键退出编辑模式，输入:wq 保存并退出vim。</p>\n</li>\n<li>\n<p>更改/var/ftp/pub目录的权限，为FTP用户添加写权限。</p>\n</li>\n</ol>\n<pre><code class=\"language-powershell\">chmod o+w /var/ftp/pub/\n</code></pre>\n<ol start=\"4\">\n<li>重启FTP服务。</li>\n</ol>\n<pre><code class=\"language-powershell\">systemctl restart vsftpd.service\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20201011163953415.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"22-本地用户模式\">2.2 本地用户模式</h4>\n<ol>\n<li>为FTP服务创建一个Linux用户。</li>\n</ol>\n<pre><code class=\"language-powershell\">adduser ftptest\n</code></pre>\n<p>为用户设置密码。</p>\n<pre><code class=\"language-powershell\">passwd ftptest\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20201011164202186.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"2\">\n<li>创建一个供FTP服务使用的文件目录。</li>\n</ol>\n<pre><code class=\"language-powershell\">mkdir /var/ftp/test\n</code></pre>\n<ol start=\"3\">\n<li>更改/var/ftp/test目录的拥有者为ftptest。</li>\n</ol>\n<pre><code class=\"language-powershell\">chown -R ftptest:ftptest /var/ftp/test\n</code></pre>\n<ol start=\"4\">\n<li>修改vsftpd.conf配置文件。</li>\n</ol>\n<p>配置FTP为主动模式请执行如下命令:</p>\n<pre><code class=\"language-powershell\">sed -i \'s/anonymous_enable=YES/anonymous_enable=NO/\' /etc/vsftpd/vsftpd.conf #禁止匿名登录FTP服务器 \nsed -i \'s/listen=NO/listen=YES/\' /etc/vsftpd/vsftpd.conf #监听IPv4 sockets \nsed -i \'s/listen_ipv6=YES/#listen_ipv6=YES/\' /etc/vsftpd/vsftpd.conf #关闭监听IPv6 sockets \nsed -i \'s/#chroot_local_user=YES/chroot_local_user=YES/\' /etc/vsftpd/vsftpd.conf #全部用户被限制在主目录 \nsed -i \'s/#chroot_list_enable=YES/chroot_list_enable=YES/\' /etc/vsftpd/vsftpd.conf #启用例外用户名单 \nsed -i \'s/#chroot_list_file=/chroot_list_file=/\' /etc/vsftpd/vsftpd.conf #指定例外用户列表文件，列表中的用户不被锁定在主目录 \necho &quot;allow_writeable_chroot=YES&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf \necho &quot;local_root=/var/ftp/test&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置本地用户登录后所在的目录\n</code></pre>\n<p>配置FTP为被动模式请执行如下命令：</p>\n<pre><code class=\"language-powershell\">sed -i \'s/anonymous_enable=YES/anonymous_enable=NO/\' /etc/vsftpd/vsftpd.conf #禁止匿名登录FTP服务器 \nsed -i \'s/listen=NO/listen=YES/\' /etc/vsftpd/vsftpd.conf #监听IPv4 sockets \nsed -i \'s/listen_ipv6=YES/#listen_ipv6=YES/\' /etc/vsftpd/vsftpd.conf #关闭监听IPv6 sockets \nsed -i \'s/#chroot_local_user=YES/chroot_local_user=YES/\' /etc/vsftpd/vsftpd.conf #全部用户被限制在主目录 \nsed -i \'s/#chroot_list_enable=YES/chroot_list_enable=YES/\' /etc/vsftpd/vsftpd.conf #启用例外用户名单 \nsed -i \'s/#chroot_list_file=/chroot_list_file=/\' /etc/vsftpd/vsftpd.conf #指定例外用户列表文件，列表中的用户不被锁定在主目录 \necho &quot;allow_writeable_chroot=YES&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf \necho &quot;local_root=/var/ftp/test&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置本地用户登录后所在的目录 \n\necho &quot;pasv_enable=YES&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #开启被动模式 \necho &quot;pasv_address=&lt;FTP服务器公网IP地址&gt;&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #本教程中为ECS服务器弹性IP \necho &quot;pasv_min_port=20&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置被动模式下，建立数据传输可使用的端口范围的最小值 \necho &quot;pasv_max_port=21&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置被动模式下，建立数据传输可使用的端口范围的最大值\n</code></pre>\n<ol start=\"5\">\n<li>在/etc/vsftpd目录下创建chroot_list文件，并在文件中写入例外用户名单。</li>\n</ol>\n<pre><code class=\"language-powershell\">#使用vim命令编辑chroot_list文件，添加例外用户名单。此名单中的用户不会被锁定在主目录，可以访问其他目录。\nvim /etc/vsftpd/chroot_list\n</code></pre>\n<p>说明: 没有例外用户时，也必须创建chroot_list文件，内容可为空。</p>\n<ol start=\"6\">\n<li>重启FTP服务。</li>\n</ol>\n<pre><code class=\"language-powershell\">systemctl restart vsftpd.service\n</code></pre>\n<h2 id=\"三客户端测试\">三、客户端测试</h2>\n<p>FTP客户端、Windows命令行工具或浏览器均可用来测试FTP服务器。（此步骤仅适用于本地用户，匿名模式无需进行测试操作）</p>\n<p>说明：使用浏览器访问FTP服务器出错时，建议您清除浏览器缓存后再尝试。</p>\n<ol>\n<li>\n<p>打开Chrom浏览器，在地址栏中输入<a href=\"ftp://&lt;\">ftp://&lt;</a>FTP服务器公网IP地址&gt;:FTP端口，FTP服务器公网IP地址为ECS服务器的弹性IP地址。例如：ftp://139.0.0.1:21。</p>\n</li>\n<li>\n<p>在弹出的对话框中，输入用户名和密码。</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20201011164412400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"3\">\n<li>登录成功界面如下，此时可对FTP文件进行相应权限的操作。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20201011164418652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-10-14 15:43:49', '2022-05-21 18:14:31');
INSERT INTO `tb_article` VALUES (97, 1, 10, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1208', '在VUE中使用RSA加密解密加签解签', '</font>\n<p>@<a href=\"目录\">TOC</a></p>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h1 id=\"前言\">前言</h1>\n<font >\n项目中部分隐私参数要前后端对接交互时，出于安全性考虑，我们会对重要的参数进行加密后再进行传输，一般采用的加密方式是非对称性加密RSA算法。\n</font>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<p><font color=#999AAA >提示：以下是本篇文章正文内容，下面案例可供参考</p>\n<h1 id=\"一什么是rsa加密\">一、什么是RSA加密？</h1>\n<p><font color=#999AAA >RSA加密是一种非对称加密。<br />\n可以在不直接传递密钥的情况下，完成解密。<br />\n这能够确保信息的安全性，避免了直接传递密钥所造成的被破解的风险。<br />\nRSA是由一对密钥来进行加解密的过程，分别称为公钥和私钥。<br />\n两者之间有数学相关，该加密算法的原理就是对一极大整数做因数分解的困难性来保证安全性。<br />\n通常个人保存私钥，公钥是公开的（可能同时多人持有）。</p>\n<h1 id=\"二加密过程\">二、加密过程</h1>\n<ul>\n<li>（1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。</li>\n<li>（2）A传递自己的公钥给B，B用A的公钥对消息进行加密。</li>\n<li>（3）A接收到B加密的消息，利用A自己的私钥对消息进行解密。<br />\n　<br />\n在这个过程中，只有2次传递过程，第一次是A传递公钥给B，第二次是B传递加密消息给A，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行解密，防止了消息内容的泄露。</li>\n</ul>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h1 id=\"三在vue中使用步骤\">三、在Vue中使用步骤</h1>\n<p>一般是客户端初始化时访问服务端时，服务端会生成一对RSA对，及公钥和密钥。</p>\n<ul>\n<li>如果前端只需要将要传给后端的数据进行<strong>加密</strong>后传输，那么前端可以只要公钥，通过公钥对要传输的参数进行加密后把加密的字符串发给后端即可，后端自有办法解密。</li>\n<li>如果前端要获取后端传过来的已经加密后的字符串，并且<strong>解密</strong>使用，那么前端就需要拿到RSA对立面的私钥进行解密后使用了。</li>\n</ul>\n<h3 id=\"使用步骤\">使用步骤：</h3>\n<h4 id=\"1安装依赖\">1、安装依赖</h4>\n<p>首先引入jsencrypt</p>\n<pre><code class=\"language-powershell\">npm install jsencrypt --save\n</code></pre>\n<h4 id=\"2在mainjs中引入\">2、在main.js中引入</h4>\n<pre><code class=\"language-powershell\">import JsEncrypt from \'jsencrypt\'\nVue.prototype.$jsEncrypt = JsEncrypt\n</code></pre>\n<h4 id=\"3将加密解密方法封装到通用的js内\">3、将加密解密方法封装到通用的js内</h4>\n<pre><code class=\"language-javascript\">let publicKey = \'这里是封装的公钥\'\nlet privateKey = \'这里是封装的私钥\'\n//加密方法\n  RSAencrypt(pas){\n    //实例化jsEncrypt对象\n    let jse = new JSEncrypt();\n    //设置公钥\n    jse.setPublicKey(publicKey);\n     console.log(\'加密：\'+jse.encrypt(pas))\n    return jse.encrypt(pas);\n  },\n  \n//解密方法\n  RSAdecrypt(pas){\n    let jse = new JSEncrypt();\n    // 私钥\n    jse.setPrivateKey(privateKey)\n     console.log(\'解密：\'+jse.decrypt(pas))\n    return jse.decrypt(pas);\n  },\n\n</code></pre>\n<p>我在项目中的使用如下图：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201216153329749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在VUE中使用RSA加密解密加签解签\" /></p>\n<h4 id=\"运行结果\">运行结果</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20201216153523787.png\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"总结\">总结</h1>\n<p>后端的使用Springboot对RSA进行加解密的过程可以看我的另一篇博客</p>\n', 1, '', 0, 0, 1, '2020-12-17 15:32:34', '2020-12-17 15:32:34');
INSERT INTO `tb_article` VALUES (98, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=92', 'SpringBoot集成WebSocket，实现后台向前端推送信息', '<p>@<a href=\"目录\">TOC</a></p>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h1 id=\"前言\">前言</h1>\n<p><font color=#999AAA >在一次项目开发中，使用到了Netty网络应用框架，以及MQTT进行消息数据的收发，这其中需要后台来将获取到的消息主动推送给前端，于是就使用到了MQTT，特此记录一下。</p>\n<h1 id=\"一什么是websocket\">一、什么是websocket？</h1>\n<p><font color=#999AAA >WebSocket协议是基于TCP的一种新的网络协议。它实现了客户端与服务器全双工通信，学过计算机网络都知道，既然是全双工，就说明了<strong>服务器可以主动发送信息给客户端</strong>。这与我们的推送技术或者是多人在线聊天的功能不谋而合。<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217170824701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>为什么不使用HTTP 协议呢？这是因为HTTP是单工通信，通信只能由客户端发起，客户端请求一下，服务器处理一下，这就太麻烦了。于是websocket应运而生。<br />\n<img src=\"https://img-blog.csdnimg.cn/2020121717094782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>下面我们就直接开始使用Springboot开始整合。以下案例都在我自己的电脑上测试成功，你可以根据自己的功能进行修改即可。<br />\n我的项目结构如下：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217173226396.png\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"二使用步骤\">二、使用步骤</h1>\n<h2 id=\"1添加依赖\">1.添加依赖</h2>\n<p><font color=#999AAA >Maven依赖：</p>\n<pre><code class=\"language-xml\">	&lt;dependency&gt;  \n           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  \n           &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;  \n    &lt;/dependency&gt; \n</code></pre>\n<h2 id=\"2启用springboot对websocket的支持\">2.启用Springboot对WebSocket的支持</h2>\n<p><font color=#999AAA >启用WebSocket的支持也是很简单，几句代码搞定：</p>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.socket.server.standard.ServerEndpointExporter;\n/**\n * @ Auther: 马超伟\n * @ Date: 2020/06/16/14:35\n * @ Description: 开启WebSocket支持\n */\n@Configuration\npublic class WebSocketConfig {\n    @Bean\n    public ServerEndpointExporter serverEndpointExporter() {\n        return new ServerEndpointExporter();\n    }\n}\n</code></pre>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h2 id=\"3核心配置websocketserver\">3.核心配置：WebSocketServer</h2>\n<p><font color=#999AAA >因为WebSocket是类似客户端服务端的形式(采用ws协议)，那么这里的WebSocketServer其实就相当于一个ws协议的Controller</p>\n<ul>\n<li>@ ServerEndpoint 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端, 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端</li>\n<li>新建一个ConcurrentHashMap webSocketMap 用于接收当前userId的WebSocket，方便传递之间对userId进行推送消息。</li>\n</ul>\n<p>下面是具体业务代码：</p>\n<pre><code class=\"language-java\">package cc.mrbird.febs.external.webScoket;\n\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Service;\n\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.time.LocalDateTime;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n/**\n * Created with IntelliJ IDEA.\n * @ Auther: 马超伟\n * @ Date: 2020/06/16/14:35\n * @ Description:\n * @ ServerEndpoint 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端,\n * 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端\n */\n@Component\n@Slf4j\n@Service\n@ServerEndpoint(&quot;/api/websocket/{sid}&quot;)\npublic class WebSocketServer {\n    //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。\n    private static int onlineCount = 0;\n    //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。\n    private static CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketSet = new CopyOnWriteArraySet&lt;WebSocketServer&gt;();\n\n    //与某个客户端的连接会话，需要通过它来给客户端发送数据\n    private Session session;\n\n    //接收sid\n    private String sid = &quot;&quot;;\n\n    /**\n     * 连接建立成功调用的方法\n     */\n    @OnOpen\n    public void onOpen(Session session, @PathParam(&quot;sid&quot;) String sid) {\n        this.session = session;\n        webSocketSet.add(this);     //加入set中\n        this.sid = sid;\n        addOnlineCount();           //在线数加1\n        try {\n            sendMessage(&quot;conn_success&quot;);\n            log.info(&quot;有新窗口开始监听:&quot; + sid + &quot;,当前在线人数为:&quot; + getOnlineCount());\n        } catch (IOException e) {\n            log.error(&quot;websocket IO Exception&quot;);\n        }\n    }\n\n    /**\n     * 连接关闭调用的方法\n     */\n    @OnClose\n    public void onClose() {\n        webSocketSet.remove(this);  //从set中删除\n        subOnlineCount();           //在线数减1\n        //断开连接情况下，更新主板占用情况为释放\n        log.info(&quot;释放的sid为：&quot;+sid);\n        //这里写你 释放的时候，要处理的业务\n        log.info(&quot;有一连接关闭！当前在线人数为&quot; + getOnlineCount());\n\n    }\n\n    /**\n     * 收到客户端消息后调用的方法\n     * @ Param message 客户端发送过来的消息\n     */\n    @OnMessage\n    public void onMessage(String message, Session session) {\n        log.info(&quot;收到来自窗口&quot; + sid + &quot;的信息:&quot; + message);\n        //群发消息\n        for (WebSocketServer item : webSocketSet) {\n            try {\n                item.sendMessage(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    /**\n     * @ Param session\n     * @ Param error\n     */\n    @OnError\n    public void onError(Session session, Throwable error) {\n        log.error(&quot;发生错误&quot;);\n        error.printStackTrace();\n    }\n\n    /**\n     * 实现服务器主动推送\n     */\n    public void sendMessage(String message) throws IOException {\n        this.session.getBasicRemote().sendText(message);\n    }\n\n    /**\n     * 群发自定义消息\n     */\n    public static void sendInfo(String message, @PathParam(&quot;sid&quot;) String sid) throws IOException {\n        log.info(&quot;推送消息到窗口&quot; + sid + &quot;，推送内容:&quot; + message);\n\n        for (WebSocketServer item : webSocketSet) {\n            try {\n                //这里可以设定只推送给这个sid的，为null则全部推送\n                if (sid == null) {\n//                    item.sendMessage(message);\n                } else if (item.sid.equals(sid)) {\n                    item.sendMessage(message);\n                }\n            } catch (IOException e) {\n                continue;\n            }\n        }\n    }\n\n    public static synchronized int getOnlineCount() {\n        return onlineCount;\n    }\n\n    public static synchronized void addOnlineCount() {\n        WebSocketServer.onlineCount++;\n    }\n\n    public static synchronized void subOnlineCount() {\n        WebSocketServer.onlineCount--;\n    }\n\n    public static CopyOnWriteArraySet&lt;WebSocketServer&gt; getWebSocketSet() {\n        return webSocketSet;\n    }\n}\n</code></pre>\n<h2 id=\"4测试controller\">4.测试Controller</h2>\n<pre><code class=\"language-java\">\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Created with IntelliJ IDEA.\n *\n * @ Auther: 马超伟\n * @ Date: 2020/06/16/14:38\n * @ Description:\n */\n@Controller(&quot;web_Scoket_system&quot;)\n@RequestMapping(&quot;/api/socket&quot;)\npublic class SystemController {\n    //页面请求\n    @GetMapping(&quot;/index/{userId}&quot;)\n    public ModelAndView socket(@PathVariable String userId) {\n        ModelAndView mav = new ModelAndView(&quot;/socket1&quot;);\n        mav.addObject(&quot;userId&quot;, userId);\n        return mav;\n    }\n\n    //推送数据接口\n    @ResponseBody\n    @RequestMapping(&quot;/socket/push/{cid}&quot;)\n    public Map pushToWeb(@PathVariable String cid, String message) {\n        Map&lt;String,Object&gt; result = new HashMap&lt;&gt;();\n        try {\n            WebSocketServer.sendInfo(message, cid);\n            result.put(&quot;code&quot;, cid);\n            result.put(&quot;msg&quot;, message);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n}\n\n</code></pre>\n<h2 id=\"5测试页面indexhtml\">5.测试页面index.html</h2>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n	&lt;head&gt;\n		&lt;meta charset=&quot;utf-8&quot;&gt;\n		&lt;title&gt;Java后端WebSocket的Tomcat实现&lt;/title&gt;\n		&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;\n	&lt;/head&gt;\n\n	&lt;body&gt;\n		&lt;div id=&quot;main&quot; style=&quot;width: 1200px;height:800px;&quot;&gt;&lt;/div&gt;\n		Welcome&lt;br/&gt;&lt;input id=&quot;text&quot; type=&quot;text&quot; /&gt;\n		&lt;button onclick=&quot;send()&quot;&gt;发送消息&lt;/button&gt;\n		&lt;hr/&gt;\n		&lt;button onclick=&quot;closeWebSocket()&quot;&gt;关闭WebSocket连接&lt;/button&gt;\n		&lt;hr/&gt;\n		&lt;div id=&quot;message&quot;&gt;&lt;/div&gt;\n	&lt;/body&gt;\n	&lt;script type=&quot;text/javascript&quot;&gt;\n		var websocket = null;\n		//判断当前浏览器是否支持WebSocket\n		if(\'WebSocket\' in window) {\n			//改成你的地址\n			websocket = new WebSocket(&quot;ws://192.168.100.196:8082/api/websocket/100&quot;);\n		} else {\n			alert(\'当前浏览器 Not support websocket\')\n		}\n\n		//连接发生错误的回调方法\n		websocket.onerror = function() {\n			setMessageInnerHTML(&quot;WebSocket连接发生错误&quot;);\n		};\n\n		//连接成功建立的回调方法\n		websocket.onopen = function() {\n			setMessageInnerHTML(&quot;WebSocket连接成功&quot;);\n		}\n		var U01data, Uidata, Usdata\n		//接收到消息的回调方法\n		websocket.onmessage = function(event) {\n			console.log(event);\n			setMessageInnerHTML(event);\n			setechart()\n		}\n\n		//连接关闭的回调方法\n		websocket.onclose = function() {\n			setMessageInnerHTML(&quot;WebSocket连接关闭&quot;);\n		}\n\n		//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。\n		window.onbeforeunload = function() {\n			closeWebSocket();\n		}\n\n		//将消息显示在网页上\n		function setMessageInnerHTML(innerHTML) {\n			document.getElementById(\'message\').innerHTML += innerHTML + \'&lt;br/&gt;\';\n		}\n\n		//关闭WebSocket连接\n		function closeWebSocket() {\n			websocket.close();\n		}\n\n		//发送消息\n		function send() {\n			var message = document.getElementById(\'text\').value;\n			websocket.send(\'{&quot;msg&quot;:&quot;\' + message + \'&quot;}\');\n			setMessageInnerHTML(message + &quot;&amp;#13;&quot;);\n		}\n	&lt;/script&gt;\n\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"6结果展示\">6.结果展示</h2>\n<p>后台：<br />\n如果有连接请求<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217181325920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>前台显示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217181300879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"总结\">总结</h1>\n<p><font color=#999AAA >这中间我遇到一个问题，就是说WebSocket启动的时候优先于spring容器，从而导致在WebSocketServer中调用业务Service会报空指针异常</p>\n<p>所以需要在WebSocketServer中将所需要用到的service给静态初始化一下：<br />\n如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217181723382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n还需要做如下配置：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217181921591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-12-18 11:40:54', '2022-05-21 18:06:14');
INSERT INTO `tb_article` VALUES (99, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8910', '留言', '<h3 id=\"留言板说明\">留言板说明</h3>\n<p>有什么话要对我说吗？这里是你畅所欲言的地方，可以咨询，可以交流，可以感叹，可以发飙，但不可以订外卖。</p>\n<p><img src=\"http://file.henaumcw.top/blog/image_1608350101016.png\" alt=\"image.png\" /></p>\n', 1, '', 0, 0, 1, '2020-12-19 10:30:42', '2020-12-19 11:55:06');
INSERT INTO `tb_article` VALUES (100, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4312', '新浪随机图片壁纸API接口 刷新网页换背景接口', '<p>新浪随机图片壁纸API接口 刷新网页换背景接口<br />\n在这里插入图片描述</p>\n<p>刷新一次页面换一次图片，可以调用到你的网站背景里面去，多炫酷啊，刷新一下本页看下效果哦。</p>\n<p>说明：随机图片壁纸api，调用的是新浪api，速度不用担心，图片资源也很多</p>\n<p>电脑动漫图片：<a href=\"http://api.btstu.cn/sjbz/?lx=dongman\">http://api.btstu.cn/sjbz/?lx=dongman</a></p>\n<p>电脑美女图片：<a href=\"http://api.btstu.cn/sjbz/?lx=meizi\">http://api.btstu.cn/sjbz/?lx=meizi</a></p>\n<p>电脑随机动漫妹子：<a href=\"http://api.btstu.cn/sjbz/?lx=suiji\">http://api.btstu.cn/sjbz/?lx=suiji</a></p>\n<p>手机动漫图片：<a href=\"http://api.btstu.cn/sjbz/?lx=m_dongman\">http://api.btstu.cn/sjbz/?lx=m_dongman</a></p>\n<p>手机美女图片：<a href=\"http://api.btstu.cn/sjbz/?lx=m_meizi\">http://api.btstu.cn/sjbz/?lx=m_meizi</a></p>\n<p>手机随机动漫妹子：<a href=\"http://api.btstu.cn/sjbz/?m_lx=suiji\">http://api.btstu.cn/sjbz/?m_lx=suiji</a></p>\n<p>手机电脑自动判断，电脑显示适合电脑的壁纸，手机显示适合手机的壁纸 <a href=\"http://api.btstu.cn/sjbz/zsy.php\">http://api.btstu.cn/sjbz/zsy.php</a></p>\n', 1, '', 0, 0, 1, '2020-12-19 16:31:05', '2021-08-30 09:53:11');
INSERT INTO `tb_article` VALUES (101, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8636', '超详细的 Vagrant 上手指南，搭建Linux虚拟机别再用VMware Workstation了！', '<p>﻿<br />\n@<a href=\"文章目录\">TOC</a></p>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h1 id=\"前言\">前言</h1>\n<p><font color=#999AAA >也许你已经习惯了 docker，习惯了在 XX 云上快速创建云主机，但是如果你想在个人电脑上安装虚拟机来搭建开发/测试环境，Vagrant 仍然不失高效之选。</font></p>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<p><font color=#999AAA >下面说下搭建的主要步骤：</p>\n<h1 id=\"一安装virtualbox\">一、安装VirtualBox</h1>\n<p><font color=#999AAA >VirtualBox 是一个跨平台的虚拟化工具，支持多个操作系统，根据自己的情况选择对应的版本下载即可。</p>\n<p>进入 VirtualBox 的主页<a href=\"https://www.virtualbox.org/\">https://www.virtualbox.org/</a>，点下载按钮，即可进入下载页面。</p>\n<p>进行安装需要<strong>cpu开启虚拟化</strong>，在开机启动的时候设置主板，CPU configuration，然后点击Intel Vitualization Technology。重启电脑</p>\n<h1 id=\"二vagrant\">二、Vagrant</h1>\n<h2 id=\"1安装vagrant\">1.安装Vagrant</h2>\n<p>在 Vagant 网站<a href=\"https://www.vagrantup.com/\">https://www.vagrantup.com/</a>下载最新的版本，根据自己的操作系统选择对应的版本下载即可。</p>\n<p>注意，Vagrant 是没有图形界面的，所以安装完成后也没有桌面快捷方式。具体使用方法，接下来会详细说明。</p>\n<p><font color=#99AA >Vagrant 的安装程序会自动把安装路径加入到 PATH 环境变量，所以，这时候可以通过命令行执行 <strong>vagrant version</strong> 检查是否安装成功：</p>\n<pre><code class=\"language-c\">C:\\Users\\ma&gt;vagrant version\n==&gt; vagrant: A new version of Vagrant is available: 2.2.14 (installed version: 2.2.5)!\n==&gt; vagrant: To upgrade visit: https://www.vagrantup.com/downloads.html\n\nInstalled Version: 2.2.5\nLatest Version: 2.2.14\n</code></pre>\n<h2 id=\"配置虚机存放位置\">配置虚机存放位置</h2>\n<p>创建虚拟机会占用较多的磁盘空间，在 Windows 系统下默认的虚机创建位置是在 C 盘，所以最好配置到其它地方。</p>\n<h2 id=\"2配置-virtualbox\">2.配置 VirtualBox</h2>\n<p>启动 VirtualBox 后，通过菜单 <code>管理 -&gt; 全局设定</code>，或者按下快捷键 <code>Ctrl + g</code>，在全局设定对话框中，修改 <code>默认虚拟电脑位置</code>，指定一个容量较大的磁盘。<br />\n<img src=\"https://img-blog.csdnimg.cn/20210308113209588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"3配置-vagrant\">3.配置 Vagrant</h2>\n<p>通过 Vagrant 创建虚机需要先导入镜像文件，也就是 box，它们默认存储的位置在用户目录下的 <code>.vagrant.d</code> 目录下，对于 Windows 系统来说，就是 <code>C:\\Users\\用户名\\.vagrant.d</code>。</p>\n<p>如果后续可能会用到较多镜像，或者你的 C 盘空间比较紧缺，可以通过设置环境变量 <code>VAGRANT_HOME</code> 来设置该目录。</p>\n<p>在 Windows 系统中，可以这样操作：新建系统环境变量，环境变量名为 <code>VAGRANT_HOME</code>，变量值为 <code>你的其他盘的路径</code>。</p>\n<h2 id=\"4下载虚机镜像\">4.下载虚机镜像</h2>\n<p>使用 Vagrant 创建虚机时，需要指定一个镜像，也就是 box。开始这个 box 不存在，所以 Vagrant 会先从网上下载，然后缓存在本地目录中。</p>\n<p>Vagrant 有一个镜像网站<a href=\"https://app.vagrantup.com/boxes/search\">https://app.vagrantup.com/boxes/search</a>，里面列出了都有哪些镜像可以用，并且提供了操作文档。<br />\n<img src=\"https://img-blog.csdnimg.cn/20210308115510105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n输入<code>vagrant init centos/7</code>（<strong>仓库镜像名</strong>），即可初始化一个centos7系统。（注意这个命令在哪个目录下执行的，他的Vagrantfile就生成在哪里）这个命令是一键下载并初始化。<strong>后面会详细介绍</strong></p>\n<blockquote>\n<p>但是这里默认下载往往会比较慢，所以下面我会介绍如何在其它地方下载到基础镜像，然后按照自己的需要重置。如果网速较好，下载顺利的朋友可以选择性地跳过部分内容。</p>\n<p>下面我给出最常用的两个 Linux 操作系统镜像的下载地址：</p>\n<p><strong>CentOS</strong></p>\n<p>CentOS 的镜像下载网站是： <a href=\"http://cloud.centos.org/centos/\">http://cloud.centos.org/centos/</a></p>\n<p><strong>Ubuntu</strong></p>\n<p>Ubuntu 的镜像下载网站是： <a href=\"http://cloud-images.ubuntu.com\">http://cloud-images.ubuntu.com</a></p>\n</blockquote>\n<p>在其中选择自己想要下载的版本，列表中有一个 vagrant 目录，里面是专门为 vagrant 构建的镜像。选择其中的 .box 后缀的文件下载即可。这里可以使用下载工具，以较快的速度下载下来。</p>\n<h2 id=\"5添加-box\">5.添加 box</h2>\n<p><font color=#999AAA >以 CentOS 7 为例，使用其它版本操作系统的也可以参考。</p>\n<p>接下来我们需要将下载后的 <code>.box</code> 文件添加到 vagrant 中。</p>\n<p>Vagrant 没有 GUI，只能从命令行访问，先启动一个命令行，然后执行:</p>\n<pre><code class=\"language-java\">$ vagrant box list\nThere are no installed boxes! Use `vagrant box add` to add some.\n</code></pre>\n<p>提示现在还没有 box。如果这是第一次运行，此时 <code>VAGRANT_HOME</code> 目录下会自动生成若干的文件和文件夹，其中有一个 boxes 文件夹，这就是要存放 box 文件的地方。</p>\n<p>执行 <code>vagrant box add</code> 命令添加 box:</p>\n<pre><code class=\"language-java\">$ vagrant box add e:\\Downloads\\CentOS-7.box --name centos-7\n==&gt; box: Box file was not detected as metadata. Adding it directly...\n==&gt; box: Adding box \'centos-7\' (v0) for provider:\n    box: Unpacking necessary files from: file:///e:/Downloads/CentOS-7.box\n    box:\n==&gt; box: Successfully added box \'centos-7\' (v0) for \'virtualbox\'!\n</code></pre>\n<p>命令后面跟着的是下载的文件路径，并且通过 --name centos-7 为这个 box 指定一个名字。</p>\n<p>后面创建虚机都需要指定这个名字，所以尽量把名字取得简短一点，同时也要能标识出这个镜像的信息（我们后面会定制自己的基础镜像，所以这里可以简单点）。</p>\n<p>再次查询，可以看到有了一个 box：</p>\n<pre><code class=\"language-java\">$ vagrant box list\ncentos-7 (virtualbox, 0)\n</code></pre>\n<h2 id=\"6vagrant-基本操作\">6.Vagrant 基本操作</h2>\n<h3 id=\"61-新建虚机\">6.1 新建虚机</h3>\n<p>创建一个目录，先执行 <code>vagrant init</code>：</p>\n<pre><code class=\"language-java\">$ mkdir demo\n$ cd demo\n$ vagrant init centos-7\nA `Vagrantfile` has been placed in this directory. You are now\nready to `vagrant up` your first virtual environment! Please read\nthe comments in the Vagrantfile as well as documentation on\n`vagrantup.com` for more information on using Vagrant.\n</code></pre>\n<p>其中的 <code>centos-7</code> 就是我们要使用的 <code>box</code> 名字。</p>\n<p>这个命令只是为我们生成一个 <code>Vagrantfile</code>，所以，这里的名字没指定或者写错了都没关系，后面会介绍如何编辑这个 <code>Vagrantfile</code> 来修改。</p>\n<h3 id=\"62-启动虚机\">6.2 启动虚机</h3>\n<p>我们等会再来细看这个文件，现在直接按照提示执行 <code>vagrant up</code>：</p>\n<pre><code class=\"language-java\">$ vagrant up\nBringing machine \'default\' up with \'virtualbox\' provider...\n==&gt; default: Importing base box \'centos-7\'...\n==&gt; default: Matching MAC address for NAT networking...\n==&gt; default: Setting the name of the VM: demo_default_1588406874156_65036\n==&gt; default: Clearing any previously set network interfaces...\n==&gt; default: Preparing network interfaces based on configuration...\n    default: Adapter 1: nat\n==&gt; default: Forwarding ports...\n    default: 22 (guest) =&gt; 2222 (host) (adapter 1)\n==&gt; default: Booting VM...\n==&gt; default: Waiting for machine to boot. This may take a few minutes...\n    default: SSH address: 127.0.0.1:2222\n    default: SSH username: vagrant\n    default: SSH auth method: private key\n</code></pre>\n<p>正常的情况下，不到一分钟应该就能启动成功了。</p>\n<h3 id=\"63-查看虚机状态\">6.3 查看虚机状态</h3>\n<p>执行下面的命令可以查看虚机的状态：</p>\n<pre><code class=\"language-java\">vagrant status\n\nCurrent machine states:\n\ndefault                   running (virtualbox)\n\nThe VM is running. To stop this VM, you can run `vagrant halt` to\nshut it down forcefully, or you can run `vagrant suspend` to simply\nsuspend the virtual machine. In either case, to restart it again,\nsimply run `vagrant up`.\n</code></pre>\n<p>该命令还提示了如何操作虚机，我们继续一一介绍</p>\n<h3 id=\"64-连接虚机\">6.4 连接虚机</h3>\n<p>如果启动没问题，接下来执行 <code>vagrant ssh</code> 就能以 <code>vagrant</code> 用户直接登入虚机中。</p>\n<p>root 用户没有默认密码，也不能直接登录。需要 root 权限的命令可以通过在命令前添加 <code>sudo</code> 来执行，也可以执行 <code>sudo -i</code> 直接切换到 root 用户。</p>\n<p>这时候打开 <code>VirtualBox</code> 程序，可以看到自动创建的虚机：<br />\n<img src=\"https://img-blog.csdnimg.cn/20210308120126381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>我们也可以在 VirtualBox 的终端上登录系统，默认的登录用户名和密码<strong>都是</strong> <code>vagrant</code>。</p>\n<p>当然还可以使用其它的 SSH 连接工具例如 XShell，SecureCRT 连接，但是这里默认网卡使用的是 NAT 模式，没有指定 IP，实际应用并不方便，我们在后面介绍网络配置时再详细介绍如何连接虚机。</p>\n<p><strong>停止虚机</strong><br />\n执行下面的命令可以关闭虚机：</p>\n<pre><code class=\"language-java\">vagrant halt\n</code></pre>\n<p>直接在 VirtualBox 上关闭虚机，或者直接在虚机内部执行 poweroff 命令也都是可以的。</p>\n<p><strong>暂停虚机</strong><br />\n执行下面的命令可以暂停虚机：</p>\n<pre><code class=\"language-java\">vagrant suspend\n</code></pre>\n<p><strong>恢复虚机</strong><br />\n执行下面的命令把暂停状态的虚机恢复运行：</p>\n<pre><code class=\"language-java\">vagrant resume\n</code></pre>\n<p>注意： 不管虚机是关闭还是暂停状态，甚至是 error 状态，都可以执行 vagrant up 来让虚机恢复运行。</p>\n<p><strong>重载虚机</strong><br />\n执行下面的命令会重启虚机，并且重新加载 Vagrantfile 中的配置信息：</p>\n<pre><code class=\"language-java\">vagrant reload\n</code></pre>\n<p><strong>删除虚机</strong><br />\n最后，执行下面的命令可以彻底删除虚机，包括整个虚机文件：</p>\n<pre><code class=\"language-java\">vagrant destroy\n</code></pre>\n<p>注意： 在当前这个小例子中，上面所有的 vagrant 命令都需要在 Vagrantfile 所在的目录下执行。</p>\n<h2 id=\"7自定义配置-vagrantfile\">7.自定义配置 Vagrantfile</h2>\n<p>端口转发（Port forward）又叫端口映射，就是把虚机的某个端口，映射到宿主机的端口上。这样就能在宿主机上访问到虚拟机中的服务。</p>\n<p>例如启动虚机时，默认的 <code>22 (guest) =&gt; 2222 (host) (adapter 1)</code> 就是把虚机的 SSH 服务端口（22）映射到宿主机的 2222 端口，这样直接在宿主机通过 ssh 客户端访问 <code>127.0.0.1:2222</code> 端口就等价于访问虚拟机的 22 端口。</p>\n<p>默认的网络连接方式是网络地址转换NAT（端口转发），如果其他主机要访问虚拟机，必须由windows端口如3333断发给虚拟机端口如3306。这样每在linux里安一个软件都要进行端口映射，不方便，（也可以在virualBox里挨个设置）。我们想要给虚拟机一个固定的ip地址，windows和虚拟机可以互相ping通。</p>\n<p><strong>方式1是在虚拟机中配置静态ip。</strong></p>\n<p>也可以更改<code>Vagrantfile</code>更改虚拟机ip，修改其中的<code>config.vm.network``&quot;private_network&quot;,ip:&quot;192.168.56.10&quot;，</code>这个ip需要在windows的<code>ipconfig</code>中查到<code>vitualbox</code>的虚拟网卡ip，然后更改下最后一个数字就行（不能是1，1是我们的主机）。配置完后<code>vagrant reload</code>重启虚拟机。在虚拟机中<code>ip addr</code>就可以查看到地址了。互相ping也能ping通。</p>\n<p>关掉防火墙，<code>VirualBox</code>中第一个网卡设置<code>NAT</code>，第二个网卡设置仅主机</p>\n<p>如果ping不了baidu</p>\n<ul>\n<li><code>cd /etc/sysconfig/network-scripts</code></li>\n<li>ls 一般有<code>ifcfg-eth0 1</code></li>\n<li><code>ip addr</code> 看哪个网格是<code>192.168.56</code>网段，然后vim他</li>\n<li><code>vim ifcfg-eth1</code> 加入</li>\n</ul>\n<pre><code>GATEWAY=192.168.56.1\nDNS1=114.114.114.114\nDNS2=8.8.8.8\n</code></pre>\n<ul>\n<li><code>service network restart</code></li>\n</ul>\n<p>默认只允许ssh登录方式，为了后来操作方便，文件上传等，我们可以配置允许账号密码登录</p>\n<pre><code class=\"language-java\">vim /etc/ssh/sshd_config\n修改\nPasswordAuthentication yes\n重启\nservice sshd restart\n账号root\n密码vagrant\n</code></pre>\n<p>配置源</p>\n<pre><code class=\"language-java\"># 备份原yum源\n\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n# 使用新yum源\ncurl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.163.com/.help/CentOS7-Base-163.repo\n# 生成缓存\nyum makecache\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p>费了莫大的力气，终于可以比较愉快地玩耍了。虽然也只是刚把基础镜像搞定了，后面可能还要针对不同用途的环境编写更加复杂的 Vagrantfile。</p>\n<p>现在很多人刚认识到 Vagrant 之后都会问，<strong>Vagrant 和 Docker 的区别是什么？</strong></p>\n<p>在容器流行之前，Vagrant 就是用来编排虚机和自动部署开发环境的，有了 Docker/Kubernetes 之后，直接用容器来编排应用确实更香。但是还有一些工作，例如容器平台自身的安装，多节点集群的部署测试等，更方便用虚机解决。</p>\n<p>此外，现在 Windows 中还可以通过 WSL 使用 Linux 系统，但是使用场景上还是有所不同。Vagrant 更多地用于快速搭建可重用的开发环境，从这个角度看，Vagrant 其实好比 IaaS 云平台，只不过规模局限在个人电脑上。</p>\n', 1, '', 0, 0, 1, '2021-03-10 18:17:11', '2022-05-21 18:06:00');
INSERT INTO `tb_article` VALUES (102, 1, 7, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=6148', '918农业信息化考研资料', '<h2 id=\"%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A\" tabindex=\"-1\">名词解释</h2>\n<p><strong>信息：</strong> 事物之间相互联系、相互作用的状态的描述。</p>\n<p><strong>信息技术：</strong> 是指计算机硬件技术、计算机软件和通信技术的总称。</p>\n<p><strong>信息系统：</strong> 是由计算机硬件、网络和通讯设备、计算机软件、信息资源、信息用户和规章制度组成的以处理信息流为目的的人机一体化系统。</p>\n<p><strong>农业信息：</strong> 是指人们利用农业生产资源进行农产品生产、加工和营销等活动的一切消息、情报、数据等的总称。</p>\n<p><strong>农业信息技术：</strong> 包括农业信息的获取技术（如遥感技术）、处理技术（如数据的并行处理技术）、模拟技术（如作物生长模拟）、自动识别技术、人工智能技术等等。</p>\n<p><strong>农业信息系统：</strong> 一般由农业生物信息、农业环境信息、农业技术知识信息和农业经济信息等四个信息子系统构成。</p>\n<p><strong>农业信息学：</strong> 农业科学与信息科学相互交叉融合形成的一门学科。可以定义为：以农业科学为基本理论基础，以农业信息为对象，以信息技术支撑，研究农业信息的采集、处理、分析、存储、传输及其运动变化规律，为农业生产服务的科学和技术。</p>\n<p><strong>信息再生：</strong> 指运用信息技术和科学方法对本原信息进行加工处理而产生出新的信息的工作过程。</p>\n<p><strong>数据库：</strong> 存放数据的仓库（顾名思义/不准确的含义）尽管数据库技术已发展成熟，但还没有一个普遍接受的、严格的定义。</p>\n<p><strong>数据库系统：</strong> 基于数据库的计算机应用系统。</p>\n<p><strong>数据模型：</strong> 是数据特征的抽象，在数据库系统中，数据模型是它的核心与基础。数据模型描述数据的结构，定义在其上的操作以及约束条件。它从概念层面上描述了系统的静态特征、动态特征和约束条件，为数据库系统的信息表示与操作提供一个抽象框架。</p>\n<p><strong>关系模型：</strong> 用关系表示（不需用指针）实体和实体之间联系的模型称为关系模型。<br />\n<strong>农业专家系统：</strong> 也叫农业智能系统，是一个拥有大量权威农业专家的知识、经验、资料、数据与成果构成的知识库，并能利用其中的知识模拟农业专家解决问题的思维方法尽心判断、推理，求得解决农业生产问题答案的智能程序系统。</p>\n<p><strong>农业模拟模型：</strong> 利用系统分析方法和计算机模拟技术，对农业系统中的生物与非生物过程及其与环境和农业技术措施之间的动态关系进行定量描述和预测。</p>\n<p><strong>系统分析法：</strong> 是把将要研究的目标当做一个统一的整体，并把这个整体分解为若干个子系统，揭示影响子系统的各项因素及相互关系，并进行数量化描述，以此为基础，对获取的信息进行综合整理、分析、判断和加工，选择出最优的因素组合，优化系统或设计新系统。</p>\n<p><strong>精确农业：</strong> 是由信息技术支持的、根据空间变异定位、定时、定量的实施一整套现代化农事</p>\n<p><strong>农业物流：</strong> 是指以农业生产为核心而发生的一系列物品从供应地向接受地的实体流动和与之有关的技术、组织、管理活动。</p>\n<p><strong>电子商务：</strong> 广义上讲，电子商务是电子工具再商务活动中的应用。<br />\n狭义上讲：电子商务是在技术、经济高度发达的现代社会里掌握信息技术和商务规则的人、系统化应用电子工具高效率、低成本地从事以商品交换为中心的葛洪活动的总称。</p>\n<p><strong>物联网：</strong> 物联网被视为互联网的应用扩展，应用创新是物联网的发展的核心，以用户体验为核心的创新是物联网发展的灵魂。</p>\n<p><strong>农业信息化：</strong> 其内涵应包括农业资源环境信息化、农业生产管理信息化、农业市场流通信息化、农业科技与教育信息化、农业产业经营信息化。</p>\n<h2 id=\"%E7%AE%80%E7%AD%94\" tabindex=\"-1\">简答</h2>\n<p><strong>1、	信息有哪些主要性质特征</strong><br />\n真实性、时效性、不完全性、等级性、层次性、对性习惯、价值性、共享性、寄载性</p>\n<p><strong>2、	什么是信息量？如何度量信息量？</strong><br />\n信息量是指从N个相等可能事件中选出一个事件所需要的信息度量或含量，也就是在辨识N个事件中特定的一个事件的过程中所需要提问&quot;是或否&quot;的最少次数.<br />\n信息的度量是利用概率来度量信息。</p>\n<p><strong>3、	农业信息有哪些主要特征？</strong><br />\n1,农业生物的自身特性：农业生产的种子、种苗、种禽等原材料．都是由农业自身提供的．这些农业生物有机体有其自身的生长、发育特性和自然再生产的规律．从事农业生产经营活动，必须掌握农业生物信息，符合农业生物自然再生产的规律．<br />\n2,农业依赖环境的特性：农业生物依赖农业环境而生长、发育、繁衍后代．光、热、水、气、风、霜、雨、雪、土壤质地以及地形地貌等环境信息，对农业生产经营起着促进或制约作用．<br />\n3,农业生产的季节性：春种、夏管、秋收、冬藏，农业生产具有强烈的季节性．按农时组织农业生产经营，要求掌握农时信息，提供农时信息．<br />\n4,农业生产的地域性：农人们按照农业生物适地适生的信息．做到因地制宜的组织农业生产经营活动．<br />\n5,农业生产的周期性：农业生物有其自身的生命周期．农业生产是遵循生物体生命周期规律的有目的的生产活动．为此，人类应掌捏农业生物的生命信息，生命周期的连续信息，以获取农业经济效益和生态效益。<br />\n6,农业生产的系统性：农业生产是生物、环境、经济、技术和人类共同参与活动的系统工程，各方面的信息同时存在，相互渗透，共同作用，推动或制约整个系统的运行.<br />\n7,农业生产的分散性：我国农付地域宽广，由几亿农民从事农业，产生信息的信源分散；将信息传输至信宿．也同样分散．要在广大农村建立信息网络，收集和传输信息，其难度较大．</p>\n<p><strong>4、	农业信息收集有哪些主要途径？</strong><br />\n主要有两类途径：<br />\n（1）	关系途径：沿着各种与信源相关的事物进行收集，如人际关系。<br />\n（2）	技术途径：利用各种技术直接或间接收集信息，如网络技术等。</p>\n<p><strong>5、	农业信息收集有哪些主要方法？</strong><br />\n收集信息的方法主要可分为人工收集法和技术收集方法，</p>\n<ol>\n<li>人工收集法：信息收集者人工地进行收集，如实验、考察、手工查阅文献等。</li>\n<li>技术收集法：通过各种技术手段自动收集，包括计算机技术、微电子技术（传感器）、感、卫星技术等等。</li>\n</ol>\n<p><strong>6、	简述农信息整理加工的基本要求和基本内容。</strong><br />\n基本要求：应符合真实、标准、及时、合适、有效等要求。<br />\n基本内容：<br />\n（1）原始信息的汇集、筛选、分析、鉴别<br />\n（2）信息变换、载体结合、信道选配<br />\n（3）信息分类、排序、编码、录制、储存<br />\n（4）信息再生、转化、进入终端显示、利用等</p>\n<p><strong>7、	简述数据额模型的三要素。</strong><br />\n（1）数据结构——描述数据额的静态特征，包括对数据结构和数据间联系的描述、<br />\n通常按照数据结构的类型来命名数据模型：<br />\n层次结构——层次模型    网状结构——网状模型    关系结构——关系模型<br />\n（2）数据操作——描述数据的动态特征和，一组定义在数据上的操作（包括操作的含义、操作符、运算规则及其语言等），主要操作：检索和更新（插入、删除、修改）<br />\n（3）数据的约束条件——完整性规则的集合，数据库中的数据必须满足这组规则。约束条件的主要目的是使数据库与它所描述的现实系统相符合。</p>\n<p><strong>8、	简述E-R数据模型。</strong><br />\nE-R模型是一种重要的数据模型，它结构简单，语义表现力丰富，描述力强，同时又能方便的转换为其他经常使用的网状、层次或关系模型，所以，再数据库设计中得到广泛应用。</p>\n<p><strong>9、	简述数据库系统的开发流程。</strong><br />\n目前信息系统开发经常采用周期法，该方法将整个信息系统的开发过程分为若干阶段，预先规定每个阶段的目标和任务，按一定准则顺次完成。AMIS的开发可采用生命周期法，其开发过程分为下图所示的六个阶段，即可行性研究、系统分析、系统总体方案设计、系统技术方案分析、系统实施、系统评价与维护。同时，再每个阶段都进行及时讨论和信息反馈。</p>\n<p><strong>10、简述农业专家系统的开发流程。</strong><br />\n包括知识获取，即从农业领域专家收集整理归纳有关的专业知识和经验、数据，并经农业专家系统开发人员消化、整理、归纳写成一条符号表示的形式；确定知识表示和推理方法；建立知识库；编写推理程序，然后调试、运行和修改等步骤。</p>\n<p><strong>11、写出SAS统计分析软件进行多重比较的程序。</strong><br />\nDATA A;<br />\nDO I=1 TO 5;<br />\nDO J=1 TO 10;<br />\nINPUT X @@;<br />\nOUTPUT;<br />\nEND;<br />\nEND;<br />\nDROP J;<br />\nCARDS;<br />\n…<br />\nPROC ANOVA;<br />\nCLASS I;<br />\nMODEL X=I;<br />\nMEANS VLSD;<br />\nRUN.</p>\n<p><strong>12、简述3S技术及其基本原理。</strong></p>\n<p><strong>3S技术是指</strong>遥感技术、地理信息技术、和全球定位系统。是空间技术、传感器技术、卫星定位与导航技术和计算机技术、通讯技术相结合，多学科高度集成的对空间信息进行采集、处理、管理、分析、表达、传播和应用的现在信息技术。</p>\n<p><strong>遥感技术原理：</strong> 直接接触目标物，在距地物几公里到几百公里、甚至上千公里的飞机、飞船、卫星上，使用光学或者电子光学仪器接受地面物体反射或者辐射的电磁波信号，并以图像胶片或数据磁带形式记录下来，形成数字影像。该影像传输到地面，经过各种校正后，进行影像分类、翻译，最后获取所需要的信息。</p>\n<p><strong>地理信息技术原理：</strong> 是在计算机硬件、软件及网络等支持下，对有关空间数据进行获取、存贮、查询检索、处理、分析、显示、更新和提供应用的技术系统。</p>\n<p><strong>全球定位系统原理：</strong> 共24颗卫星，其中3颗备用，分布在6个轨道面上。轨道面对地球赤道面的倾角为55°，各轨道平面升交点赤经相差60°，相邻轨道上卫星的升交距相差30°，轨道平均高度约20200km，均为近圆形轨道，运行周期11h58m。</p>\n<p><strong>13、地物空间数据矢量化的方法有哪些？</strong><br />\n矢量结构是通过记录坐标的方式来表达点线面等地理实体。获取方法：（1）手工数字化法；（2）手扶跟踪数字化法；（3）数据结构转换法。<br />\n（栅格数据结构：栅格结构是以规则的阵列来表示空间地物或现象分布的数据组织，组织中的符复合数据表示地理要素的非几合属性特征。获取方法：1手工网格法2扫描数字化法3分类影像输入法47数据结构转换法。）</p>\n<p><strong>14、简述农业模拟模型的研制步骤。</strong><br />\n（1）	模型选择与系统定义。弄清研究目的、研究水平和研究对象。<br />\n（2）	资料来源。①自己积累或文献资料②从同行专家处获取③补充试验或支持研究<br />\n（3）	模块设计与模型设计。编程语言的选择、算法编程、界面编程、输入输出内容和形式。<br />\n（4）	模型检验与改进。①敏感性分析  分析模型对主要参数和变量反应的灵敏度②校正  调整模型的参数和关系，使得模型符合特定的环境和资料参数③核实  将模拟结果与实际结果进行相关回归分析；将实际结果与模拟结果按同一时间坐标绘1:1图进行比较；检查模拟结果与实际结果的平均误差。</p>\n<p><strong>15、简述农业信息服务的基本原理和基本内容。</strong><br />\n基本内容：1.农业资源信息服务2.农业教育服务3.农业咨询服务4.农业物流服务</p>\n<p><strong>16、实现精确农业的关键技术有哪些？</strong><br />\n精确农业的支持技术除地理信息系统（GIS）、遥感技术（RS）、全球定位系统（GPS）外，还包括决策支持系统（DSS）和变量投入技术（VRT），以上几个关键技术互相补充，共同构建精确农业的技术体系。</p>\n<h1 id=\"%E7%BB%BC%E5%90%88%E9%A2%98\" tabindex=\"-1\">综合题</h1>\n<p><strong>1、	结合专业，谈谈学习农业信息学的意义（不能少于300字）<br />\n2、	结合专业，谈谈在我国如何实现农业的信息化。</strong></p>\n', 1, '', 0, 0, 1, '2021-08-30 10:24:09', '2022-05-21 17:44:21');
INSERT INTO `tb_article` VALUES (103, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1342', '《计算机网络》复习要点', '<p>《计算机网络》复习要点<br />\n一、概述（远看、近看互联网）<br />\n计算机网络的定义、功能<br />\n组成、分类、拓扑结构<br />\n互联网（因特网）的多级结构、接入方式<br />\n二、物理层<br />\n模拟数据与数字数据、模拟信号与数字信号、模拟信道与数字信道<br />\n不归零码、归零码、曼彻斯特编码、差分曼彻斯特编码<br />\n数据传输率、带宽、信道容量、误码率、时延<br />\n多路复用技术：频分、时分、波分<br />\n交换技术：电路、分组（原理、区别）<br />\n介质：双绞线、同轴电缆、光纤<br />\n三、网络体系结构<br />\n分层原理（为何分层、层间关系、数据在层间传递、封转的过程）<br />\n网络协议的概念、组成元素<br />\nOSI体系结构（每层功能）<br />\nTCP/IP体系结构（每层功能、每层主要协议）<br />\nOSI与 TCP/IP体系结构的比较、综合的五层体系结构<br />\n四、数据链路层（以太网）<br />\n以太网特点、拓扑结构、要解决的问题<br />\nIEEE802标准<br />\nMAC层功能、MAC地址、MAC帧格式<br />\nCSMA/CD工作原理<br />\n交换机（网桥）的工作原理、特点、转发表的建立方法<br />\n交换机与集线器的区别<br />\nVLAN的概念、特点、好处、划分方法<br />\n局域网的搭建、VLAN的划分（实践环节）<br />\n五、网络层（网络互联）<br />\n网络互联的思路、工作原理<br />\n路由器的作用、工作原理<br />\n路由表的基本内容和查表方法<br />\nIP分组的格式、router处理IP分组基本过程<br />\nIP地址（分类地址、子网划分地址）<br />\n单播地址、广播地址、组播地址、特殊IP地址<br />\n子网掩码的作用、使用方法<br />\nIP地址与硬件地址的区别与关系<br />\nARP的功能、原理、有效范围<br />\nICMP功能、特点<br />\nPing、tracert的原理<br />\nRIP的功能、工作原理、优缺点<br />\nOSPF、BGP的功能、特点<br />\n组建互联网、配置地址、路由的基本方法（实践环节）<br />\n六、端到端传输<br />\n传输层的作用、服务类型（可靠传输、不可靠传输）<br />\n端口、端口号的作用、特点、知名端口<br />\nTCP的服务特点、报文格式<br />\nTCP可靠传输的措施（滑动窗口、流量控制、慢开始、拥塞避免算法等）<br />\nUDP的特点、报文格式、应用场景<br />\n七、网络应用<br />\n客户/服务器工作模式的特点<br />\nDNS（域名结构、域名服务器的层次结构、解析过程）</p>\n', 1, '', 0, 0, 1, '2021-08-30 10:42:30', '2021-08-30 10:42:30');
INSERT INTO `tb_article` VALUES (104, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=515', '下载库不库', '<table>\n<thead>\n<tr>\n<th>安装包列表清单👉👉👉</th>\n<th>👇</th>\n<th>👇</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F05%2F07%2FFroit5NB_mysql-installer-community-5.7.28.0.msi?Expires=1652584202\" target=\"_blank\">MySQL</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F08%2F18%2FVFSexUgC_CentOS-7-x86_64-DVD-2003.iso?Expires=1652584306\" target=\"_blank\">Centos7</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F09%2F28%2FMkIuEzVA_%E8%A1%A8%E6%83%85%E5%8C%85.rar?Expires=1652584333\" target=\"_blank\">表情包</a></td>\n</tr>\n<tr>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F05%2F07%2FkSuZFcV0_Redis-x64-3.2.100.zip?Expires=1652584447\" target=\"_blank\">Redis</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F05%2F07%2FhuKw8WI7_jdk-8u201-windows-x64.exe?Expires=1652584467\" target=\"_blank\">JDK8-win64</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F05%2F07%2Fy9YB1Fox_jdk-8u181-linux-x64.tar.gz?Expires=1652584495\" target=\"_blank\">JDK8-Linux</a></td>\n</tr>\n<tr>\n<td><a href=\"http://cloud.henaumcw.top/#/s/ZbCP\" target=\"_blank\">截图工具</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2022%2F06%2F01%2Ff9wuuLPb_wiztree_3_29_setup.exe?Expires=1654090488\" target=\"_blank\">磁盘树分析</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2022%2F06%2F01%2F9FCoSfiA_attahcmentName_findDuplicateClass.exe?Expires=1654090530\" target=\"_blank\">jar包冲突分析工具</a></td>\n</tr>\n<tr>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2022%2F06%2F01%2FrLd8HhNt_mqttfx-1.7.1-windows-x64%20%281%29.exe?Expires=1654090571\" target=\"_blank\">MQTT.FX 1.7.1</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2022%2F06%2F01%2FUPpiUJjH_Listary.exe?Expires=1654090607\" target=\"_blank\">Lisary</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F07%2F21%2FYs5dI2fb_WinMTR-v092%20%281%29.rar?Expires=1654090780\" target=\"_blank\">WinMTR路由追踪</a></td>\n</tr>\n</tbody>\n</table>\n', 1, '', 0, 0, 1, '2022-05-15 09:16:51', '2022-06-01 21:45:57');
INSERT INTO `tb_article` VALUES (105, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3797', 'Hello Halo', '<h2 id=\"hello-halo\">Hello Halo</h2>\n<p>如果你看到了这一篇文章，那么证明你已经安装成功了，感谢使用 <a href=\"https://halo.run\">Halo</a> 进行创作，希望能够使用愉快。</p>\n<h2 id=\"相关链接\">相关链接</h2>\n<ul>\n<li>官网：<a href=\"https://halo.run\">https://halo.run</a></li>\n<li>社区：<a href=\"https://bbs.halo.run\">https://bbs.halo.run</a></li>\n<li>主题仓库：<a href=\"https://halo.run/s/themes\">https://halo.run/s/themes</a></li>\n<li>开源地址：<a href=\"https://github.com/halo-dev/halo\">https://github.com/halo-dev/halo</a></li>\n</ul>\n<p>在使用过程中，有任何问题都可以通过以上链接找寻答案，或者联系我们。</p>\n<blockquote>\n<p>这是一篇自动生成的文章，请删除这篇文章之后开始你的创作吧！</p>\n</blockquote>\n', 1, '', 0, 0, 1, '2020-04-24 18:38:38', '2022-05-21 18:21:34');
INSERT INTO `tb_article` VALUES (106, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1562', '关于我', '<h2 id=\"%E8%87%AA%E8%AF%AD\" tabindex=\"-1\">自语</h2>\n<ul>\n<li>大家好，我是一枚刚入门的后端开发工程师👨🏻‍💻，在读研究生，目前主攻Java后端开发.</li>\n<li>我希望用代码改变世界,我也在改变世界,自豪脸😏</li>\n<li>目前正走在成为一个<s>厉害</s>(Zhuang Bi)程序猿的路上. 前途很艰辛, 但是我会坚持!</li>\n<li>生活不止有撸码和工作, 也有诗和远方. 在快乐中生活, 在快乐中工作, 爱家人, 爱自己</li>\n</ul>\n<p><strong>子曰：生而知之者，上也；学而知之者，次也；困而学之，又其次也；困而不学，民斯为下矣。<br />\n人生得意须尽欢，莫使金樽空对月。<br />\n少小须勤学，文章可立身。满朝朱紫贵，尽是读书人。</strong></p>\n<h2 id=\"%E6%8A%80%E8%83%BD\" tabindex=\"-1\">技能</h2>\n<ul>\n<li>语言：Java, JavaScript, HTML, CSS</li>\n<li>数据库：MySQL, Redis, Oracle</li>\n<li>开发框架：Spring, Spring Boot, Spring Cloud Alibaba, MyBatis, Shiro, JQuery，Bootstrap，Layui，Vue</li>\n<li>交互协议：TCP/IP，Netty，MQTT，WebSocket</li>\n<li>中间件：Kafka, Zookeeper,MyCat</li>\n<li>构建工具： Maven, Tomcat</li>\n<li>环境： Centos, Linux, Git,Eclipse, Intellij IDEA</li>\n</ul>\n<h2 id=\"%E5%AD%A6%E4%B9%A0\" tabindex=\"-1\">学习</h2>\n<ul>\n<li>有道是学无止境，Java 后端开发的路很难走，但是既然走了这条路，那就得一直走下去。</li>\n<li>Java 相关的技术栈很多，学起来很不容易，最近两年的行情也是优胜劣汰，希望自己能够快速成长起来。</li>\n<li>夯实基础，学习源码。</li>\n<li>初识<strong>知识图谱</strong>，希望在这条路上也有所成长。</li>\n</ul>\n<p><ins>问渠哪得清如许？为有源头活水来。</ins></p>\n<blockquote>\n<p>要问为什么方塘的水会如此清澈？是由于有永不枯竭的源头为它源源不断地输送活水啊。<br />\n诗句常用来比喻知识是不断更新和发展的，需要不断积累，就像水源头一样，在人生的学习中不断地学习、运用和探索，才能使自己永葆先进和活力。</p>\n</blockquote>\n<h2 id=\"%E5%8D%9A%E5%AE%A2\" tabindex=\"-1\">博客</h2>\n<ul>\n<li>期望：平时生活和工作一种记录, 希望之后回过头再来看自己的博客也会有所收获或感想</li>\n<li>技术、感想与生活</li>\n<li>对生活和学习的一个记录</li>\n<li>希望自己越来越强大，为了自己所爱的人</li>\n</ul>\n<h2 id=\"%E5%88%86%E4%BA%AB\" tabindex=\"-1\">分享</h2>\n<p>最喜欢的一首诗，与你共勉：</p>\n<blockquote>\n<p><strong>大鹏一日同风起，抟摇直上九万里。<br />\n假令风歇时下来，犹能簸却沧溟水。<br />\n世人见我恒殊调，闻余大言皆冷笑。<br />\n宣父犹能畏后生，丈夫未可轻年少。</strong></p>\n</blockquote>\n', 1, '', 0, 0, 1, '2020-10-07 12:41:27', '2022-08-02 11:19:04');
INSERT INTO `tb_article` VALUES (107, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1639', 'Springboot多模块配置详细教程+源码案例+所遇到的坑', '<h3 id=\"springboot多模块配置详细教程\">Springboot多模块配置详细教程</h3>\n<blockquote>\n<p>这两天参考了下若依大神的后台管理项目，感觉程序的健壮性是真的强大，本人佩服的五体投地，很多程序设计技巧规范非常值得我去学习，其中第一个便是Springboot的多模块化配置，也正好项目中需要，所以特地学习一下，但是实际操作中遇到了很多问题，特此记录一下。</p>\n</blockquote>\n<h6 id=\"进行多模块配置的好处maven多模块项目通常由一个父模块和若干个子模块构成每个模块都对应着一个pomxml它们之间通过继承和聚合也称作多模块相互关联多模块适用于一些比较大的项目通过合理的模块拆分实现代码的复用便于维护和管理\">进行多模块配置的好处：maven多模块项目通常由一个父模块和若干个子模块构成，每个模块都对应着一个pom.xml。它们之间通过继承和聚合（也称作多模块）相互关联。多模块适用于一些比较大的项目，通过合理的模块拆分，实现代码的复用，便于维护和管理。</h6>\n<p>在开始动手之前，我们先捋一捋每个模块的作用，清楚需求做事才有目的。之后再说如何创建：<br />\n<img src=\"https://img-blog.csdnimg.cn/20191231180812711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n首先，如上图所示，我这里分了四个子模块和一个父模块。</p>\n<p>其中ww_system模块主要放entity、service、serviceImpl、mapper等文件。<br />\nww_common主要放一些公共的工具类，<br />\nww_blog是我的前台controller控制器<br />\nww_admin 是系统的web启动入口，包括系统后台controller都在这。是整个系统启动的入口。</p>\n<p>有心的朋友可以再单独把service也单独抽出来做一个模块，不过我觉得没有必要，用了mybatisplus之后service和mapper就很少写了。</p>\n<h3 id=\"如何创建\">如何创建？</h3>\n<h4 id=\"1创建父模块\">1，创建父模块</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20191231181705863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n父模块的创建和平常我们创建Springboot项目没法不同，一步一步来就行了，不过既然是父模块，那么它显然是不需要src目录的，所以创建后直接删掉它就行。其他的东西爱删不删，<strong>留下pom文件就行。</strong></p>\n<h4 id=\"2创建子模块\">2，创建子模块。</h4>\n<p>创建子模块的时候不要直接在左上角new -&gt;project来创建。要选择我们刚创建好的父模块项目，在它上面右击创建new module。<br />\n<img src=\"https://img-blog.csdnimg.cn/20191231182055709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n然后一直下一步就行，这里还没有什么要注意的地方，按照这种方式在父模块上右键创建其余的另外三个子模块。</p>\n<h4 id=\"3重点配置依赖\">3，重点：配置依赖</h4>\n<p>都创建好之后就是重点了，要配置我们几个模块之间的关联关系，<br />\n大致思路就是：所有的子模块都继承父模块<br />\nww_admin和ww_blog两个带控制器的模块要引用ww_system和ww_common公共模块。<br />\n公共模块ww_common不依赖任何模块，只补充它所需要的jar包坐标就行</p>\n<p>然后，父模块pom中不需要配置build打包配置</p>\n<h6 id=\"父模块pom文件内容\">父模块pom文件内容：</h6>\n<p><strong>注意模块引用和modules标签！！！！</strong></p>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.macw&lt;/groupId&gt;\n    &lt;artifactId&gt;wwblog&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n\n    &lt;name&gt;wwblog&lt;/name&gt;\n    &lt;url&gt;http://www.henaumcw.top&lt;/url&gt;\n    &lt;description&gt;马超伟●个人博客系统&lt;/description&gt;\n\n    &lt;properties&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n        &lt;macw.version&gt;1.0.0&lt;/macw.version&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n        &lt;shiro.version&gt;1.4.2&lt;/shiro.version&gt;\n        &lt;thymeleaf.extras.shiro.version&gt;2.0.0&lt;/thymeleaf.extras.shiro.version&gt;\n        &lt;druid.version&gt;1.1.14&lt;/druid.version&gt;\n    &lt;/properties&gt;\n\n    &lt;modules&gt;\n        &lt;module&gt;ww_admin&lt;/module&gt;\n        &lt;module&gt;ww_blog&lt;/module&gt;\n        &lt;module&gt;ww_system&lt;/module&gt;\n        &lt;module&gt;ww_common&lt;/module&gt;\n    &lt;/modules&gt;\n    &lt;packaging&gt;pom&lt;/packaging&gt;\n\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;!-- SpringBoot的依赖配置--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;\n                &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n                &lt;type&gt;pom&lt;/type&gt;\n                &lt;scope&gt;import&lt;/scope&gt;\n            &lt;/dependency&gt;\n            &lt;!--thymeleaf依赖--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n                &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--阿里数据库连接池 --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n                &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;\n                &lt;version&gt;${druid.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!-- 阿里JSON解析器 --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n                &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n                &lt;version&gt;${fastjson.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--系统模块--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.macw&lt;/groupId&gt;\n                &lt;artifactId&gt;ww_system&lt;/artifactId&gt;\n                &lt;version&gt;${macw.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--博客前台模块--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.macw&lt;/groupId&gt;\n                &lt;artifactId&gt;ww_blog&lt;/artifactId&gt;\n                &lt;version&gt;${macw.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--系统后台入口模块--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.macw&lt;/groupId&gt;\n                &lt;artifactId&gt;ww_admin&lt;/artifactId&gt;\n                &lt;version&gt;${macw.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--公共模块--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.macw&lt;/groupId&gt;\n                &lt;artifactId&gt;ww_common&lt;/artifactId&gt;\n                &lt;version&gt;${macw.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.1&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;source&gt;${java.version}&lt;/source&gt;\n                    &lt;target&gt;${java.version}&lt;/target&gt;\n                    &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n    &lt;!--配置阿里云国内镜像--&gt;\n    &lt;repositories&gt;\n        &lt;repository&gt;\n            &lt;id&gt;public&lt;/id&gt;\n            &lt;name&gt;aliyun nexus&lt;/name&gt;\n            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;\n            &lt;releases&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n            &lt;/releases&gt;\n        &lt;/repository&gt;\n    &lt;/repositories&gt;\n&lt;/project&gt;\n\n</code></pre>\n<h6 id=\"ww-systempom文件内容\">ww_system:pom文件内容：</h6>\n<p>注意parent标签和模块引用</p>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;wwblog&lt;/artifactId&gt;\n        &lt;groupId&gt;com.macw&lt;/groupId&gt;\n        &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;groupId&gt;com.macw&lt;/groupId&gt;\n    &lt;artifactId&gt;ww_system&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;name&gt;ww_system&lt;/name&gt;\n    &lt;description&gt;系统模块&lt;/description&gt;\n    &lt;dependencies&gt;\n        &lt;!-- Mysql驱动包 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- 通用工具--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.macw&lt;/groupId&gt;\n            &lt;artifactId&gt;ww_common&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--Mybatis plus--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;\n            &lt;version&gt;3.3.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-extension&lt;/artifactId&gt;\n            &lt;version&gt;3.3.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;\n            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;\n            &lt;version&gt;2.3.28&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n\n</code></pre>\n<h6 id=\"ww-common模块pom文件内容\">ww_common模块pom文件内容：</h6>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;wwblog&lt;/artifactId&gt;\n        &lt;groupId&gt;com.macw&lt;/groupId&gt;\n        &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;groupId&gt;com.macw&lt;/groupId&gt;\n    &lt;artifactId&gt;ww_common&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;name&gt;ww_common&lt;/name&gt;\n    &lt;description&gt;公共模块&lt;/description&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- Spring框架基本的核心工具 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- SpringWeb模块 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;${lombo.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n\n</code></pre>\n<h6 id=\"ww-admin模块pom文件内容\">ww_admin模块pom文件内容：</h6>\n<p><strong>注意这里的模块引用和build标签内容</strong></p>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;wwblog&lt;/artifactId&gt;\n        &lt;groupId&gt;com.macw&lt;/groupId&gt;\n        &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;groupId&gt;com.macw&lt;/groupId&gt;\n    &lt;artifactId&gt;ww_admin&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;name&gt;ww_admin&lt;/name&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n    &lt;description&gt;系统后台●总后台web服务入口模块&lt;/description&gt;\n  \n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- SpringBoot集成thymeleaf模板 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- spring-boot-devtools --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n            &lt;optional&gt;true&lt;/optional&gt; &lt;!-- 表示依赖不会传递 --&gt;\n        &lt;/dependency&gt;\n\n        &lt;!--公共模块--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.macw&lt;/groupId&gt;\n            &lt;artifactId&gt;ww_common&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;!--博客前台--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.macw&lt;/groupId&gt;\n            &lt;artifactId&gt;ww_blog&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;!--系统模块--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.macw&lt;/groupId&gt;\n            &lt;artifactId&gt;ww_system&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;3.3.0&lt;/version&gt;\n        &lt;/dependency&gt;\n\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;fork&gt;true&lt;/fork&gt; &lt;!-- 如果没有该配置，devtools不会生效 --&gt;\n                &lt;/configuration&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;repackage&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n        &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n\n</code></pre>\n<h4 id=\"4-启动入口配置\">4 启动入口配置</h4>\n<p>启动入口只在ww_admin下配置Application启动类就行了，其他模块下不需要。<br />\n需要注意的是启动类一定要放在模块的根目录下，<br />\n我之前就是放在了模块目录下然后就导致了bean注入失败等的许多错误，需要加上@ComponentScan等好几个来进行包扫描，及其麻烦</p>\n<p>所以最好的就是放在根目录下，如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20191231185137914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n如果遇到bean注释失败的错误，那么别问其他，就去找你的包扫描吧，肯定是路径的问题。我就在这里栽了好久好久。<br />\n添加控制器和连接池之后的目录大致是这样的<br />\n<img src=\"https://img-blog.csdnimg.cn/20191231185515837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n由于篇幅限制上面pom文件中删掉了很多与这篇文章讲解无用的依赖。如果报错或无法启动请参考本项目源码：<a href=\"https://gitee.com/macw/wwblog.git\">https://gitee.com/macw/wwblog.git</a></p>\n<p>今天先更新到这，其他有问题闲来再更新</p>\n', 1, '', 0, 0, 1, '2020-04-25 08:33:11', '2022-05-21 18:21:18');
INSERT INTO `tb_article` VALUES (108, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4738', 'centos7系统运行、停止java程序常用命令，springboot打包运行', '<p>﻿</p>\n<h4 id=\"对于spring-boot导出的jar包程序\">对于Spring Boot导出的jar包程序</h4>\n<p>当连接的远程服务器执行的时候，一旦关闭了当前终端，程序也被迫停止运行了。这显然是不行的<br />\n我想要的是让它常驻后台执行，不受启动其终端关闭与否的影响。</p>\n<h5 id=\"解决办法\">解决办法</h5>\n<p>在jar包文件所在的目录执行以下命令：</p>\n<pre><code> nohup java -jar springboot-0.0.1-SNAPSHOT.jar  &gt;nohup 2&gt;&amp;1 &amp;\n</code></pre>\n<p>nohup: 不挂断的执行命令，忽略所有的挂断信号。 运行后台命令 最后加 &amp;<br />\n在jar目录下会生成一个nohup.out文件，默认的log输出到这里了。</p>\n<h5 id=\"命令解释\">命令解释</h5>\n<p>以上命令是不输出启动日志的，运行后会只输出一个运行的进程号。<br />\n想要输出启动日志可以这样：</p>\n<pre><code>java -jar xx.jar &gt; log.file 2&gt;&amp;1 &amp;\n</code></pre>\n<p><strong>这里启动信息就输出到了日志文件上，注意的是log文件需要先创建chmod授权</strong><br />\n可以给日志一个777授权，测试阶段无所谓：</p>\n<pre><code>chmod 777 -R /home/logs\n</code></pre>\n<h5 id=\"21含义\">2&gt;&amp;1含义</h5>\n<p>&amp; 1 更准确的说是文件描述符 1,<br />\n而1 一般代表的就是STDOUT_FILENO,实际上这个操作就是一个dup2(2)调用<br />\n.他标准输出到all_result ,然后复制标准输出到文件描述符2(STDERR_FILENO)， 其后果就是文件描述符1和2指向同一个文件表项,也可以说错误的输出被合并了<br />\n.其中0表示键盘输入 1表示屏幕输出 2表示错误输出.把标准出错重定向到标准输出,然后扔到/DEV/NULL下面去。通俗的说，就是把所有标准输出和标准出错都扔到垃圾桶里面。<br />\n|值|含义  |<br />\n|--|--|<br />\n| 0 |标准输入（一般是键盘）  |<br />\n|1|标准输出（一般是显示屏，准确的说是用户终端控制台）|<br />\n|2|标准错误（出错信息输出）|</p>\n<p>最后一个&amp; ， 是让该命令在后台执行</p>\n<h4 id=\"查看进程\">查看进程</h4>\n<p><strong>查看全部进程</strong></p>\n<pre><code>ps -ef \n</code></pre>\n<p><strong>查看java进程</strong></p>\n<pre><code>ps -ef |grep java\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20200106122724191.png\" alt=\"在这里插入图片描述\" /><br />\n如图所示：<br />\n第一个进程是我jar包启动进程，第二个是java的查找进程不用管<br />\n前面的那个root是当前用户，第一个数字403是当前进程号<br />\n<strong>杀死当前进程</strong></p>\n<pre><code>kill -9 403\n</code></pre>\n<p><strong>只查询当前jar包程序的进程号：</strong></p>\n<pre><code>pgrep -f \'java -jar springboot-0.0.1-SNAPSHOT.jar\'\n</code></pre>\n<p>如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20200106123205274.png\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 15:30:30', '2022-05-21 18:21:05');
INSERT INTO `tb_article` VALUES (109, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4126', 'SpringBoot在自定义实现类中调用service层等Spring其他层报错为null的解决办法', '<p>﻿## 背景：<br />\n使用Springboot整合Netty写了一个TCP实现客户端服务端通信接收主板信息，然后需要将设备实时发送的检测数据等关键信息存储到数据库，也是为了能最快利用mybatis框架实现数据访问，然后在TCP服务器消息处理时，需要写数据库，直接调用DAO层，编译报错。改为调用Service层，编译正常，运行到调用的地方，报空指针异常，跟踪到异常位置，发现service为空，也就是按照之前controller层通过<br />\n@Autowired注入service层失效。<br />\n解决方案：</p>\n<h2 id=\"1不要用mybatis使用原生的jdbc连接数据库进行存储\">1.不要用mybatis,使用原生的jdbc连接数据库进行存储</h2>\n<p>代码如下：</p>\n<pre><code class=\"language-java\">blic class MessageHandler extends ChannelInboundHandlerAdapter {\n	private static Logger logger = LoggerFactory.getLogger(MessageHandler.class);\n	/**\n	 * 本方法用于读取客户端发送的信息\n	 * @param ctx\n	 * @param msg\n	 * @throws Exception\n	 */\n	@Override\n	public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n    System.out.println(&quot;输出接收过来的信息： &quot;+msg);\n        //将msg进行入库操作\n        //基础的jdbc连接操作，这里省去基础的连接方法\n        String str;\n        // 传递sql语句\n        Statement stt;\n        Connection conn = null;\n        String sql = &quot;insert into test_db(datas) values (\'&quot;+msg+&quot;\')&quot;;  //写SQL\n        try {\n            conn = mysqlimages.getConn();  //一个连接数据库的方法，这就不贴了，很简单的\n            //获取Statement对象\n            stt = conn.createStatement();\n            //执行sql语句\n            stt.executeUpdate(sql);\n            logger.info(&quot;&gt;&gt;&gt;插入数据库成功&quot;);\n            str = Const.SECCESS;\n        }catch (Exception e) {\n            logger.error(&quot;&lt;&lt;&lt;插入数据错误--&quot;+e.getMessage());\n            str = Const.ERROR;\n        }\n</code></pre>\n<p>这种方法可以实现，但是不推荐，本来这里数据量就大，再用jdbc没有连接池将会造成业务阻塞netty本身的worker工作线程。<br />\n所以推荐使用下一种方法：</p>\n<h2 id=\"2使用postconstruct静态初始化spring的成员变量\">2.使用@PostConstruct静态初始化spring的成员变量</h2>\n<p>代码如下：<br />\nchannelRead方法：</p>\n<pre><code class=\"language-java\">	//调用线程池处理大数据量问题\n	ExecutorService executor = Executors.newFixedThreadPool(5);\n    int num=0;\n    \n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        System.out.println();\n        log.info(&quot;加载客户端报文......&quot;);\n        log.info(&quot;【&quot; + ctx.channel().id() + &quot;】&quot; + &quot; :&quot; + msg);\n        /**\n         *  下面可以解析数据，保存数据，生成返回报文，将需要返回报文写入write函数\n         */\n        num++;\n        System.out.println(num);//输出当前已经接收过来的条数\n        //引入异步业务线程池的方式，避免长时间业务耗时业务阻塞netty本身的worker工作线程\n        executor.submit(new Callable&lt;Object&gt;() {\n            @Override\n            public Object call() throws Exception {\n                log.info(&quot;收到服务端发来的方法请求了--------------------------------------------&quot;);\n                ServerHandler handler = new ServerHandler();//这个类在下面\n                handler.test(msg.toString());\n                return null;\n            }\n        });\n        //响应客户端\n        this.channelWrite(ctx.channel().id(), msg);\n    }\n\n\n@Component \npublic class ServerHandler extends IoHandlerAdapter {\n\n    @Autowired\n    private ITest2StaticService test2StaticService;// 注入service方法\n\n    private static ServerHandler serverHandler;\n\n    @PostConstruct //通过@PostConstruct实现初始化bean之前进行的操作\n    //在初始化的时候初始化静态对象和它的静态成员变量healthDataService，原理是拿到service层bean对象，静态存储下来，防止被释放。\n    public void init() {\n        serverHandler = this;\n        serverHandler.test2StaticService = this.test2StaticService;\n        // 初使化时将已静态化的testService实例化\n    }\n\n    //测试调用\n    public void test(String msg) {\n        Test2Static test2Static = new Test2Static();\n        test2Static.setBb(Double.valueOf(msg));\n        test2Static.setCreateTime(LocalDateTime.now());\n        System.out.println(&quot;1111111111111111&quot;);\n        boolean b = serverHandler.test2StaticService.save(test2Static);\n        System.out.println(&quot;---! &quot;+b);\n    }\n\n}\n\nIoHandlerAdapter类 所用到的maven坐标：\n  &lt;!-- https://mvnrepository.com/artifact/org.apache.mina/mina-core --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.mina&lt;/groupId&gt;\n            &lt;artifactId&gt;mina-core&lt;/artifactId&gt;\n            &lt;version&gt;2.1.3&lt;/version&gt;\n        &lt;/dependency&gt;\n\n\n</code></pre>\n<p><strong>2.说明：</strong></p>\n<p>将需要调用Spring的Service层的类通过@Component注解为组件加载；<br />\n同样通过@Autowired获取Service层的Bean对象；<br />\n为类声明一个静态变量，方便下一步存储bean对象；<br />\n<strong>划重点：通过注解@PostConstruct ，在初始化的时候初始化静态对象和它的静态成员变量healthDataService，原理是拿到service层bean对象，静态存储下来，防止被释放。</strong></p>\n<p>找了好久，终于找到这个方法，本来以为很简单，却总是怎么也写不进去数据库。调用service一直为空，可困扰我好久。<br />\n特此记录。。。。。。。。。。。。。。。。。</p>\n<p><strong>那些浪费的时间，都是丢在真理路上的金子~~~~!</strong></p>\n', 1, '', 0, 0, 1, '2020-04-25 15:34:08', '2022-05-21 18:20:49');
INSERT INTO `tb_article` VALUES (110, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7908', 'java实现微信第三方登录流程源码详解，所遇到的坑', '<p>﻿&gt; 昨天在写一个手机版的web项目，要在微信客户端使用微信第三方登录，想着也没啥，看看就看看吧，但是可恶的微信官方文档给我画了很大的一个坑，特此记录</p>\n<h6 id=\"二次更新说明一下我这个是用我微信网页授权就是在微信客户端点开链接或菜单能弹出微信授权登录框的功能\">二次更新，说明一下我这个是用我微信网页授权，就是在微信客户端点开链接或菜单能弹出微信授权登录框的功能！</h6>\n<p><img src=\"https://img-blog.csdnimg.cn/20191219191009275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n前期准备工作我就不多说了，无非就是公众平台账号，填写相关资料耐心等待审核就好。</p>\n<p>这里要注意一点的是，网站应用创建好之后的<strong>授权回调域填写顶级域名就好</strong>，之前我一直写的二级域名，测试的时候回调总是过不来，后来回来看文档，微信说的就是，<strong>该域名下的所有页面都 可以回调</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20191219100843364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n创建好网站应用之后我们来看微信提供的接口文档</p>\n<p><a href=\"https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html\">微信开放平台第三方登录接口文档地址</a></p>\n<h4 id=\"第一步请求code\">第一步：请求CODE</h4>\n<p>根据官方文档，请求code这里要按照响应的参数进行拼接，参数就按照官方提供的，需要注意的是appid是你用哪个公众号登录就用哪个公众号的appid，<strong>这里不是开放平台的网站应用appid</strong></p>\n<p>然后另一个坑，redirect_uri，一定要用urlEncode对链接进行处理，这个链接是用户打开这个链接同意登录之后会跳转的地址，我们要跳转到后台对回调的信息就行处理，所以就要回调到我们域名下的controller控制器方法中，并且一定是要外网可访问。比如：<a href=\"http://www.test.com/callback\">www.test.com/callback</a><br />\n把链接进行Encode处理，<a href=\"http://www.jsons.cn/urlencode/\">这里提供一个 encode在线解码工具</a></p>\n<p>拼接好路径之后再微信客户端打开就应该会显示某某公众号的授权登录页面了，如果报错那就是路径没有拼接正确</p>\n<p>请求code的控制器如下所示：<br />\n参数是我自己的，换成你的参数就好</p>\n<pre><code class=\"language-java\">    @RequestMapping(&quot;/getCode&quot;)\n    public void getCode(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        //拼接url\n        StringBuilder url = new StringBuilder();\n        url.append(&quot;https://open.weixin.qq.com/connect/oauth2/authorize?&quot;);\n        //微信开放平台的appid\n        url.append(&quot;appid=&quot; + WeixinConfig.appId);\n        //转码\n        try {\n        	//回调地址 ,回调地址要进行Encode转码\n            String redirect_uri = URLEncoder.encode(WeixinConfig.REDIRECT_URI, &quot;utf-8&quot;);\n            System.out.println(&quot;redirect_uri==&quot; + redirect_uri);\n            url.append(&quot;&amp;redirect_uri=&quot; + redirect_uri);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        url.append(&quot;&amp;response_type=code&quot;);\n        url.append(&quot;&amp;scope=snsapi_userinfo&quot;);\n        url.append(&quot;&amp;state=&quot; + request.getSession().getId());\n        url.append(&quot;#wechat_redirect&quot;);\n        System.out.println(&quot;url===&quot; + url.toString());\n//        return &quot;redirect:&quot; + url.toString();\n        String s = url.toString();\n        response.sendRedirect(s);\n    }\n</code></pre>\n<p>返回说明</p>\n<p>用户允许授权后，将会重定向到redirect_uri的网址上，并且带上code和state参数</p>\n<p><strong>第二步：通过code换取网页授权access_token</strong></p>\n<p><strong>第三步：刷新access_token（如果需要）</strong></p>\n<p><strong>第四步：拉取用户信息(需scope为 snsapi_userinfo)</strong></p>\n<p>这三步我们应该在上面授权回调方法中调用，起初我在想每一个方法都要返回一个json，那么是不是我要三个控制器方法才行？，怎样才能在一个控制器里调用三个方法呢？</p>\n<p>感谢大神提供的发送GET请求的工具类：</p>\n<pre><code class=\"language-java\">public static JSONObject doGetJson(String url) throws Exception, IOException {\n        JSONObject jsonObject = null;\n        //初始化httpClient\n        DefaultHttpClient client = new DefaultHttpClient();\n        //用Get方式进行提交\n        HttpGet httpGet = new HttpGet(url);\n        //发送请求\n        HttpResponse response = client.execute(httpGet);\n\n        //获取数据\n        HttpEntity entity = response.getEntity();\n        //格式转换\n        if (entity != null) {\n            String result = EntityUtils.toString(entity, &quot;UTF-8&quot;);\n            jsonObject = JSONObject.fromObject(result);\n        }\n        //释放链接\n        httpGet.releaseConnection();\n        return jsonObject;\n    }\n</code></pre>\n<p>最后附上我的授权回调方法：</p>\n<pre><code class=\"language-java\">  /**\n     * 微信 授权登录回调\n     **/\n    @RequestMapping(&quot;/callback&quot;)\n    public void callback(String code, String state, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        System.out.println(&quot;====&quot; + code + &quot;===&quot; + state + &quot;====&quot;);\n        logger.debug(&quot;code===&quot; + code);\n        logger.debug(&quot;state===&quot; + state);\n        if (StringUtils.isNotEmpty(code)) {\n            logger.debug(&quot;sssssssss====&quot; + code);\n            StringBuilder url = new StringBuilder();\n            url.append(&quot;https://api.weixin.qq.com/sns/oauth2/access_token?&quot;);\n            //微信公众平台的AK和SK\n            url.append(&quot;appid=&quot; + WeixinConfig.appId);\n            url.append(&quot;&amp;secret=&quot; + WeixinConfig.appSecret);\n            //这是微信回调给你的code\n            url.append(&quot;&amp;code=&quot; + code);\n            url.append(&quot;&amp;grant_type=authorization_code&quot;);\n            System.out.println(&quot;url.toString()===&quot; + url.toString());\n            logger.debug(&quot;url.toString()===&quot; + url.toString());\n\n            JSONObject jsonObject = AuthUtil.doGetJson(url.toString());\n            logger.debug(&quot;jsonObject================&quot;+jsonObject);\n            //解析jsonStr的字符串\n            //1.获取微信用户的openid\n            String openid = jsonObject.getString(&quot;openid&quot;);\n\n            //2.获取获取access_token\n            String access_token = jsonObject.getString(&quot;access_token&quot;);\n\n            logger.debug(&quot;openid===&quot; + openid);\n            logger.debug(&quot;access_token===&quot; + access_token);\n\n            String infoUrl = &quot;https://api.weixin.qq.com/sns/userinfo?access_token=&quot; + access_token + &quot;&amp;openid=&quot; + openid\n                    + &quot;&amp;lang=zh_CN&quot;;\n            logger.debug(&quot;infoUrl===&quot; + infoUrl);\n\n            //3.获取微信用户信息\n            JSONObject userInfo = AuthUtil.doGetJson(infoUrl);\n            logger.debug(&quot;userInfo======================&quot;+userInfo);\n            //至此拿到了微信用户的所有信息,剩下的就是业务逻辑处理部分了\n            //保存openid和access_token到session\n            if (openid==null){\n                logger.debug(&quot;-------------------------微信授权回调，获取用户信息失败！=============================&quot;);\n                response.sendRedirect(&quot;http://m.huerdai.net/html/Program-error.html&quot;);\n                return;\n            }\n            request.getSession().setAttribute(&quot;openid&quot;, openid);\n            request.getSession().setAttribute(&quot;access_token&quot;, access_token);\n\n            logger.debug(&quot;openid===&quot; + openid);\n            logger.debug(&quot;access_token===&quot; + access_token);\n\n            String sessionid = getRequest().getSession().getId();\n            //去数据库查询有没有这个 openid\n            CustomerInfo customerInfoServiceOne = iCustomerInfoService.getOne(new QueryWrapper&lt;CustomerInfo&gt;().eq(&quot;openid&quot;, openid));\n            //如果没有这一个用户，则创建\n            if (customerInfoServiceOne == null) {\n                CustomerInfo customerInfo = new CustomerInfo();\n              	//省略实体set方法\n                boolean save = registerService.register(customerInfo);\n                if (save) {\n                    logger.debug(&quot;首次认证:http://m.huerdai.net&quot;);\n                    redisTemplate.opsForValue().set(sessionid, customerInfoServiceOne.getCustomerId());\n//                    response.sendRedirect(&quot;http://m.huerdai.net/index.html&quot;);\n                    response.sendRedirect(&quot;http://m.huerdai.net/html/bind-tel.html&quot;);\n                    return;\n                } else {\n                    logger.debug(&quot;认证失败！&quot;);\n                    response.sendRedirect(&quot;http://m.huerdai.net/error.html&quot;);\n                    return;\n                }\n            } else {\n                //已经授权过，没有绑定手机号，也是直接跳转到首页\n                redisTemplate.opsForValue().set(sessionid, customerInfoServiceOne.getCustomerId());\n                if (customerInfoServiceOne.getMobilePhone() == null) {\n                    logger.debug(&quot;已经授权过，没有绑定手机号，也是直接跳转到首页&quot;);\n                    //并且将用户信息存到Redis中\n//                    response.sendRedirect(&quot;http://m.huerdai.net/index.html&quot;);\n                    response.sendRedirect(&quot;http://m.huerdai.net/html/bind-tel.html&quot;);\n                    return;\n                } else {\n                    //已经授权过，并且已经绑定手机号\n                    logger.debug(&quot;有openid的跳转http://m.huerdai.net222222&quot;);\n                    response.sendRedirect(&quot;http://m.huerdai.net/index.html&quot;);\n                    return;\n                }\n\n            }\n\n        } else {\n            logger.debug(&quot;code获取失败！====&quot; + code);\n            // return new ModelAndView(&quot;redirect:http://m.huerdai.net/error.html&quot;);\n            response.sendRedirect(&quot;http://m.huerdai.net/error.html&quot;);\n        }\n    }\n</code></pre>\n<p>到这里就微信登录并且获取用户信息就算完成了，</p>\n<p>然后我遇到一个问题就是用户首次登录进来的时候会报openid找不到异常，第二次进来就好了，也没有其他报错信息，期待有大佬路过指正问题原因，感激不尽！</p>\n<p>这之间其他的一些问题异常和容易碰到的坑以后有时间再总结！</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:35:49', '2022-05-21 18:20:38');
INSERT INTO `tb_article` VALUES (111, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1812', 'Springboot自定义注解实现操作日志管理', '<p>﻿## 操作日志的记录</p>\n<p><strong>为什么要有日志？</strong><br />\n因为我们不光要记录代码的运行，如（logback log4j），而且还应该记录用户的行为，这叫做<strong>业务运行日志</strong></p>\n<blockquote>\n<p>例如：记录 zhangsan 在项目中 调用了哪个方法， 什么时间调用的 。访问的ip地址，  访问了哪些数据，做了什么操作，以此当程序出现问题的时候更利于我们进行错误的排查！</p>\n</blockquote>\n<p><strong>业务运行日志的作用</strong></p>\n<ol>\n<li>记录用户的行为 用于后续的分析</li>\n<li>记录用户的所有的操作</li>\n</ol>\n<p><strong>业务运行日志最常用的使用场景：记录管理员所有的行为操作， 可以用于业务分析，事故恢复</strong></p>\n<h3 id=\"日志实现的思路\">日志实现的思路</h3>\n<h4 id=\"1我们需要记录哪些数据--存入数据库\">1.我们需要记录哪些数据  存入数据库</h4>\n<p>这里列出一个我所用的表结构，如下所示：</p>\n<table>\n<thead>\n<tr><th>字段</th><th>含义</th></tr>\n</thead>\n<tbody>\n<tr><td>log_id</td><td>主键</td></tr>\n<tr><td>log_date</td><td>时间</td></tr>\n<tr><td>log_content</td><td>操作内容  例如：查询全部菜单信息  添加用户数据</td></tr>\n<tr><td>log_name_id</td><td>用户的id</td></tr>\n<tr><td>log_ip</td><td>用户的ip地址</td></tr>\n<tr><td>log_type</td><td>操作类型</td></tr>\n</tbody>\n</table>\n<h4 id=\"2在项目中什么位置记录\">2.在项目中什么位置记录</h4>\n<blockquote>\n<p>日志记录是一个数据库的添加操作 是一段代码</p>\n</blockquote>\n<p><strong>通常，我们在Controller方法进行后置增强</strong><br />\n如下图所示，我们在需要记录操作的controller上使用aop配置一个切入点，以此来记录用户所进行的操作<br />\n<img src=\"https://img-blog.csdnimg.cn/20191211145643492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"3如何实现记录功能\">3.如何实现记录功能</h4>\n<p>实现方式：AOP</p>\n<h4 id=\"4aop日志记录-具体代码实现\">4.Aop日志记录 具体代码实现</h4>\n<p>aop的使用流程，这里使用注解式aop来实现<br />\n具体步骤：</p>\n<ol>\n<li>\n<p>设置切入点</p>\n<ol>\n<li>可以切在方法上</li>\n<li>可以切在注解上\n<pre><code>@Transactional 事务注解 注解加在类上 aop 切在注解上\n</code></pre>\n</li>\n</ol>\n</li>\n<li>\n<p>写增强 日志记录增强</p>\n<ol>\n<li>获取日志的相关信息<br />\n用户的id  ip地址，  时间，  操作的描述，  类型等信息</li>\n<li>将日志对象 添加到数据库</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"增强方法的编写\">增强方法的编写</h4>\n<p><strong>增强方法中获取session</strong><br />\n因为我们是通过aop来获取用户的请求的，所以就需要通过当前的请求拿到session，进而去获取用户的信息。<br />\n<img src=\"https://img-blog.csdnimg.cn/20191211150342156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>但是，操作的描述如何获取呢？</strong></p>\n<pre><code>比如 执行的方法不同  描述是不一样的\nlogin             管理员登录\nselectAllMenu  查询了所有的菜单\n</code></pre>\n<p>解决方案：<strong>使用自定义注解：</strong></p>\n<ol>\n<li>\n<p>在 目标 方法上添加自定义注解 （@Log） 如下</p>\n</li>\n<li>\n<p>在增强中获取注解(@Log)的value 和 type</p>\n</li>\n</ol>\n<p><strong>代码实现</strong></p>\n<p>自定义日志注解<br />\n<img src=\"https://img-blog.csdnimg.cn/20191211151108554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<pre><code class=\"language-java\">import java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * 元注解：加在自定义注解上的注解\n * @Target 定义注解可以添加的位置 METHOD 方法上 type 类上\n * @Retention RUNTIME 运行时  不管编译 还是 运行 这个注解都可以用\n *\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface LogAnnotation {\n    /**\n     * 写法类似于接口的方法 后面可以通过default 关键字给默认值\n     * 用法类似于属性\n     * @return\n     */\n    String value() default &quot;&quot;;\n    String type() default &quot;&quot;;\n}\n</code></pre>\n<p><strong>这里要注意什么是元注解，和 注解属性的定义方式</strong></p>\n<h5 id=\"2-在目标方法上使用注解\">2. 在目标方法上使用注解</h5>\n<p><img src=\"https://img-blog.csdnimg.cn/20191211150853141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n3. 在增强方法中获取注解的value 和 type<br />\n<img src=\"https://img-blog.csdnimg.cn/20191211151652465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<pre><code class=\"language-java\">        /**\n         * 操作的描述\n         *\n         * 执行的方法不同  描述是不一样的\n         * login         管理员登录\n         * selectAllGuru 查询了所有的上师\n         *\n         * 获取注解的值\n         */\n//        1.通过连接点获取方法签名 被切入方法的所有信息\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n//        2.获取被切入方法对象\n        Method method = signature.getMethod();\n//        3.获取方法上的注解\n        LogAnnotation annotation = method.getAnnotation(LogAnnotation.class);\n//        4.获取注解的值\n        String value = annotation.value();\n</code></pre>\n<h2 id=\"完整的aop的代码实现\">完整的aop的代码实现</h2>\n<pre><code class=\"language-java\">package com.tourism.hu.config;\n\n/**\n * @author 马超伟\n * @PROJECT_NAME: fzll\n * @Description:\n * @date 15:29\n * @Copyright: All rights Reserved, Designed By Huerdai  \n * Copyright:    Copyright(C) 2019-2020\n * Company       Huerdai Henan LTD.\n */\n\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.tourism.hu.entity.CustomerInfo;\nimport com.tourism.hu.entity.CustomerLoginLog;\nimport com.tourism.hu.service.ICustomerInfoService;\nimport com.tourism.hu.service.ICustomerLoginLogService;\nimport com.tourism.hu.util.IpAddressUtil;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\n\nimport javax.annotation.Resource;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpSession;\nimport java.lang.reflect.Method;\nimport java.time.LocalDateTime;\n\n/*** @Aspect 标记当前类为功能增强类 切面类 *\n *  @Configuration 标记当前类为配置类 这个注解包含了@Component的功能\n */\n@Aspect\n@Configuration\npublic class LogAop {\n\n    private  Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Resource\n    private ICustomerInfoService iCustomerInfoService;\n\n    @Resource\n    private RedisTemplate redisTemplate;\n\n    @Resource\n    private ICustomerLoginLogService iCustomerLoginLogService;\n\n    /**\n     * JoinPoint 连接点 就是切入点 通过这个对象可以获取切入点的相关所有信息 例如：被切入的方法和注解\n     *\n     * @param joinPoint ** 切入点的设置 切注解 @annotation *\n     */\n    @After(&quot;@annotation(com.tourism.hu.config.Log)&quot;)\n    public void logAfter(JoinPoint joinPoint) {\n    	//new 一个日志的实体，用来保存日志信息\n        CustomerLoginLog loginLog = new CustomerLoginLog();\n        // 1.获取日志相关的信息  用户的id session  ip  时间  操作的描述  类型  ctrl+H\n        /**\n         * 获取用户id\n         * 为什么不能装配session？因为服务器有多个session\n         * 通过 ServletRequestAttributes 可以获取当前请求\n         * 当前请求可以获取当前会话的session\n         */\n         //获取用户的请求\n        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = requestAttributes.getRequest();\n        //得到session\n        HttpSession session = request.getSession();\n        String sessionid = session.getId();\n        //通过sessionid去获取用户信息\n        Object obj = redisTemplate.opsForValue().get(sessionid);\n        String customerId = &quot;&quot;;\n        if(obj!=null) {\n            customerId=obj.toString();\n        }\n        //拿到用户对象\n        CustomerInfo customerInfo = iCustomerInfoService.getOne(new QueryWrapper&lt;CustomerInfo&gt;().eq(&quot;id&quot;, customerId));\n        if (customerInfo!=null){\n        	//将用户的id 存入到日志实体中\n            loginLog.setCustomerId(customerInfo.getCustomerId());\n        }\n         loginLog.setLoginTime(LocalDateTime.now());\n        /**\n         * 获取用户的ip\n         * 通过工具类 ip\n         */\n        loginLog.setLoginIp(IpAddressUtil.getIp());\n\n        /**\n         * 操作的描述\n         * 执行的方法不同  描述是不一样的\n         * login         管理员登录\n         * 获取注解的值\n         */\n//        1.通过连接点获取方法签名 被切入方法的所有信息\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n//        2.获取被切入方法对象\n        Method method = signature.getMethod();\n//        3.获取方法上的注解\n        Log annotation = method.getAnnotation(Log.class);\n//        4.获取注解的值\n        String value = annotation.value();\n        loginLog.setLogContent(value);\n        // 获取注解的类型\n        String type = annotation.type();\n        if (type!=null){\n            loginLog.setLoginType(type);\n        }\n//        2.将日志对象 添加到数据库\n        System.out.println(loginLog);\n        logger.debug(&quot;loginLog====&quot;+loginLog);\n        boolean save = iCustomerLoginLogService.save(loginLog);\n        logger.debug(&quot;保存日志------&quot;+save);\n    }\n}\n\n</code></pre>\n<h4 id=\"所用到的工具类\">所用到的工具类</h4>\n<p>获取ip地址的工具类IpAddressUtil</p>\n<pre><code class=\"language-java\">  public static String getIp() {\n        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();\n        String ip = &quot;null&quot;;\n        try {\n            ip = request.getHeader(&quot;x-forwarded-for&quot;);\n            if (StringUtils.isEmpty(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getHeader(&quot;Proxy-Client-IP&quot;);\n            }\n            if (StringUtils.isEmpty(ip) || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);\n            }\n            if (StringUtils.isEmpty(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getHeader(&quot;HTTP_CLIENT_IP&quot;);\n            }\n            if (StringUtils.isEmpty(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);\n            }\n            if (StringUtils.isEmpty(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getRemoteAddr();\n            }\n        } catch (Exception e) {\n            logger.error(&quot;IPUtils ERROR &quot;, e);\n        }\n        //使用代理，则获取第一个IP地址\n        if(StringUtils.isNotEmpty(ip) &amp;&amp; ip.length() &gt; 15) {\n          if(ip.indexOf(&quot;,&quot;) &gt; 0) {\n              ip = ip.substring(0, ip.indexOf(&quot;,&quot;));\n          }\n      }\n        return ip;\n    }\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:36:30', '2022-05-21 18:20:19');
INSERT INTO `tb_article` VALUES (112, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7762', 'Linux-Centos7,开放相应端口命令', '<p>﻿今天在配置阿里云服务器的时候，发现我明明已经开放了云服务器防火墙的8080端口，然而Tomcat还是无法访问，然后意思到可能是Linux系统的防火墙的8080端口可能还没有打开，于是查询总结了以下命令：</p>\n<h2 id=\"现在linux防火墙有两种服务\">现在Linux防火墙有两种服务</h2>\n<h2 id=\"--1service-firewalld\">- 1.service firewalld</h2>\n<h2 id=\"--2service-iptables\">- 2.service iptables</h2>\n<h4 id=\"一就firewalld来说\">一.就firewalld来说</h4>\n<ul>\n<li>查看开放的端口命令：</li>\n</ul>\n<pre><code>netstat -anp\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20191117124820976.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>查询防火墙状态</li>\n</ul>\n<pre><code>systemctl status firewalld\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20191117124948744.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>如果防火墙关闭了，就开启</li>\n</ul>\n<pre><code> systemctl start firewalld\n</code></pre>\n<ul>\n<li>查询对应端口号</li>\n</ul>\n<pre><code>firewall-cmd --query-port=8080/tcp\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2019111712524287.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>如果显示no，则开启</li>\n</ul>\n<pre><code>firewall-cmd --add-port=8080/tcp --permanent\n</code></pre>\n<p>注意这条命令是 --add,加入端口号，上面那个是query查询端口号<br />\n<img src=\"https://img-blog.csdnimg.cn/20191117125331279.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>然后重启防火墙</li>\n</ul>\n<pre><code>firewall-cmd --reload\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20191117125437520.png\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"二service-iptables\">二.service iptables</h2>\n<ol>\n<li>开放端口命令： /sbin/iptables -I INPUT -p tcp --dport 8085 -j ACCEPT<br />\n2.保存：/etc/rc.d/init.d/iptables save<br />\n3.重启服务：/etc/init.d/iptables restart<br />\n4.查看端口是否开放：/sbin/iptables -L -n</li>\n</ol>\n<h5 id=\"最后附上云服务器打开端口号的配置\">最后附上云服务器打开端口号的配置</h5>\n<p><img src=\"https://img-blog.csdnimg.cn/20191117125617767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 15:37:01', '2022-05-21 18:20:08');
INSERT INTO `tb_article` VALUES (113, 1, 8, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=6918', '省市区管理sql数据表设计、以及全国省市区全部最新数据', '<p>﻿使用Mysql数据库，主要字段有：<br />\n区域主键、区域名称、区域上级标识、地名简称、区域等级、区域编码、邮政编码、组合名称、经度、维度、拼音，<br />\n其页面展示效果图如下：<br />\n<img src=\"https://img-blog.csdnimg.cn/2019101611124889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n建表sql为：</p>\n<pre><code class=\"language-sql\">CREATE TABLE `region`  (\n  `id` int(11) NOT NULL COMMENT \'区域主键\',\n  `name` varchar(40) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'区域名称\',\n  `pid` int(11) NULL DEFAULT NULL COMMENT \'区域上级标识\',\n  `sname` varchar(40) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'地名简称\',\n  `level` int(11) NULL DEFAULT NULL COMMENT \'区域等级\',\n  `citycode` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'区域编码\',\n  `yzcode` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'邮政编码\',\n  `mername` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'组合名称\',\n  `Lng` float NULL DEFAULT NULL COMMENT \'经度\',\n  `Lat` float NULL DEFAULT NULL COMMENT \'维度\',\n  `pinyin` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'拼音\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n\n</code></pre>\n<h3 id=\"插入全国最新数据地址库\">插入全国最新数据地址库：</h3>\n<p>由于CSDN篇幅限制，数据一篇放不下，<br />\nsql文件下载地址为：<a href=\"https://download.csdn.net/download/macwx/11869084\">https://download.csdn.net/download/macwx/11869084</a><br />\n下面只是部分数据，全部数据请下载文件，是CSDN篇幅限制不让我全部复制下来啊~~~~</p>\n<pre><code class=\"language-sql\">\nINSERT INTO `fz_region` VALUES (100000, \'中国\', 0, \'中国\', 0, \'\', \'\', \'中国\', 116.368, 39.9151, \'China\');\nINSERT INTO `fz_region` VALUES (110000, \'北京\', 100000, \'北京\', 1, \'\', \'\', \'中国,北京\', 116.405, 39.905, \'Beijing\');\nINSERT INTO `fz_region` VALUES (110100, \'北京市\', 110000, \'北京\', 2, \'010\', \'100000\', \'中国,北京,北京市\', 116.405, 39.905, \'Beijing\');\nINSERT INTO `fz_region` VALUES (110101, \'东城区\', 110100, \'东城\', 3, \'010\', \'100010\', \'中国,北京,北京市,东城区\', 116.41, 39.9316, \'Dongcheng\');\nINSERT INTO `fz_region` VALUES (110102, \'西城区\', 110100, \'西城\', 3, \'010\', \'100032\', \'中国,北京,北京市,西城区\', 116.36, 39.9305, \'Xicheng\');\nINSERT INTO `fz_region` VALUES (110105, \'朝阳区\', 110100, \'朝阳\', 3, \'010\', \'100020\', \'中国,北京,北京市,朝阳区\', 116.485, 39.9484, \'Chaoyang\');\nINSERT INTO `fz_region` VALUES (110106, \'丰台区\', 110100, \'丰台\', 3, \'010\', \'100071\', \'中国,北京,北京市,丰台区\', 116.286, 39.8585, \'Fengtai\');\nINSERT INTO `fz_region` VALUES (110107, \'石景山区\', 110100, \'石景山\', 3, \'010\', \'100043\', \'中国,北京,北京市,石景山区\', 116.223, 39.9056, \'Shijingshan\');\nINSERT INTO `fz_region` VALUES (110108, \'海淀区\', 110100, \'海淀\', 3, \'010\', \'100089\', \'中国,北京,北京市,海淀区\', 116.298, 39.9593, \'Haidian\');\nINSERT INTO `fz_region` VALUES (110109, \'门头沟区\', 110100, \'门头沟\', 3, \'010\', \'102300\', \'中国,北京,北京市,门头沟区\', 116.101, 39.9404, \'Mentougou\');\nINSERT INTO `fz_region` VALUES (110111, \'房山区\', 110100, \'房山\', 3, \'010\', \'102488\', \'中国,北京,北京市,房山区\', 116.143, 39.7479, \'Fangshan\');\nINSERT INTO `fz_region` VALUES (110112, \'通州区\', 110100, \'通州\', 3, \'010\', \'101149\', \'中国,北京,北京市,通州区\', 116.657, 39.9097, \'Tongzhou\');\nINSERT INTO `fz_region` VALUES (110113, \'顺义区\', 110100, \'顺义\', 3, \'010\', \'101300\', \'中国,北京,北京市,顺义区\', 116.654, 40.1302, \'Shunyi\');\nINSERT INTO `fz_region` VALUES (110114, \'昌平区\', 110100, \'昌平\', 3, \'010\', \'102200\', \'中国,北京,北京市,昌平区\', 116.231, 40.2207, \'Changping\');\nINSERT INTO `fz_region` VALUES (110115, \'大兴区\', 110100, \'大兴\', 3, \'010\', \'102600\', \'中国,北京,北京市,大兴区\', 116.341, 39.7267, \'Daxing\');\nINSERT INTO `fz_region` VALUES (110116, \'怀柔区\', 110100, \'怀柔\', 3, \'010\', \'101400\', \'中国,北京,北京市,怀柔区\', 116.632, 40.316, \'Huairou\');\nINSERT INTO `fz_region` VALUES (110117, \'平谷区\', 110100, \'平谷\', 3, \'010\', \'101200\', \'中国,北京,北京市,平谷区\', 117.121, 40.1406, \'Pinggu\');\nINSERT INTO `fz_region` VALUES (110228, \'密云县\', 110100, \'密云\', 3, \'010\', \'101500\', \'中国,北京,北京市,密云县\', 116.843, 40.3762, \'Miyun\');\nINSERT INTO `fz_region` VALUES (110229, \'延庆县\', 110100, \'延庆\', 3, \'010\', \'102100\', \'中国,北京,北京市,延庆县\', 115.975, 40.4567, \'Yanqing\');\nINSERT INTO `fz_region` VALUES (120000, \'天津\', 100000, \'天津\', 1, \'\', \'\', \'中国,天津\', 117.19, 39.1256, \'Tianjin\');\nINSERT INTO `fz_region` VALUES (120100, \'天津市\', 120000, \'天津\', 2, \'022\', \'300000\', \'中国,天津,天津市\', 117.19, 39.1256, \'Tianjin\');\nINSERT INTO `fz_region` VALUES (120101, \'和平区\', 120100, \'和平\', 3, \'022\', \'300041\', \'中国,天津,天津市,和平区\', 117.215, 39.1172, \'Heping\');\nINSERT INTO `fz_region` VALUES (120102, \'河东区\', 120100, \'河东\', 3, \'022\', \'300171\', \'中国,天津,天津市,河东区\', 117.226, 39.1232, \'Hedong\');\nINSERT INTO `fz_region` VALUES (120103, \'河西区\', 120100, \'河西\', 3, \'022\', \'300202\', \'中国,天津,天津市,河西区\', 117.223, 39.1096, \'Hexi\');\nINSERT INTO `fz_region` VALUES (120104, \'南开区\', 120100, \'南开\', 3, \'022\', \'300110\', \'中国,天津,天津市,南开区\', 117.151, 39.1382, \'Nankai\');\nINSERT INTO `fz_region` VALUES (120105, \'河北区\', 120100, \'河北\', 3, \'022\', \'300143\', \'中国,天津,天津市,河北区\', 117.197, 39.1482, \'Hebei\');\nINSERT INTO `fz_region` VALUES (120106, \'红桥区\', 120100, \'红桥\', 3, \'022\', \'300131\', \'中国,天津,天津市,红桥区\', 117.151, 39.1671, \'Hongqiao\');\nINSERT INTO `fz_region` VALUES (120110, \'东丽区\', 120100, \'东丽\', 3, \'022\', \'300300\', \'中国,天津,天津市,东丽区\', 117.314, 39.0863, \'Dongli\');\nINSERT INTO `fz_region` VALUES (120111, \'西青区\', 120100, \'西青\', 3, \'022\', \'300380\', \'中国,天津,天津市,西青区\', 117.009, 39.1412, \'Xiqing\');\nINSERT INTO `fz_region` VALUES (120112, \'津南区\', 120100, \'津南\', 3, \'022\', \'300350\', \'中国,天津,天津市,津南区\', 117.385, 38.9914, \'Jinnan\');\nINSERT INTO `fz_region` VALUES (120113, \'北辰区\', 120100, \'北辰\', 3, \'022\', \'300400\', \'中国,天津,天津市,北辰区\', 117.132, 39.2213, \'Beichen\');\nINSERT INTO `fz_region` VALUES (120114, \'武清区\', 120100, \'武清\', 3, \'022\', \'301700\', \'中国,天津,天津市,武清区\', 117.044, 39.3842, \'Wuqing\');\nINSERT INTO `fz_region` VALUES (120115, \'宝坻区\', 120100, \'宝坻\', 3, \'022\', \'301800\', \'中国,天津,天津市,宝坻区\', 117.31, 39.7176, \'Baodi\');\nINSERT INTO `fz_region` VALUES (120116, \'滨海新区\', 120100, \'滨海新区\', 3, \'022\', \'300451\', \'中国,天津,天津市,滨海新区\', 117.702, 39.0267, \'Binhaixinqu\');\nINSERT INTO `fz_region` VALUES (120221, \'宁河县\', 120100, \'宁河\', 3, \'022\', \'301500\', \'中国,天津,天津市,宁河县\', 117.826, 39.3305, \'Ninghe\');\nINSERT INTO `fz_region` VALUES (120223, \'静海县\', 120100, \'静海\', 3, \'022\', \'301600\', \'中国,天津,天津市,静海县\', 116.974, 38.9458, \'Jinghai\');\nINSERT INTO `fz_region` VALUES (120225, \'蓟县\', 120100, \'蓟县\', 3, \'022\', \'301900\', \'中国,天津,天津市,蓟县\', 117.408, 40.0457, \'Jixian\');\n\n\n\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:37:24', '2022-05-21 18:19:51');
INSERT INTO `tb_article` VALUES (114, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3039', 'Spring Boot 封装文件上传工具类', '<p>﻿springboot 实现文件的上传这里我用的是commins-io依赖：<br />\n坐标如下：</p>\n<pre><code class=\"language-java\"> &lt;dependency&gt;\n      &lt;groupId&gt;commons-io&lt;/groupId&gt;\n      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;\n      &lt;version&gt;2.4&lt;/version&gt;\n    &lt;/dependency&gt;\n</code></pre>\n<p>引入这个依赖之后就可以使用下面这个工具类进行文件上传的操作了：<br />\n如下：</p>\n<pre><code class=\"language-java\">package com.tourism.fzll.util;\n\nimport java.io.File;\nimport java.util.UUID;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\nimport org.springframework.web.multipart.MultipartFile;\n\npublic class FileUploadUtil {\n	\n	public static String upload(MultipartFile file) {\n		try {\n			String extName = file.getOriginalFilename();\n			// 获取文件后缀\n			if (extName.lastIndexOf(&quot;.&quot;) &lt;= 0) {\n				throw new RuntimeException(&quot;不支持该文件类型&quot;);\n			}\n			extName = extName.substring(extName.lastIndexOf(&quot;.&quot;));\n			String webUrl = getWebUrl();\n			String fileName = getFileName();\n			String sysPath = System.getProperty(&quot;catalina.home&quot;) + &quot;/webapps&quot;;\n			// 获取文件名字\n			fileName = getFileName() + extName;\n			// 获取文件地址\n			String filePath = &quot;/content/&quot; + fileName;\n			String Url = sysPath +&quot;/content/&quot;;\n			File file2 = new File(Url);\n			if (!file2.exists()) {\n				file2.mkdirs();\n			}\n			file.transferTo(new File(sysPath + filePath));\n			return webUrl + filePath;\n		} catch (Exception e) {\n			throw new RuntimeException(e);\n		}\n	}\n	/**\n	 * \n	 * @Title: upload \n	 * @Description: (将文件保存到指定的路径下) \n	 * @param file\n\n	 * @return  \n	 * @date 2019年9月30日 上午10:22:31\n	 * @author 马超伟\n	 */\n	public static String upload(MultipartFile file,String specifiedPath) {\n		try {\n			String extName = file.getOriginalFilename();\n			// 获取文件后缀\n			if (extName.lastIndexOf(&quot;.&quot;) &lt;= 0) {\n				throw new RuntimeException(&quot;不支持该文件类型&quot;);\n			}\n			extName = extName.substring(extName.lastIndexOf(&quot;.&quot;));\n			String fileName = getFileName();\n			// 获取文件名字\n			fileName = getFileName() + extName;\n			File file2 = new File(specifiedPath);\n			if (!file2.exists()) {\n				file2.mkdirs();\n			}\n			file.transferTo(new File(specifiedPath + File.separator+ fileName));\n			return fileName;\n		} catch (Exception e) {\n			throw new RuntimeException(e);\n		}\n	}\n\n	/**\n	 * 获取文件名\n	 * @return\n	 */\n	public static String getFileName() {\n		String uuid = UUID.randomUUID().toString();\n		uuid = uuid.replace(&quot;-&quot;, &quot;&quot;);\n		return uuid.toLowerCase();\n	}\n\n	public static String getWebUrl() {\n		HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();\n		return  request.getServletContext().getRealPath(&quot;/img&quot;);\n	}\n	\n	public static String getWebProUrl() {\n		HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();\n		return request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() +request.getContextPath();\n	}\n	\n}\n\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:37:53', '2021-08-30 10:00:30');
INSERT INTO `tb_article` VALUES (115, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1196', 'layui 树形表格 treeTable使用详细指南，不能折叠解决办法', '<p>﻿最近在写一个商品分类管理的功能，本来想用layui的树形组件来写，但发现layui原生的tree只能展示title，而分类的其他字段无法展示，这就有点不适用了，无意中看到一位大神自定义写的一个树形表格组件，正好满足我的要求，特此将使用方法以及其中遇到的一些坑记录下来。。。</p>\n<h3 id=\"首先看下treetable的\">首先看下treeTable的</h3>\n<p><a href=\"https://whvse.gitee.io/treetable-lay/\">演示地址</a></p>\n<p><a href=\"https://gitee.com/whvse/treetable-lay\">项目地址</a></p>\n<p>好了，如果看完演示到这里你觉得正好符合你的功能要求，就可以继续往下看了，</p>\n<p>虽然项目地址中已经把使用介绍的很详细了，但是我在这里要补充一下我遇到的坑：</p>\n<h2 id=\"使用方法\">使用方法</h2>\n<h4 id=\"1引入模块\">1，引入模块</h4>\n<p>打开项目地址，将整个项目下载下来，项目中其他文件可以参考，我们主要用的就是treetable-lay这个文件夹的内容。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190925170811464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n下载好项目后把treetable-lay放在我们自己项目的任意位置，但是尽量和layui文件夹放一块，好找！<br />\n下面是我放的位置，如图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190925171552808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"2初始化模块配置\">2，初始化模块配置</h4>\n<p>要扩展layui的模块使用我们引入的js模块，注意base路径是treetable-lay文件夹所在的父路径，这里出错会报404，extend内容最好不要改。<br />\n下面我先每个重点注意事项单独列出来，最后放完整代码。</p>\n<pre><code class=\"language-java\">   layui.config({\n        base: \'${pageContext.request.contextPath}/layuiadmin/modules/\' //   资源所在路径\n    }).extend({\n        treetable: \'treetable-lay/treetable\'\n    }).use([\'treetable\', \'table\', \'layer\'], function () {\n        var treetable = layui.treetable;\n        var layer = layui.layer;\n        var table = layui.table;\n        var $ = layui.jquery;\n});\n</code></pre>\n<p>如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/201909251720347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"3动态渲染表格\">3，动态渲染表格</h4>\n<p>数据是从后台查询出来，数据格式不需要做处理，只需要查询所有就行了，官方文档给了json格式，我自己也做了一个简单的封装，一会儿再说json格式。</p>\n<p>这里要注意的是treeIdName和treePidName这两个属性，要对应自己查询出来的id和pid。支持自定义这点非常好</p>\n<pre><code class=\"language-java\"> &lt;%--树形表格--%&gt;\n &lt;table class=&quot;layui-table&quot; id=&quot;Lay_category_treeTable&quot; lay-filter=&quot;Lay_category_treeTable&quot;&gt;&lt;/table&gt;\n    \n    //js如下：\n    layui.use([\'treetable\', \'table\', \'layer\'], function () {\n        var treetable = layui.treetable;\n        var layer = layui.layer;\n        var table = layui.table;\n        var $ = layui.jquery;\n\n        var re;\n        // 渲染表格\n        var renderTable = function () {\n            layer.load(3);    //这里好像是要加载几层 ，我的是3层，就写了个3，\n            re = treetable.render({\n                elem: \'#Lay_category_treeTable\',\n                url: \'${basepath}/goodscategory/selectTreeTable\',\n                treeColIndex: 1,          // 树形图标显示在第几列\n                treeSpid: 0,             // 最上级的父级id\n                treeIdName: \'classId\',       // 	id字段的名称\n                treePidName: \'parentId\',    // 	pid字段的名称\n                treeDefaultClose: true,     //是否默认折叠\n                page: false,\n                //treeLinkage: true,      //父级展开时是否自动展开所有子级\n                cols: [[\n                    {type: \'numbers\'},\n                    {title: &quot;分类名称&quot;, field: &quot;className&quot;,align:&quot;left&quot;},\n                    {title: &quot;分类编码&quot;, field: &quot;classCode&quot;},\n                    //  {title: &quot;分类层级&quot;, field: &quot;classIdLevel&quot;},\n                    {title: &quot;分类状态&quot;, field: &quot;classIdStatus&quot;,templet: \'#classIdStatusTpl\'},\n                    {title: &quot;创建人&quot;, field: &quot;createUser&quot;},\n                    {\n                        title: &quot;创建时间&quot;,\n                        field: &quot;createTime&quot;,\n                        templet: \'&lt;div&gt;{{# if(d.createTime!=null){ }} {{ layui.util.toDateString(d.createTime,\\\'yyyy-MM-dd HH:mm:ss\\\')  }} {{# } }}&lt;/div&gt;\'\n                    },\n                    {title: &quot;更新人员&quot;, field: &quot;updateUser&quot;},\n                    {\n                        title: &quot;更新时间&quot;,\n                        field: &quot;updateTime&quot;,\n                        templet: \'&lt;div&gt;{{# if(d.updateTime!=null){ }} {{ layui.util.toDateString(d.updateTime,\\\'yyyy-MM-dd HH:mm:ss\\\')  }} {{# } }}&lt;/div&gt;\'\n                    },\n                    {title: &quot;操作&quot;, templet: &quot;#updateAndDelete&quot;}\n                ]],\n                done: function () {\n                    layer.closeAll(\'loading\');\n                }\n            })\n        };\n</code></pre>\n<p>可以使用url传递数据，也可以使用data传递数据，如果使用url传递数据，参数是where字段，<br />\n跟layui数据表格的使用方式一致。</p>\n<h4 id=\"4参数说明这里直接复制官方的\">4，参数说明，（这里直接复制官方的）</h4>\n<p>layui数据表格的所有参数都可以用，除此之外treetable新增的参数有：</p>\n<table>\n<thead>\n<tr><th>参数</th><th>类型</th><th>是否必填</th><th>描述</th><th> </th></tr>\n</thead>\n<tbody>\n<tr><td>treeColIndex</td><td>int</td><td>是</td><td>树形图标显示在第几列</td><td> </td></tr>\n<tr><td>treeSpid</td><td>object</td><td>是</td><td>最上级的父级id</td><td> </td></tr>\n<tr><td>treeIdName</td><td>string</td><td>否</td><td>id字段的名称</td><td> </td></tr>\n<tr><td>treePidName</td><td>string</td><td>否</td><td>pid字段的名称</td><td> </td></tr>\n<tr><td>treeDefaultClose</td><td>boolean</td><td>否</td><td>是否默认折叠</td><td> </td></tr>\n<tr><td>treeLinkage</td><td>boolean</td><td>否</td><td>父级展开时是否自动展开所有子级</td><td> </td></tr>\n</tbody>\n</table>\n<p> <strong>treeColIndex</strong></p>\n<p> 树形图标（箭头和文件夹、文件的图标）显示在第几列， 索引值是cols数组的下标。</p>\n<p> <strong>treeSpid</strong></p>\n<p> 最上级的父级id，比如你可以规定pid为0或-1的是最顶级的目录。</p>\n<p> <strong>treeIdName</strong></p>\n<p> treetable是以id和pid字段来渲染树形结构的，如果你的数据没有id和pid字段，你可以指定id和pid字段的名称。</p>\n<p> <strong>treePidName</strong></p>\n<p> pid在你的数据字段中的名称。</p>\n<p> <strong>treeDefaultClose</strong></p>\n<p> 默认是全部展开的，如果需要默认全部关闭，加上treeDefaultClose:true即可。</p>\n<p> <strong>treeLinkage</strong></p>\n<p> 父级展开时是否自动展开所有子级</p>\n<h4 id=\"注意事项\">注意事项</h4>\n<ul>\n<li>不能使用分页功能，即使写了page:true，也会忽略该参数。</li>\n<li>不能使用排序功能，不要开启排序功能。</li>\n<li>table.reload()不能实现刷新，请参考demo的刷新。</li>\n<li>除了文档上写的treetable.xxx的方法之外，其他数据表格的方法都使用table.xxx。</li>\n<li>建议删除和修改请求完后台之后请刷新（重新渲染）表格，最好不要使用obj.delete方式删除。</li>\n</ul>\n<h4 id=\"5其他方法\">5，其他方法</h4>\n<p>这里除了layui的方法新增的方法有展开所有，折叠所有，刷新表格 ，三种方法，使用方法如下：</p>\n<pre><code class=\"language-java\"> &lt;div class=&quot;layui-btn-group&quot;&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-expand&quot;&gt;全部展开&lt;/button&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-fold&quot;&gt;全部折叠&lt;/button&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-refresh&quot;&gt;刷新表格&lt;/button&gt;\n &lt;/div&gt;\n\n	 renderTable();   //这个就是上面的渲染表格 var renderTable = function () {...}\n        //展开所有\n        $(\'#btn-expand\').click(function () {\n            //alert(0)\n            treetable.expandAll(\'#Lay_category_treeTable\');\n        });\n        //折叠所有\n        $(\'#btn-fold\').click(function () {\n           // alert(1)\n            treetable.foldAll(\'#Lay_category_treeTable\');\n        });\n        //刷新表格\n        $(\'#btn-refresh\').click(function () {\n            renderTable();\n        });\n\n</code></pre>\n<h4 id=\"6content图标\">6，content图标。</h4>\n<p>图标这个从gitee码云的源码上看吧，不再详细说，也没啥可说的。</p>\n<h2 id=\"7我遇到的坑\">7，我遇到的坑</h2>\n<p>我照着他给的教程一步步弄下来页面也显示出来了，但就是不能折叠，不管是我用折叠方法还是点那个三角图片还是设置为默认折叠，就是不管用，<br />\n不能折叠，可把我给气坏了。<br />\n苦思冥想找不到问题，最后我去研究treetable.js这个文件</p>\n<p>发现其中有一段代码他给注释掉了，如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190925174505180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n然后我把注释的这一段代码打开，哎，好了，展开折叠正常了，不知道什么原因，不知道有没有其他人遇到过。。。</p>\n<h5 id=\"最后分享一下我写的不成熟的这个页面的功能汇总做个记录\">最后，分享一下我写的不成熟的这个页面的功能汇总，做个记录：</h5>\n<p>主要功能有，树形表格展示，添加，修改，删除，批量删除，搜索，layui时间日期自定义格式列，表格全部展开、折叠、刷新表格等功能，有兴趣的看下吧~~<br />\n效果图如下所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190925175823787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>全部代码在这~：</strong></p>\n<pre><code class=\"language-java\">&lt;%--\n  Created by IntelliJ IDEA.\n  User: Administrator\n  Date: 2019/9/23\n  Time: 13:25\n  To change this template use File | Settings | File Templates.\n--%&gt;\n\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;\n&lt;%@ include file=&quot;../meta.jsp&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;商品分类管理&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;${basepath}layuiadmin/layui/css/layui.css&quot; media=&quot;all&quot;&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;${basepath}layuiadmin/modules/treetable-lay/treetable.css&quot;&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;${basepath}js/jquery-1.12.0.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;${basepath}js/cookies.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;${basepath}layuiadmin/layui/layui.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;${basepath}layuiadmin/modules/treetable-lay/treetable.js&quot;&gt;&lt;/script&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n        .layui-table-cell {\n            height: auto;\n            line-height: 30px;\n        }\n\n    &lt;/style&gt;\n\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=&quot;layui-card-body&quot;&gt;\n    &lt;div style=&quot;padding-bottom: 10px;&quot; id=&quot;LAY_lay_add&quot;&gt;\n        &lt;button type=&quot;button&quot; class=&quot;layui-btn layui-btn-danger&quot; onclick=&quot;doMultiDelete()&quot;&gt;\n            &lt;i class=&quot;layui-icon layui-icon-delete&quot;&gt;&lt;/i&gt; 批量删除\n        &lt;/button&gt;\n        &lt;button class=&quot;layui-btn layuiadmin-btn-role &quot; data-type=&quot;add&quot; onclick=&quot;toOpenAddLayer()&quot;&gt;\n            &lt;i class=&quot;layui-icon layui-icon-add-circle-fine&quot;&gt;&lt;/i&gt; 添加\n        &lt;/button&gt;\n        &amp;nbsp;\n        &lt;div class=&quot;layui-input-inline&quot; style=&quot;width: 200px;&quot;&gt;\n            &lt;input type=&quot;text&quot; name=&quot;search&quot; id=&quot;Lay_toSearch_input&quot; placeholder=&quot;请输入分类名称&quot; autocomplete=&quot;off&quot;\n                   class=&quot;layui-input&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;layui-input-inline&quot; style=&quot;width: 100px;&quot;&gt;\n            &lt;button type=&quot;button&quot; class=&quot;layui-btn layui-btn-normal&quot; id=&quot;btn-search&quot;&lt;%-- onclick=&quot;doSearch()&quot;--%&gt;&gt;\n                &lt;i class=&quot;layui-icon layui-icon-search&quot;&gt;&lt;/i&gt; 搜索\n            &lt;/button&gt;\n        &lt;/div&gt;\n        &amp;nbsp;\n        &lt;div class=&quot;layui-btn-group&quot;&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-expand&quot;&gt;全部展开&lt;/button&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-fold&quot;&gt;全部折叠&lt;/button&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-refresh&quot;&gt;刷新表格&lt;/button&gt;\n        &lt;/div&gt;\n        &lt;%--\n                &lt;button type=&quot;button&quot; class=&quot;layui-btn layui-btn-normal  change-icon&quot;&gt;随机更换小图标&lt;/button&gt;\n        --%&gt;\n    &lt;/div&gt;\n\n    &lt;%--树形表格--%&gt;\n    &lt;table class=&quot;layui-table&quot; id=&quot;Lay_category_treeTable&quot; lay-filter=&quot;Lay_category_treeTable&quot;&gt;&lt;/table&gt;\n\n    &lt;%--树形菜单--%&gt;\n    &lt;div id=&quot;Lay_category_tree&quot; lay-filter=&quot;Lay_category_tree&quot;&gt;&lt;/div&gt;\n\n    &lt;%--Table表格--%&gt;\n    &lt;%-- &lt;table id=&quot;Lay_back_table&quot; lay-filter=&quot;Lay_back_table&quot;&gt;&lt;/table&gt;--%&gt;\n\n\n&lt;/div&gt;\n\n&lt;script type=&quot;text/html&quot; id=&quot;updateAndDelete&quot;&gt;\n    &lt;button type=&quot;button&quot; class=&quot;layui-btn  layui-btn-normal&quot; onclick=&quot;toOpenUpdateLayer(\'{{d.classId}}\')&quot;&gt;\n        &lt;i class=&quot;layui-icon layui-icon-edit&quot;&gt;&lt;/i&gt;修改\n    &lt;/button&gt;\n    &lt;button type=&quot;button&quot; class=&quot;layui-btn layui-btn-danger&quot; onclick=&quot;doDelete(\'{{d.classId}}\')&quot;&gt;\n        &lt;i class=&quot;layui-icon layui-icon-delete&quot;&gt;&lt;/i&gt; 删除\n    &lt;/button&gt;\n&lt;/script&gt;\n\n&lt;%--弹出层--%&gt;\n\n&lt;form id=&quot;addForm&quot; class=&quot;layui-form&quot;&gt;\n    &lt;div class=&quot;layui-form&quot; lay-filter=&quot;layuiconfig-form-role&quot; id=&quot;layuiconfig-form-role&quot;\n         style=&quot;padding: 20px 30px 0 0;display: none&quot;&gt;\n        &lt;div class=&quot;layui-form-item&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;分类名称&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;input name=&quot;className&quot; id=&quot;className&quot; class=&quot;layui-input&quot;&gt;\n                &lt;input name=&quot;classId&quot; id=&quot;classId&quot; lay-type=&quot;hide&quot; type=&quot;hidden&quot; class=&quot;layui-input&quot;&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;layui-form-item&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;分类编码&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;input name=&quot;classCode&quot; id=&quot;classCode&quot; class=&quot;layui-input&quot;&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;layui-form-item&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;分类状态&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;input type=&quot;checkbox&quot; lay-skin=&quot;switch&quot; lay-text=&quot;启用|禁用&quot; value=&quot;1&quot; checked name=&quot;classIdStatus&quot;\n                       id=&quot;classIdStatus&quot; class=&quot;layui-input&quot;&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=&quot;layui-form-item&quot; id=&quot;Lay_select_Level&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;请选择分类级别&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;select name=&quot;classIdLevel&quot; lay-verify=&quot;required&quot; lay-filter=&quot;classIdLevel&quot;&gt;\n                    &lt;option value=&quot;&quot;&gt;&lt;/option&gt;\n                    &lt;option value=&quot;1&quot; selected&gt;一级分类&lt;/option&gt;\n                    &lt;option value=&quot;2&quot;&gt;二级分类&lt;/option&gt;\n                    &lt;option value=&quot;3&quot;&gt;三级分类&lt;/option&gt;\n                &lt;/select&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n\n        &lt;div class=&quot;layui-form-item&quot; style=&quot;display: none&quot; id=&quot;Lay_One_Level&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;请选择所属的一级分类&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;select name=&quot;parentId&quot; id=&quot;parentId&quot;  lay-filter=&quot;parent_classIdLevel_One&quot;&gt;\n                    &lt;option value=&quot;&quot;&gt;&lt;/option&gt;\n                &lt;/select&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=&quot;layui-form-item&quot; style=&quot;display: none&quot; id=&quot;Lay_Two_Level&quot; &gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;请选择所属的二级分类&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;select name=&quot;parentId2&quot; id=&quot;Two_parentId&quot;  lay-filter=&quot;parent_classIdLevel_Two&quot;&gt;\n                    &lt;option value=&quot;&quot;&gt;&lt;/option&gt;\n                &lt;/select&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n\n        &lt;div class=&quot;layui-form-item&quot; style=&quot;text-align: right&quot;&gt;\n            &lt;button class=&quot;layui-btn &quot; lay-submit lay-filter=&quot;LAY-sysconfig-submit&quot; id=&quot;LAY-sysconfig-submit&quot;&gt;确认添加\n            &lt;/button&gt;\n            &lt;button lay-submit lay-filter=&quot;updateSubmitBtn&quot; class=&quot;layui-btn&quot; id=&quot;updateSubmitBtn&quot;&gt;确认修改&lt;/button&gt;\n\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/form&gt;\n\n&lt;script type=&quot;text/html&quot; id=&quot;classIdStatusTpl&quot;&gt;\n    {{#  if(d.classIdStatus==1){ }}\n    启用\n    {{#  } else { }}\n    &lt;i style=&quot;color: red;&quot;&gt;禁用&lt;/i&gt;\n    {{#  } }}\n&lt;/script&gt;\n\n&lt;script type=&quot;text/javascript&quot;&gt;\n\n    layui.config({\n        base: \'${pageContext.request.contextPath}/layuiadmin/modules/\' //   资源所在路径\n    }).extend({\n        treetable: \'treetable-lay/treetable\'\n    }).use([\'treetable\', \'table\', \'layer\'], function () {\n        var treetable = layui.treetable;\n        var layer = layui.layer;\n        var table = layui.table;\n        var $ = layui.jquery;\n\n        var re;\n\n        // 渲染表格\n        var renderTable = function () {\n            layer.load(3);\n            re = treetable.render({\n                elem: \'#Lay_category_treeTable\',\n                url: \'${basepath}/goodscategory/selectTreeTable\',\n                treeColIndex: 1,          // 树形图标显示在第几列\n                treeSpid: 0,             // 最上级的父级id\n                treeIdName: \'classId\',       // 	id字段的名称\n                treePidName: \'parentId\',    // 	pid字段的名称\n                treeDefaultClose: true,     //是否默认折叠\n                page: false,\n                //treeLinkage: true,      //父级展开时是否自动展开所有子级\n                cols: [[\n                    {type: \'numbers\'},\n                    {title: &quot;分类名称&quot;, field: &quot;className&quot;,align:&quot;left&quot;},\n                    {title: &quot;分类编码&quot;, field: &quot;classCode&quot;},\n                    //  {title: &quot;分类层级&quot;, field: &quot;classIdLevel&quot;},\n                    {title: &quot;分类状态&quot;, field: &quot;classIdStatus&quot;,templet: \'#classIdStatusTpl\'},\n                    {title: &quot;创建人&quot;, field: &quot;createUser&quot;},\n                    {\n                        title: &quot;创建时间&quot;,\n                        field: &quot;createTime&quot;,\n                        templet: \'&lt;div&gt;{{# if(d.createTime!=null){ }} {{ layui.util.toDateString(d.createTime,\\\'yyyy-MM-dd HH:mm:ss\\\')  }} {{# } }}&lt;/div&gt;\'\n                    },\n                    {title: &quot;更新人员&quot;, field: &quot;updateUser&quot;},\n                    {\n                        title: &quot;更新时间&quot;,\n                        field: &quot;updateTime&quot;,\n                        templet: \'&lt;div&gt;{{# if(d.updateTime!=null){ }} {{ layui.util.toDateString(d.updateTime,\\\'yyyy-MM-dd HH:mm:ss\\\')  }} {{# } }}&lt;/div&gt;\'\n                    },\n                    {title: &quot;操作&quot;, templet: &quot;#updateAndDelete&quot;}\n                ]],\n                done: function () {\n                    layer.closeAll(\'loading\');\n                }\n\n            })\n        };\n\n        renderTable();\n        //展开所有\n        $(\'#btn-expand\').click(function () {\n            //alert(0)\n            treetable.expandAll(\'#Lay_category_treeTable\');\n        });\n        //折叠所有\n        $(\'#btn-fold\').click(function () {\n           // alert(1)\n            treetable.foldAll(\'#Lay_category_treeTable\');\n        });\n        //刷新表格\n        $(\'#btn-refresh\').click(function () {\n            renderTable();\n        });\n\n        $(\'#btn-search\').click(function () {\n            var keyword = $(\'#Lay_toSearch_input\').val();\n            //alert(keyword);\n           // var searchName = $(\'#Lay_toSearch_input\').val();\n            var searchCount = 0;\n            $(\'#Lay_category_treeTable\').next(\'.treeTable\').find(\'.layui-table-body tbody tr td\').each(function () {\n                $(this).css(\'background-color\', \'transparent\');\n                var text = $(this).text();\n                if (keyword != \'\' &amp;&amp; text.indexOf(keyword) &gt;= 0) {\n                    $(this).css(\'background-color\', \'rgba(250,230,160,0.5)\');\n                    if (searchCount == 0) {\n                        treetable.expandAll(\'#Lay_category_treeTable\');\n                        $(\'html,body\').stop(true);\n                        $(\'html,body\').animate({scrollTop: $(this).offset().top - 150}, 500);\n                    }\n                    searchCount++;\n                }\n            });\n            if (keyword == \'\') {\n                layer.msg(&quot;请输入搜索内容&quot;, {icon: 5});\n            } else if (searchCount == 0) {\n                layer.msg(&quot;没有匹配结果&quot;, {icon: 5});\n            }\n        });\n    });\n\n\n    //这是一棵树，\n    layui.use([\'table\', \'tree\', &quot;layer&quot;, \'jquery\', \'form\'], function () {\n        var table = layui.table;\n        var layer = layui.layer;\n        var form = layui.form;\n        var tree = layui.tree;\n        var $ = layui.jquery;\n\n        $.ajax({\n            url: &quot;${pageContext.request.contextPath}/goodscategory/selectTree&quot;,\n            success: function (data) {\n                //console.log(data);\n                //渲染\n                var inst1 = tree.render({\n                    elem: \'#Lay_category_tree\',  //绑定元素\n                    data: data.data,\n                    showCheckbox: true\n                    // accordion:true\n                });\n            }\n        });\n    });\n\n\n    //搜索操作\n    function doSearch() {\n        //1.获取到输入框中输入的内容\n        var searchName = $(\'#Lay_toSearch_input\').val();\n        //发送请求，并且接收数据\n        layui.use(\'table\', function () {\n            var table = layui.table;\n            table.reload(\'Lay_back_table\', {\n                where: {&quot;platform&quot;: searchName}\n            });\n        });\n    }\n\n    //执行编辑修改\n    function toOpenUpdateLayer(classId) {\n        //alert(classId);\n        //1.获取当前行数据===》发送ajax请求，获取当前行数据\n        $.ajax({\n            url: &quot;${pageContext.request.contextPath}/goodscategory/selectOne&quot;,\n            data: &quot;aid=&quot; + classId,\n            success: function (data) {\n                $(&quot;#className&quot;).val(data.className);\n                $(&quot;#classId&quot;).val(data.classId);\n                $(&quot;#classCode&quot;).val(data.classCode);\n                // $(&quot;#classIdStatus&quot;).val(data.classIdStatus);\n                $(&quot;#classIdStatus&quot;).selected(data.classIdStatus);\n\n            }\n        });\n\n        //2.把数据填充到修改弹出层中==&gt;弹出层显示\n        layui.use([\'layer\', \'form\', \'table\'], function () {\n            var form = layui.form;\n            var layer = layui.layer;\n            var table = layui.table;\n            var $ = layui.jquery;\n\n            $(&quot;#Lay_select_Level&quot;).hide();\n            layer.open({\n                title: &quot;修改配置&quot;,\n                content: $(&quot;#layuiconfig-form-role&quot;),\n                type: 1,\n                maxmin: true,\n                area: [\'500px\', \'480px\'],\n                end:function(){\n                    window.location.reload();\n                }\n            });\n\n            $(&quot;#LAY-sysconfig-submit&quot;).hide();\n            $(&quot;#updateSubmitBtn&quot;).show();\n\n            //3.提交表单\n            form.on(&quot;submit(updateSubmitBtn)&quot;, function (data) {\n                // console.log(data);\n                $.ajax({\n                    url: &quot;${pageContext.request.contextPath}/goodscategory/updateGoods&quot;,\n                    data: data.field,\n                    type: &quot;post&quot;,\n                    //4.接收后台修改响应回来的数据；关闭弹出层、提示修改信息、刷新table\n                    success: function (data) {\n                        //1.关闭掉添加弹出层\n                        layer.closeAll(\'page\');\n                        //2.提示修改成功\n                        layer.alert(&quot;修改&quot; + data.msg+&quot;，请点击右上角刷新表格后生效！&quot;, {time: 3000});\n                        //刷新table\n                      //  table.reload(&quot;Lay_category_treeTable&quot;);\n                    }\n                });\n                return false;//阻止跳转；\n            })\n        });\n\n    }\n\n    //执行添加\n    function toOpenAddLayer() {\n        layui.use([&quot;form&quot;, &quot;layer&quot;, &quot;table&quot;], function () {\n            var form = layui.form;\n            var layer = layui.layer;\n            var table = layui.table;\n\n            layer.open({\n                title: &quot;添加配置&quot;,\n                content: $(&quot;#layuiconfig-form-role&quot;),\n                type: 1,\n                maxmin: true,\n                area: [\'500px\', \'480px\'],\n                end: function () {\n                    window.location.reload();\n                }\n            });\n\n            $(&quot;#updateSubmitBtn&quot;).hide();\n            $(&quot;#LAY-sysconfig-submit&quot;).show();\n\n            form.on(\'select(classIdLevel)\', function (data) {\n                //console.log(data.elem); //得到select原始DOM对象\n                console.log(&quot;data.value = &quot;+data.value); //得到被选中的值\n                //console.log(data.othis); //得到美化后的DOM对象\n                if(data.value == 1){\n                    // alert(1);\n                    $(&quot;#Lay_One_Level&quot;).hide();\n                    $(&quot;#Lay_Two_Level&quot;).hide();\n                }\n                if (data.value == 2) {\n                    // alert(2);\n                    $(&quot;#Lay_One_Level&quot;).show();\n                    $(&quot;#Lay_Two_Level&quot;).hide();\n                    $.ajax({\n                        url: \'${basepath}goodscategory/selectOneLevel\',\n                        dataType: \'json\',\n                        type: \'post\',\n                        success: function (data) {\n                            $.each(data, function (index, item) {\n                                //console.log(&quot;000 &quot; + index);\n                                //console.log(&quot;111 &quot; + item);\n                                $(\'#parentId\').append(new Option(item.className, item.classId));//往下拉菜单里添加元素\n                            });\n                            form.render();//菜单渲染 把内容加载进去\n                        }\n                    })\n                }\n                if (data.value == 3) {\n                    // alert(3);\n                    $(&quot;#Lay_One_Level&quot;).hide();\n                   // form.on(\'select(parent_classIdLevel_One)\', function (data2){\n                        $(&quot;#Lay_Two_Level&quot;).show();\n                        $.ajax({\n                            url: \'${basepath}goodscategory/selectTwoLevel\',\n                            dataType: \'json\',\n                            type: \'post\',\n                            success: function (data) {\n                                $.each(data, function (index, item) {\n                                    //console.log(&quot;000 &quot; + index);\n                                    //console.log(&quot;111 &quot; + item);\n                                    $(\'#Two_parentId\').append(new Option(item.className, item.classId));//往下拉菜单里添加元素\n                                });\n                                form.render();//菜单渲染 把内容加载进去\n                            }\n                        })\n                   // })\n                }\n            });\n\n            //当点击提交按钮的时候，会进入到这个函数\n            form.on(&quot;submit(LAY-sysconfig-submit)&quot;, function (data) {\n                 console.log(data.field);\n                $.ajax({\n                    url: &quot;${pageContext.request.contextPath}/goodscategory/addGoodsCategory&quot;,\n                    data: data.field,\n                    type: &quot;post&quot;,\n                    success: function (data) {\n                        //1.关闭掉添加弹出层\n                        layer.closeAll(\'page\');\n                        //2.提示添加成功\n                        layer.alert(&quot;添加&quot; + data.msg, {time: 3000});\n                        //3.刷新table\n                        table.reload(&quot;Lay_back_table&quot;);\n\n                    }\n                });\n                return false;//阻止跳转；\n            })\n        })\n    }\n\n    function doDelete(classId) {\n       // alert(classId);\n        //确认；如果点击确认删除；否则不删除\n        layui.use([\'layer\', \'table\'], function () {\n            var table = layui.table;\n            var layer = layui.layer;\n\n            layer.confirm(\'确定要删除吗？\', {icon: 3, title: \'确认删除\'}, function (index) {\n                $.ajax({\n                    url: &quot;${pageContext.request.contextPath}/goodscategory/deletecl&quot;,\n                    data: &quot;aid=&quot; + classId,\n                    success: function (data) {\n                        layer.alert(&quot;删除&quot; + data.msg, {time: 2000});\n                        // table.reload(&quot;Lay_back_table&quot;);\n                        layer.close(index);\n                    }\n                })\n            });\n        });\n    }\n\n    function doMultiDelete() {\n        //获取到选中的内容的id===》table模块中找方法\n        layui.use([\'layer\', \'table\'], function () {\n            var table = layui.table;\n            var layer = layui.layer;\n            //获取到选中的数据\n            var checkStatus = table.checkStatus(\'Lay_back_table\'); //idTest 即为基础参数 id 对应的值\n            // console.log(checkStatus.data);//获取选中行的数据\n            var data = checkStatus.data;\n\n            if (data.length == 0) {\n                layer.alert(&quot;请选中要删除的数据&quot;);\n            } else {\n                layer.confirm(&quot;确定要删除选中的所有数据&quot;, function (index) {\n                    //把所有选中的数据的id封装到一个数组中\n                    var ids = new Array(data.length);\n                    for (var i = 0; i &lt; ids.length; i++) {\n                        ids[i] = data[i].id;\n                    }\n                    console.log(&quot;ids===&quot; + ids);\n                    //执行删除操作\n                    $.ajax({\n                        url: &quot;${pageContext.request.contextPath}/prefixThird/deleteMany&quot;,\n                        data: &quot;ids=&quot; + ids,\n                        success: function (data) {\n                            //删除确认框关闭掉\n                            layer.close(index);\n                            //删除提示\n                            layer.alert(&quot;删除&quot; + data.msg+&quot;，请点击右上角刷新表格后生效！&quot;, {time: 2000});\n                            //刷新table\n                            // table.reload(&quot;Lay_back_table&quot;);\n                            // renderTable();\n                        }\n                    })\n                });\n            }\n        });\n    }\n\n\n&lt;/script&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:38:19', '2022-05-21 18:19:34');
INSERT INTO `tb_article` VALUES (116, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7439', 'CSDN-markdown编辑器 使用大全（备份记录快捷键使用方法）', '<p>﻿@<a href=\"这里写自定义目录标题\">TOC</a></p>\n<h1 id=\"欢迎使用markdown编辑器\">欢迎使用Markdown编辑器</h1>\n<p>你好！ 这是你第一次使用 <strong>Markdown编辑器</strong> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</p>\n<h2 id=\"新的改变\">新的改变</h2>\n<p>我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：</p>\n<ol>\n<li><strong>全新的界面设计</strong> ，将会带来全新的写作体验；</li>\n<li>在创作中心设置你喜爱的代码高亮样式，Markdown <strong>将代码片显示选择的高亮样式</strong> 进行展示；</li>\n<li>增加了 <strong>图片拖拽</strong> 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；</li>\n<li>全新的 <strong>KaTeX数学公式</strong> 语法；</li>\n<li>增加了支持<strong>甘特图的mermaid语法[^1]</strong> 功能；</li>\n<li>增加了 <strong>多屏幕编辑</strong> Markdown文章功能；</li>\n<li>增加了 <strong>焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置</strong> 等功能，功能按钮位于编辑区域与预览区域中间；</li>\n<li>增加了 <strong>检查列表</strong> 功能。<br />\n[^1]: <a href=\"https://mermaidjs.github.io/\">mermaid语法说明</a></li>\n</ol>\n<h2 id=\"功能快捷键\">功能快捷键</h2>\n<p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br />\n重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br />\n加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br />\n斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br />\n标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br />\n无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br />\n有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br />\n检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br />\n插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br />\n插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br />\n插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd><br />\n查找：<kbd>Ctrl/Command</kbd> + <kbd>F</kbd><br />\n替换：<kbd>Ctrl/Command</kbd> + <kbd>G</kbd></p>\n<h2 id=\"合理的创建标题有助于目录的生成\">合理的创建标题，有助于目录的生成</h2>\n<p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br />\n输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br />\n以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p>\n<h2 id=\"如何改变文本的样式\">如何改变文本的样式</h2>\n<p><em>强调文本</em> <em>强调文本</em></p>\n<p><strong>加粗文本</strong> <strong>加粗文本</strong></p>\n<p>==标记文本==</p>\n<p><del>删除文本</del></p>\n<blockquote>\n<p>引用文本</p>\n</blockquote>\n<p>H~2~O is是液体。</p>\n<p>2<sup>10</sup> 运算结果是 1024.</p>\n<h2 id=\"插入链接与图片\">插入链接与图片</h2>\n<p>链接: <a href=\"https://mp.csdn.net\">link</a>.</p>\n<p>图片: <img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw\" alt=\"Alt\" /></p>\n<p>带尺寸的图片: ![Alt](<a href=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw\">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw</a> =30x30)</p>\n<p>居中的图片: <img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center\" alt=\"Alt\" /></p>\n<p>居中并且带尺寸的图片: ![Alt](<a href=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center\">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center</a> =30x30)</p>\n<p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p>\n<h2 id=\"如何插入一段漂亮的代码片\">如何插入一段漂亮的代码片</h2>\n<p>去<a href=\"https://mp.csdn.net/configure\">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.</p>\n<pre><code class=\"language-javascript\">// An highlighted block\nvar foo = \'bar\';\n</code></pre>\n<h2 id=\"生成一个适合你的列表\">生成一个适合你的列表</h2>\n<ul>\n<li>项目\n<ul>\n<li>项目\n<ul>\n<li>项目</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>项目1</li>\n<li>项目2</li>\n<li>项目3</li>\n</ol>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;计划任务</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;完成任务</li>\n</ul>\n<h2 id=\"创建一个表格\">创建一个表格</h2>\n<p>一个简单的表格是这么创建的：<br />\n项目     | Value<br />\n-------- | -----<br />\n电脑  | $1600<br />\n手机  | $12<br />\n导管  | $1</p>\n<h3 id=\"设定内容居中居左居右\">设定内容居中、居左、居右</h3>\n<p>使用<code>:---------:</code>居中<br />\n使用<code>:----------</code>居左<br />\n使用<code>----------:</code>居右<br />\n| 第一列       | 第二列         | 第三列        |<br />\n|:-----------:| -------------:|:-------------|<br />\n| 第一列文本居中 | 第二列文本居右  | 第三列文本居左 |</p>\n<h3 id=\"smartypants\">SmartyPants</h3>\n<p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：<br />\n|    TYPE   |ASCII                          |HTML<br />\n|----------------|-------------------------------|-----------------------------|<br />\n|Single backticks|<code>\'Isn\'t this fun?\'</code>            |\'Isn\'t this fun?\'            |<br />\n|Quotes          |<code>&quot;Isn\'t this fun?&quot;</code>            |&quot;Isn\'t this fun?&quot;            |<br />\n|Dashes          |<code>-- is en-dash, --- is em-dash</code>|-- is en-dash, --- is em-dash|</p>\n<h2 id=\"创建一个自定义列表\">创建一个自定义列表</h2>\n<p>Markdown<br />\n:  Text-to-HTML conversion tool</p>\n<p>Authors<br />\n:  John<br />\n:  Luke</p>\n<h2 id=\"如何创建一个注脚\">如何创建一个注脚</h2>\n<p>一个具有注脚的文本。<a href=\"注脚的解释\">^2</a></p>\n<h2 id=\"注释也是必不可少的\">注释也是必不可少的</h2>\n<p>Markdown将文本转换为 HTML。</p>\n<p>*[HTML]:   超文本标记语言</p>\n<h2 id=\"katex数学公式\">KaTeX数学公式</h2>\n<p>您可以使用渲染LaTeX数学表达式 <a href=\"https://khan.github.io/KaTeX/\">KaTeX</a>:</p>\n<p>Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\forall<br />\nn\\in\\mathbb N$ 是通过欧拉积分</p>\n<p>$$<br />\n\\Gamma(z) = \\int_0<sup z-1=\"\">\\infty t</sup>e^{-t}dt,.<br />\n$$</p>\n<blockquote>\n<p>你可以找到更多关于的信息 <strong>LaTeX</strong> 数学表达式<a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\">here</a>.</p>\n</blockquote>\n<h2 id=\"新的甘特图功能丰富你的文章\">新的甘特图功能，丰富你的文章</h2>\n<div class=\"mermaid\">\ngantt\n        dateFormat  YYYY-MM-DD\n        title Adding GANTT diagram functionality to mermaid\n        section 现有任务\n        已完成               :done,    des1, 2014-01-06,2014-01-08\n        进行中               :active,  des2, 2014-01-09, 3d\n        计划一               :         des3, after des2, 5d\n        计划二               :         des4, after des3, 5d\n</div>\n<ul>\n<li>关于 <strong>甘特图</strong> 语法，参考 <a href=\"https://mermaidjs.github.io/\">这儿</a>,</li>\n</ul>\n<h2 id=\"uml-图表\">UML 图表</h2>\n<p>可以使用UML图表进行渲染。 <a href=\"https://mermaidjs.github.io/\">Mermaid</a>. 例如下面产生的一个序列图：</p>\n<div class=\"mermaid\">\nsequenceDiagram\n张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?\n李四--&gt;&gt;王五: 你最近怎么样，王五？\n李四--x 张三: 我很好，谢谢!\n李四-x 王五: 我很好，谢谢!\nNote right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.\n\n李四--&gt;&gt;张三: 打量着王五...\n张三-&gt;&gt;王五: 很好... 王五, 你怎么样?\n</div>\n<p>这将产生一个流程图。:</p>\n<div class=\"mermaid\">\ngraph LR\nA[长方形] -- 链接 --&gt; B((圆))\nA --&gt; C(圆角长方形)\nB --&gt; D{菱形}\nC --&gt; D\n</div>\n<ul>\n<li>关于 <strong>Mermaid</strong> 语法，参考 <a href=\"https://mermaidjs.github.io/\">这儿</a>,</li>\n</ul>\n<h2 id=\"flowchart流程图\">FLowchart流程图</h2>\n<p>我们依旧会支持flowchart的流程图：</p>\n<div class=\"mermaid\">\nflowchat\nst=&gt;start: 开始\ne=&gt;end: 结束\nop=&gt;operation: 我的操作\ncond=&gt;condition: 确认？\n\nst-&gt;op-&gt;cond\ncond(yes)-&gt;e\ncond(no)-&gt;op\n</div>\n<ul>\n<li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href=\"http://adrai.github.io/flowchart.js/\">这儿</a>.</li>\n</ul>\n<h2 id=\"导出与导入\">导出与导入</h2>\n<h3 id=\"导出\">导出</h3>\n<p>如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <strong>文章导出</strong> ，生成一个.md文件或者.html文件进行本地保存。</p>\n<h3 id=\"导入\">导入</h3>\n<p>如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，<br />\n继续你的创作。</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:38:37', '2020-04-25 15:38:37');
INSERT INTO `tb_article` VALUES (117, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1805', 'git从入门配置到常用基本命令，傻瓜式操作一步步命令总结', '<p>﻿### 1，git的下载安装<br />\n下载地址：<a href=\"https://git-scm.com/download/win\">git官方下载地址https://git-scm.com/download/win</a></p>\n<p>安装，双击安装包，一直不停的下一步就安装好了。</p>\n<p>检验是否安装成功：在电脑的任何位置 右键 Git Bash Here （打开Git命令窗口）</p>\n<h3 id=\"2配置本地git\">2，配置本地git</h3>\n<p>name是你自己的名字<br />\n邮箱要是你在github或者码云上注册的邮箱</p>\n<pre><code class=\"language-git\">git config --global user.name &quot;Your Name&quot;  \ngit config --global user.email &quot;email@example.com&quot;\n</code></pre>\n<h3 id=\"3基本命令\">3，基本命令</h3>\n<p>1，在自己电脑上创建一个文件夹，就是版本库<br />\n创建一个本地版本库  写一个文档  交给git管理（添加到本地版本库）</p>\n<p>2，进入文件夹内部， 右键 Git Bash Here （打开Git命令窗口）输入</p>\n<pre><code>git init \n</code></pre>\n<p>命令。初始化本地版本库。如果你的电脑不显示这个文件夹，请打开显示隐藏的项目，</p>\n<p>3，随便创建一个txt文件，添加test.tx文件到本地版本库</p>\n<p>添加当前文件夹 所有的文件 到暂存区</p>\n<pre><code>git add .\n</code></pre>\n<p>添加指定的文件</p>\n<pre><code>git add test.txt\n</code></pre>\n<p>将暂存区文件提交到本地版本库</p>\n<pre><code class=\"language-git\">git commit -m &quot;v1.0 写版本描述信息 必须写&quot;\n</code></pre>\n<p>查看所有的版本信息</p>\n<pre><code>git log   #查看日志 所有的版本信息\ngit reflog   #查看日志 所有的版本信息\n</code></pre>\n<p>区别</p>\n<ol>\n<li>git log 只显示当前版本 和 之前的所有的版本</li>\n<li>git reflog 显示所有版本 和 所有的操作信息</li>\n</ol>\n<p>更新文件，添加第二个版本</p>\n<pre><code>git add . \ngit commit -m &quot;v2.0 写版本信息 必须写&quot; \n</code></pre>\n<p>回到第一个版本</p>\n<pre><code>   git reset --hard HEAD^   ^回退一个版本 ^^回退100个版本\n   git reset --hard HEAD~100 回退100个版本\n</code></pre>\n<p>再从版本1 回到 版本2</p>\n<pre><code>git reset --hard 版本的编号（不需要写全 5 6位数字就可以）\n</code></pre>\n<p>如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826204103589.png\" alt=\"在这里插入图片描述\" /></p>\n<h3 id=\"版本库的结构\">版本库的结构</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20190826204236680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>查看当前版本库和工作区的文件状态</strong></p>\n<p>git status</p>\n<ol>\n<li>文件 显示红色 文件中有修改  没有做添加 也没有提交<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826204404213.png\" alt=\"在这里插入图片描述\" /></li>\n<li>文件 显示绿色 文件添加了 位于暂存区 没有提交<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826204445349.png\" alt=\"在这里插入图片描述\" /></li>\n<li>没有文件需要提交<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826204509671.png\" alt=\"在这里插入图片描述\" /></li>\n</ol>\n<p><strong>版本撤销</strong></p>\n<p>git checkout  版本撤销</p>\n<ol>\n<li>文件没有添加到暂存区 红色状态  会删除所有新增的内容</li>\n<li>文件添加到暂存区之后 新增的内容是撤销不了的</li>\n</ol>\n<h2 id=\"本地git-集成码云\">本地git 集成码云</h2>\n<ol>\n<li>注册码云</li>\n<li>在本地电脑执行命令生成SSH公钥 输入命令一直回车<br />\n获取公钥命令，然后一直回车就好</li>\n</ol>\n<pre><code>       ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot; \n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190826205114559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\nid_rea是秘钥，不要轻易给别人<br />\nid_rea.pub 公钥，给谁无所谓</p>\n<p>3，在码云配置公钥<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826205234866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>仓库相关的操作</strong></p>\n<ol>\n<li>创建一个仓库<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826205324719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n将整个仓库 克隆（下载） 到本地<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826205347200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></li>\n</ol>\n<p>复制 SSH 连接<br />\n在本地执行克隆的命令</p>\n<pre><code>git clone 粘贴你负责的ssh连接\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190826205439777.png\" alt=\"在这里插入图片描述\" /><br />\n<strong>将之前测试的本地文件推送到远程仓库：</strong></p>\n<pre><code>git add .\ngit commit -m &quot;v2.0 test&quot;\ngit push\n</code></pre>\n<p>在远程写一个文件  更新到本地</p>\n<pre><code>git pull\n</code></pre>\n<h2 id=\"分支的使用\">分支的使用</h2>\n<h5 id=\"常用分支命令\">常用分支命令</h5>\n<pre><code>查看分支,查看当前拥有多少个分支\n	git branch  \n\n创建分支 \n	git branch 要创建的分支的名称  \n\n切换分支 \n	git checkout 要去往的分支名称\n</code></pre>\n<p><strong>删除分支</strong>,慎用，不要轻易删除分支<br />\ngit branch -d 分支名<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826210311773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" />	<br />\n<strong>开发的时候用到的dev分支</strong></p>\n<pre><code>git checkout -b dev // 创建并切换到dev分支\n\ngit push --set-upstream origin dev // 将dev分支推送到远程仓库\n</code></pre>\n<p><strong>合并dev分支至master</strong></p>\n<pre><code>git checkout master // 切换到master分支\n\ngit merge dev // 合并dev分支到当前分支（master）\n</code></pre>\n<h5 id=\"在idea中使用git遇到的一个问题\">在idea中使用Git遇到的一个问题</h5>\n<p>报错：</p>\n<blockquote>\n<p>Push rejected: Push to origin/master was rejected</p>\n</blockquote>\n<p>意思是git拒绝合并两个不相干的东西<br />\n此时你需要在打开Git Bash，然后进入相应的目录，然后敲git命令</p>\n<pre><code>$ git pull origin master --allow-unrelated-histories\n</code></pre>\n<p>出现类似于这种信息就说明pull成功了：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190827191650505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n然后再执行push命令。就可以成功了！</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:39:22', '2022-05-21 18:19:23');
INSERT INTO `tb_article` VALUES (118, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8188', 'SpringBoot集成shiro认证，实现Shiro认证的登录操作', '<p>﻿### 什么是Shiro权限管理？</p>\n<blockquote>\n<p>Apache Shiro 是 Java 的一个安全框架。目前，使用 Apache Shiro 的人越来越多，因为它相 当简单，对比<br />\nSpring Security，可能没有 Spring Security 做的功能强大，但是在实际工作时<br />\n可能并不需要那么复杂的东西，所以使用小而简单的 Shiro 就足够了。对于它俩到底哪个 好，这个不必纠结，能更简单的解决项目问题就好了。</p>\n</blockquote>\n<p>权限管理分为认证和授权</p>\n<h1 id=\"认证\">认证</h1>\n<h4 id=\"认证的基本概念\">认证的基本概念</h4>\n<p>身份认证：校验用户是不是系统合法用户的过程（比如登录操作）</p>\n<blockquote>\n<p><strong>身份认证，就是判断一个用户是否为合法用户的处理过程</strong>。</p>\n<p><strong>最常用的简单身份认证方式是系统通过核对用户输入的用户名和密码，看其是否与系统中存储的该用户的用户名和密码是否一致，来判断用户身份是否正确。</strong></p>\n<p>对于采用指纹等系统，则出示指纹；对于硬件Key等刷卡系统，则需要刷卡。通过二维码等等都是认证的过程</p>\n</blockquote>\n<h4 id=\"认证基本的对象\">认证基本的对象</h4>\n<h5 id=\"subject-主体\">Subject 主体</h5>\n<p>官方给出的解释是这样的：</p>\n<blockquote>\n<p>Without question, the most important concept in Apache Shiro is the Subject. ‘Subject’ is just a security term that means a security-specific ‘view’ of an application user. A Shiro Subject instance represents both security state and operations for a single application user.<br />\n翻译过来就是：<br />\n毫无疑问，<strong>shiro中最重要的概念就是subject（主体）</strong>。subject是一个虚拟的用户对象（就是相当于我们之前的User Admin对象等）。</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20190825173535988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>使用Subject的之后的流程变化</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190825173552565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>其实，<br />\n<strong>Subject可以认为就是Admin  User这些类</strong><br />\n另外subject中还有两个重要概念：</p>\n<blockquote>\n<p><strong>Credential 凭证信息  就是密码的意思</strong></p>\n<p><strong>Principal 身份信息 就是账号的意思</strong></p>\n</blockquote>\n<p>扩展阅读：（看一下官方的解释为什么叫Subject而不叫User）</p>\n<blockquote>\n<p>We originally wanted to call it ‘User’ since that “just makes sense”, but we decided against it: too many applications have existing APIs that already have their own User classes/frameworks, and we didn’t want to conflict with those. Also, in the security world, the term ‘Subject’ is actually the recognized nomenclature.<br />\n翻译如下：<br />\n我们最初是想把它叫做User的，这样很容易理解，但是大部分的应用程序都已经有了User类，为了不和这些原有的api发生冲突，我们最后决定不这么做。</p>\n</blockquote>\n<h4 id=\"认证的登录操作案例springboot集成shiro\">认证的登录操作案例：SpringBoot集成shiro</h4>\n<p>下面开始使用Shiro实现带认证的登录操作</p>\n<h6 id=\"导入依赖\">导入依赖</h6>\n<pre><code class=\"language-xml\">&lt;!--shiro相关依赖--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;\n    &lt;version&gt;1.3.2&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;\n    &lt;version&gt;1.3.2&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;\n    &lt;version&gt;1.3.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h5 id=\"第一个demo\">第一个demo</h5>\n<p>基本思路</p>\n<blockquote>\n<p>用户输入的账号密码  和 数据库中存储的账号密码 比对</p>\n<p>注意：shiro 默认不支持连接数据库  默认通过配置文件获取数据<br />\n所以我们要重写Realm中的方法，实现对数据库的连接</p>\n</blockquote>\n<ol>\n<li>接收用户输入的账号密码,</li>\n<li>要重写Realm中的方法，实现对数据库的连接和数据获取</li>\n<li>写Springboot的配置类，创建并将重写的Realm设置放进去安全管理器， 将安全管理器 和Subject建立联系</li>\n<li>将用户输入的账号密码给Subject</li>\n<li>调用Subject的login方法完成登录</li>\n</ol>\n<p><strong>代码实现流程</strong></p>\n<h6 id=\"重写realm的代码\">重写Realm的代码</h6>\n<pre><code class=\"language-java\">package com.macw.realm;\n\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.macw.entity.Admin;\nimport com.macw.mapper.AdminMapper;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.*;\nimport org.apache.shiro.realm.AuthenticatingRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Resource;\n\n/**\n * @author maCw\n * @version 1.0\n * @date 2019/8/22 16:13\n */\n\npublic class MyRealm extends AuthenticatingRealm {\n\n    @Resource\n    private AdminMapper adminMapper;\n    /**\n     * 记录日志\n     */\n    Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        //1，获取令牌中的数据，账号\n        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;\n        String username = token.getUsername();\n        //2，通过账号查询获取数据库中对应的账号信息\n        Admin admin = adminMapper.selectOne(new QueryWrapper&lt;Admin&gt;().eq(&quot;username&quot;, username));\n        logger.info(&quot;---&quot;+admin);\n        Subject subject = SecurityUtils.getSubject();\n        //将查询的对象放进去subject自带的session中去\n        subject.getSession().setAttribute(&quot;admins&quot;, admin);\n        //如果有数据，对象为非null，说明查询到了数据，封装account返回\n        if (admin != null){\n            SimpleAccount simpleAccount = new SimpleAccount(admin.getUsername(), admin.getPassword(), this.getName());\n            return simpleAccount;\n        }else {\n            //如果对象为空，return null就会抛出账户不存在异常\n            return null;\n        }\n    }\n}\n\n</code></pre>\n<h5 id=\"在springboot中配置shiro\">在SpringBoot中配置shiro</h5>\n<pre><code class=\"language-java\">package com.macw.config;\n\nimport com.macw.realm.MyRealm;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.spring.web.ShiroFilterFactoryBean;\nimport org.apache.shiro.web.config.WebIniSecurityManagerFactory;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.Map;\n\n\n/**\n * @Configuration 标记当前类为配置类  相当于spring.xml\n */\n@Configuration\npublic class ShiroConfig {\n\n    /**\n     * @Bean 声明创建对象  并把对象放在工厂中  相当于bean标签\n     * 如果形参类型对应的对象在工厂中有  会自动装配上\n     * @return\n     */\n    @Bean\n    public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultSecurityManager defaultSecurityManager){\n        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\n        /**\n         * 过滤器链 过滤拦截规则 哪些页面拦截  哪些页面不拦截\n         */\n        Map map = new HashMap();\n        /**\n         * anon 代表匿名可访问 就是不用登录就可以访问  登录页面  登录的url\n         * authc 认证可访问 代表登录后才能访问\n         *\n         * 支持通配符*\n         * 注意拦截规则 一个一个配置\n         */\n        map.put(&quot;/login.jsp&quot;,&quot;anon&quot;);\n        map.put(&quot;/login/*&quot;,&quot;anon&quot;);\n\n        map.put(&quot;/main/*&quot;, &quot;authc&quot;);\n        map.put(&quot;/guru/*&quot;, &quot;authc&quot;);\n        map.put(&quot;/menu/*&quot;, &quot;authc&quot;);\n\n        shiroFilterFactoryBean.setFilterChainDefinitionMap(map);\n\n        /**\n         * 设置安全管理器，将创建的安全管理器放进shiroFilterFactoryBean过滤工厂里面\n         */\n        shiroFilterFactoryBean.setSecurityManager(defaultSecurityManager);\n        return shiroFilterFactoryBean;\n    }\n\n    /**\n     * 创建安全管理器,并将自定义的Realm放进去管理器\n     * @return\n     */\n    @Bean\n    public DefaultSecurityManager getDefaultSecurityManager(MyRealm myRealm){\n        DefaultSecurityManager defaultSecurityManager = new DefaultWebSecurityManager();\n//        需要赋值一个Realm\n        defaultSecurityManager.setRealm(myRealm);\n        return defaultSecurityManager;\n    }\n\n    /**\n     * 创建自定义的Realm\n     */\n    @Bean\n    public MyRealm getMyRealm(){\n        return new MyRealm();\n    }\n}\n</code></pre>\n<p>如果引用到其他项目的话这里需要修改的是 拦截规则  和  自定义的Realm</p>\n<h5 id=\"修改原来的登录方法\">修改原来的登录方法</h5>\n<p>在控制器里的登录方法中修改：</p>\n<pre><code class=\"language-java\">    /**\n     * 使用shiro登录\n     * @param username\n     * @param password\n     * @return\n     */\n    @RequestMapping(&quot;adminLogin&quot;)\n    public String adminLogin(String username,String password){\n//        1.将用户输入的账号密码 封装在token中\n        UsernamePasswordToken token = new UsernamePasswordToken(username, password);\n\n//        2.获取Subject\n        Subject subject = SecurityUtils.getSubject();\n\n//        3.通过Subject 的login方法 完成登录\n        try {\n            subject.login(token);\n            //到这里如果没有异常说明登录成功，\n            return &quot;redirect:/main/main.jsp&quot;;\n        }catch (Exception e){\n            //有异常说明登录失败，重定向到登录页面\n            return &quot;redirect:/login.jsp&quot;;\n        }\n    }\n</code></pre>\n<h5 id=\"shiro中session的使用\">shiro中Session的使用</h5>\n<p><strong>方案1：HttpSession</strong></p>\n<p><strong>方案2：shiro中的session</strong></p>\n<pre><code>Session session1 = SecurityUtils.getSubject().getSession();\n</code></pre>\n<p>注意：方案1  和 方案2 都可以 使用  但是只能使用一种方案  不要混合使用</p>\n<h4 id=\"登录认证总结\">登录认证总结</h4>\n<p><strong>认证：登录，身份认证，校验用户是不是系统合法用户的过程</strong></p>\n<p><strong>主体Subject：就是Admin，User这些类，但是和之前自己定义的User Admin稍以后区别，Subject不仅封装用户和认证相关的数据（账号密码），还封装了和认证相关的方法（login方法）</strong></p>\n<p><strong>Credential 凭证信息  就是密码的意思</strong></p>\n<p><strong>Principal 身份信息 就是账号的意思</strong></p>\n<p><strong>重写Realm中的方法</strong></p>\n<ol>\n<li>\n<p><strong>为什么要重写Realm中的方法</strong></p>\n<p><strong>默认不支持连接数据库  默认的实现是查询配置文件</strong></p>\n</li>\n<li>\n<p><strong>解决方案</strong></p>\n<p><strong>shiro默认的doGetAuthenticationInfo方法是查询配置文件，由于这个方法是父类的一个抽象方法，通过继承和多态，可以继承父类，覆盖这个方法（在方法中写入我们新的方法实现 连接数据库 查询数据库中的账号信息）</strong></p>\n</li>\n</ol>\n<p><strong>集成项目的基本流程</strong></p>\n<ol>\n<li>\n<p>写shiro的配置类（创建对象）</p>\n<p><strong>注意：拦截规则 和 自定义的Realm 需要根据自己项目的情况调整</strong></p>\n</li>\n<li>\n<p>修改原来的登录方法</p>\n</li>\n</ol>\n', 1, '', 0, 0, 1, '2020-04-25 15:39:42', '2022-05-21 18:18:00');
INSERT INTO `tb_article` VALUES (119, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4252', '详解Redis，Redis缓存，Redis分布式锁', '<p>﻿</p>\n<h3 id=\"1redis基本知识\">1、Redis基本知识</h3>\n<h4 id=\"简介\">简介</h4>\n<p>Redis是一个支持网络、基于内存、可选持久性的NoSql数据库，目前在很多的系统中都使用了Redis，尤其是在实现缓存功能的时候应用的尤其广泛（缓存功能也是很多人对Redis的认识），那么Redis到底有哪些优点和缺点，为什么会被广泛应用呢？</p>\n<h4 id=\"redis的优点\">Redis的优点</h4>\n<p>Redis的第一个优点就是<strong>速度快</strong>，Redis使用C语言实现，基于内存，数据的读写效率非常的高，这也是为什么很多系统的缓存功能使用Redis来实现，<em><strong>但是需要明确的是Redis是一个数据库，缓存只是它的一项应用而已。</strong></em></p>\n<p>Redis的第二个优点是<strong>单线程模型</strong>，所谓单线程模型就是每一个请求都会有一个全新的线程来进行处理，这一点类似于Struts2，每一个请求都会有一个新的线程来进行处理。这样做的好处就是避免了线程频繁切换带来的系统开销，同时也避免了让人头疼的多线程问题。</p>\n<p>Redis的第三个优点就是使用了<strong>非阻塞I/O</strong> （NIO），不在网络上浪费时间，进一步提高了效率。</p>\n<p>Redis的第四个优点就是支持多种的<strong>数据类型</strong>，并且每一种数据类型都提供了丰富的操作命令，适用于很多特殊的场景，并且支持自定义命令创建个性化的操作命令。</p>\n<h2 id=\"2redis持久化机制\">2、redis持久化机制</h2>\n<p>redis服务器宕机，内存数据是会丢失了，为了保证数据不丢失需要对数据做备份，所备份就是持久化，Redis的持久化即将内存中的数据同步到硬盘，主要包括两种方式RDB、AOF。</p>\n<p><strong>RDB持久化机制，(默认使用)</strong>：做当前内存数据的全本快照，<br />\n将内存中的数据以快照的方式写入到二进制文件dump.rdb,<br />\n在redis.conf中可以设置发起快照保存的条件。在指定的时间内如果有超过指定数量的key被修改，则会发起快照保存。</p>\n<p>这种方式在数据的实时性上不高，在突然断电的情况下，可能会出现部分数据的丢失，即最后一次快照之后在内存中发生修改的数据。</p>\n<p>简单来说：RDB就是将redis上的所有数据做个备份，存储的是二进制的数据。</p>\n<p><strong>AOF持久化机制，(默认是关闭)</strong>：</p>\n<p>AOF是将Redis内存数据库中更改的数据都记录到指定的文件appendonly.aof。在redis.conf中可以进行写磁盘的相关设置。</p>\n<p>在突然断电的情况下，由于在appendonly.aof中保存了最后一次写磁盘之后redis内存发生数据修改的指令，所以在这个Redis重启后，基本不会发生数据丢失，比RDB具有更好的数据安全性。</p>\n<p>appendfsync always   接收到更改数据的命令，立即将其记录到appendonly.aof中，能保证数据持久化，数据完全不丢失，但效率相对最低。</p>\n<p>appendfsync everysec   每秒钟将redis内存数据修改的命令记录到appendonly.aof中，在性能和持久化上做了折中。因频繁执行磁盘操作，在仅存在单个Master执行写操作时，效率可能存在问题。但在多个Master执行写操作的Redis集群中，效率会提升。</p>\n<p>appendfsync no  依赖于操作系统，因不会频繁执行磁盘操作而性能最好，但redis内存数据修改持久化没有保证，无法保证数据可靠性</p>\n<p><strong>如何开启AOF持久化：</strong><br />\n将redis.conf文件中 appendonly 改成 yes ，自动创建appendonly.aof，该文件存储的客户端执行过<strong>增删改操作的命令</strong></p>\n<br/>\n<h3 id=\"3-redis的数据结构\">3、 Redis的数据结构</h3>\n<p>redis数据库存储数据使用的key-value，键值对方式存储<br />\nkey是string类型 value的数据结构支持5个string、set、sorted_set、list、hash<br />\n<img src=\"https://img-blog.csdnimg.cn/20190820092223845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"4redis-的常用命令\">4、Redis 的常用命令</h4>\n<h5 id=\"string可以存数字\">String(可以存数字)</h5>\n<p>可以实现原子性的自增（数据安全）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820092339194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>这是最基本的类型了，没啥可说的，就是普通的set和get，做简单的k-v缓存</p>\n<h5 id=\"hash\">hash</h5>\n<p>这个是类似map的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在redis里，然后每次读写缓存的时候，可以就操作hash里的某个字段。</p>\n<pre><code>key=150\n\n\n\nvalue={\n\n “id”: 150,\n\n “name”: “zhangsan”,\n\n “age”: 20\n\n}\n\n</code></pre>\n<p>hash类的数据结构，主要是用来存放一些对象，把一些简单的对象给缓存起来，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值</p>\n<pre><code>value={\n\n “id”: 150,\n\n “name”: “zhangsan”,\n\n “age”: 21\n\n}\n\n</code></pre>\n<h5 id=\"list\">list</h5>\n<p>有序列表，这个是可以玩儿出很多花样的</p>\n<p>微博，某个大v的粉丝，就可以以list的格式放在redis里去缓存</p>\n<pre><code>key=某大v\n\nvalue=[zhangsan, lisi, wangwu]\n\nkey=书名\n\nvalue=[评论1, 评论2, 评论3]\n</code></pre>\n<p>比如可以通过list存储一些列表型的数据结构，类似粉丝列表了、文章的评论列表了之类的东西</p>\n<p>比如可以通过<strong>lrange命令</strong>，就是从某个元素开始读取多少个元素，可以基于list实现分页查询，这个很棒的一个功能，基于redis实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走</p>\n<p>比如可以搞个简单的消息队列，从list头怼进去，从list尾巴那里弄出来</p>\n<h5 id=\"set\">set</h5>\n<p>无序集合，自动去重</p>\n<p>直接基于set将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于jvm内存里的HashSet进行去重，但是如果你的某个系统部署在多台机器上呢？</p>\n<p>得基于redis进行全局的set去重</p>\n<p>可以基于set玩儿交集、并集、差集的操作，比如交集吧，可以把两个人的粉丝列表整一个交集，看看俩人的共同好友是谁？对吧</p>\n<p>把两个大v的粉丝都放在两个set中，对两个set做交集</p>\n<h5 id=\"sorted-set-跳表\">sorted set 跳表</h5>\n<p>排序的set，去重但是可以排序，写进去的时候给一个分数，自动根据分数排序，这个可以玩儿很多的花样，最大的特点是有个分数可以自定义排序规则</p>\n<p>比如说你要是想根据时间对数据排序，那么可以写入进去的时候用某个时间作为分数，人家自动给你按照时间排序</p>\n<p>排行榜：将每个用户以及其对应的什么分数写入进去，zadd board score username，接着zrevrange board 0 99，就可以获取排名前100的用户；zrank board username，可以看到用户在排行榜里的排名</p>\n<p><strong>总结：优先掌握 String 即可</strong><br />\n<br/></p>\n<h4 id=\"5数据失效时间\">5、数据失效时间</h4>\n<p>场景：</p>\n<p>手机验证码登录  手机验证码注册</p>\n<p>验证码后台生成  Redis</p>\n<ol>\n<li>集中存储</li>\n<li>可以设置过期时间</li>\n</ol>\n<pre><code>验证码  \n\nkey = 手机号 \nvalue = 验证码  \n\n设置3分钟过期\n</code></pre>\n<p>Redis中可以设置数据的存活时间</p>\n<p>命令</p>\n<pre><code>expire key 存活时间的秒\nttl key 查看key对应的数据的存活时间.\npexipre key 存活时间的毫秒\npttl key 查看key对应的数据的存活时间,毫秒单位\n</code></pre>\n<p><strong>expire key 存活时间的秒</strong></p>\n<p>失效的原理</p>\n<ol>\n<li>\n<p><strong>定期随机删除+惰性删除</strong></p>\n<pre><code>key  \n1    1分钟\n2    1分钟  \n3    1分钟\n4    1分钟\n5\n6\n\nredis 每过100ms 随机抽取一定数量的设置了失效时间的key 将过期的删除\n\n有些key过期了 每次都没有随机到  就一直删不掉  怎么办？\n\n惰性删除 get key 的时候 先判断 key是否过期 如果过期 返回数据为空\n\n</code></pre>\n<p>定期随机删除  例如100ms</p>\n<p>查询的时候 先检查key</p>\n</li>\n<li>\n<p><strong>内存淘汰机制</strong></p>\n<p>如果redis的内存占用过多的时候，此时会进行内存淘汰，有如下一些策略：</p>\n<p>redis 10个key，现在已经满了，redis需要删除掉5个key</p>\n<p>1个key，最近1分钟被查询了100次</p>\n<p>1个key，最近10分钟被查询了50次</p>\n<p>1个key，最近1个小时被查询了1次</p>\n<ol>\n<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了</li>\n<li><strong>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</strong></li>\n<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊</li>\n<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）</li>\n<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key</li>\n<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除</li>\n</ol>\n<p>LRU算法  扩展视野</p>\n</li>\n</ol>\n<br/>\n<h4 id=\"6redis的基本应用\">6、Redis的基本应用！！！</h4>\n<h5 id=\"二级缓存\">二级缓存</h5>\n<ol>\n<li>\n<p>为什么要做缓存</p>\n</li>\n<li>\n<p>缓存的选择（二级缓存）</p>\n</li>\n<li>\n<p>二级缓存的基本概念</p>\n<ol>\n<li>是什么</li>\n<li>如何开启</li>\n</ol>\n</li>\n<li>\n<p>二级缓存的缺点</p>\n</li>\n<li>\n<p>使用Redis集成二级缓存的步骤</p>\n<ol>\n<li>实现cache接口</li>\n</ol>\n</li>\n</ol>\n<p><strong>缓存的作用</strong></p>\n<ol>\n<li>数据从内存获取,提升数据获取速度.</li>\n<li>减轻了数据库读操作的访问压力(数据基本不变)</li>\n</ol>\n<p><strong>MyBatis二级缓存机制(开启)</strong></p>\n<p>机制：</p>\n<ol>\n<li>\n<p>Java本地缓存空间.(jar)</p>\n</li>\n<li>\n<p>mybaits事务提交后操作缓存</p>\n</li>\n<li>\n<p>Mybatis根据Mapper文件的namespace划分多个缓存空间.</p>\n</li>\n<li>\n<p>mybatis会将查询语句执行结果,缓存在 sql所在mapper文件对应的namespace对应的缓存空间中.</p>\n<p>会将执行的查询sql(对sql处理后产生的对象)作为key.</p>\n</li>\n<li>\n<p>MyBatis执行DML,在事务提交之后,默认清空当前sql所在的mapper文件对应的namespace对应的缓存空间中</p>\n<p>A Mapper   User表  脏读</p>\n<p>B Mapper   User表  删除  缓存清空</p>\n<p>缓存空间融合</p>\n<ol>\n<li><strong>所有关于User表的操作都写在一个Mapper中</strong></li>\n<li>Mapper配置 融合缓存空间（基本没有人使用）</li>\n<li>第三方的缓存空间\n<ol>\n<li>ehcache</li>\n<li><strong>Redis</strong></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093046989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>MyBatis缓存实现原理(源码)</strong></p>\n<p><code>org.apache.ibatis.cache.impl.PerpetualCache.class</code></p>\n<ol>\n<li>\n<p>根据namepace划分缓存空间(id)</p>\n</li>\n<li>\n<p>MyBatis二级缓存本质是一个Map结构</p>\n<p>key :和执行的sql先关</p>\n<p>value:查询结果相关</p>\n</li>\n<li>\n<p>存放数据的功能: select语句(key)----查询结果(value)</p>\n</li>\n<li>\n<p>获得数据的功能: 根据key</p>\n</li>\n<li>\n<p>清空缓存的功能: clear</p>\n</li>\n<li>\n<p>MyBatis管理每个缓存,使用Map管理 key:id(namespace)  value:PerpetualCache</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093242240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>MyBatis缓存的问题?(缓存数据量不能太多)</strong></p>\n<ol>\n<li>mybatis缓存在tomcat的jvm内部分配的缓存空间.</li>\n<li>缓存数据过多,挤占java运行期间需要的内存.</li>\n</ol>\n<p>解决办法:</p>\n<p>将Mybatis的二级缓存空间转移到Redis数据库中</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093258936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>Mybatis二级缓存空间划分</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093309465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>Redis缓存空间的划分设计</strong></p>\n<p>核心:</p>\n<ol>\n<li>每个缓存空间是一个map</li>\n<li>每个缓存空间对应一个namespace.(管理多个cache空间)</li>\n</ol>\n<p>方案:</p>\n<ol>\n<li>将mybatis的namespace作为redis的key</li>\n<li>将key对应的value作为hash数据结构使用.(替换PerpetualCache)</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093323489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>自定义Redis缓存实现</strong></p>\n<p><strong>自定义缓存实现类</strong></p>\n<ol>\n<li>\n<p>自定义MyBatis二级缓存</p>\n<ol>\n<li>自定缓存类实现Cache接口</li>\n<li>导入redis操作相关的工具(jar,JedisUtil,jedis.properties)</li>\n<li>必须具备如下功能:</li>\n</ol>\n</li>\n<li>\n<p>根据namepace划分缓存空间(id)</p>\n</li>\n<li>\n<p>MyBatis二级缓存本质是一个Map结构</p>\n<p>key :和执行的sql先关</p>\n<p>value:查询结果相关</p>\n</li>\n<li>\n<p>存放数据的功能: select语句(key)----查询结果(value)</p>\n</li>\n<li>\n<p>获得数据的功能: 根据key</p>\n</li>\n<li>\n<p>清空缓存的功能: clear</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093345829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>使用自定义的缓存</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093414993.png\" alt=\"在这里插入图片描述\" /></p>\n<h5 id=\"session共享\">Session共享</h5>\n<p><strong>为何要实现session共享？</strong></p>\n<p>nginx负载均衡,希望兼顾权重的按照硬件性能分配访问压力的优势,又想保证多个tomcat使用同一个session应该怎么解决？<br />\n<img src=\"https://img-blog.csdnimg.cn/20190820093754832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>ip_hash</li>\n<li>session复制</li>\n<li>Redis</li>\n</ol>\n<p><strong>解决方案</strong></p>\n<p>使用redis管理负载均衡中多个tomcat的session.(Redis共享session)</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093811946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>如何实现Redis管理Session</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093611617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>配置步骤</strong></p>\n<ol>\n<li>tomcat使用redis管理session的jar</li>\n</ol>\n<p>将jar拷贝tomcat中lib</p>\n<ol start=\"2\">\n<li>配置tomcat的session管理方式为RedisSessionManager</li>\n</ol>\n<pre><code class=\"language-xml\">1. tomcat 配置文件context.xml\n\n&lt;!--注册session管理工具--&gt;\n&lt;Manager className=&quot;session管理工具全类名&quot;\n         host=&quot;redis的ip地址&quot;\n         port=&quot;端口&quot;\n         maxInactiveInterval=&quot;session存活时间 秒 1800&quot; 秒\n         /&gt;\n\n&lt;!--将session管理工具使用在tomcat操作过程中--&gt;\n&lt;Valve className=&quot;RedisSessionHandlerValve在tomcat中使用session管理工具&quot;/&gt;\n</code></pre>\n<p><strong>重启两个tomcat</strong></p>\n<h4 id=\"缓存问题\">缓存问题</h4>\n<ol>\n<li>\n<p>缓存穿透</p>\n</li>\n<li>\n<p>缓存雪崩</p>\n<pre><code>User\n\n根据主键查询 \n\nkey\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n1W  -id  缓存中都没有 \n\n2000个查询  每秒 可以认为是安全的\n</code></pre>\n</li>\n</ol>\n<h5 id=\"缓存穿透\">缓存穿透</h5>\n<p>缓存击穿  大量不存在的key攻击</p>\n<p>只需要极少的空间就可以判断一个元素是不是在一个集合之内，这正好是我们所需要的场景啊：判断key是否存在<br />\n<img src=\"https://img-blog.csdnimg.cn/2019082009405750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n解决方案</p>\n<ol>\n<li>\n<p>空值缓存 （非恶意攻击）</p>\n<pre><code>key  value\n-1   null\n</code></pre>\n</li>\n<li>\n<p>布隆过滤器</p>\n<p>可以判断key是否在数据库中存在</p>\n<p>缺点：可能会判断出错 概率不高 但是会</p>\n</li>\n</ol>\n<h5 id=\"缓存雪崩\">缓存雪崩</h5>\n<p>微博</p>\n<pre><code>key = 鹿晗微博1  value = 相关信息 评论  追评 点赞 等\nkey = 鹿晗微博2  value = 相关信息 评论  追评 点赞 等\nkey = 鹿晗微博3  value = 相关信息 评论  追评 点赞 等\nkey = 鹿晗微博4  value = 相关信息 评论  追评 点赞 等\nkey = 鹿晗微博5  value = 相关信息 评论  追评 点赞 等\nkey = 吃瓜群众1 \nkey = 吃瓜群众2 \nkey = 吃瓜群众3 \nkey = 吃瓜群众4 \nkey = 吃瓜群众5\n\n上千万key 这些key一定会设置失效 失效时间设置的不合理  同一时间大量key过期了（500W）  如果发生在平时 无所谓\n不巧的是  上热搜了 突然间 大量的用户来访问 相关的信息\n</code></pre>\n<p>大量key同一时间失效 将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820094117131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>大量流量  且数据失效  导致不存在的数据每次请求都要到存储层去查询  一模一样的SQL   数据库崩溃</p>\n<ol>\n<li>合理的设置过期时间  单体架构</li>\n<li>分布式锁</li>\n<li>多级缓存</li>\n</ol>\n<p>分布式的锁，谁获得了这把锁，谁就可以访问数据库</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820094139437.png\" alt=\"在这里插入图片描述\" /></p>\n<p>大型项目中</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820094222330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>如果说用户查不到数据  降级服务</p>\n<ol>\n<li>先等着  两三秒</li>\n<li>能直接  返回固定数据</li>\n<li>等等</li>\n</ol>\n<h3 id=\"7redis-分布式锁\">7、Redis 分布式锁</h3>\n<h4 id=\"什么是分布式锁\">什么是分布式锁</h4>\n<p>一种逻辑处理</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820094239766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"redis-分布式锁\">Redis 分布式锁</h4>\n<p>分布式锁本质上要实现的目标就是在 Redis 里面占一个“茅坑”，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。</p>\n<p>占坑一般是使用 <strong>setnx(set if not exists) 指令</strong>，只允许被一个客户端占坑。先来先占， 用完了，再调用 del 指令释放茅坑。</p>\n<pre><code>// 这里的冒号:就是一个普通的字符，没特别含义，它可以是任意其它字符，不要误解\n&gt; setnx lock:codehole true\nOK\n... do something critical ...\n&gt; del lock:codehole\n(integer) 1\n</code></pre>\n<p>但是有个问题，如果逻辑执行到中间出现异常了，可能会导致 del 指令没有被调用，这样就会陷入死锁，锁永远得不到释放。</p>\n<p>于是我们在拿到锁之后，再给<strong>锁加上一个过期时间</strong>，比如 5s，这样即使中间出现异常也可以保证 5 秒之后锁会自动释放。</p>\n<pre><code>&gt; setnx lock:codehole true\nOK\n&gt; expire lock:codehole 5\n... do something critical ...\n&gt; del lock:codehole\n(integer) 1\n</code></pre>\n<p>但是以上逻辑还有问题。如果在 setnx 和 expire 之间服务器进程突然挂掉了，可能是因为机器掉电或者是被人为杀掉的，就会导致 expire 得不到执行，也会造成死锁。</p>\n<p>这种问题的根源就在于 setnx 和 expire 是两条指令而不是原子指令。如果这两条指令可以一起执行就不会出现问题。也许你会想到用 Redis 事务来解决。但是这里不行，因为 expire 是依赖于 setnx 的执行结果的，如果 setnx 没抢到锁，expire 是不应该执行的。事务里没有 if-else 分支逻辑，事务的特点是一口气执行，要么全部执行要么一个都不执行。</p>\n<p>为了解决这个疑难，Redis 开源社区涌现了一堆分布式锁的 library，专门用来解决这个问题。实现方法极为复杂，小白用户一般要费很大的精力才可以搞懂。如果你需要使用分布式锁，意味着你不能仅仅使用 Jedis 或者 redis-py 就行了，还得引入分布式锁的 library。</p>\n<p><strong>为了治理这个乱象，Redis 2.8 版本中作者加入了 set 指令的扩展参数，使得 setnx 和 expire 指令可以一起执行，彻底解决了分布式锁的乱象。从此以后所有的第三方分布式锁 library 可以休息了。</strong></p>\n<pre><code>&gt; set lock:codehole true ex 5 nx\nOK\n... do something critical ...\n&gt; del lock:codehole\n</code></pre>\n<p>上面这个指令就是 setnx 和 expire 组合在一起的原子指令，它就是分布式锁的奥义所在。</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:40:11', '2022-05-21 18:17:42');
INSERT INTO `tb_article` VALUES (120, 1, 4, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=146', 'Java随机生成【用户对象】：中文姓名、全国随机省市居住地、随机邮箱、手机号、注册时间工具类', '<p>﻿### 话不多说，先上工具类，下面再解释：<br />\nJava随机生成【用户对象】：<br />\n中文姓名、全国随机省市居住地、随机邮箱、手机号、注册时间<br />\nGenerateUserUtil.java工具类</p>\n<pre><code class=\"language-java\">package com.macw.util;\n\nimport com.macw.entity.User;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Random;\n\n/**\n * @author 超伟\n */\npublic class GenerateUserUtil {\n\n    private static final String place[][] = {\n            {&quot;北京&quot;, &quot;市辖区&quot;, &quot;市辖县&quot;},\n            {&quot;天津&quot;, &quot;市辖区&quot;, &quot;市辖县&quot;},\n            {&quot;安徽&quot;, &quot;安庆市&quot;, &quot;蚌埠市&quot;, &quot;亳州市&quot;, &quot;巢湖市&quot;, &quot;池州市&quot;, &quot;滁州市&quot;, &quot;阜阳市&quot;, &quot;合肥市&quot;, &quot;淮北市&quot;, &quot;淮南市&quot;, &quot;黄山市&quot;, &quot;六安市&quot;, &quot;马鞍山市&quot;, &quot;宿州市&quot;, &quot;铜陵市&quot;, &quot;芜湖市&quot;, &quot;宣城市&quot;},\n            {&quot;澳门&quot;, &quot;澳门&quot;},\n            {&quot;香港&quot;, &quot;香港&quot;},\n            {&quot;福建&quot;, &quot;福州市&quot;, &quot;龙岩市&quot;, &quot;南平市&quot;, &quot;宁德市&quot;, &quot;莆田市&quot;, &quot;泉州市&quot;, &quot;厦门市&quot;, &quot;漳州市&quot;},\n            {&quot;甘肃&quot;, &quot;白银市&quot;, &quot;定西市&quot;, &quot;甘南藏族自治州&quot;, &quot;嘉峪关市&quot;, &quot;金昌市&quot;, &quot;酒泉市&quot;, &quot;兰州市&quot;, &quot;临夏回族自治州&quot;, &quot;陇南市&quot;, &quot;平凉市&quot;, &quot;庆阳市&quot;, &quot;天水市&quot;, &quot;武威市&quot;, &quot;张掖市&quot;},\n            {&quot;广东&quot;, &quot;潮州市&quot;, &quot;东莞市&quot;, &quot;佛山市&quot;, &quot;广州市&quot;, &quot;河源市&quot;, &quot;惠州市&quot;, &quot;江门市&quot;, &quot;揭阳市&quot;, &quot;茂名市&quot;, &quot;梅州市&quot;, &quot;清远市&quot;, &quot;汕头市&quot;, &quot;汕尾市&quot;, &quot;韶关市&quot;, &quot;深圳市&quot;, &quot;阳江市&quot;, &quot;云浮市&quot;, &quot;湛江市&quot;, &quot;肇庆市&quot;, &quot;中山市&quot;, &quot;珠海市&quot;},\n            {&quot;广西&quot;, &quot;百色市&quot;, &quot;北海市&quot;, &quot;崇左市&quot;, &quot;防城港市&quot;, &quot;贵港市&quot;, &quot;桂林市&quot;, &quot;河池市&quot;, &quot;贺州市&quot;, &quot;来宾市&quot;, &quot;柳州市&quot;, &quot;南宁市&quot;, &quot;钦州市&quot;, &quot;梧州市&quot;, &quot;玉林市&quot;},\n            {&quot;贵州&quot;, &quot;安顺市&quot;, &quot;毕节地区&quot;, &quot;贵阳市&quot;, &quot;六盘水市&quot;, &quot;黔东南苗族侗族自治州&quot;, &quot;黔南布依族苗族自治州&quot;, &quot;黔西南布依族苗族自治州&quot;, &quot;铜仁地区&quot;, &quot;遵义市&quot;},\n            {&quot;海南&quot;, &quot;海口市&quot;, &quot;三亚市&quot;, &quot;省直辖县级行政区划&quot;},\n            {&quot;河北&quot;, &quot;保定市&quot;, &quot;沧州市&quot;, &quot;承德市&quot;, &quot;邯郸市&quot;, &quot;衡水市&quot;, &quot;廊坊市&quot;, &quot;秦皇岛市&quot;, &quot;石家庄市&quot;, &quot;唐山市&quot;, &quot;邢台市&quot;, &quot;张家口市&quot;},\n            {&quot;河南&quot;, &quot;安阳市&quot;, &quot;鹤壁市&quot;, &quot;焦作市&quot;, &quot;开封市&quot;, &quot;洛阳市&quot;, &quot;漯河市&quot;, &quot;南阳市&quot;, &quot;平顶山市&quot;, &quot;濮阳市&quot;, &quot;三门峡市&quot;, &quot;商丘市&quot;, &quot;新乡市&quot;, &quot;信阳市&quot;, &quot;许昌市&quot;, &quot;郑州市&quot;, &quot;周口市&quot;, &quot;驻马店市&quot;},\n            {&quot;黑龙江&quot;, &quot;大庆市&quot;, &quot;大兴安岭地区&quot;, &quot;哈尔滨市&quot;, &quot;鹤岗市&quot;, &quot;黑河市&quot;, &quot;鸡西市&quot;, &quot;佳木斯市&quot;, &quot;牡丹江市&quot;, &quot;七台河市&quot;, &quot;齐齐哈尔市&quot;, &quot;双鸭山市&quot;, &quot;绥化市&quot;, &quot;伊春市&quot;},\n            {&quot;湖北&quot;, &quot;鄂州市&quot;, &quot;恩施土家族苗族自治州&quot;, &quot;黄冈市&quot;, &quot;黄石市&quot;, &quot;荆门市&quot;, &quot;荆州市&quot;, &quot;十堰市&quot;, &quot;随州市&quot;, &quot;武汉市&quot;, &quot;咸宁市&quot;, &quot;襄樊市&quot;, &quot;孝感市&quot;, &quot;宜昌市&quot;},\n            {&quot;湖南&quot;, &quot;长沙市&quot;, &quot;常德市&quot;, &quot;郴州市&quot;, &quot;衡阳市&quot;, &quot;怀化市&quot;, &quot;娄底市&quot;, &quot;邵阳市&quot;, &quot;湘潭市&quot;, &quot;湘西土家族苗族自治州&quot;, &quot;益阳市&quot;, &quot;永州市&quot;, &quot;岳阳市&quot;, &quot;张家界市&quot;, &quot;株洲市&quot;},\n            {&quot;吉林&quot;, &quot;白城市&quot;, &quot;白山市&quot;, &quot;长春市&quot;, &quot;吉林市&quot;, &quot;辽源市&quot;, &quot;四平市&quot;, &quot;松原市&quot;, &quot;通化市&quot;, &quot;延边朝鲜族自治州&quot;},\n            {&quot;江苏&quot;, &quot;常州市&quot;, &quot;淮安市&quot;, &quot;连云港市&quot;, &quot;南京市&quot;, &quot;南通市&quot;, &quot;苏州市&quot;, &quot;宿迁市&quot;, &quot;泰州市&quot;, &quot;无锡市&quot;, &quot;徐州市&quot;, &quot;盐城市&quot;, &quot;扬州市&quot;, &quot;镇江市&quot;},\n            {&quot;江西&quot;, &quot;抚州市&quot;, &quot;赣州市&quot;, &quot;吉安市&quot;, &quot;景德镇市&quot;, &quot;九江市&quot;, &quot;南昌市&quot;, &quot;萍乡市&quot;, &quot;上饶市&quot;, &quot;新余市&quot;, &quot;宜春市&quot;, &quot;鹰潭市&quot;},\n            {&quot;辽宁&quot;, &quot;鞍山市&quot;, &quot;本溪市&quot;, &quot;朝阳市&quot;, &quot;大连市&quot;, &quot;丹东市&quot;, &quot;抚顺市&quot;, &quot;阜新市&quot;, &quot;葫芦岛市&quot;, &quot;锦州市&quot;, &quot;辽阳市&quot;, &quot;盘锦市&quot;, &quot;沈阳市&quot;, &quot;铁岭市&quot;, &quot;营口市&quot;},\n            {&quot;内蒙古&quot;, &quot;阿拉善盟&quot;, &quot;巴彦淖尔市&quot;, &quot;包头市&quot;, &quot;赤峰市&quot;, &quot;鄂尔多斯市&quot;, &quot;呼和浩特市&quot;, &quot;呼伦贝尔市&quot;, &quot;通辽市&quot;, &quot;乌海市&quot;, &quot;乌兰察布市&quot;, &quot;锡林郭勒盟&quot;, &quot;兴安盟&quot;},\n            {&quot;宁夏&quot;, &quot;固原市&quot;, &quot;石嘴山市&quot;, &quot;吴忠市&quot;, &quot;银川市&quot;, &quot;中卫市&quot;},\n            {&quot;青海&quot;, &quot;果洛藏族自治州&quot;, &quot;海北藏族自治州&quot;, &quot;海东地区&quot;, &quot;海南藏族自治州&quot;, &quot;海西蒙古族藏族自治州&quot;, &quot;黄南藏族自治州&quot;, &quot;西宁市&quot;, &quot;玉树藏族自治州&quot;},\n            {&quot;山东&quot;, &quot;滨州市&quot;, &quot;德州市&quot;, &quot;东营市&quot;, &quot;菏泽市&quot;, &quot;济南市&quot;, &quot;济宁市&quot;, &quot;莱芜市&quot;, &quot;聊城市&quot;, &quot;临沂市&quot;, &quot;青岛市&quot;, &quot;日照市&quot;, &quot;泰安市&quot;, &quot;威海市&quot;, &quot;潍坊市&quot;, &quot;烟台市&quot;, &quot;枣庄市&quot;, &quot;淄博市&quot;},\n            {&quot;山西&quot;, &quot;长治市&quot;, &quot;大同市&quot;, &quot;晋城市&quot;, &quot;晋中市&quot;, &quot;临汾市&quot;, &quot;吕梁市&quot;, &quot;朔州市&quot;, &quot;太原市&quot;, &quot;忻州市&quot;, &quot;阳泉市&quot;, &quot;运城市&quot;},\n            {&quot;陕西&quot;, &quot;安康市&quot;, &quot;宝鸡市&quot;, &quot;汉中市&quot;, &quot;商洛市&quot;, &quot;铜川市&quot;, &quot;渭南市&quot;, &quot;西安市&quot;, &quot;咸阳市&quot;, &quot;延安市&quot;, &quot;榆林市&quot;},\n            {&quot;四川&quot;, &quot;阿坝藏族羌族自治州&quot;, &quot;巴中市&quot;, &quot;成都市&quot;, &quot;达州市&quot;, &quot;德阳市&quot;, &quot;甘孜藏族自治州&quot;, &quot;广安市&quot;, &quot;广元市&quot;, &quot;乐山市&quot;, &quot;凉山彝族自治州&quot;, &quot;泸州市&quot;, &quot;眉山市&quot;, &quot;绵阳市&quot;, &quot;内江市&quot;, &quot;南充市&quot;, &quot;攀枝花市&quot;, &quot;遂宁市&quot;, &quot;雅安市&quot;, &quot;宜宾市&quot;, &quot;资阳市&quot;, &quot;自贡市&quot;},\n            {&quot;西藏&quot;, &quot;阿里地区&quot;, &quot;昌都地区&quot;, &quot;拉萨市&quot;, &quot;林芝地区&quot;, &quot;那曲地区&quot;, &quot;日喀则地区&quot;, &quot;山南地区&quot;},\n            {&quot;新疆&quot;, &quot;阿克苏地区&quot;, &quot;阿勒泰地区&quot;, &quot;巴音郭楞蒙古自治州&quot;, &quot;博尔塔拉蒙古自治州&quot;, &quot;昌吉回族自治州&quot;, &quot;哈密地区&quot;, &quot;和田地区&quot;, &quot;喀什地区&quot;, &quot;克拉玛依市&quot;, &quot;克孜勒苏柯尔克孜自治州&quot;, &quot;塔城地区&quot;, &quot;吐鲁番地区&quot;, &quot;乌鲁木齐市&quot;, &quot;伊犁哈萨克自治州&quot;, &quot;自治区直辖县级行政区划&quot;},\n            {&quot;云南&quot;, &quot;保山市&quot;, &quot;楚雄彝族自治州&quot;, &quot;大理白族自治州&quot;, &quot;德宏傣族景颇族自治州&quot;, &quot;迪庆藏族自治州&quot;, &quot;红河哈尼族彝族自治州&quot;, &quot;昆明市&quot;, &quot;丽江市&quot;, &quot;临沧市&quot;, &quot;怒江僳僳族自治州&quot;, &quot;普洱市&quot;, &quot;曲靖市&quot;, &quot;文山壮族苗族自治州&quot;, &quot;西双版纳傣族自治州&quot;, &quot;玉溪市&quot;, &quot;昭通市&quot;},\n            {&quot;浙江&quot;, &quot;杭州市&quot;, &quot;湖州市&quot;, &quot;嘉兴市&quot;, &quot;金华市&quot;, &quot;丽水市&quot;, &quot;宁波市&quot;, &quot;衢州市&quot;, &quot;绍兴市&quot;, &quot;台州市&quot;, &quot;温州市&quot;, &quot;舟山市&quot;},\n            {&quot;重庆&quot;, &quot;市辖区&quot;, &quot;市辖县&quot;, &quot;县级市&quot;},\n            {&quot;台湾&quot;, &quot;台北市&quot;, &quot;高雄市&quot;, &quot;基隆市&quot;, &quot;台中市&quot;, &quot;台南市&quot;, &quot;新竹市&quot;, &quot;嘉义市&quot;},\n    };\n\n    private static String base = &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;;\n    private static String firstName = &quot;赵钱孙李周吴郑王冯陈褚卫蒋沈韩杨朱秦尤许何吕施张孔曹严华金魏陶姜戚谢邹喻柏水窦章云苏潘葛奚范彭郎鲁韦昌马苗凤花方俞任袁柳酆鲍史唐费廉岑薛雷贺倪汤滕殷罗毕郝邬安常乐于时傅皮卞齐康伍余元卜顾孟平黄和穆萧尹姚邵湛汪祁毛禹狄米贝明臧计伏成戴谈宋茅庞熊纪舒屈项祝董梁杜阮蓝闵席季麻强贾路娄危江童颜郭梅盛林刁钟徐邱骆高夏蔡田樊胡凌霍虞万支柯咎管卢莫经房裘缪干解应宗宣丁贲邓郁单杭洪包诸左石崔吉钮龚程嵇邢滑裴陆荣翁荀羊於惠甄魏加封芮羿储靳汲邴糜松井段富巫乌焦巴弓牧隗山谷车侯宓蓬全郗班仰秋仲伊宫宁仇栾暴甘钭厉戎祖武符刘姜詹束龙叶幸司韶郜黎蓟薄印宿白怀蒲台从鄂索咸籍赖卓蔺屠蒙池乔阴郁胥能苍双闻莘党翟谭贡劳逄姬申扶堵冉宰郦雍却璩桑桂濮牛寿通边扈燕冀郏浦尚农温别庄晏柴瞿阎充慕连茹习宦艾鱼容向古易慎戈廖庚终暨居衡步都耿满弘匡国文寇广禄阙东殴殳沃利蔚越夔隆师巩厍聂晁勾敖融冷訾辛阚那简饶空曾毋沙乜养鞠须丰巢关蒯相查后江红游竺权逯盖益桓公万俟司马上官欧阳夏侯诸葛闻人东方赫连皇甫尉迟公羊澹台公冶宗政濮阳淳于仲孙太叔申屠公孙乐正轩辕令狐钟离闾丘长孙慕容鲜于宇文司徒司空亓官司寇仉督子车颛孙端木巫马公西漆雕乐正壤驷公良拓拔夹谷宰父谷粱晋楚阎法汝鄢涂钦段干百里东郭南门呼延归海羊舌微生岳帅缑亢况后有琴梁丘左丘东门西门商牟佘佴伯赏南宫墨哈谯笪年爱阳佟第五言福百家姓续&quot;;\n    private static String girl = &quot;秀娟英华慧巧美娜静淑惠珠翠雅芝玉萍红娥玲芬芳燕彩春菊兰凤洁梅琳素云莲真环雪荣爱妹霞香月莺媛艳瑞凡佳嘉琼勤珍贞莉桂娣叶璧璐娅琦晶妍茜秋珊莎锦黛青倩婷姣婉娴瑾颖露瑶怡婵雁蓓纨仪荷丹蓉眉君琴蕊薇菁梦岚苑婕馨瑗琰韵融园艺咏卿聪澜纯毓悦昭冰爽琬茗羽希宁欣飘育滢馥筠柔竹霭凝晓欢霄枫芸菲寒伊亚宜可姬舒影荔枝思丽 &quot;;\n    private static String boy = &quot;伟刚勇毅俊峰强军平保东文辉力明永健世广志义兴良海山仁波宁贵福生龙元全国胜学祥才发武新利清飞彬富顺信子杰涛昌成康星光天达安岩中茂进林有坚和彪博诚先敬震振壮会思群豪心邦承乐绍功松善厚庆磊民友裕河哲江超浩亮政谦亨奇固之轮翰朗伯宏言若鸣朋斌梁栋维启克伦翔旭鹏泽晨辰士以建家致树炎德行时泰盛雄琛钧冠策腾楠榕风航弘&quot;;\n    private static final String[] email_suffix = &quot;@gmail.com,@yahoo.com,@msn.com,@hotmail.com,@aol.com,@ask.com,@live.com,@qq.com,@0355.net,@163.com,@163.net,@263.net,@3721.net,@yeah.net,@googlemail.com,@126.com,@sina.com,@sohu.com,@yahoo.com.cn&quot;.split(&quot;,&quot;);\n    private static String[] sexs = {&quot;男&quot;, &quot;女&quot;};\n\n    private static int getNum(int start, int end) {\n        return (int) (Math.random() * (end - start + 1) + start);\n    }\n//    获得随机数的方法\n\n    private static int getRandom(int length) {\n        Random random = new Random();\n        return random.nextInt(length);\n    }\n\n\n    /**\n     * 返回Email\n     *\n     * @param lMin 最小长度\n     * @param lMax 最大长度\n     * @return\n     */\n    private static String getEmail(int lMin, int lMax) {\n        int length = getNum(lMin, lMax);\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i &lt; length; i++) {\n            int number = (int) (Math.random() * base.length());\n            sb.append(base.charAt(number));\n        }\n        sb.append(email_suffix[(int) (Math.random() * email_suffix.length)]);\n        return sb.toString();\n    }\n\n    /**\n     * 返回手机号码\n     */\n    private static String[] telFirst = &quot;134,135,136,137,138,139,150,151,152,157,158,159,130,131,132,155,156,133,153&quot;.split(&quot;,&quot;);\n\n    private static String getTel() {\n        int index = getNum(0, telFirst.length - 1);\n        String first = telFirst[index];\n        String second = String.valueOf(getNum(1, 888) + 10000).substring(1);\n        String third = String.valueOf(getNum(1, 9100) + 10000).substring(1);\n        return first + second + third;\n    }\n\n    /**\n     * 返回中文姓名\n     */\n    private static String name_sex = &quot;&quot;;\n\n    private static String getChineseName() {\n        int index = getNum(0, firstName.length() - 1);\n        String first = firstName.substring(index, index + 1);\n        int sex = getNum(0, 1);\n        String str = boy;\n        int length = boy.length();\n        if (sex == 0) {\n            str = girl;\n            length = girl.length();\n            name_sex = &quot;女&quot;;\n        } else {\n            name_sex = &quot;男&quot;;\n        }\n        index = getNum(0, length - 1);\n        String second = str.substring(index, index + 1);\n        int hasThird = getNum(0, 1);\n        String third = &quot;&quot;;\n        if (hasThird == 1) {\n            index = getNum(0, length - 1);\n            third = str.substring(index, index + 1);\n        }\n        return first + second + third;\n    }\n\n\n    /**\n     * 生成随机时间\n     *\n     * @param beginDate\n     * @param endDate\n     * @return\n     */\n    private static Date randomDate(String beginDate, String endDate) {\n\n        try {\n\n            SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);\n//构造开始日期 \n            Date start = format.parse(beginDate);\n//构造结束日期 \n            Date end = format.parse(endDate);\n\n//getTime()表示返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 \n\n            if (start.getTime() &gt;= end.getTime()) {\n\n                return null;\n\n            }\n\n            long date = random(start.getTime(), end.getTime());\n\n            return new Date(date);\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n\n        }\n\n        return null;\n\n    }\n\n    private static long random(long begin, long end) {\n\n        long rtn = begin + (long) (Math.random() * (end - begin));\n\n        //如果返回的是开始时间和结束时间，则递归调用本函数查找随机值 \n\n        if (rtn == begin || rtn == end) {\n\n            return random(begin, end);\n\n        }\n\n        return rtn;\n\n    }\n\n    /**\n     * 生成用户对象\n     *\n     * @return\n     */\n    public static User getUser() {\n        User cmfzUser = new User();\n        cmfzUser.setUserName(getChineseName());\n        cmfzUser.setUserNickname(&quot;大圣&quot;);\n        cmfzUser.setUserTelphone(getTel());\n        cmfzUser.setUserPassword(&quot;123456&quot;);\n        cmfzUser.setUserStatus(0);\n        cmfzUser.setGuruId(1);\n        cmfzUser.setUserSex(sexs[getRandom(sexs.length)]);\n        String[] strings = place[getRandom(place.length)];\n        cmfzUser.setUserProvince(strings[0]);\n        cmfzUser.setUserCity(strings[getRandom(strings.length)]);\n        cmfzUser.setUserAutograph(&quot;岁月静好&quot;);\n        cmfzUser.setUserImage(&quot;hhh.jpg&quot;);\n        cmfzUser.setUserCreateDate(randomDate(&quot;2019-03-01&quot;, &quot;2019-8-15&quot;));\n        return cmfzUser;\n    }\n\n}\n\n</code></pre>\n<p>这里我所创建的用户对象是：</p>\n<pre><code class=\"language-java\">\n/**\n * @author macw\n * @since 2019-08-13\n */\n@Data\n@EqualsAndHashCode(callSuper = false)\n@Accessors(chain = true)\n@TableName(&quot;cmfz_user&quot;)\npublic class User implements Serializable {\n\n    @TableId(value = &quot;user_id&quot;, type = IdType.AUTO)\n    @Excel(name = &quot;用户编号&quot;)\n    private Integer userId;\n    @Excel(name = &quot;手机号&quot;)\n    private String userTelphone;\n    @Excel(name = &quot;密码&quot;)\n    private String userPassword;\n    @Excel(name = &quot;头像&quot;)\n    private String userImage;\n    @Excel(name = &quot;用户昵称&quot;)\n    private String userNickname;\n    @Excel(name = &quot;用户名&quot;)\n    private String userName;\n    @Excel(name = &quot;性别&quot;)\n    private String userSex;\n    @Excel(name = &quot;个性签名&quot;)\n    private String userAutograph;\n    @Excel(name = &quot;省份&quot;)\n    private String userProvince;\n    @Excel(name = &quot;城市&quot;)\n    private String userCity;\n    @Excel(name = &quot;所属小组&quot;)\n    private Integer guruId;\n    @Excel(name = &quot;用户状态&quot;,replace = {&quot;男_1&quot;,&quot;女_0&quot;})\n    private Integer userStatus;\n    @TableField(&quot;user_create_date&quot;)\n    @Excel(name = &quot;注册时间&quot;)\n    private Date userCreateDate;\n    @TableField(exist = false)\n    private Integer count;\n\n}\n\n</code></pre>\n<p>然后就可以直接调用生成十万条用户数据了！<br />\n调用测试类如下：</p>\n<pre><code class=\"language-java\">  @Test\n    public void test1(){\n        SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n        long start = System.currentTimeMillis();\n        System.out.println(&quot;-----&quot;+date);\n        int insert = 0;\n        for (int i = 0; i &lt; 10000; i++) {\n            User user = GenerateUserUtil.getUser();\n            insert += userMapper.insert(user);\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;成功添加： &quot;+insert+&quot; 条数据，所用时间：&quot;+(end-start)+&quot;ms&quot;);\n    }\n</code></pre>\n<p>如此，就可轻轻松松向数据库添加十万条数据了，</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:40:35', '2022-05-21 18:17:29');
INSERT INTO `tb_article` VALUES (121, 1, 8, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5040', 'MySQL数据库4种常用优化方式，sql语句书写优化规范', '<p>﻿<strong>MySQL数据库优化</strong></p>\n<p><a href=\"#引言\">1. 引言</a></p>\n<p><a href=\"#数据库优化手段\">2. 数据库优化手段</a></p>\n<p><a href=\"#优化储备知识\">3. 优化储备知识</a></p>\n<p><a href=\"#慢查询\">3.1 慢查询</a></p>\n<p><a href=\"#执行计划\">3.2 执行计划</a></p>\n<p><a href=\"#索引优化\">4. 索引优化</a></p>\n<p><a href=\"#索引语法\">4.1 索引语法</a></p>\n<p><a href=\"#索引应用场景\">4.2 索引应用场景</a></p>\n<p><a href=\"#查询缓存\">5. 查询缓存</a></p>\n<p><a href=\"#sql优化\">6. SQL优化</a></p>\n<p><a href=\"#读写分离\">7. 读写分离</a></p>\n<p><a href=\"#centos中linux的安装\">7.1 CentOS中linux的安装</a></p>\n<p><a href=\"#mysql主从复制\">7.2 MySQL主从复制</a></p>\n<p><a href=\"#读写分离基于mycat实现\">7.3 读写分离(基于MyCat实现)</a></p>\n<h1 id=\"引言\">引言</h1>\n<p>实际项目中，我们的数据往往存储在数据库中，但是由于数据库本身是持久化存储，数据的查询速度受到磁盘IO瓶颈的限制，同时，随着数据量的增长，数据的查询也会因为单表数据量的巨大，影响查询速度。所以我们需要对数据库进行优化，提高系统的响应效率。</p>\n<h1 id=\"数据库优化手段\">数据库优化手段</h1>\n<ol>\n<li>\n<p>索引优化。</p>\n</li>\n<li>\n<p>添加查询缓存。</p>\n</li>\n<li>\n<p>优化数据库SQL语句。</p>\n</li>\n<li>\n<p>数据库Cluster(搭建数据库集群环境)。</p>\n</li>\n</ol>\n<h1 id=\"优化储备知识\">优化储备知识</h1>\n<h2 id=\"31-慢查询\">3.1 慢查询</h2>\n<blockquote>\n<p>慢查询就是查看我们每条sql语句查询所用的时间，<br />\n开启慢查询的目的是将我们每次查询所用的时间记录在日志里进行观察检测，如果检测到查询的时间到达超过一定的预定时间（比如查询时间超过1秒的语句），将被记录下来进行优化！</p>\n</blockquote>\n<ol>\n<li>查看慢查询的信息状态</li>\n</ol>\n<blockquote>\n<p>show variables like \'%quer%\';</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818165456174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>开启慢查询</li>\n</ol>\n<blockquote>\n<p>set global slow_query_log=on;</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818170417988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>修改慢查询最短时间为1s</li>\n</ol>\n<blockquote>\n<p>set GLOBAL long_query_time = 1;</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818170539243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>查看MySQL执行过的慢查询SQL语句。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818170706476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"32-执行计划\">3.2 执行计划</h2>\n<p>补充： 数据库查询优化中需要了解MySQL执行计划命令，查看sql的执行效率</p>\n<p>进行一条查询语句，点下左上角的解释看语句解释：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190818170730136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"索引优化\">索引优化</h1>\n<h2 id=\"41-索引语法\">4.1 索引语法</h2>\n<ol>\n<li>索引的作用</li>\n</ol>\n<blockquote>\n<p>加快以索引字段为条件的查询效率。</p>\n</blockquote>\n<ol>\n<li>创建索引</li>\n</ol>\n<blockquote>\n<p>create index  索引名字 on 表(字段)</p>\n</blockquote>\n<ol>\n<li>删除索引</li>\n</ol>\n<blockquote>\n<p>drop index  索引名字</p>\n</blockquote>\n<ol>\n<li>查询某张表创建了哪些索引</li>\n</ol>\n<blockquote>\n<p>Show index from 表名;</p>\n</blockquote>\n<ol>\n<li>索引的特点</li>\n</ol>\n<blockquote>\n<p>①索引会占用存储空间，虽然比较少，但是也占用了。</p>\n</blockquote>\n<blockquote>\n<p>②MySQL会自动为primary 主键列和unique 唯一列自动增加索引。</p>\n</blockquote>\n<blockquote>\n<p>③MySQL数据库对数据做DML操作时，需要同时做维护索引的操作。</p>\n</blockquote>\n<blockquote>\n<p><strong>隐含之意，就是索引会降低数据库增删改的效率。</strong></p>\n</blockquote>\n<ol>\n<li>使用原则：</li>\n</ol>\n<blockquote>\n<p>一般会对sql中的where条件字段或者order by字段建立索引。</p>\n</blockquote>\n<h2 id=\"42-索引应用场景\">4.2 索引应用场景</h2>\n<p>实际项目中，如果从业务角度出发，发现经常会用到某个字段，对表数据进行查询，或者根据经常用到某个字段的排序，则该数据是需要增加索引的。</p>\n<h1 id=\"在这里插入图片描述查询缓存\"><img src=\"https://img-blog.csdnimg.cn/20190818171131437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n查询缓存</h1>\n<ol>\n<li>在数据库操作对象DAO处增加查询缓存。</li>\n</ol>\n<blockquote>\n<p><em>参考Ehcache缓存，或者MyBatis+Ehcache整合方案、Hibernate二级缓存Ehcache。</em></p>\n</blockquote>\n<ol start=\"2\">\n<li>需要注意的问题是，要注意数据的一致性，所以缓存思路如下：</li>\n</ol>\n<blockquote>\n<p>① 只对查询结果进行缓存</p>\n</blockquote>\n<blockquote>\n<p>②<br />\n缓存结果存放要以业务逻辑相关为划分单位。比如，如果是单表，则可以创建一个缓存区域，与该表对应，如果业务中涉及到表连接操作，要将查询结果缓存在这多张表的查询结果都要缓存在对应的一个缓存区域中。</p>\n</blockquote>\n<ol start=\"3\">\n<li>\n<p>当执行增删改的时候，为了避免出现脏数据。</p>\n</li>\n<li>\n<p>基于以上的特点，缓存原则是对那些查询需求远大于增删改需求的数据，进行缓存。</p>\n</li>\n</ol>\n<blockquote>\n<p>例如：新闻网站的首页数据、电商的类别数据等。</p>\n</blockquote>\n<h1 id=\"sql优化\">SQL优化</h1>\n<ol>\n<li>\n<p>尽量不要在要给在SQL语句的where子句中使用函数，这样会使索引失效。</p>\n</li>\n<li>\n<p>如果已经确定查询结果只有一条数据（当表中数据的该字段是唯一的），在查询SQL末尾增加<br />\nlimit    1，这样MySQL的查询执行引擎在找到1条数据之后就会停止搜索，提高效率。（mysql5.6之后有效）<br />\n例如：</p>\n</li>\n</ol>\n<blockquote>\n<p>select * from t_department where department_name = \'研发部\' limit 1;</p>\n</blockquote>\n<ol start=\"3\">\n<li>\n<p>模糊查询尽量使用右模糊：‘xx%’，这样可以利用上索引，而使用‘%xx’这种模糊查询会导致该查询字段上的索引失效。</p>\n</li>\n<li>\n<p>如果非要使用表连接，最好要保证连接的两个字段都是创建了索引的。</p>\n</li>\n<li>\n<p>查询的时候最好用什么数据查询什么数据，避免使用select<br />\n*,原因是数据库访问往往是远程通过网络来访问，这也就意味着，查询结果也是通过网络来传输的，如果查询了额外的无用的数据，他们会额外占用网络带宽，数据传输效率也会降低。</p>\n</li>\n<li>\n<p>尽量使用非空 not<br />\nnull，可以使用‘’空串代替null。因为‘’不占用空间，null会占用空间的。</p>\n</li>\n<li>\n<p>使用!= 或者&lt;&gt; 数据库会放弃索引。</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/2019081817164678.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"6\">\n<li>在SQL语句中不要有运算，否则MySQL会放弃索引。（mysql在执行查询时，会自动过滤当前语句，当效率大于使用索引时，则默认不使用索引）</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818171706234.png\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>\n<p>对于百万级以上的表数据，如果要做表连接查询，一定要对表先分页，然后对分页结果再做表连接。</p>\n</li>\n<li>\n<p>尽量避免大事务操作，这样会降低系统的并发能力。在满足实际业务的前提下，尽量缩短事务的边界。</p>\n</li>\n<li>\n<p>Where子句多条件and连接的情况，要把精确条件放在最先执行的位置，提高效率。Oracle中是从右至左。MySQL中是从左至右。<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081817175944.jpg\" alt=\"在这里插入图片描述\" /></p>\n</li>\n</ol>\n<h1 id=\"mysql集群环境之------读写分离主从复制\">MySql集群环境之------读写分离、主从复制</h1>\n<p>搭建MySQL的集群环境来优化查询<br />\n详细的使用搭建步骤可参考我之前文章：</p>\n<p><a href=\"https://blog.csdn.net/MacWx/article/details/98778719\"> Centos 7使用MyCat搭建 MySQL-读写分离</a></p>\n<a href=\"https://blog.csdn.net/MacWx/article/details/98777361\">\nCentos 7搭建MySQL-主从复制</a>\n', 1, '', 0, 0, 1, '2020-04-25 15:40:58', '2022-05-21 18:17:14');
INSERT INTO `tb_article` VALUES (122, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5888', 'POI简介，以及使用POI技术实现Excel文件的导入导出案例', '<p>﻿### 1、什么是POI？<br />\nApache POI 是 Apache 软件基金会的开放源码函式库，POI 提供 API 给 Java 程序对<br />\nMicrosoft Office 格式档案读和写的功能。</p>\n<p><strong>常用的两种java操作Excel技术POi和JXL的对比：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190814211200494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>POI 和 JXL 对 Excel 抽象出来的对象对比</strong><br />\n|                  |       POI        |   JXL    |<br />\n| :--------------: | :--------------: | :------: |<br />\n|    Excel 文档    |   HSSFWorkbook   | Workbook |<br />\n|  Excel 的工作表  |    HSSFSheet     |  Sheet   |<br />\n|    Excel 的行    |     HSSFRow      |    无    |<br />\n| Excel 中的单元格 |     HSSFCell     |   Cell   |<br />\n|    Excel 字体    |     HSSFFont     |          |<br />\n| Excel 单元格样式 |  HSSFCellStyle   |          |<br />\n|    Excel 颜色    |    HSSFColor     |          |<br />\n|    合并单元格    | CellRangeAddress |          |</p>\n<h3 id=\"2使用poi实现excel的导入导出\">2、使用POI实现Excel的导入导出</h3>\n<p>先来回忆一下window使用Excel和POi对Excel抽象出来的对象</p>\n<ol>\n<li>创建一个Excel文件 HSSFWorkbook</li>\n<li>创建一张工作表 HSSFSheet</li>\n<li>选中一行  HSSFRow</li>\n<li>选中一个单元格  HSSFCell</li>\n<li>在单元格中写入数据</li>\n<li>保存</li>\n</ol>\n<h4 id=\"第一个demo-excel导出\">第一个demo Excel导出</h4>\n<p><strong>1，导入POI依赖</strong></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;\n    &lt;artifactId&gt;poi&lt;/artifactId&gt;\n    &lt;version&gt;3.11&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p><strong>2，POI工具类实现导出</strong><br />\n案例1：</p>\n<pre><code class=\"language-java\">package com.macw;\n\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\nimport org.junit.Test;\n\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class PoiTest {\n\n    @Test\n    public void test1() throws IOException {\n//        1.创建一个文件对象\n        HSSFWorkbook hssfWorkbook = new HSSFWorkbook();\n\n//        2.创建一个表对象 通过文件对象创建表对象\n        HSSFSheet sheet = hssfWorkbook.createSheet(&quot;表名：excel数据表&quot;);\n\n//        3.获取行对象 下标从0开始\n        HSSFRow row = sheet.createRow(0);\n\n//        4.获取第1个单元格  下标从0开始\n        HSSFCell cell = row.createCell(0);\n\n//        5.在单元格中写入数据\n        cell.setCellValue(&quot;Hello Wolld&quot;);\n\n//        6.保存在磁盘中 流  文件名的后缀必须有.xls\n        hssfWorkbook.write(new FileOutputStream(&quot;E://demo.xls&quot;));\n    }\n}\n```java\n案例2：\n模拟从数据库查到的所有用户及用户信息导出到excel文件中\n</code></pre>\n<pre><code>@RequestMapping(&quot;/exportAll&quot;)\npublic void exportAll(HttpServletResponse resp){\n    //模拟从数据库查到的所有用户及用户信息\n    List&lt;User&gt; users = new ArrayList&lt;User&gt;();\n    User user = new User(&quot;1&quot;,&quot;张三 1&quot;,&quot;2019-8-10&quot;);\n    User user1 = new User(&quot;2&quot;,&quot;张三 2&quot;,&quot;2019-8-10&quot;);\n    User user2 = new User(&quot;3&quot;,&quot;张三 3&quot;,&quot;2019-8-10&quot;);\n    User user3 = new User(&quot;4&quot;,&quot;张三 4&quot;,&quot;2019-8-10&quot;);\n    User user4 = new User(&quot;5&quot;,&quot;张三 5&quot;,&quot;2019-8-10&quot;);\n    User user5 = new User(&quot;6&quot;,&quot;张三 6&quot;,&quot;2019-8-10&quot;);\n    User user6 = new User(&quot;7&quot;,&quot;张三 7&quot;,&quot;2019-8-10&quot;);\n    User user7 = new User(&quot;8&quot;,&quot;张三 8&quot;,&quot;2019-8-10&quot;);\n    users.add(user);\n    users.add(user1);\n    users.add(user2);\n    users.add(user3);\n    users.add(user4);\n    users.add(user5);\n    users.add(user6);\n    users.add(user7);\n    //创建工作薄\n    HSSFWorkbook workbook = new HSSFWorkbook();\n    //创建工作表\n    HSSFSheet sheet = workbook.createSheet(&quot;用户信息&quot;);\n    //设置列宽 第一个参数：列索引 第二个参数：列宽\n    sheet.setColumnWidth(2, 4500);\n    //创建导出样式\n    HSSFCellStyle cellStyle = workbook.createCellStyle();\n    //创建字体\n    HSSFFont font = workbook.createFont();\n    //设置字体颜色\n    font.setColor(HSSFFont.COLOR_RED);\n    //设置加粗\n    font.setBold(true);\n   \n    //设置字体\n    font.setFontName(&quot;宋体&quot;);\n    //设置居中\n    cellStyle.setAlignment(CellStyle.ALIGN_CENTER);\n    //管理字体样式\n    cellStyle.setFont(font);\n    //创建标题栏\n    HSSFRow row = sheet.createRow(0);\n    HSSFCell cell = null;\n    String[] titles = {&quot;编号&quot;,&quot;真实姓名&quot;,&quot;出生年月&quot;};\n    for (int i = 0; i &lt; titles.length; i++) {\n        cell = row.createCell(i);\n        cell.setCellValue(titles[i]);\n    //标题行使用样式\n        cell.setCellStyle(cellStyle);\n    }\n    for (int i = 1; i &lt;= users.size(); i++) {\n         //创建数据行对象\n        row = sheet.createRow(i);\n        //数据行第一列设值\n        cell = row.createCell(0);\n        cell.setCellValue(users.get(i-1).getUserId());\n        //数据行第二列设值\n        cell = row.createCell(1);\n        cell.setCellValue(users.get(i-1).getRealname());\n        //数据行第三列设值\n        cell = row.createCell(2);\n        cell.setCellValue(users.get(i-1).getDharmaName());\n    }\n    String fileName = &quot;用户报表(&quot;+new\n            SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date())+&quot;).xls&quot;;\n    //处理中文下载名乱码\n    try {\n        fileName = new  String(fileName.getBytes(&quot;utf-8&quot;),&quot;utf-8&quot;);\n        //设置 response\n        resp.setContentType(&quot;application/vnd.ms-excel&quot;);\n        resp.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename=&quot;+fileN\n                ame);\n       \n        workbook.write(resp.getOutputStream());\n        workbook.close();\n    } catch (Exception e) {\n    // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n}\n</code></pre>\n<h3 id=\"3poi导入\">3、POI导入</h3>\n<pre><code class=\"language-java\"> @RequestMapping(&quot;/uploadIn&quot;)\n    @ResponseBody\n    public Map uploadIn(MultipartFile multipartFile) throws IOException {\n        //输出文件名\n        logger.info(&quot;----------文件名为： &quot;+multipartFile.getOriginalFilename());\n        //1，获取流对象\n        InputStream inputStream = multipartFile.getInputStream();\n\n//        2.通过poi解析流 得到 Excel文件对象\n        HSSFWorkbook workbook = new HSSFWorkbook(inputStream);\n\n//        3.通过对象获取数据 得到表\n        HSSFSheet sheet = workbook.getSheetAt(0);\n\n//        4.通过表 得到行\n        int lastRowNum = sheet.getLastRowNum();\n        //定义计数器，计算批量导入多少条数据\n        int sum = 0;\n        for (int i = 1; i &lt;= lastRowNum; i++) {\n            Guru guru = new Guru();\n            HSSFRow row = sheet.getRow(i);\n//            获取单元格\n            double guruId = row.getCell(0).getNumericCellValue();\n            guru.setGuruId((int) guruId);\n\n            guru.setGuruName(row.getCell(1).getStringCellValue());\n            guru.setGuruImage(row.getCell(2).getStringCellValue());\n            guru.setGuruNickname(row.getCell(3).getStringCellValue());\n            guru.setGuruStatus((int) row.getCell(4).getNumericCellValue());\n            System.out.println(guru);\n			//执行添加的SQL\n            int insert = guruMapper.insert(guru);\n            //统计添加成功的条数\n            sum+=insert;\n        }\n        Map map = new HashMap();\n        map.put(&quot;flag&quot;, sum+&quot;&quot;);\n        return map;\n    }\n</code></pre>\n<p>页面代码：</p>\n<pre><code class=\"language-html\">&lt;div id=&quot;insertFile&quot; class=&quot;easyui-dialog&quot; data-options=&quot;closed:true&quot;&gt;\n    &lt;form id=&quot;insertFileForm&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;\n        上传Excel文件：&lt;input class=&quot;easyui-filebox&quot; name=&quot;multipartFile&quot;\n                         data-options=&quot;required:true,missingMessage:\'请选择文件\'&quot;/&gt;&lt;br/&gt;&lt;br/&gt;\n        &lt;a href=&quot;javascript:void(0)&quot; class=&quot;easyui-linkbutton&quot; iconCls=&quot;icon-save&quot; onClick=&quot;insertFileConfirm()&quot;&gt;上传&lt;/a&gt;\n    &lt;/form&gt;\n&lt;/div&gt;\n\n\njs代码：\n\n //批量上传的文件提交\n    function insertFileConfirm() {\n        $(&quot;#insertFileForm&quot;).form(&quot;submit&quot;, {\n            url: &quot;${pageContext.request.contextPath}/guru/uploadIn&quot;,\n            success: function (data) {\n               console.log(data);\n                alert(&quot;成功添加：&quot;+data.flag+&quot; 条数据&quot;);\n                $(&quot;#insertFile&quot;).dialog(&quot;close&quot;);\n                $(&quot;#guruManager&quot;).datagrid(&quot;reload&quot;);\n            }\n        })\n    }\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:41:41', '2022-05-21 18:16:54');
INSERT INTO `tb_article` VALUES (123, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=9', 'Maven仓库 一键自动删除失效jar包，没事儿点点_', '<p>﻿因为网路等各种原因，使用maven仓库下载jar包可能会下载失败，或者下载一半停止，</p>\n<p>下载失效的jar包会严重影响我们程序的运行，<br />\n看着明明没问题，但是一运行就报错，而且还很难找到错误问题原因，</p>\n<p><strong>所以及时得清理失效的jar包会使我们从程序减少出错的可能；</strong></p>\n<p>如何清理失效的jar包呢，<br />\n失效的jar在我们的maven仓库 都有一个.lastUpdated结尾的后缀，、</p>\n<p>只要是有这个后缀的文件夹里面的jar包就都是失效的，</p>\n<p>下面说一个使用windows的批处理清理带.lastUpdated结尾的失效jar包的解决办法：</p>\n<p>新建一个记事本，输入一下命名：</p>\n<pre><code>@echo  off\nrem create by sunhao(sunhao.java@gmail.com)\nrem crazy coder\nset REPOSITORY_PATH=D:\\Maven\\repository\nrem 正在搜索...\nfor /f &quot;delims=&quot; %%i in (\'dir /b /s &quot;%REPOSITORY_PATH%\\*lastUpdated*&quot;\') do (\n    del /s /q %%i\n)\nrem 搜索完毕\npause\n</code></pre>\n<p>其中的：<br />\n<strong>set REPOSITORY_PATH=D:\\Maven\\repository</strong><br />\n改为你的本地仓库路径地址</p>\n<p><strong>然后将这个txt文件另存为：删除失效jar包工具没事儿点点.bat<br />\n一定要是.bat结尾的批处理文件才行啊，</strong></p>\n<p>然后就可以把 这个东西发送到桌面快捷方式，闲着没事就点点清理jar包</p>\n<p>如果双击不运行的话就右键以管理员身份打开~</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:41:44', '2022-05-21 18:16:24');
INSERT INTO `tb_article` VALUES (124, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4066', 'Redis持久化机制RDB 和AOF', '<p>﻿## redis持久化机制</p>\n<p>redis服务器宕机，内存数据是会丢失了，为了保证数据不丢失需要对数据做备份，所备份就是持久化，Redis的持久化即将内存中的数据同步到硬盘，主要包括两种方式RDB、AOF。</p>\n<p><strong>RDB持久化机制，(默认使用)</strong>：做当前内存数据的全本快照，<br />\n将内存中的数据以快照的方式写入到二进制文件dump.rdb,<br />\n在redis.conf中可以设置发起快照保存的条件。在指定的时间内如果有超过指定数量的key被修改，则会发起快照保存。</p>\n<p>这种方式在数据的实时性上不高，在突然断电的情况下，可能会出现部分数据的丢失，即最后一次快照之后在内存中发生修改的数据。</p>\n<p>简单来说：RDB就是将redis上的所有数据做个备份，存储的是二进制的数据。</p>\n<p><strong>AOF持久化机制，(默认是关闭)</strong>：</p>\n<p>AOF是将Redis内存数据库中更改的数据都记录到指定的文件appendonly.aof。在redis.conf中可以进行写磁盘的相关设置。</p>\n<p>在突然断电的情况下，由于在appendonly.aof中保存了最后一次写磁盘之后redis内存发生数据修改的指令，所以在这个Redis重启后，基本不会发生数据丢失，比RDB具有更好的数据安全性。</p>\n<p>appendfsync always   接收到更改数据的命令，立即将其记录到appendonly.aof中，能保证数据持久化，数据完全不丢失，但效率相对最低。</p>\n<p>appendfsync everysec   每秒钟将redis内存数据修改的命令记录到appendonly.aof中，在性能和持久化上做了折中。因频繁执行磁盘操作，在仅存在单个Master执行写操作时，效率可能存在问题。但在多个Master执行写操作的Redis集群中，效率会提升。</p>\n<p>appendfsync no  依赖于操作系统，因不会频繁执行磁盘操作而性能最好，但redis内存数据修改持久化没有保证，无法保证数据可靠性</p>\n<p><strong>如何开启AOF持久化：</strong><br />\n将redis.conf文件中 appendonly 改成 yes ，自动创建appendonly.aof，该文件存储的客户端执行过<strong>增删改操作的命令</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190811162518765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"什么是aof重写\">什么是AOF重写？</h2>\n<p>当命令存储了一定程度的时候，有一些命令可能是已经无效的了<br />\n例如set usernname xx  del usename,添加一条数据，后又删除，所以这两条命令备份的备份的时候就都是无效的<br />\n所有redis会对AOF文件进行优化，把一些没有对于数据恢复没有意义的命令优化掉<br />\n默认AOF是关闭的，需要在redis.conf中进行开启<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081116254741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 15:41:47', '2022-05-21 18:16:11');
INSERT INTO `tb_article` VALUES (125, 1, 5, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7659', 'Mybatis中$ {} 和 # {}的区别，动态SQL之if、where、set、trim、foreach标签的使用', '<p>﻿## 一．Mapper文件的补充细节</p>\n<p><strong>a)	Xml的特殊字符</strong><br />\n在mapper文件中，小于号用&amp; lt;代替， 大于号用 &amp; gt;代替</p>\n<pre><code>i.	&lt;   &amp;lt;  \nii.	&gt;  &amp;gt; \n</code></pre>\n<p><strong>b)	$ {} 和 # {}的区别</strong><br />\ni.	使用上，$ {}要获取的参数值，对应的参数必须使用Param注解<br />\nii.	底层上，<br />\n${}使用字符串拼接<br />\n#{}使用?占位符</p>\n<ol>\n<li>字符串拼接，可以拼接表名 列名 sql关键字</li>\n<li>?占位符，只能绑定数据，但可以避免sql注入攻击</li>\n</ol>\n<h2 id=\"二动态sql\">二．动态SQL</h2>\n<p>什么是动态SQL？就是能够根据不同的条件，产生不同 的SQL语句。</p>\n<blockquote>\n<p>比如我们常见的多条件搜索框，可以根据姓名、性别、年龄、工资范围等按照一定的条件进行搜素，<br />\n但如果我只输入姓名搜素呢，或者按照姓名+年龄进行搜素呢，这样排列组合情况就太多了，我们不可能一个条件去写一个SQL的，<br />\n所以就需要我们根据用户输入的条件来动态的生成一条SQL语句。</p>\n</blockquote>\n<p><strong>Mapper文件中动态SQL常用的几个标签</strong><br />\n&lt; if&gt; 作用：<br />\n满足条件时执行sql，不满足则不执行</p>\n<p>&lt; where&gt; 作用：</p>\n<ol>\n<li>会自动删除if动态sql产生的多余的and or前缀</li>\n<li>会在if动态sql语句前添加where关键字</li>\n</ol>\n<p>如下SQL语句所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728141308831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>&lt; set&gt;作用：<br />\n1.会自动if动态sql产生的多余的逗号后缀<br />\n2.会在if动态sql语句前添加set关键字</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190728141444363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>&lt; trim&gt;作用：<br />\n可以自定义前缀和后缀：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019072814165010.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>&lt; foreach&gt; 循环遍历，<br />\n常用来做批量删除的时候用</strong><br />\n如下图所示：<br />\ncollection:相当于集合名，<br />\nitem表示集合中的一个元素，<br />\nopen是循环之前要加的东西，<br />\nclose是循环结束的时候要加的东西，<br />\nseparator:元素间使用什么分隔。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728141835696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:17', '2022-05-21 18:15:56');
INSERT INTO `tb_article` VALUES (126, 1, 5, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7397', '简单理解什么是Spring中的IOC控制反转和DI依赖注入，Spring对象的三种创建方式', '<p>﻿IOC ：Inversion of Control     控制反转<br />\nDI  :  dependency Injection   依赖注入</p>\n<p>咋一听，控制反转、依赖注入，似乎很高大上的名字，概念比较抽象，但其实慢慢分析，转换成自己的话也不难理解：</p>\n<p><strong>IOC的理解：</strong></p>\n<p><em>在原始社会的时候，我们需要自己生火、自己挖井。这个时候主动权在自己手里。随着时代的发展我们现在有燃气公司和水利公司。我们现在想喝水直接扭水龙头水就流出来了，但是水这个来源的控制权交给自来水公司了，这个过程称之为控制反转</em></p>\n<p>对于Spring来说，以前自己创建的对象UserService service = new UserServiceImpl(),<br />\nservice.xxx()<br />\n而现在，对象的创建交给Spring工厂，用的时候去工厂中获取，<br />\nClassPathXmlApplicationContext ac = new ...;</p>\n<p>从之前自己创建对象，到现在交给Spring工厂创建对象，包括给属性赋值也交给Spring工厂来完成，这个由我们自己完成一些事情转移到Spring框架完成这些事情的过程，Spring称之为控制反转（IOC）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190728145347156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>DI (依赖注入):</strong></p>\n<p>如果我们站在spring工厂的角度，工厂创建需要的对象，并且还可以给程序员中的类的属性赋值，对象由工厂创建，最终由程序员使用，这就是spring的依赖注入<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728145414207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<blockquote>\n<p>IOC和DI实际上是等同的概念，如果要进行区分的话，IOC和DI可以理解为同一个东西的不同角度看法，IOC<br />\n站在程序员的角度，以前创建对象是我们自己new出来的，现在让容器自己创建，控制权交给了容器，对于<br />\n我们来说控制权反转了。<br />\nDI是站在容器的角度，从Spring角度来看，用到的所有的对象都是自己创建的，并且对象在创建的时候需要<br />\n依赖的参数也是容器注入的，而这种维持对象之间依赖关系的方式就是依赖注入。</p>\n</blockquote>\n<blockquote>\n<p>所以IOC和DI实际上都是指容器负责创建对象和维护对象之间依赖关系的这种行为。</p>\n</blockquote>\n<h3 id=\"说到这里再来分析一下spring创建对象的三种方式\">说到这里，再来分析一下Spring创建对象的三种方式：</h3>\n<p><strong>1，通过构造方法创建，采用默认的构造函数，</strong><br />\n也就是通过xml+bean标签，bean标签要写class的类的全限定名，其原理是通过java类的反射机制创建对象。<br />\nindex : 参数的索引,从0 开始<br />\nname: 参数名<br />\ntype:类型(区分开关键字和封装类int 和Integer)</p>\n<pre><code>&lt;bean id=&quot;peo&quot; class=&quot;com.macw.pojo.People&quot;&gt;\n&lt;!-- ref 引用另一个bean value 基本数据类型或String 等--&gt;\n    &lt;constructor-arg index=&quot;0&quot; name=&quot;id&quot; type=&quot;int&quot;  value=&quot;123&quot;&gt;&lt;/constructor-arg&gt;\n    &lt;constructor-arg index=&quot;1&quot; name=&quot;name&quot; type=&quot;java.lang.String&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>在早期Spring1.0版本，还没有注解的时候，Spring能够帮我们创建对象和管理对象，<br />\n但是没有注解每创建一个对象就要配置一个xml，其实还没有我们直接new一个对象来得快呢，</p>\n<p>但是为什么spring框架仍然有他的极大优势呢，因为他最重要的一个特性是能够帮我们管理对象，<br />\n自己new对象在类中多处调用会造成程序模块之间耦合性太强，不利于维护更新。而spring帮我们管理对象通过依赖注入声明的是管理对象的关系。</p>\n<p><strong>2、通过实例工厂创建对象<br />\n也就是 工厂设计模式：帮助创建类对象，一个工厂可以生产多个对象</strong></p>\n<pre><code>// 工厂，创建对象\npublic class StudentFactory {\n    // 实例方法创建对象\n    public Student getInstance() {\n        return new User(001,&quot;学生工厂：调用实例方法&quot;);\n    }\n\n    // 静态方法创建对象\n    public static Student getStaticInstance() {\n        return new Student(002,&quot; 学生工厂：调用静态方法&quot;);\n    }\n}\n\n配置文件：\n\n&lt;!-- # 3.1 工厂类，实例方法 --&gt;\n    &lt;!-- 先创建工厂 --&gt;\n    &lt;bean id=&quot;factory&quot; class=&quot;com.macw.StudentFactory&quot;&gt;&lt;/bean&gt;\n    &lt;!-- 在创建student对象，用factory方的实例方法 --&gt;\n    &lt;bean id=&quot;student2&quot; factory-bean=&quot;factory&quot; factory-method=&quot;getInstance&quot;&gt;&lt;/bean&gt;\n</code></pre>\n<p>其中： factory-bean=”factory”指定工厂。factory-method=”getInstance”指定工厂的哪个方法。</p>\n<p><strong>3.静态工厂创建对象，不需要创建工厂，快速创建对象</strong></p>\n<p>实现步骤：编写一个静态工厂（在方法上添加static）</p>\n<pre><code>public class StudentFactory{\n    public static Student newInstance(){\n        return new Student(001,&quot;studentTest&quot;);\n    }\n}\n\n在applicationContext.xml中\n&lt;bean  id = &quot;student2&quot;  class = &quot;com.macw.pojo.StudentFactory&quot;  factory-method = &quot;newInstance&quot;&gt;&lt;/bean&gt;\n\n</code></pre>\n<p>在spring2.0之后采用注解的形式开发，减少了大量 的xml配置文件，开发的形式变为xml+bean配置数据源，大量使用第三方框架，通过组件注解配置自己的类。</p>\n<p>spring3.0之后采用配置类+bean注解来创建对象，目的想取代xml配置文件，也就是springboot自动装配的底层原理</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:22', '2022-05-21 18:15:42');
INSERT INTO `tb_article` VALUES (127, 1, 6, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7538', '面试题：BeanFactory和FactoryBean有啥关系_', '<p>﻿没啥太大关系!</p>\n<p>BeanFactory(对象工厂)，他是spring框架中的工厂类，spring的工厂设计的比较复杂，BeanFactory被抽象成了一个接口，我们经常写代码叫做ClassPathXmlApplicationContext是BeanFactory的实现类</p>\n<p>FactoryBean也是一个接口，主要用于特殊对象的创建，例如Connectoin和SqlSession对象，由于他们是一个接口，这些对象的创建需要使用代码完成，所以需要一个类实现FactoryBean接口间接创建这些类的对象</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:26', '2022-05-21 18:15:29');
INSERT INTO `tb_article` VALUES (128, 1, 6, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7939', '使用代理模式实现Spring AOP的面向切面编程，动态代理的四种增强处理', '<p>﻿<strong>什么是代理类？</strong><br />\n代理就是代替我们去执行一些额外的工作。</p>\n<p><strong>目标类:只有核心功能的类</strong></p>\n<p>比如我们在写service的时候，<strong>调用dao方法是我们的核心业务</strong>，<strong>而service类中的日志记录，事务处理，异常处理等都属于额外的功能</strong>，每个service方法中都要写一次这些额外功能也会造成大量代码的冗余，</p>\n<p><strong>而面向切面编程的意思就是说把这些公共的、额外的代码功能抽取出来，每个service里面只写我们的核心业务</strong>，这样就提高了我们的开发效率。</p>\n<p><strong>为什么代理类和目标类要实现相同的接口？</strong><br />\n1.从代码的角度来说,代理类对象能够赋值给接口类型的变量<br />\n2.要保证代理类和目标类有相同的功能</p>\n<p>有了代理类:<br />\n程序员可以只关心核心功能</p>\n<p><strong>额外功能+目标类 =代理类</strong></p>\n<p>以上这种说法就是叫做静态代理，<br />\n静态代理就是在代码编译时,代理类已经存在<br />\n好处:程序员可以只关心核心功能<br />\n不好:多个代理类 ，    没有解决代码冗余的问题</p>\n<h2 id=\"什么是动态代理\">什么是动态代理？</h2>\n<p>运行时,动态创建出来代理对象<br />\nSpringAOP通过动态代理,让程序猿只关心核心代码,同时代码不再冗余</p>\n<p><strong>springAOP的开发步骤:</strong><br />\n1.写核心功能(目标类)<br />\n核心功能就是调用dao方法：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728174629656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2.配置目标类<br />\n要在SpringApplication.xml文件中配置目标类所在路径</p>\n<pre><code> &lt;!--配置目标类--&gt;\n    &lt;bean id=&quot;bookService&quot; class=&quot;com.macw.serviceImpl.bookServiceImpl&quot;&gt;\n        &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p><strong>3.写额外功能(增强处理)</strong><br />\n(公共功能:日志处理/事务处理/异常处理/性能分析....) 等</p>\n<p>前置增强(MethodBeforeAdvice):在核心功能之前执行的额外功能<br />\n后置增强:在核心功能之后执行的额外功能</p>\n<p>环绕增强:在核心功能之前以及之后执行的额外功能<br />\n异常增强:在核心功能发生异常时执行的额外功能</p>\n<p><strong>前置增强的配置使用：</strong><br />\n1，声明一个类，需要实现	MethodBeforeAdvice接口：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728175452663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2，spring配置文件中,配置声明的增强功能类</p>\n<pre><code>	&lt;!--额外功能--&gt;\n   &lt;bean id=&quot;myBeforeAdvice&quot; class=&quot;com.macw.advice.myBeforeAdvice&quot;&gt;&lt;/bean&gt;\n</code></pre>\n<p>3，在spring配置文件中,通过aop标签做配置(需要添加aop命名空间以及schema验证文档):<br />\n.在哪些方法上面做增强处理<br />\n.在需要增强处理的方法上面,加哪个增强处理<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728180128311.png\" alt=\"在这里插入图片描述\" /><br />\n4.让spring在运行的时候,帮我们创建代理对象()<br />\n<img src=\"https://img-blog.csdnimg.cn/2019072817590249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>详解advice<br />\nMethodBeforeAdvice前置增强的before方法</strong><br />\n实现MethodBeforeAdvice接口必须要要实现before方法，这个方法有三个参数，<br />\narg0：目标方法，<br />\narg1:目标方法参数，<br />\narg2:目标类，<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728180359181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2.AfterReturningAdvice:后置增强<br />\n<img src=\"https://img-blog.csdnimg.cn/2019072818044361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n3.ThrowsAdvice:异常增强<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728180513201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>4.MethodInterceptor:环绕增强,目标方法执行之前以及之后做的增强处理</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190728180541273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n总结：<br />\n<strong>Spring AOP:Aspect Oriented Program 面向切面编程</strong><br />\n几个重要概念：</p>\n<p>1.切入点:需要把增强处理加在的位置;service层的方法上面;需要在配置文件中配置<br />\n2.增强处理:额外功能(公共功能) ,通知/建议(advice)<br />\n3.目标类:核心功能所在的类(原始类)<br />\n4.切面:把增强处理,放在切入点的位置,形成的一个概念<br />\n5.编织/织入:把增强处理放置在切入点的过程</p>\n<p><strong>AOP使用场景:</strong><br />\n1.把功能内容抽取出来,形成advice;在配置文件中中做配置====&gt;程序猿只关心核心功能;解决冗余<br />\n2.在原有功能基础之上,做功能扩展===&gt;在不改变原有代码的基础上做功能扩展</p>\n<p>AOP实现:代理模式的使用</p>\n<p>代理类的产生原理<br />\n类加载ClassLoader<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728181445489.png\" alt=\"在这里插入图片描述\" /></p>\n<p>代理类的生成:由jdk动态代理生成<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728181529670.png\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"springaop实现原理\">SpringAOP实现原理:</h2>\n<p>1.底层通过字节码技术,把目标对象以及额外功能动态封装,生成代理对象  ==&gt;动态代理<br />\n使用了JDK动态代理以及cglib动态代理<br />\n2.为什么通过id得到的是代理对象<br />\nspring工厂创建对象之后,由BeanPostProcessor进行处理<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728181629605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:28', '2020-10-07 13:09:55');
INSERT INTO `tb_article` VALUES (129, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=9891', 'idea新手好用的几个插件、让你快速掌握IDEA', '<p>﻿从Myeclipse突然转到idea，最让我们感到不顺手的就是快捷键的使用变了，</p>\n<p>习惯了一个东西再去接受另一个新事物是很难接受的，虽然我们可以让idea切换成eclipse的快捷键，</p>\n<p>但是仍然有很多功能的快捷键的我们所不知道的，</p>\n<p>所以我要推荐的第一个插件就是：</p>\n<h2 id=\"1key-promoter-x\">1、Key promoter X</h2>\n<blockquote>\n<p>显示点击某个功能选项的快捷键（如果有的话）<br />\n前期新手使用确实对idea的快捷键感到头疼，有了这个的话就能帮助我们很快的掌握各种快捷键<br />\n等到使用熟练之后再把这个关掉就好了</p>\n</blockquote>\n<p>Key Promoter (X)其实这里是指2个插件，分别为Key Promoter X 和Key Promoter ，主要功能差不多的，都是一个提示插件，当你在IDEA里面使用鼠标的时候，如果这个鼠标操作是能够用快捷键替代的，那么Key Promoter X会在右下角弹出一个提示框，Key Promoter 会在左上角弹出一个提示框告，<strong>并且当你想看看一个功能的快捷键的时候你只需要把鼠标放上去不动他就会提示你这个功能的快捷键是啥</strong>、<strong>或者告知你这个鼠标操作可以用什么快捷键替代</strong>。当然，对于Key Promoter X还有一个官方功能解释那就是用来统计你鼠标操作的次数，然后在一个窗口中展示出来。对于想完全使用快捷键在IDEA的，这个插件就很有用。</p>\n<p><strong>安装：</strong><br />\n安装这个插件很简单，只需要打开Settings,然后找到Plugins那一栏目,然后输入key promoter,点击install就行，安装好会让你重启生效，<br />\n<img src=\"https://img-blog.csdnimg.cn/20190730090501863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"idea安装插件\" /><br />\n这是我已经安装过了。<br />\n如果找不到，就直接到仓库里找即可。</p>\n<h2 id=\"2jrebel-for-intellij\">2，JRebel for IntelliJ</h2>\n<blockquote>\n<p>一款热部署插件，只要不是修改了项目的配置文件，用它都可以实现热部署。<br />\n在没有这个之前频繁的重启和reply搞得我烦不胜烦。而这个简直没有太方便，节省了大量的重启程序的等待时间<br />\n只不过是收费的，但是目前已经有好多破解方法了，不过功能确实很强大。算是开发必备神器了。</p>\n</blockquote>\n<p><strong>安装：</strong><br />\n安装和上面安装步骤一样，打开Settings,然后找到Plugins那一栏目,然后输入Jrebel,一般第一个就是,点击install安装重启就能用，安装好如下图所示会在setting下面出现JRebel的配置信息：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190730091920369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n我这个是已经激活过了，<br />\n激活流程可以参考这篇大神写的文章：<a href=\"https://blog.csdn.net/songfei_dream/article/details/90921505\">https://blog.csdn.net/songfei_dream/article/details/90921505</a></p>\n<p><strong>使用：</strong><br />\n这个安装完之后会在右上角启动哪里多两个启动项，如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/2019073010052628.png\" alt=\"在这里插入图片描述\" /><br />\n再次启动程序的时候我们就可以通过jrebel启动tomcat了，实现真正 的热部署。快捷键是crtl+F10</p>\n<h2 id=\"3mybatis-plugin\">3,Mybatis plugin</h2>\n<blockquote>\n<p>可以在mapper接口中和mapper的xml文件中来回跳转，就想接口跳到实现类那样简单。<br />\n这个是免费版的，有收费要破解的，不过功能都差不多</p>\n</blockquote>\n<p><strong>安装：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190730101011297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>效果：</strong><br />\n点击箭头就可以实现dao和mapper文件之间的跳转<br />\n<img src=\"https://img-blog.csdnimg.cn/2019073011004642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"4alibaba-java-coding--guidelines\">4、Alibaba java Coding  Guidelines</h2>\n<blockquote>\n<p>阿里巴巴java开发规范手册<br />\n规范代码，从小开始<br />\n这个插件会智能时时的提醒你哪里写的不规范，并且命名哪里不好，建议你怎样怎样改，等等。<br />\n开发必备，很重要，习惯一旦养成很难再修改的，从开始就要规范代码书写风格<br />\n<img src=\"https://img-blog.csdnimg.cn/20190731104714623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<h2 id=\"5装饰插件activate-power-mode\">5，装饰插件：activate-power-mode</h2>\n<blockquote>\n<p>这是一款让你在编码的时候，整个屏幕都为之颤抖的插件。<br />\n敲的越快，抖动越厉害，并且会统计你在不停歇的情况下一口气敲了多少次键盘<br />\n不过这个插件晃的我头晕，</p>\n</blockquote>\n<p><strong>效果</strong></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNzcyNzQzLzIwMTgwNC83NzI3NDMtMjAxODA0MTEyMzIxMzAzNzQtMjA4NzI3MTU1MC5naWY\" alt=\"在这里插入图片描述\" /><br />\n重点还是前4个好用哈，最后一个就是玩玩~</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:31', '2021-08-30 09:58:46');
INSERT INTO `tb_article` VALUES (130, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7138', 'Nginx搭建负载均衡详细操作', '<p>﻿</p>\n<p><strong>什么是负载均衡?</strong></p>\n<p>互联网早期，业务流量比较小并且业务逻辑比较简单，<strong>单台服务器</strong>便可以满足基本的需求；但随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台机器的性能问题以及单点问题凸显了出来，因此需要<strong>多台机器</strong>来进行性能的水平扩展以及避免单点故障。但是要如何将不同的用户的流量分发到不同的服务器上面呢？</p>\n<p>那么通过使用nginx搭建的负载均衡器即可解决该问题</p>\n<p>客户端的流量首先会到达负载均衡服务器，由负载均衡服务器通过一定的调度算法将流量分发到不同的应用服务器上面，同时负载均衡服务器也会对应用服务器做周期性的健康检查，当发现故障节点时便动态的将节点从应用服务器集群中剔除，以此来保证应用的高可用。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190801211348483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>搭建步骤以及准备条件：</strong></p>\n<ol>\n<li>搭建三台Linux服务器</li>\n<li>一台安装Nginx,另外两台各安装Tomcat</li>\n<li>对Nginx的/etc/nginx/conf.d/default.conf进行配置</li>\n<li>测试负载均衡</li>\n</ol>\n<p>这里我用的是使用Vmware创建三台Linux服务器，其中一台安装Nginx，为其使用dhclient分配ip为：192.168.248.128<br />\n另外两台安装jdk+Tomcat.，分别为其分配IP为：192.168.129和129.168.248.130.</p>\n<p>结果如下图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019080121244254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"详细操作\">详细操作：</h2>\n<h4 id=\"1克隆三台linux服务器\">1.克隆三台Linux服务器</h4>\n<p>​     1.1 以上图为例 dhclient 分配 ip地址</p>\n<p>​            安装tomcat的两台服务器ip分别为192.168.30.128、192.168.30.130</p>\n<p>​            安装的nginx的服务器ip为192.168.30.131</p>\n<h4 id=\"2安装jdk和tomcat\">2.安装JDK和Tomcat</h4>\n<p>在192.168.30.128、192.168.30.130上先安装JDK，在安装tomcat</p>\n<p>安装tomcat需要依赖JDK</p>\n<p>安装步骤参考之前的文章</p>\n<h4 id=\"3安装nginx\">3.安装Nginx</h4>\n<p>​    在192.168.30.131安装Nginx</p>\n<h4 id=\"4配置负载均衡\">4.配置负载均衡</h4>\n<p>在192.168.30.131安装Nginx的服务器上， 打开/etc/nginx/conf.d/default.conf文件</p>\n<pre><code>#新增\nupstream aa{\n    server 192.168.30.128:8080;\n    server 192.168.30.130:8080;\n}\n\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n        #新增一行\n        proxy_pass  http://aa;\n    }\n}\n\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190801212805182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"5关闭nginx上的安全组\">5.关闭Nginx上的安全组</h4>\n<p>使用  vi  /etc/selinux/config<br />\n编辑config文件，修改SELNUX=disabled<br />\n如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190801213601273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>注意：修改过安全组要把系统重启reboot下生效！<br />\n重启之后如果不能访问就要禁用掉防火墙：systemctl stop firewalld<br />\n并且开启Nginx：stystemctl start nginx</p>\n<h4 id=\"6测试\">6.测试</h4>\n<p>通过  <a href=\"http://192.168.30.131:80\">http://192.168.30.131:80</a> 访问Nginx,即可看到实际访问了tomcat</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190801212929871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"负载均衡的策略\">负载均衡的策略</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190801213815648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>\n<p>轮询 （默认）</p>\n<p>特点：一个一个挨着访问，tomcat服务器会被依次访问</p>\n</li>\n<li>\n<p>权重</p>\n<p>weight=数字越大权重越大，被访问的几率越高</p>\n<p>下边的配置上边的机器访问2次，下边的访问1次</p>\n</li>\n</ol>\n<p>​    <img src=\"https://img-blog.csdnimg.cn/20190801213027809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n​</p>\n<ol start=\"3\">\n<li>\n<p>ip黏着</p>\n<p>根据用户的ip,绑定到一台tomcat服务器<br />\n根据客户端用户的ip地址计算出一个可以被访问的tomcat服务器<br />\n如果客户端用户的ip地址不变，那么访问的tomcat就固定了</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190801213058161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>原理:把用户的ip进行hash处理(取用户ip的hash值),对tomcat总数量取模,然后根据得到的值,对应找到要访问的Tomcat</p>\n<h2 id=\"反向代理和正向代理的区别\">反向代理和正向代理的区别</h2>\n<p>代理如果在服务器端就是反向代理，如果放在客户端就是正向代理<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080121444414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"反向代理-和-负载均衡-的关系\">反向代理 和 负载均衡 的关系？</h2>\n<p>什么是负载均衡？ 搭建多个tomcat服务器，在用户访问量大的时候，可以访问不同的tomcat，减少某个tomcat的访问压力</p>\n<p>在nginx中如果想实现负载均衡，需要借助反向代理机制</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:36', '2021-08-30 09:58:33');
INSERT INTO `tb_article` VALUES (131, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4788', 'Centos7安装JDK和Tomcat详细步骤', '<p>﻿</p>\n<p><strong>安装步骤</strong></p>\n<ol>\n<li>将JDK安装包上传到/opt下</li>\n<li>解压</li>\n<li>配置JDK的环境变量</li>\n<li>使配置生效</li>\n<li>测试JDK是否安装成功</li>\n</ol>\n<h4 id=\"1上传jdk安装包到centos系统中的opt目录下\">1.上传JDK安装包到Centos系统中的/opt目录下</h4>\n<p>1.1 使用xftp软件和服务器建立传输</p>\n<p><img src=\"https://img-blog.csdnimg.cn/201908020841059.png\" alt=\"[外链图片转存失败(img-CtHs62Ir-1564705402590)(assets\\1563577470477.png)]\" /></p>\n<p>1.2 建立会话</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084124185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-aak5tZci-1564705402592)(assets\\1563577590105.png)]\" /></p>\n<p>1.3 填写连接会话的参数</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084201723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-CTZFFQe9-1564705402594)(assets\\1563578003459.png)]\" /><br />\n<img src=\"https://img-blog.csdnimg.cn/20190802084218687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-QoTSsKd0-1564705402598)(assets\\1563578266172.png)]\" /></p>\n<p>1.4 上传JDK的安装包到Linux系统中的/opt目录下</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084249307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-XJtwQDjf-1564705402601)(assets\\1563578083307.png)]\" /></p>\n<h4 id=\"2对上传后的jdk进行解压操作\">2.对上传后的JDK进行解压操作</h4>\n<p>2.1 进入/opt目录，查看上传后的JDK安装包</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084321703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-n0qkNEmT-1564705402603)(assets\\1563578357662.png)]\" /></p>\n<p>2.2 使用tar命令对安装包进行解压安装操作</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084348488.png\" alt=\"[外链图片转存失败(img-sWXS2ocl-1564705402604)(assets\\1563578725269.png)]\" /></p>\n<p>2.3 解压后查看结果</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084400475.png\" alt=\"​	[外链图片转存失败(img-0JMcmAyB-1564705402604)(assets\\1563578770033.png)]\" /></p>\n<p>2.4 对解压包进行重命名，此步骤不是必须的，主要是为了方便后边配置环境变量</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084415519.png\" alt=\"[外链图片转存失败(img-WRGm8lhb-1564705402605)(assets\\1563578859303.png)]\" /></p>\n<h4 id=\"3配置环境变量\">3.配置环境变量</h4>\n<p>3.1 编辑/etc/profile文件</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084429531.png\" alt=\"[外链图片转存失败(img-B4O5MFI5-1564705402605)(assets\\1563579105923.png)]\" /></p>\n<p>3.2 来到profile文件末尾，按i进入编辑模式</p>\n<p>3.3 增加JAVA_HOME和PATH两个环境变量</p>\n<pre><code># JAVA_HOME\nexport JAVA_HOME=/opt/jdk1.8\n# PATH\nexport PATH=$PATH:$JAVA_HOME/bin\n解释： $PATH是获取本身已经配置的path环境变量   \n      :(冒号)是分隔符的作用，相当于windows系统中配置的逗号\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084914896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-ZNrtSdAZ-1564705402606)(assets\\1563579389001.png)]\" /></p>\n<p>编辑完成保存退出</p>\n<p>3.4 使用source命令配置文件生效</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084942990.png\" alt=\"[外链图片转存失败(img-q9UO9DAk-1564705402607)(assets\\1563579423623.png)]\" /></p>\n<p>3.5 测试javac和java命令是否可用</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802085045546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-K7rZKudz-1564705402607)(assets\\1563579582383.png)]\" /></p>\n<p>使用java -version命令查看当前安装的jdk版本</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802085108870.png\" alt=\"[外链图片转存失败(img-VzAF0eDj-1564705402608)(assets\\1563579655693.png)]\" /></p>\n<p>到此，jdk1.8就算安装完成了，接下来安装tomcat</p>\n<h2 id=\"tomcat安装步骤\">Tomcat安装步骤：</h2>\n<ul>\n<li>上传tomcat到/opt下</li>\n<li>解压</li>\n<li>启动tomcat</li>\n<li>使用windows系统的浏览器访问Linux服务器的tomcat</li>\n</ul>\n<p><strong>1.上传tomcat到Linux系统的/opt目录下</strong><br />\n1.1 打开xftp连接到Linux系统上，将tomcat上传至/opt目录下<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085521524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>2.对于上传后的tomcat，进行解压安装</strong><br />\n2.1 查看上传后的tomcat，并且使用tar命令解压<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080208554144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2.2 查看解压后的tomcat<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085552895.png\" alt=\"在这里插入图片描述\" /><br />\n<strong>3.启动tomcat</strong><br />\n3.1 进入解压后的tomcat中bin子目录<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085615441.png\" alt=\"在这里插入图片描述\" /><br />\n3.2 执行./startup.sh命令启动tomcat<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085812211.png\" alt=\"在这里插入图片描述\" /><br />\n4.访问tomcat<br />\n4.1 在windows系统中打开浏览器输入 <a href=\"http://ip:8080\">http://ip:8080</a> 访问已经启动的tomcat<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085914846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>注意事项：如果不能访问就关闭linux系统的防火墙</strong><br />\nsystemctl stop firewalld<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085941311.png\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:12:15', '2020-10-07 13:06:41');
INSERT INTO `tb_article` VALUES (132, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=6753', 'Centos7安装Nginx详细安装步骤', '<p>﻿</p>\n<h2 id=\"centos7安装nginx步骤\">Centos7安装Nginx步骤</h2>\n<ol>\n<li>手动配置nginx的yum仓库</li>\n<li>使用yum命令安装nginx</li>\n<li>启动nginx</li>\n<li>访问nginx</li>\n</ol>\n<h4 id=\"1指定nginx的yum仓库\">1.指定nginx的yum仓库</h4>\n<p>说明：centos系统中默认的yum仓库中没有nginx的安装包，<br />\n<strong>所以要想安装nginx需要单独指定它的仓库地址</strong></p>\n<p>1.1 将nginx.repo上传到Linux服务器下的/etc/yum.repos.d/下</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095154684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-Le4aM6gZ-1564710569597)(assets\\1563680660832.png)]\" /></p>\n<p>nginx.repo文件内容说明（了解）：</p>\n<p>name=     #一个描述，随意。<br />\nbaseurl=   #设置资源库的地址<br />\ngpkcheck=0 表示对从这个源下载的rpm包不进行校验  ， 1是校验；<br />\nenable=1 表示启用这个源 ， 0是禁用。</p>\n<pre><code class=\"language-xml\">[nginx]\nname=nginx repo\nbaseurl=http://nginx.org/packages/centos/7/x86_64/\ngpgcheck=0\nenabled=1\n</code></pre>\n<h4 id=\"2安装nginx\">2.安装nginx</h4>\n<p>2.1 使用yum install nginx 安装nginx</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095217158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-XwWjM2JW-1564710569604)(assets\\1563681894366.png)]\" /></p>\n<p>输入y</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095227875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-tPhk5gH7-1564710569604)(assets\\1563681901148.png)]\" /></p>\n<p>安装完成</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095238959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-xfGPm3C9-1564710569605)(assets\\1563681914220.png)]\" /></p>\n<p>可以查看whereis nginx查看安装位置</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095250383.png\" alt=\"[外链图片转存失败(img-sL0CGaE1-1564710569606)(assets\\1563681972621.png)]\" /></p>\n<p>nginx安装配置文件位置(重要):</p>\n<p>配置文件位置: /etc/nginx/nginx.conf</p>\n<p>配置文件路径: /etc/nginx/conf.d/default.conf (默认加载)</p>\n<h3 id=\"3启动nginx\">3.启动nginx</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095304135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-nrRDw8Jq-1564710569606)(assets\\1563682067852.png)]\" /></p>\n<p>启动Nginx<br />\nsystemctl start nginx<br />\n停止Nginx<br />\nsystemctl stop nginx<br />\n查看Nginx启动状态<br />\nsystemctl status nginx</p>\n<h4 id=\"4访问nginx\">4.访问nginx</h4>\n<p>在windows中打开浏览器输入<a href=\"http://ip:80\">http://ip:80</a></p>\n<p>说明：80是http协议的默认端口号，当端口号为80时可以省略不写</p>\n<p>[外链图片转存失败(img-vgBkRSr7-1564710569607)(assets\\1563711413922.png)]</p>\n<p><a href=\"p://ip:80\">p://ip:80</a></p>\n<p>说明：80是http协议的默认端口号，当端口号为80时可以省略不写</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095346272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存中...(img-vgBkRSr7-1564710569607)]\" /><br />\n到此，Centos7安装Nginx就完成啦</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:12:18', '2020-10-07 13:06:06');
INSERT INTO `tb_article` VALUES (133, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=2354', 'Yum命令使用，使用yum安装vim案例演示yum的使用', '<p>﻿</p>\n<h4 id=\"何为yum-\">何为Yum ?</h4>\n<p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。</p>\n<p>基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>\n<p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>\n<blockquote>\n<p>简单说：从指定服务器自动下载并安装，使用简单方便</p>\n</blockquote>\n<p>1.安装指定的软件命令：yum install &lt;package_name&gt;</p>\n<p>2.更新指定的软件命令：yum update &lt;package_name&gt;</p>\n<p>3.删除软件包命令：yum remove &lt;package_name&gt;</p>\n<p>4.查找软件包 命令：yum search <keyword></p>\n<p>5.列出所有可安裝的软件清单命令：yum list</p>\n<h4 id=\"下边以vim的安装为例演示yum的使用\">下边以Vim的安装为例，演示Yum的使用</h4>\n<p>Vim是一个类似于Vi的著名的功能强大、高度可定制的文本编辑器，在Vi的基础上改进和增加了很多特性。</p>\n<p>1.1 使用Yum命令安装Vim</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095654938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-PZSCRNhs-1564710956716)(assets\\1563677444298.png)]\" /></p>\n<p>1.2 输入y，确定安装</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095716576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-cEviKAHX-1564710956718)(assets\\1563677490574.png)]\" /></p>\n<p>再输入一个y</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095725494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-IhB43gIF-1564710956718)(assets\\1563677545056.png)]\" /></p>\n<p>出现这个提示说明vim ，以及vim需要的依赖都安装完成</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095738125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-DdonWFH8-1564710956721)(assets\\1563677584819.png)]\" /></p>\n<p>1.3 通过vim命令修改某个文件，可以发现内容有颜色，说明vim已经正常安装并且可以使用了</p>\n<p>​      此处主要是为了介绍yum安装，vim的使用不再介绍，vim的基本使用和vi是一样</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095750451.png\" alt=\"[外链图片转存失败(img-Zc1KZtCS-1564710956723)(assets\\1563677748821.png)]\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/201908020958026.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-oXMPAesr-1564710956726)(assets\\1563677754841.png)]\" /></p>\n<h4 id=\"yum安装的原理介绍\">yum安装的原理介绍</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095812908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-wqcOkbSo-1564710956727)(assets\\1563679844231.png)]\" /></p>\n', 1, '', 0, 0, 1, '2020-09-29 17:24:57', '2020-12-19 17:11:42');
INSERT INTO `tb_article` VALUES (134, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=815', 'Spring boot 整合mybatis报错ClassNotFoundException_ org.mybatis.logging.LoggerFactory', '<p>﻿<strong>使用spring boot整合mybatis需要加入依赖：</strong></p>\n<pre><code>&lt;dependency&gt;\n      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n      &lt;version&gt;1.3.2&lt;/version&gt;\n    &lt;/dependency&gt;\n</code></pre>\n<p>这时候项目是没有任何问题的，正常运行！</p>\n<h2 id=\"但是\">但是</h2>\n<p>但是后来我使用<strong>Lombok</strong>和<strong>MyBatis-Plus</strong>进行开发，然后就引入了一个叫做<strong>mybatis-plus-boot-starter</strong>的依赖，再次运行测试的时候就一直报错：</p>\n<p>java.lang.IllegalStateException: Failed to load ApplicationContext</p>\n<p><strong>Caused by: java.lang.ClassNotFoundException: org.mybatis.logging.LoggerFactory</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190806202954276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n百度了一下其他人说是少了commons-logging 的jar包，我加上后依旧报错</p>\n<p>有人说是少了slf4j-api的jar包，我加上后也是依旧报错。</p>\n<p><strong>还有人说是少了mybatis-plus-boot-starter</strong>，到这里我似乎发现了什么，<br />\n<strong>使用mybatis-plus是让spring boot集成了mybatis，那么我在上面配置的mybatis-spring-boot-starter这个jar同样是集成mybatis的，这两个会不会有冲突？或者是因为这个jar导致了下面的mybatis-plus报错？</strong></p>\n<p>抱着试试的态度，我把mybatis-spring-boot-starter这个jar注释掉然后再运行，</p>\n<h2 id=\"然后就\">然后就，</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190806203918945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"大功告成\">大功告成！</h2>\n<p>后来我又测试，如果没有mybatis-plus提供的</p>\n<pre><code>   &lt;dependency&gt;\n        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n        &lt;version&gt;3.1.2&lt;/version&gt;\n    &lt;/dependency&gt;\n</code></pre>\n<p>这个依赖的话，同样会报ClassNotFoundException: org.mybatis.logging.LoggerFactory这个错！</p>\n<p>所以就能确定我的错误原因了！</p>\n<p>最后附一个lombok常用注解：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190806204243388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:12:32', '2020-10-07 13:05:32');
INSERT INTO `tb_article` VALUES (135, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3944', 'Centos 7搭建MySQL-主从复制', '<p>﻿## 什么是主从复制?</p>\n<p>如果数据库服务器一旦宕机，我们的项目将无法运行，如果数据库服务器硬盘损坏还将面临数据丢失的问题!!!</p>\n<p><strong>将MySQL数据库主机的数据复制到MySQL从机上(备份)</strong></p>\n<p>原理：将MySQL主机的SQL语句以日志的方式记录下来，通过网络将日志文件复制到从机上，执行日志中的SQL语句同步主机的操作和数据</p>\n<p>搭建步骤</p>\n<ol>\n<li>创建三台Linux服务器</li>\n<li>分别安装MySQL数据库</li>\n<li>配置主节点（Mysql主机操作）</li>\n<li>配置从节点（Mysql从机操作）</li>\n</ol>\n<h4 id=\"1搭建三台linux服务器\">1.搭建三台Linux服务器</h4>\n<p>一台作为mysql数据库的主节点(master)</p>\n<p>另外两台作为mysql数据库的从节点(slave)</p>\n<h4 id=\"2分别安装mysql数据库\">2.分别安装mysql数据库</h4>\n<p>说明：可以先安装一台，然后在克隆两台</p>\n<p>2.1 上传mysql的yum源</p>\n<p>2.2 使用yum install 命令安装</p>\n<p>2.3 启动mysql数据库，修改密码，设置允许远程访问</p>\n<p>2.4 关闭防火墙</p>\n<p>或者上传rpm安装包离线安装</p>\n<p>可参考之前文章Linux上安装mysql教程：<br />\n<a href=\"https://blog.csdn.net/MacWx/article/details/98171109\">https://blog.csdn.net/MacWx/article/details/98171109</a></p>\n<h4 id=\"3配置主从\">3.配置主从</h4>\n<p>3.1 在主节点（也就是Mysql主机）</p>\n<p>vi /etc/my.cnf</p>\n<p>增加</p>\n<pre><code>server-id=132\nlog_bin\n\n#需要同步的数据库\nbinlog-do-db=baizhi\n#忽略(不需要)同步的数据库\nbinlog-ignore-db=mysql\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807193853293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-EzkAqLnM-1565177567068)(assets\\1563789758573.png)]\" /></p>\n<p>重启主节点的mysql数据库</p>\n<p>登录，查看主机状态</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194339252.png\" alt=\"[外链图片转存失败(img-KKS7eoUF-1565177567069)(assets\\1563789882250.png)]\" /></p>\n<p>3.2 从节点</p>\n<p>说明：如果是克隆的需要先删除从机上的/var/lib/mysql/auto.cnf文件</p>\n<pre><code>rm -f  /var/lib/mysql/auto.cnf\n</code></pre>\n<p>vi /etc/my.cnf</p>\n<p>增加</p>\n<pre><code>server-id=133\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2019080719440416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-R1q40Q0I-1565177567069)(assets\\1563789981959.png)]\" /></p>\n<p>重启mysql数据库       systemctl restart mysqld</p>\n<p>登录mysql数据库       mysql -uroot -p</p>\n<p>关闭从机状态              stop slave</p>\n<p>设置和主机建立连接</p>\n<p>语法</p>\n<pre><code>change master to master_host=\'主机ip地址\',master_user=主机用户名,master_password=主机密码,master_log_file=\'主机日志文件名\',master_log_pos=日志文件的位置\n</code></pre>\n<p>示例</p>\n<pre><code>change master to master_host=’192.168.152.133’,master_user=’root’,master_password=’123456’,master_log_file=’mysqld-bin.000001’,master_log_pos=241\n</code></pre>\n<p>查看从机状态              show slave status \\G;</p>\n<h4 id=\"4测试\">4.测试</h4>\n<p>在主节点创建一个叫做baizhi的数据库，然后在该数据库中创建一张表，添加一条测试数据</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194430611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-GOAwJ4fR-1565177567070)(assets\\1563868813155.png)]\" /></p>\n<p>在从节点查看</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194442918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-UwygxUPF-1565177567071)(assets\\1563868782868.png)]\" /></p>\n<p>看到我们在Mysql主机添加一条记录，从机也有了相应的记录，这就实现了mysql的主从复制！</p>\n', 1, '', 0, 0, 1, '2020-10-07 13:03:14', '2020-12-21 14:50:26');
INSERT INTO `tb_article` VALUES (136, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8818', 'Centos 7使用MyCat搭建 MySQL-读写分离', '<p>﻿</p>\n<h2 id=\"什么是读写分离\">什么是读写分离?</h2>\n<p>只有mysql的主机接收增删改SQL语句，从机接收查询语句，分担主机的查询压力</p>\n<p><strong>搭建步骤</strong></p>\n<ol>\n<li>新建一台Linux服务器、关闭防火墙</li>\n<li>上传mycat的安装包到服务器、解压安装</li>\n<li>配置mycat的环境变量</li>\n<li>修改mycat的server.xml和schema.xml配置文件</li>\n<li>启动mycat</li>\n<li>测试</li>\n</ol>\n<h4 id=\"1上传mycat安装包到-usr目录下\">1.上传mycat安装包到 /usr目录下</h4>\n<p>使用Shell上传文件<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807194804651.png\" alt=\"[外链图片转存失败(img-RxcePQqK-1565178387515)(assets\\1563939118812.png)]\" /></p>\n<h4 id=\"2解压安装\">2.解压安装</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194829867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-azuw4Fis-1565178387516)(assets\\1563939127063.png)]\" /></p>\n<h4 id=\"3配置环境变量\">3.配置环境变量</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194842945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-M3lz6kTq-1565178387517)(assets\\1563939234079.png)]\" /></p>\n<p>在profile文件中添加以下内容：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194853939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-0SxjIG8z-1565178387518)(assets\\1563939258590.png)]\" /></p>\n<p>使用source使profile生效</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019080719491061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-KlZcok9I-1565178387524)(assets\\1563939334854.png)]\" /><br />\n测试mycat命令已经可以正常使用！！！<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807195045279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"4修改mycat的配置文件\">4.修改mycat的配置文件</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195058987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-Y5sHEbse-1565178387525)(assets\\1563939427059.png)]\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195118274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-ggyxZ0dJ-1565178387525)(assets\\1563939587312.png)]\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195134837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-ukQkcW8t-1565178387526)(assets\\1563939932919.png)]\" /></p>\n<p>关闭防火墙</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195145851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-ZtqO2hDx-1565178387526)(assets\\1563939991140.png)]\" /></p>\n<p>测试<br />\n在windows主机上使用navicat连接mysql进行测试<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807195203899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-QsAmFHId-1565178387527)(assets\\1563940150731.png)]\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195304645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>连接成功后我们之后再进行增删改查操作就可以只连接mycat主机进行操作</strong>，mycat会自动的进行对mysql的主机接收增删改SQL语句，从机接收查询语句，分担主机的查询压力。</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:09', '2020-10-07 13:02:54');
INSERT INTO `tb_article` VALUES (137, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=498', 'Linux 常用基本命令总结', '<p>﻿## Linux 常用基本命令总结</p>\n<p>1.1  <strong>ls</strong><br />\n作用：查看目录下的所有文件</p>\n<p>ls -a    -后边的参数   命令可以跟参数<br />\n作用：可以查询被隐藏的文件<br />\n<strong>ls -l</strong><br />\n作用：查看文件的详细信息</p>\n<p>通常我们结合起来使用：<br />\n查询文件夹下的全部文件信息：<strong>ls -la</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203216430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\nr:可读权限<br />\nw：可写权限<br />\nx：可执行权限</p>\n<p>三个为一组，其中前三个为当前用户对该文件的权限<br />\n中间三个为root管理员用户的权限<br />\n最后三个是其他用户的权限</p>\n<p>例如，如果设置为只可读：r--<br />\n只可读写：rw-<br />\n等<br />\n1.2 <strong>cd  切换目录</strong></p>\n<p>绝对路径   以 /  开头<br />\n相对路径   从当前所在的目录开始</p>\n<p>cd .   一个.代表当前目录<br />\ncd ..   两个..代表上一级目录<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080720354164.png\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>1.3 mkdir</strong><br />\n作用：创建文件夹<br />\n用法： mkdir  文件夹名称(可以是相对或者绝对路径)<br />\nmkdir  a1  在当前文件夹中创建a1文件夹<br />\nmkdir -p a1/b1  创建b1文件夹，如果父文件夹不存在可以一并创建</p>\n<p><strong>1.4 touch</strong>   (了解)<br />\n作用：创建空白文件<br />\ntouch 1.txt  创建一个空白的1.txt文件</p>\n<p><strong>1.5 echo</strong><br />\n作用：打印<br />\necho hello   向控制台打印hello字符串</p>\n<p><strong>1.6  &gt;  &gt;&gt;</strong><br />\n作用：指定输出的文件<br />\necho hello &gt; 1.txt  向1.txt文件中输出hello<br />\n区别 &gt; 是覆盖原有文件的内容  &gt;&gt; 在原有文件中追加新的内容</p>\n<p><strong>1.7 cat</strong><br />\n作用：查看文件内容<br />\ncat  1.txt  在控制台打印1.txt文件中的内容</p>\n<p><strong>1.8 cp</strong><br />\n作用：复制<br />\n在tmp目录下创建一个文件1.txt<br />\n[root@localhost  tmp] cp  1.txt  /1.txt  将当前目录下的1.txt 复制到根目录下</p>\n<p><strong>1.9 mv</strong><br />\n作用：移动和重命名<br />\n[root@localhost  tmp] mv  1.txt  2.txt  将当前目录下的1.txt 重命名为2.txt<br />\n[root@localhost  tmp] mv  2.txt  /     将当前目录下的2.txt 移动到 跟目录下</p>\n<p><strong>2.0 rm</strong><br />\n作用：删除<br />\n有询问的删除!!<br />\nrm 文件名<br />\nrm -r 文件夹      -r 是递归<br />\n不带询问的删除 -f<br />\nrm -f 文件名    直接删除文件，不询问<br />\nrm -rf 文件夹    直接删除文件夹，不询问</p>\n<p><strong>2.2 pwd</strong><br />\n作用：打印当前所在的目录路径<br />\n可以获取当前路径进行复制使用<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080720355591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2.3 cat、more、less、head、tail</strong><br />\n作用：查看文件的内容<br />\ncat特点：展示文件中所有内容</p>\n<p>more和less 特点：分页展示文件中内容<br />\n回车往下一行 ，空格往下翻一页</p>\n<pre><code> more只能往下翻， less还可以通过键盘上的上下键 上下翻\n 使用less查看，使用q键退出查看\n</code></pre>\n<p>head特点：查看文件的前n行<br />\nhead  -n  5  /etc/profile  查看文件的前5行</p>\n<p>tail特点：查看文件的最后几行<br />\ntail的特殊作用：查看日志文件 tail -f xxx.txt  可以监听文件，打印出新生产的日志信息</p>\n<p><strong>2.3 tab键</strong>  （键盘上的一个快捷键）<br />\n作用：自动补全命令 文件路径等<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080720361717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2.4 grep</strong><br />\n作用：根据关键字查找<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203652730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>2.5 find</strong><br />\n作用：从系统中进行查找<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203702947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>2.6 systemctl  (system control)</strong><br />\n作用：开启、关闭、查看、重启系统的服务<br />\n语法：systemctl  start     服务名<br />\nsystemctl  restart   服务名<br />\nsystemctl  stop     服务名<br />\nsystemctl  status    服务名</p>\n<p>例如：以防火墙为例，进行服务器的开启，关闭等操作</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807203715174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>在centos6  services iptables stop  (了解)<br />\n重启虚拟机防火墙会自动开启</p>\n<p>在实际的阿里云服务器中可以不关闭防火墙，只开启指定端口(通过图形界面完成)</p>\n<p><strong>2.7 ps -ef</strong><br />\n作用：查看虚拟机正在运行的进程<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203737801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2.8 kill -9 进程id</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807203800657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n如果当前虚拟机ip丢失，dhclient命令又无法使用<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203811609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>3.0 tar 命令</strong><br />\n作用：对文件进行压缩和解压缩操作<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203821896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"2vi编辑器\">2.VI编辑器</h2>\n<p>作用：linux操作的一款编辑器，只能用键盘操作，无法使用鼠标</p>\n<p>使用 vi 文件名     进入vi编辑器<br />\n输入i、A、a、O、o都可进入编辑模式，进入编辑模式左下角会变成insert<br />\n按下Esc键盘左上角的退出键退出编辑模式<br />\n：冒号进入末行模式<br />\nq，不保存退出vi<br />\nq! ,不保存强制退出<br />\nwq保存退出vi<br />\nwq！，保存并强制退出</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019080720390785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"命令补充\">命令补充</h2>\n<p>权限相关：groupadd  组名<br />\nuseradd -g 组名 用户名<br />\npasswd 用户名<br />\nsu 用户名<br />\nchmod u=rwx,g=rwx,o=rwx 文件</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:13', '2020-10-07 13:01:43');
INSERT INTO `tb_article` VALUES (138, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3338', 'Redis数据库的介绍、安装、数据结构、常用命令', '<p>﻿## 1、 redis是什么呢？</p>\n<p>redis是非关系型数据库(nosql)，基于内存读写的数据库,采用key-value的方式存储数据<br />\n<strong>nosql：  not noly sql</strong> ，没有表的SQL</p>\n<p>在目前的企业开发中会用关系型数据库（Oracale+MySQL）+非关系型数据库(Redis 、MongoDB、Memcache)共同开发项目</p>\n<p><strong>为什么使用NoSQL</strong></p>\n<p>现在存在数据格式非常多样，不适合应用表格进行存储。<br />\n表格数据称之为 结构化数据<br />\n非表格数据称之为 半结构化 （kv json)  非结构化数据 音频 视频</p>\n<p>Redis是基于内存读写的数据库，<br />\n硬盘读取速度 大约几百M<br />\n内存读取速度 大约 上千M<br />\n所以Redis相对来说是要比关系型数据库要快很多</p>\n<p>Redis的应用场景：查询读取操作非常频繁的业务<br />\n例如：缓存</p>\n<h2 id=\"2redis的下载安装\">2、Redis的下载安装</h2>\n<p>Redis可从<br />\n<a href=\"https://redis.io/download\">https://redis.io/download</a><br />\n官网进行下载，有windows版和linux版，<br />\n都是下载直接解压就可使用<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807210547190.png\" alt=\"在这里插入图片描述\" /><br />\n解压后的目录如下：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807211247767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n不过需要注意的是：<br />\n在windows系统上，我们要修改redis.windows.conf这个文件，将appendonly no改为appendonly yes<br />\n因为redis是忘往内存上面存储数据的，改完这个可以使数据直接同步到硬盘上。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807211152164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n而启动的时候也不要双击redis-server.exe进行启动，因为这样启动是不能加载到redis.windows.conf这个配置文件的，<br />\n所以启动的时候我们要在redis解压的目录下进入cmd，<br />\n输入：redis-server  redis.windows.conf  启动redis服务<br />\n如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807211617774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n这样就启动了Redis服务，再双击redis-cli.exe就启动了Redis的客户端</p>\n<p>Linux系统下启动Redis服务要进到解压目录的src下，<br />\n输入./redis-server  ../redis.conf<br />\n进行启动，如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807212204837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"3redis的数据结构常用命令\">3、Redis的数据结构、常用命令</h2>\n<p><strong>redis数据库存储数据使用的key-value</strong><br />\n<strong>key是string类型  value的数据结构支持5个string、set、sorted_set、list、hash</strong></p>\n<p>value最大占用空间 1GB<br />\nredis支持的数据结构比较丰富、对不同的数据结构，还拥有不同的操作命令</p>\n<p>set、get、del<br />\nkeys *  打印所有的key</p>\n<p>基础命令 （key value）</p>\n<p>keys *</p>\n<p>命令的作用：显示redis中 所有的key<br />\nkeys  name*  name后面可以有0---多个任意字符<br />\nkeys  name?  name后面必须只存在一个字符</p>\n<p><strong>exists key</strong><br />\n判断 key是否存在 若返回 1 则存在 0 不存在</p>\n<p><strong>del key</strong><br />\n作用：删除 某一个key</p>\n<p><strong>help 命令</strong><br />\n帮助命令</p>\n<p><strong>flushall</strong> 清空所有数据库中的内容</p>\n<p>退出 <strong>exit|quit</strong> 退出redis的服务器</p>\n<h2 id=\"redis中值是字符串类型-string-数字\">Redis中值是字符串类型 （String 数字）</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213239589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>set</strong><br />\n用于设置 一个字符串类型的  key value</p>\n<p><strong>get</strong><br />\n根据key获取值</p>\n<p><strong>mset</strong><br />\n一次性设置多个 key value</p>\n<p>mget<br />\nstrlen<br />\nappend<br />\ngetrange 截取子串<br />\ngetrange name 0 3<br />\nsetex 设置一个key的存活有效期 (秒) psetex 作用与 setex 一致 但是毫秒<br />\nsetnx<br />\n如果当前没有这个key的话 那么 setnx等价于 set命令<br />\n如果当前存在这个key的话 那么 setnx不起作用<br />\ndecr 针对数字类型 做 -1操作 另外 desr key 数字 根据数字做减法操作<br />\nincr incrby incrbyfloat</p>\n<blockquote>\n<p>应用场景：缓存查询结果(json或者序列化) 用户访问记录 例如：通过记录ip-访问次数来显示ip的访问<br />\n统计粉丝数、点击次数、点赞</p>\n</blockquote>\n<h2 id=\"redis中值是set类型在这里插入图片描述\">Redis中值是set类型<img src=\"https://img-blog.csdnimg.cn/20190807213452727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></h2>\n<h2 id=\"c-list类型的数据操作的命令\">c) List类型的数据操作的命令</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213545465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\ni.	lpush 栈式结构<br />\nlpush name suns[2]<br />\nlpush name xiaohei[1]<br />\nlpush name xiaowb[0]<br />\nii.	lpushx 如果操作的key不存在 则不起作用<br />\n如果操作的key存在 则等同于lpush<br />\niii.	rpush 操作的内容 等效 java List<br />\n第一个操作的元素 就放置在第一个位置<br />\n依次类推<br />\n应用场景：关注列表、消息队列</p>\n<h2 id=\"hash类型的数据操作的命令\">hash类型的数据操作的命令</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213752596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"zset-sorted-set类型的数据操作的命令\">zset (sorted_set)类型的数据操作的命令</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213813240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"7-redis命令的补充部分\">7. Redis命令的补充部分</h2>\n<p>a)	只有set命令 可以操作 任意类型的数据</p>\n<p>b)	注意Redis中会有数据库概念 默认存在16数据库 0 ---- 15</p>\n<p>默认所使用的数据库 0 如果要选择使用别的数据库 select 编号</p>\n<p>注意：不同数据库所创建的key 相互隔离 互补干扰的。通过flushall 清空的是所有数据库中的key. 清空当前的数据库 flushdb这个命令<br />\n如何该表Redis中对于数据库的支持呢？编辑 redis.conf</p>\n<p>**	expire相关命令  （促销 秒杀  手机验证码倒计时 排行榜  Cache）**<br />\ni.	在Redis创建key value 默认都是持久化的 永久保存。<br />\nii.	可以通过expire 命令 指定 key 存活时间<br />\nexpire key seconds</p>\n<p><strong>查看某一个key的存活时常</strong><br />\npersist 作用 可以把 一个应用了expire命令key 再次转换持久化的key<br />\nexpireat key  unix 时间戳 毫秒数iii.</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213646467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:20', '2021-08-30 09:57:06');
INSERT INTO `tb_article` VALUES (139, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5037', '面试题：说一下HashMap和HashSet的实现原理？', '<p>﻿## HashMap 的实现原理：</p>\n<p><strong>HashMap是基于Hash算法实现的，</strong><br />\n我们通过put（key，value）存储数据，通过get（key）来获取数据</p>\n<p>当传入key时，HashMap会根据Key.hashCode()计算出Hash值，根据Hash值将value保存在bucket里	，。</p>\n<p><strong>当计算出相同的Hash值时，我们称之为Hash冲突</strong>，HashMap 的做法是用链表和红黑树存储相同Hash值的value，<br />\n当hash冲突的个数比较少时，使用链表存储，<br />\n否则使用红黑树。</p>\n<h2 id=\"hashset-的实现原理\">HashSet 的实现原理：</h2>\n<p>HashSet是基于HashMap实现的，HashSet 底层使用HashMap来保存所有元素，<br />\n因此HashSet 的实现比较简单，相关HashSet 的操作，基本上都是直接调用底层HashMap的相关方法来完成，HashSet不允许有重复的值，并且元素是无序的。</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:25', '2021-08-30 09:53:48');
INSERT INTO `tb_article` VALUES (140, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7105', '多线程相关面试题_并行和并发的区别、线程和进程、线程的创建方式、运行状态', '<p>﻿<strong>1，并行和并发有什么区别</strong></p>\n<p>并行：多个处理器或多核处理器同时处理多个任务。<br />\n并发：多个任务在同一个CPU核上，按细分的时间片轮流（交替）执行，从逻辑上来看并发的任务是同时执行；</p>\n<p>简而言之：<br />\n并发=两个队列和一台处理器<br />\n并发=两个队列和两个处理器</p>\n<p><strong>2、线程和进程的区别</strong></p>\n<p>一个程序下至少有一个进程，<br />\n一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p>\n<p><strong>3.守护线程是什么?</strong></p>\n<p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在Java中垃圾回收线程就是特殊的守护线程。</p>\n<p><strong>4.创建线程有哪几种方式?</strong></p>\n<p>创建线程有三种方式:</p>\n<pre><code>  ●继承Thread重写run方法;\n\n  ●实现Runnable接口;\n\n  ●实现Callable接口。\n</code></pre>\n<p><strong>5.线程有哪些状态?线程的状态:</strong></p>\n<pre><code>   NEW尚未启动\n\n   RUNNABLE正在执行中\n\n   BLOCKED阻塞的(被同步锁或者I0锁阻塞)\n\n   WAITING永久等待状态\n\n  TIMED_ WAITING 等待指定的时间重新被唤醒的状态\n</code></pre>\n<p><strong>6，sleep（）和 wait（）的区别</strong></p>\n<p>类的不同，sleep（）来自Thred ，wait（）来着Object，<br />\n释放锁，sleep（）不释放锁，而wait（）释放锁<br />\n用法不同，sleep（）到时间会自动醒来，自动回复线程，而wait（）需要用notify（）/  notifyAll()来唤醒线程。</p>\n<p><strong>7，线程的run（）和start（）方法有什么区别</strong></p>\n<p>start（）方法用于启动线程，<br />\nrun（）方法用于执行线程的运行时代码，<br />\nrun（）可以重复使用，而start（）只能调用一次。</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:52', '2021-08-30 09:53:36');
INSERT INTO `tb_article` VALUES (141, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=2509', 'tomcat集群环境下如何保证session一致性', '<p>﻿## 为什么集群环境下，会出现session不一致问题？</p>\n<p>答：使用nginx的负载均衡之后，不确定访问哪个tomcat，导致客户端存储的jsessionid携带到集群环境下的其他tomcat是无效的。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811142904838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>关于集群环境下，解决session不一致问题?</strong></p>\n<p>方式1：负载均衡的策略ip黏着：在nginx的default.conf配置<strong>ip_hash</strong>,这样客户端会固定的访问某一台服务器</p>\n<p>方式2：使用redis管理集群环境的session，session对象不在存储在tomcat服务器，而是redis数据库中,如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811143147501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>实现原理描述:</strong><br />\n客户端访问nginx，分配到tomcat-1服务器，创建session对象，jsessionid,将jsessionid作为key，session对象作为value存到redis数据库中，随着响应将jsessionid返回给客户端浏览器，该客户端浏览器向nginx在次发出请求，写cookie(包含jsessionid),到nginx后被分配到tomcat-2服务器，tomcat-2获取cookie中的jsessionid，去redis数据库查找对应的session对象并且返回使用</p>\n<h2 id=\"实现步骤\">实现步骤：</h2>\n<p>1.将下边三个jar上传到tomcat服务器中的lib目录下<br />\n要重写tomcat的session实现方法，将session管理到redis服务器中<br />\n如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811143509147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2. 修改tomcat中conf目录下的context.xml<br />\n原因1：我们上传的jar中的类，替换了tomcat中的代码，需要让tomcat知道我们的类叫什么名字<br />\n原因2：配置redis数据库所在服务器的ip地址和redis数据库的端口号</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190811143631510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n3. 重启tomcat服务<br />\n进入bin目录 ,先执行./shutdown.sh 再执行./startup.sh</p>\n<p>注意：以上操作集群中的tomcat(有几个就操作几个)都是相同的操作</p>\n<p>4，测试<br />\n做一个登陆页面，测试一下上面的操作有没有成功</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:58', '2020-12-21 14:52:10');
INSERT INTO `tb_article` VALUES (142, 1, 5, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=2462', 'mybatis的二级缓存，以及如何利用redis优化mybatis缓存？', '<p>﻿学习redis，缓存是很重要的一块</p>\n<p><strong>1.1 为什么要使用缓存？</strong></p>\n<p>为mybatis增加缓存功能，可有利用减少数据库访问</p>\n<p>系统运行的瓶颈很重要的一个因素就是数据库，<br />\n减少数据库的访问压力，可以提高整个系统的吞吐量。</p>\n<p><strong>什么是缓存？</strong></p>\n<p>将SQL语句，以及对应的查询结果存在服务器内存中，这一块内存存储区域，被我们称之为缓存。</p>\n<p>如果之后再执行该同样的SQL语句，则直接从缓存中去取，不再去查询数据库，可减小数据库的访问压力。</p>\n<p><strong>缓存的核心使用思路</strong></p>\n<ol>\n<li>开启缓存</li>\n<li>缓存的作用范围 缓存中的数据可以使用的范围</li>\n<li>脏数据的处理<br />\n脏数据：缓存是数据库中热点数据的备份，当数据库中的热点数据发生变化时，缓存也要和数据库保持一致，否则相应的数据成为脏数据。</li>\n</ol>\n<h2 id=\"12-mybatis现有的缓存\">1.2 mybatis现有的缓存</h2>\n<p><strong>mybatis的缓存分成一级缓存和二级缓存</strong></p>\n<p>一级缓存也称之为SqlSession级别的缓存，默认开启，只一次查询有效，作用范围太小，意义不大。<br />\n脏数据的处理 ：执行增删改有可能造成脏数据，一旦执行增删改立刻清空缓存。</p>\n<p>二级缓存称之为SqlSessionFactory级别的缓存,<br />\n通常我们所说的缓存默认指的就是二级缓存。</p>\n<p>二级缓存使用步骤</p>\n<ol>\n<li>开启二级缓存 (如果和spring整合，默认已经开启)<br />\n若没有，要在mybatis-config.xml中配置一下信息：</li>\n</ol>\n<pre><code>&lt;settings&gt;\n	&lt;setting name = &quot;cacheEnabled&quot;  value=&quot;true&quot; /&gt; \n&lt;/settings&gt;\n</code></pre>\n<ol start=\"2\">\n<li>在mapper文件增加 &lt; cache/&gt;</li>\n</ol>\n<p>*Mapper.xml中配置：</p>\n<pre><code>&lt;cache /&gt;\n</code></pre>\n<p>只有添加了cache标签的mapper文件中的查询结果才会放置到对应的二级缓存中</p>\n<ol start=\"3\">\n<li>\n<p>将需要存储到缓存中的对象实现序列化接口</p>\n</li>\n<li>\n<p>二级缓存作用范围<br />\n同1个namespace下</p>\n</li>\n<li>\n<p>脏数据的处理<br />\n执行同1个namespace下的增删改，自动清空该namespace下的缓存</p>\n</li>\n</ol>\n<p>内置的二级缓存通常也不用。<br />\n内置的二级缓存本身有namespace的问题，并且不支持持久化。<br />\n所以平时主要用：Ehcache 独立的缓存组件，使用纯Java编写。<br />\n准备工作：引入相关jar包 ehcache-core.jar   mybatis-ehcache.jar</p>\n<p>使用步骤：</p>\n<ol>\n<li>开启 缓存，Config.xml中配置和上面一样</li>\n<li>mapper.xml中配置，cache标签要加一个type属性指向我们自定义的cache<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081115082521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></li>\n<li>src下添加ehcache.xml<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811150937127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\nEncache作用于整个项目中 。<br />\n对脏数据的处理：执行增删改，立刻清空缓存中的数据。</li>\n</ol>\n<p>注意：低版本的mybatis配合ehcache有问题，需要升级mybatis到3.2以上<br />\n另外ehcache.xml 需要添加updateCheck=”false” 禁用检查更新<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811151048191.png\" alt=\"在这里插入图片描述\" /></p>\n<p>说了这么多，</p>\n<h2 id=\"如何使用redis优化mybatis缓存\">如何使用redis优化mybatis缓存</h2>\n<p>mybatis已经实现了二级缓存，为什么使用redis对其优化？？？</p>\n<p>mybatis本身二级缓存的查询结果要存储在当前服务器的JVM虚拟机中，如果缓存的数据量过大会造成jvm服务器臃肿缓慢，大量占用内存空间。</p>\n<p>所以我们最好将缓存的数据从tomcat服务器上转移到redis服务器上，redis存取速度快，并且是一个独立进程和jvm没有关系。</p>\n<p><strong>实现步骤</strong></p>\n<ol>\n<li>添加jar包<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081115272444.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在mapper文件中，增加自定义二级缓存的实现类配置<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081115302038.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></li>\n<li>在src下，增加一个redis.properties配置文件，指明要连接redis数据库的ip和端口号<br />\n默认是连接本地的redis<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811153210940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n总结：为了减少mysql数据库的查询压力，借助mybatis二级缓存，让多用户共享查询结果<br />\n前提执行的SQL语句是相同的。但是项目运行过程中，发现二级缓存存储的数据量越来越大，大量占用了当前JVM的空间，为了解决这个问题，使用redis数据库存储缓存的数据</li>\n</ol>\n', 1, '', 0, 0, 1, '2020-10-07 12:56:29', '2022-05-21 18:13:56');
INSERT INTO `tb_article` VALUES (143, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=987', 'spring boot 实现文件的上传下载', '<p>﻿## spring boot实现文件的上传，</p>\n<p>我是使用maven搭建的spring boot项目，页面集成的jsp。<br />\n页面结构如下：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811160646759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n准备工作：在webapp下新建一个目录叫upload</p>\n<p><strong>1，页面，upload.jsp</strong></p>\n<pre><code>&lt;body&gt;\n&lt;form method=&quot;post&quot; action=&quot;${pageContext.request.contextPath}/file/upload&quot; enctype=&quot;multipart/form-data&quot;&gt;\n    &lt;input type=&quot;file&quot; name=&quot;files&quot;&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n</code></pre>\n<p><strong>2) 控制器 ,FileController.java</strong></p>\n<pre><code>@Controller\n@RequestMapping(&quot;/file&quot;)\npublic class FileController {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RequestMapping(&quot;/upload&quot;)\n    public String upLoad(MultipartFile files, HttpSession session) throws IOException {\n        logger.info(&quot;upload 方法执行了&quot;);\n        //获取上传文件的路径\n        String realPath = session.getServletContext().getRealPath(&quot;upload&quot;);\n        System.out.println(&quot;--------&quot;+realPath);\n        //获取上传的文件名，\n        File file1 = new File(realPath, files.getOriginalFilename());\n        //执行文件上传复制\n        files.transferTo(file1);\n        //跳到下载页面\n        return &quot;/download.jsp&quot;;\n\n    }\n}\n</code></pre>\n<p><strong>3) 修改上传文件大小的限制，application.properties</strong></p>\n<pre><code>//配置tomcat端口号\nserver.port=8080\n//项目访问路径\nserver.servlet.context-path=/maven_springboot\n//jsp页面热部署\nserver.servlet.jsp.init-parameters.development=true\n//修改上传文件大小限制为10Mb\nspring.servlet.multipart.max-file-size=10485760\n\n</code></pre>\n<h2 id=\"2下载\">2，下载</h2>\n<p><strong>1) 页面 download.jsp</strong><br />\n这里的fileName应该是要从数据库读取出来，包括上传也是应该把上传的文件信息存到数据库，这里我就不写了。<br />\n就直接把文件写死了，</p>\n<pre><code>&lt;body&gt;\n&lt;a href=&quot;${pageContext.request.contextPath}/file/download?fileName=aaa.png&quot;&gt;下载&lt;/a&gt;\n&lt;/body&gt;\n</code></pre>\n<p><strong>2）控制器, FileController</strong></p>\n<pre><code> @RequestMapping(&quot;/download&quot;)\n    public void Download(String fileName, HttpServletResponse response,HttpSession session) throws Exception {\n   //设置下载响应头\n        response.setHeader(&quot;content-disposition&quot;,&quot;attachment;fileName&quot;+ URLEncoder.encode(fileName,&quot;UTF-8&quot;));\n    //获取文件路径\n        String uploadPath = session.getServletContext().getRealPath(&quot;upload&quot;);\n\n        File file = new File(uploadPath,fileName);\n        ServletOutputStream outputStream = response.getOutputStream();\n        FileUtils.copyFile(file,response.getOutputStream());\n\n    }\n</code></pre>\n<p>这里要用到一个jar包，commons-io包的FileUtils工具类，<br />\npom引入该依赖如下：</p>\n<pre><code> &lt;dependency&gt;\n      &lt;groupId&gt;commons-io&lt;/groupId&gt;\n      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;\n      &lt;version&gt;2.4&lt;/version&gt;\n    &lt;/dependency&gt;\n\n</code></pre>\n<p>如此，一个简单的上传下载demo就算完成了</p>\n', 1, '', 0, 0, 1, '2020-09-29 17:25:27', '2020-12-21 14:53:59');
INSERT INTO `tb_article` VALUES (144, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1364', 'Centos Linux系统使用vsftpd搭建ftp服务', '<p>﻿## Linux，Centos系统使用vsftpd搭建ftp服务</p>\n<h3 id=\"一安装vsftpd\">一、安装vsftpd</h3>\n<ol>\n<li>运行以下命令安装vsftpd。</li>\n</ol>\n<pre><code class=\"language-powershell\">yum install -y vsftpd\n</code></pre>\n<p>返回如下图所示界面时，表示安装成功。<br />\n<img src=\"https://img-blog.csdnimg.cn/20201011163459305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"2\">\n<li>运行以下命令设置FTP服务开机自启动。</li>\n</ol>\n<pre><code class=\"language-powershell\">systemctl enable vsftpd.service\n</code></pre>\n<ol start=\"3\">\n<li>启动FTP服务。</li>\n</ol>\n<pre><code class=\"language-powershell\">systemctl start vsftpd.service\n</code></pre>\n<ol start=\"4\">\n<li>运行以下命令查看FTP服务监听的端口。</li>\n</ol>\n<pre><code class=\"language-powershell\">netstat -antup | grep ftp\n</code></pre>\n<p>出现如下图所示界面，表示FTP服务已启动，监听的端口号为 21。此时，vsftpd默认已开启匿名访问功能，您无需输入用户名密码即可登录FTP服务器，但没有修改或上传文件的权限。<br />\n<img src=\"https://img-blog.csdnimg.cn/20201011163555146.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h3 id=\"二配置vsftpd\">二、配置vsftpd</h3>\n<blockquote>\n<p>vsftpd（very secure FTP<br />\ndaemon）是一款在Linux发行版中最受推崇的FTP服务器。vsftpd支持匿名访问和本地用户模式两种访问方式。匿名访问方式任何用户都可以访问搭建的FTP服务；本地用户模式只支持添加的本地用户访问搭建的FTP服务。</p>\n</blockquote>\n<ul>\n<li>说明: 匿名用户模式和本地用户模式只可同时配置一种。</li>\n</ul>\n<h4 id=\"21-匿名用户模式\">2.1 匿名用户模式</h4>\n<ol>\n<li>修改配置文件vsftpd.conf。</li>\n</ol>\n<pre><code class=\"language-powershell\">vim /etc/vsftpd/vsftpd.conf\n</code></pre>\n<p>按 i 键进入编辑模式，将匿名上传权限 anon_upload_enable=YES 的注释解开。<br />\n<img src=\"https://img-blog.csdnimg.cn/20201011163821978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"2\">\n<li>\n<p>按ESC键退出编辑模式，输入:wq 保存并退出vim。</p>\n</li>\n<li>\n<p>更改/var/ftp/pub目录的权限，为FTP用户添加写权限。</p>\n</li>\n</ol>\n<pre><code class=\"language-powershell\">chmod o+w /var/ftp/pub/\n</code></pre>\n<ol start=\"4\">\n<li>重启FTP服务。</li>\n</ol>\n<pre><code class=\"language-powershell\">systemctl restart vsftpd.service\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20201011163953415.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"22-本地用户模式\">2.2 本地用户模式</h4>\n<ol>\n<li>为FTP服务创建一个Linux用户。</li>\n</ol>\n<pre><code class=\"language-powershell\">adduser ftptest\n</code></pre>\n<p>为用户设置密码。</p>\n<pre><code class=\"language-powershell\">passwd ftptest\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20201011164202186.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"2\">\n<li>创建一个供FTP服务使用的文件目录。</li>\n</ol>\n<pre><code class=\"language-powershell\">mkdir /var/ftp/test\n</code></pre>\n<ol start=\"3\">\n<li>更改/var/ftp/test目录的拥有者为ftptest。</li>\n</ol>\n<pre><code class=\"language-powershell\">chown -R ftptest:ftptest /var/ftp/test\n</code></pre>\n<ol start=\"4\">\n<li>修改vsftpd.conf配置文件。</li>\n</ol>\n<p>配置FTP为主动模式请执行如下命令:</p>\n<pre><code class=\"language-powershell\">sed -i \'s/anonymous_enable=YES/anonymous_enable=NO/\' /etc/vsftpd/vsftpd.conf #禁止匿名登录FTP服务器 \nsed -i \'s/listen=NO/listen=YES/\' /etc/vsftpd/vsftpd.conf #监听IPv4 sockets \nsed -i \'s/listen_ipv6=YES/#listen_ipv6=YES/\' /etc/vsftpd/vsftpd.conf #关闭监听IPv6 sockets \nsed -i \'s/#chroot_local_user=YES/chroot_local_user=YES/\' /etc/vsftpd/vsftpd.conf #全部用户被限制在主目录 \nsed -i \'s/#chroot_list_enable=YES/chroot_list_enable=YES/\' /etc/vsftpd/vsftpd.conf #启用例外用户名单 \nsed -i \'s/#chroot_list_file=/chroot_list_file=/\' /etc/vsftpd/vsftpd.conf #指定例外用户列表文件，列表中的用户不被锁定在主目录 \necho &quot;allow_writeable_chroot=YES&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf \necho &quot;local_root=/var/ftp/test&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置本地用户登录后所在的目录\n</code></pre>\n<p>配置FTP为被动模式请执行如下命令：</p>\n<pre><code class=\"language-powershell\">sed -i \'s/anonymous_enable=YES/anonymous_enable=NO/\' /etc/vsftpd/vsftpd.conf #禁止匿名登录FTP服务器 \nsed -i \'s/listen=NO/listen=YES/\' /etc/vsftpd/vsftpd.conf #监听IPv4 sockets \nsed -i \'s/listen_ipv6=YES/#listen_ipv6=YES/\' /etc/vsftpd/vsftpd.conf #关闭监听IPv6 sockets \nsed -i \'s/#chroot_local_user=YES/chroot_local_user=YES/\' /etc/vsftpd/vsftpd.conf #全部用户被限制在主目录 \nsed -i \'s/#chroot_list_enable=YES/chroot_list_enable=YES/\' /etc/vsftpd/vsftpd.conf #启用例外用户名单 \nsed -i \'s/#chroot_list_file=/chroot_list_file=/\' /etc/vsftpd/vsftpd.conf #指定例外用户列表文件，列表中的用户不被锁定在主目录 \necho &quot;allow_writeable_chroot=YES&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf \necho &quot;local_root=/var/ftp/test&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置本地用户登录后所在的目录 \n\necho &quot;pasv_enable=YES&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #开启被动模式 \necho &quot;pasv_address=&lt;FTP服务器公网IP地址&gt;&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #本教程中为ECS服务器弹性IP \necho &quot;pasv_min_port=20&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置被动模式下，建立数据传输可使用的端口范围的最小值 \necho &quot;pasv_max_port=21&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置被动模式下，建立数据传输可使用的端口范围的最大值\n</code></pre>\n<ol start=\"5\">\n<li>在/etc/vsftpd目录下创建chroot_list文件，并在文件中写入例外用户名单。</li>\n</ol>\n<pre><code class=\"language-powershell\">#使用vim命令编辑chroot_list文件，添加例外用户名单。此名单中的用户不会被锁定在主目录，可以访问其他目录。\nvim /etc/vsftpd/chroot_list\n</code></pre>\n<p>说明: 没有例外用户时，也必须创建chroot_list文件，内容可为空。</p>\n<ol start=\"6\">\n<li>重启FTP服务。</li>\n</ol>\n<pre><code class=\"language-powershell\">systemctl restart vsftpd.service\n</code></pre>\n<h2 id=\"三客户端测试\">三、客户端测试</h2>\n<p>FTP客户端、Windows命令行工具或浏览器均可用来测试FTP服务器。（此步骤仅适用于本地用户，匿名模式无需进行测试操作）</p>\n<p>说明：使用浏览器访问FTP服务器出错时，建议您清除浏览器缓存后再尝试。</p>\n<ol>\n<li>\n<p>打开Chrom浏览器，在地址栏中输入<a href=\"ftp://&lt;\">ftp://&lt;</a>FTP服务器公网IP地址&gt;:FTP端口，FTP服务器公网IP地址为ECS服务器的弹性IP地址。例如：ftp://139.0.0.1:21。</p>\n</li>\n<li>\n<p>在弹出的对话框中，输入用户名和密码。</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20201011164412400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"3\">\n<li>登录成功界面如下，此时可对FTP文件进行相应权限的操作。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20201011164418652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-10-14 15:43:49', '2022-05-21 18:14:31');
INSERT INTO `tb_article` VALUES (145, 1, 10, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=2505', '在VUE中使用RSA加密解密加签解签', '</font>\n<p>@<a href=\"目录\">TOC</a></p>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h1 id=\"前言\">前言</h1>\n<font >\n项目中部分隐私参数要前后端对接交互时，出于安全性考虑，我们会对重要的参数进行加密后再进行传输，一般采用的加密方式是非对称性加密RSA算法。\n</font>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<p><font color=#999AAA >提示：以下是本篇文章正文内容，下面案例可供参考</p>\n<h1 id=\"一什么是rsa加密\">一、什么是RSA加密？</h1>\n<p><font color=#999AAA >RSA加密是一种非对称加密。<br />\n可以在不直接传递密钥的情况下，完成解密。<br />\n这能够确保信息的安全性，避免了直接传递密钥所造成的被破解的风险。<br />\nRSA是由一对密钥来进行加解密的过程，分别称为公钥和私钥。<br />\n两者之间有数学相关，该加密算法的原理就是对一极大整数做因数分解的困难性来保证安全性。<br />\n通常个人保存私钥，公钥是公开的（可能同时多人持有）。</p>\n<h1 id=\"二加密过程\">二、加密过程</h1>\n<ul>\n<li>（1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。</li>\n<li>（2）A传递自己的公钥给B，B用A的公钥对消息进行加密。</li>\n<li>（3）A接收到B加密的消息，利用A自己的私钥对消息进行解密。<br />\n　<br />\n在这个过程中，只有2次传递过程，第一次是A传递公钥给B，第二次是B传递加密消息给A，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行解密，防止了消息内容的泄露。</li>\n</ul>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h1 id=\"三在vue中使用步骤\">三、在Vue中使用步骤</h1>\n<p>一般是客户端初始化时访问服务端时，服务端会生成一对RSA对，及公钥和密钥。</p>\n<ul>\n<li>如果前端只需要将要传给后端的数据进行<strong>加密</strong>后传输，那么前端可以只要公钥，通过公钥对要传输的参数进行加密后把加密的字符串发给后端即可，后端自有办法解密。</li>\n<li>如果前端要获取后端传过来的已经加密后的字符串，并且<strong>解密</strong>使用，那么前端就需要拿到RSA对立面的私钥进行解密后使用了。</li>\n</ul>\n<h3 id=\"使用步骤\">使用步骤：</h3>\n<h4 id=\"1安装依赖\">1、安装依赖</h4>\n<p>首先引入jsencrypt</p>\n<pre><code class=\"language-powershell\">npm install jsencrypt --save\n</code></pre>\n<h4 id=\"2在mainjs中引入\">2、在main.js中引入</h4>\n<pre><code class=\"language-powershell\">import JsEncrypt from \'jsencrypt\'\nVue.prototype.$jsEncrypt = JsEncrypt\n</code></pre>\n<h4 id=\"3将加密解密方法封装到通用的js内\">3、将加密解密方法封装到通用的js内</h4>\n<pre><code class=\"language-javascript\">let publicKey = \'这里是封装的公钥\'\nlet privateKey = \'这里是封装的私钥\'\n//加密方法\n  RSAencrypt(pas){\n    //实例化jsEncrypt对象\n    let jse = new JSEncrypt();\n    //设置公钥\n    jse.setPublicKey(publicKey);\n     console.log(\'加密：\'+jse.encrypt(pas))\n    return jse.encrypt(pas);\n  },\n  \n//解密方法\n  RSAdecrypt(pas){\n    let jse = new JSEncrypt();\n    // 私钥\n    jse.setPrivateKey(privateKey)\n     console.log(\'解密：\'+jse.decrypt(pas))\n    return jse.decrypt(pas);\n  },\n\n</code></pre>\n<p>我在项目中的使用如下图：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201216153329749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在VUE中使用RSA加密解密加签解签\" /></p>\n<h4 id=\"运行结果\">运行结果</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20201216153523787.png\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"总结\">总结</h1>\n<p>后端的使用Springboot对RSA进行加解密的过程可以看我的另一篇博客</p>\n', 1, '', 0, 0, 1, '2020-12-17 15:32:34', '2020-12-17 15:32:34');
INSERT INTO `tb_article` VALUES (146, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4125', 'SpringBoot集成WebSocket，实现后台向前端推送信息', '<p>@<a href=\"目录\">TOC</a></p>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h1 id=\"前言\">前言</h1>\n<p><font color=#999AAA >在一次项目开发中，使用到了Netty网络应用框架，以及MQTT进行消息数据的收发，这其中需要后台来将获取到的消息主动推送给前端，于是就使用到了MQTT，特此记录一下。</p>\n<h1 id=\"一什么是websocket\">一、什么是websocket？</h1>\n<p><font color=#999AAA >WebSocket协议是基于TCP的一种新的网络协议。它实现了客户端与服务器全双工通信，学过计算机网络都知道，既然是全双工，就说明了<strong>服务器可以主动发送信息给客户端</strong>。这与我们的推送技术或者是多人在线聊天的功能不谋而合。<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217170824701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>为什么不使用HTTP 协议呢？这是因为HTTP是单工通信，通信只能由客户端发起，客户端请求一下，服务器处理一下，这就太麻烦了。于是websocket应运而生。<br />\n<img src=\"https://img-blog.csdnimg.cn/2020121717094782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>下面我们就直接开始使用Springboot开始整合。以下案例都在我自己的电脑上测试成功，你可以根据自己的功能进行修改即可。<br />\n我的项目结构如下：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217173226396.png\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"二使用步骤\">二、使用步骤</h1>\n<h2 id=\"1添加依赖\">1.添加依赖</h2>\n<p><font color=#999AAA >Maven依赖：</p>\n<pre><code class=\"language-xml\">	&lt;dependency&gt;  \n           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  \n           &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;  \n    &lt;/dependency&gt; \n</code></pre>\n<h2 id=\"2启用springboot对websocket的支持\">2.启用Springboot对WebSocket的支持</h2>\n<p><font color=#999AAA >启用WebSocket的支持也是很简单，几句代码搞定：</p>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.socket.server.standard.ServerEndpointExporter;\n/**\n * @ Auther: 马超伟\n * @ Date: 2020/06/16/14:35\n * @ Description: 开启WebSocket支持\n */\n@Configuration\npublic class WebSocketConfig {\n    @Bean\n    public ServerEndpointExporter serverEndpointExporter() {\n        return new ServerEndpointExporter();\n    }\n}\n</code></pre>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h2 id=\"3核心配置websocketserver\">3.核心配置：WebSocketServer</h2>\n<p><font color=#999AAA >因为WebSocket是类似客户端服务端的形式(采用ws协议)，那么这里的WebSocketServer其实就相当于一个ws协议的Controller</p>\n<ul>\n<li>@ ServerEndpoint 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端, 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端</li>\n<li>新建一个ConcurrentHashMap webSocketMap 用于接收当前userId的WebSocket，方便传递之间对userId进行推送消息。</li>\n</ul>\n<p>下面是具体业务代码：</p>\n<pre><code class=\"language-java\">package cc.mrbird.febs.external.webScoket;\n\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Service;\n\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.time.LocalDateTime;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n/**\n * Created with IntelliJ IDEA.\n * @ Auther: 马超伟\n * @ Date: 2020/06/16/14:35\n * @ Description:\n * @ ServerEndpoint 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端,\n * 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端\n */\n@Component\n@Slf4j\n@Service\n@ServerEndpoint(&quot;/api/websocket/{sid}&quot;)\npublic class WebSocketServer {\n    //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。\n    private static int onlineCount = 0;\n    //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。\n    private static CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketSet = new CopyOnWriteArraySet&lt;WebSocketServer&gt;();\n\n    //与某个客户端的连接会话，需要通过它来给客户端发送数据\n    private Session session;\n\n    //接收sid\n    private String sid = &quot;&quot;;\n\n    /**\n     * 连接建立成功调用的方法\n     */\n    @OnOpen\n    public void onOpen(Session session, @PathParam(&quot;sid&quot;) String sid) {\n        this.session = session;\n        webSocketSet.add(this);     //加入set中\n        this.sid = sid;\n        addOnlineCount();           //在线数加1\n        try {\n            sendMessage(&quot;conn_success&quot;);\n            log.info(&quot;有新窗口开始监听:&quot; + sid + &quot;,当前在线人数为:&quot; + getOnlineCount());\n        } catch (IOException e) {\n            log.error(&quot;websocket IO Exception&quot;);\n        }\n    }\n\n    /**\n     * 连接关闭调用的方法\n     */\n    @OnClose\n    public void onClose() {\n        webSocketSet.remove(this);  //从set中删除\n        subOnlineCount();           //在线数减1\n        //断开连接情况下，更新主板占用情况为释放\n        log.info(&quot;释放的sid为：&quot;+sid);\n        //这里写你 释放的时候，要处理的业务\n        log.info(&quot;有一连接关闭！当前在线人数为&quot; + getOnlineCount());\n\n    }\n\n    /**\n     * 收到客户端消息后调用的方法\n     * @ Param message 客户端发送过来的消息\n     */\n    @OnMessage\n    public void onMessage(String message, Session session) {\n        log.info(&quot;收到来自窗口&quot; + sid + &quot;的信息:&quot; + message);\n        //群发消息\n        for (WebSocketServer item : webSocketSet) {\n            try {\n                item.sendMessage(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    /**\n     * @ Param session\n     * @ Param error\n     */\n    @OnError\n    public void onError(Session session, Throwable error) {\n        log.error(&quot;发生错误&quot;);\n        error.printStackTrace();\n    }\n\n    /**\n     * 实现服务器主动推送\n     */\n    public void sendMessage(String message) throws IOException {\n        this.session.getBasicRemote().sendText(message);\n    }\n\n    /**\n     * 群发自定义消息\n     */\n    public static void sendInfo(String message, @PathParam(&quot;sid&quot;) String sid) throws IOException {\n        log.info(&quot;推送消息到窗口&quot; + sid + &quot;，推送内容:&quot; + message);\n\n        for (WebSocketServer item : webSocketSet) {\n            try {\n                //这里可以设定只推送给这个sid的，为null则全部推送\n                if (sid == null) {\n//                    item.sendMessage(message);\n                } else if (item.sid.equals(sid)) {\n                    item.sendMessage(message);\n                }\n            } catch (IOException e) {\n                continue;\n            }\n        }\n    }\n\n    public static synchronized int getOnlineCount() {\n        return onlineCount;\n    }\n\n    public static synchronized void addOnlineCount() {\n        WebSocketServer.onlineCount++;\n    }\n\n    public static synchronized void subOnlineCount() {\n        WebSocketServer.onlineCount--;\n    }\n\n    public static CopyOnWriteArraySet&lt;WebSocketServer&gt; getWebSocketSet() {\n        return webSocketSet;\n    }\n}\n</code></pre>\n<h2 id=\"4测试controller\">4.测试Controller</h2>\n<pre><code class=\"language-java\">\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Created with IntelliJ IDEA.\n *\n * @ Auther: 马超伟\n * @ Date: 2020/06/16/14:38\n * @ Description:\n */\n@Controller(&quot;web_Scoket_system&quot;)\n@RequestMapping(&quot;/api/socket&quot;)\npublic class SystemController {\n    //页面请求\n    @GetMapping(&quot;/index/{userId}&quot;)\n    public ModelAndView socket(@PathVariable String userId) {\n        ModelAndView mav = new ModelAndView(&quot;/socket1&quot;);\n        mav.addObject(&quot;userId&quot;, userId);\n        return mav;\n    }\n\n    //推送数据接口\n    @ResponseBody\n    @RequestMapping(&quot;/socket/push/{cid}&quot;)\n    public Map pushToWeb(@PathVariable String cid, String message) {\n        Map&lt;String,Object&gt; result = new HashMap&lt;&gt;();\n        try {\n            WebSocketServer.sendInfo(message, cid);\n            result.put(&quot;code&quot;, cid);\n            result.put(&quot;msg&quot;, message);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n}\n\n</code></pre>\n<h2 id=\"5测试页面indexhtml\">5.测试页面index.html</h2>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n	&lt;head&gt;\n		&lt;meta charset=&quot;utf-8&quot;&gt;\n		&lt;title&gt;Java后端WebSocket的Tomcat实现&lt;/title&gt;\n		&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;\n	&lt;/head&gt;\n\n	&lt;body&gt;\n		&lt;div id=&quot;main&quot; style=&quot;width: 1200px;height:800px;&quot;&gt;&lt;/div&gt;\n		Welcome&lt;br/&gt;&lt;input id=&quot;text&quot; type=&quot;text&quot; /&gt;\n		&lt;button onclick=&quot;send()&quot;&gt;发送消息&lt;/button&gt;\n		&lt;hr/&gt;\n		&lt;button onclick=&quot;closeWebSocket()&quot;&gt;关闭WebSocket连接&lt;/button&gt;\n		&lt;hr/&gt;\n		&lt;div id=&quot;message&quot;&gt;&lt;/div&gt;\n	&lt;/body&gt;\n	&lt;script type=&quot;text/javascript&quot;&gt;\n		var websocket = null;\n		//判断当前浏览器是否支持WebSocket\n		if(\'WebSocket\' in window) {\n			//改成你的地址\n			websocket = new WebSocket(&quot;ws://192.168.100.196:8082/api/websocket/100&quot;);\n		} else {\n			alert(\'当前浏览器 Not support websocket\')\n		}\n\n		//连接发生错误的回调方法\n		websocket.onerror = function() {\n			setMessageInnerHTML(&quot;WebSocket连接发生错误&quot;);\n		};\n\n		//连接成功建立的回调方法\n		websocket.onopen = function() {\n			setMessageInnerHTML(&quot;WebSocket连接成功&quot;);\n		}\n		var U01data, Uidata, Usdata\n		//接收到消息的回调方法\n		websocket.onmessage = function(event) {\n			console.log(event);\n			setMessageInnerHTML(event);\n			setechart()\n		}\n\n		//连接关闭的回调方法\n		websocket.onclose = function() {\n			setMessageInnerHTML(&quot;WebSocket连接关闭&quot;);\n		}\n\n		//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。\n		window.onbeforeunload = function() {\n			closeWebSocket();\n		}\n\n		//将消息显示在网页上\n		function setMessageInnerHTML(innerHTML) {\n			document.getElementById(\'message\').innerHTML += innerHTML + \'&lt;br/&gt;\';\n		}\n\n		//关闭WebSocket连接\n		function closeWebSocket() {\n			websocket.close();\n		}\n\n		//发送消息\n		function send() {\n			var message = document.getElementById(\'text\').value;\n			websocket.send(\'{&quot;msg&quot;:&quot;\' + message + \'&quot;}\');\n			setMessageInnerHTML(message + &quot;&amp;#13;&quot;);\n		}\n	&lt;/script&gt;\n\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"6结果展示\">6.结果展示</h2>\n<p>后台：<br />\n如果有连接请求<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217181325920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>前台显示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217181300879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"总结\">总结</h1>\n<p><font color=#999AAA >这中间我遇到一个问题，就是说WebSocket启动的时候优先于spring容器，从而导致在WebSocketServer中调用业务Service会报空指针异常</p>\n<p>所以需要在WebSocketServer中将所需要用到的service给静态初始化一下：<br />\n如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217181723382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n还需要做如下配置：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217181921591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-12-18 11:40:54', '2022-05-21 18:06:14');
INSERT INTO `tb_article` VALUES (147, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1451', '留言', '<h3 id=\"留言板说明\">留言板说明</h3>\n<p>有什么话要对我说吗？这里是你畅所欲言的地方，可以咨询，可以交流，可以感叹，可以发飙，但不可以订外卖。</p>\n<p><img src=\"http://file.henaumcw.top/blog/image_1608350101016.png\" alt=\"image.png\" /></p>\n', 1, '', 0, 0, 1, '2020-12-19 10:30:42', '2020-12-19 11:55:06');
INSERT INTO `tb_article` VALUES (148, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=6562', '新浪随机图片壁纸API接口 刷新网页换背景接口', '<p>新浪随机图片壁纸API接口 刷新网页换背景接口<br />\n在这里插入图片描述</p>\n<p>刷新一次页面换一次图片，可以调用到你的网站背景里面去，多炫酷啊，刷新一下本页看下效果哦。</p>\n<p>说明：随机图片壁纸api，调用的是新浪api，速度不用担心，图片资源也很多</p>\n<p>电脑动漫图片：<a href=\"http://api.btstu.cn/sjbz/?lx=dongman\">http://api.btstu.cn/sjbz/?lx=dongman</a></p>\n<p>电脑美女图片：<a href=\"http://api.btstu.cn/sjbz/?lx=meizi\">http://api.btstu.cn/sjbz/?lx=meizi</a></p>\n<p>电脑随机动漫妹子：<a href=\"http://api.btstu.cn/sjbz/?lx=suiji\">http://api.btstu.cn/sjbz/?lx=suiji</a></p>\n<p>手机动漫图片：<a href=\"http://api.btstu.cn/sjbz/?lx=m_dongman\">http://api.btstu.cn/sjbz/?lx=m_dongman</a></p>\n<p>手机美女图片：<a href=\"http://api.btstu.cn/sjbz/?lx=m_meizi\">http://api.btstu.cn/sjbz/?lx=m_meizi</a></p>\n<p>手机随机动漫妹子：<a href=\"http://api.btstu.cn/sjbz/?m_lx=suiji\">http://api.btstu.cn/sjbz/?m_lx=suiji</a></p>\n<p>手机电脑自动判断，电脑显示适合电脑的壁纸，手机显示适合手机的壁纸 <a href=\"http://api.btstu.cn/sjbz/zsy.php\">http://api.btstu.cn/sjbz/zsy.php</a></p>\n', 1, '', 0, 0, 1, '2020-12-19 16:31:05', '2021-08-30 09:53:11');
INSERT INTO `tb_article` VALUES (149, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=168', '超详细的 Vagrant 上手指南，搭建Linux虚拟机别再用VMware Workstation了！', '<p>﻿<br />\n@<a href=\"文章目录\">TOC</a></p>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h1 id=\"前言\">前言</h1>\n<p><font color=#999AAA >也许你已经习惯了 docker，习惯了在 XX 云上快速创建云主机，但是如果你想在个人电脑上安装虚拟机来搭建开发/测试环境，Vagrant 仍然不失高效之选。</font></p>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<p><font color=#999AAA >下面说下搭建的主要步骤：</p>\n<h1 id=\"一安装virtualbox\">一、安装VirtualBox</h1>\n<p><font color=#999AAA >VirtualBox 是一个跨平台的虚拟化工具，支持多个操作系统，根据自己的情况选择对应的版本下载即可。</p>\n<p>进入 VirtualBox 的主页<a href=\"https://www.virtualbox.org/\">https://www.virtualbox.org/</a>，点下载按钮，即可进入下载页面。</p>\n<p>进行安装需要<strong>cpu开启虚拟化</strong>，在开机启动的时候设置主板，CPU configuration，然后点击Intel Vitualization Technology。重启电脑</p>\n<h1 id=\"二vagrant\">二、Vagrant</h1>\n<h2 id=\"1安装vagrant\">1.安装Vagrant</h2>\n<p>在 Vagant 网站<a href=\"https://www.vagrantup.com/\">https://www.vagrantup.com/</a>下载最新的版本，根据自己的操作系统选择对应的版本下载即可。</p>\n<p>注意，Vagrant 是没有图形界面的，所以安装完成后也没有桌面快捷方式。具体使用方法，接下来会详细说明。</p>\n<p><font color=#99AA >Vagrant 的安装程序会自动把安装路径加入到 PATH 环境变量，所以，这时候可以通过命令行执行 <strong>vagrant version</strong> 检查是否安装成功：</p>\n<pre><code class=\"language-c\">C:\\Users\\ma&gt;vagrant version\n==&gt; vagrant: A new version of Vagrant is available: 2.2.14 (installed version: 2.2.5)!\n==&gt; vagrant: To upgrade visit: https://www.vagrantup.com/downloads.html\n\nInstalled Version: 2.2.5\nLatest Version: 2.2.14\n</code></pre>\n<h2 id=\"配置虚机存放位置\">配置虚机存放位置</h2>\n<p>创建虚拟机会占用较多的磁盘空间，在 Windows 系统下默认的虚机创建位置是在 C 盘，所以最好配置到其它地方。</p>\n<h2 id=\"2配置-virtualbox\">2.配置 VirtualBox</h2>\n<p>启动 VirtualBox 后，通过菜单 <code>管理 -&gt; 全局设定</code>，或者按下快捷键 <code>Ctrl + g</code>，在全局设定对话框中，修改 <code>默认虚拟电脑位置</code>，指定一个容量较大的磁盘。<br />\n<img src=\"https://img-blog.csdnimg.cn/20210308113209588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"3配置-vagrant\">3.配置 Vagrant</h2>\n<p>通过 Vagrant 创建虚机需要先导入镜像文件，也就是 box，它们默认存储的位置在用户目录下的 <code>.vagrant.d</code> 目录下，对于 Windows 系统来说，就是 <code>C:\\Users\\用户名\\.vagrant.d</code>。</p>\n<p>如果后续可能会用到较多镜像，或者你的 C 盘空间比较紧缺，可以通过设置环境变量 <code>VAGRANT_HOME</code> 来设置该目录。</p>\n<p>在 Windows 系统中，可以这样操作：新建系统环境变量，环境变量名为 <code>VAGRANT_HOME</code>，变量值为 <code>你的其他盘的路径</code>。</p>\n<h2 id=\"4下载虚机镜像\">4.下载虚机镜像</h2>\n<p>使用 Vagrant 创建虚机时，需要指定一个镜像，也就是 box。开始这个 box 不存在，所以 Vagrant 会先从网上下载，然后缓存在本地目录中。</p>\n<p>Vagrant 有一个镜像网站<a href=\"https://app.vagrantup.com/boxes/search\">https://app.vagrantup.com/boxes/search</a>，里面列出了都有哪些镜像可以用，并且提供了操作文档。<br />\n<img src=\"https://img-blog.csdnimg.cn/20210308115510105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n输入<code>vagrant init centos/7</code>（<strong>仓库镜像名</strong>），即可初始化一个centos7系统。（注意这个命令在哪个目录下执行的，他的Vagrantfile就生成在哪里）这个命令是一键下载并初始化。<strong>后面会详细介绍</strong></p>\n<blockquote>\n<p>但是这里默认下载往往会比较慢，所以下面我会介绍如何在其它地方下载到基础镜像，然后按照自己的需要重置。如果网速较好，下载顺利的朋友可以选择性地跳过部分内容。</p>\n<p>下面我给出最常用的两个 Linux 操作系统镜像的下载地址：</p>\n<p><strong>CentOS</strong></p>\n<p>CentOS 的镜像下载网站是： <a href=\"http://cloud.centos.org/centos/\">http://cloud.centos.org/centos/</a></p>\n<p><strong>Ubuntu</strong></p>\n<p>Ubuntu 的镜像下载网站是： <a href=\"http://cloud-images.ubuntu.com\">http://cloud-images.ubuntu.com</a></p>\n</blockquote>\n<p>在其中选择自己想要下载的版本，列表中有一个 vagrant 目录，里面是专门为 vagrant 构建的镜像。选择其中的 .box 后缀的文件下载即可。这里可以使用下载工具，以较快的速度下载下来。</p>\n<h2 id=\"5添加-box\">5.添加 box</h2>\n<p><font color=#999AAA >以 CentOS 7 为例，使用其它版本操作系统的也可以参考。</p>\n<p>接下来我们需要将下载后的 <code>.box</code> 文件添加到 vagrant 中。</p>\n<p>Vagrant 没有 GUI，只能从命令行访问，先启动一个命令行，然后执行:</p>\n<pre><code class=\"language-java\">$ vagrant box list\nThere are no installed boxes! Use `vagrant box add` to add some.\n</code></pre>\n<p>提示现在还没有 box。如果这是第一次运行，此时 <code>VAGRANT_HOME</code> 目录下会自动生成若干的文件和文件夹，其中有一个 boxes 文件夹，这就是要存放 box 文件的地方。</p>\n<p>执行 <code>vagrant box add</code> 命令添加 box:</p>\n<pre><code class=\"language-java\">$ vagrant box add e:\\Downloads\\CentOS-7.box --name centos-7\n==&gt; box: Box file was not detected as metadata. Adding it directly...\n==&gt; box: Adding box \'centos-7\' (v0) for provider:\n    box: Unpacking necessary files from: file:///e:/Downloads/CentOS-7.box\n    box:\n==&gt; box: Successfully added box \'centos-7\' (v0) for \'virtualbox\'!\n</code></pre>\n<p>命令后面跟着的是下载的文件路径，并且通过 --name centos-7 为这个 box 指定一个名字。</p>\n<p>后面创建虚机都需要指定这个名字，所以尽量把名字取得简短一点，同时也要能标识出这个镜像的信息（我们后面会定制自己的基础镜像，所以这里可以简单点）。</p>\n<p>再次查询，可以看到有了一个 box：</p>\n<pre><code class=\"language-java\">$ vagrant box list\ncentos-7 (virtualbox, 0)\n</code></pre>\n<h2 id=\"6vagrant-基本操作\">6.Vagrant 基本操作</h2>\n<h3 id=\"61-新建虚机\">6.1 新建虚机</h3>\n<p>创建一个目录，先执行 <code>vagrant init</code>：</p>\n<pre><code class=\"language-java\">$ mkdir demo\n$ cd demo\n$ vagrant init centos-7\nA `Vagrantfile` has been placed in this directory. You are now\nready to `vagrant up` your first virtual environment! Please read\nthe comments in the Vagrantfile as well as documentation on\n`vagrantup.com` for more information on using Vagrant.\n</code></pre>\n<p>其中的 <code>centos-7</code> 就是我们要使用的 <code>box</code> 名字。</p>\n<p>这个命令只是为我们生成一个 <code>Vagrantfile</code>，所以，这里的名字没指定或者写错了都没关系，后面会介绍如何编辑这个 <code>Vagrantfile</code> 来修改。</p>\n<h3 id=\"62-启动虚机\">6.2 启动虚机</h3>\n<p>我们等会再来细看这个文件，现在直接按照提示执行 <code>vagrant up</code>：</p>\n<pre><code class=\"language-java\">$ vagrant up\nBringing machine \'default\' up with \'virtualbox\' provider...\n==&gt; default: Importing base box \'centos-7\'...\n==&gt; default: Matching MAC address for NAT networking...\n==&gt; default: Setting the name of the VM: demo_default_1588406874156_65036\n==&gt; default: Clearing any previously set network interfaces...\n==&gt; default: Preparing network interfaces based on configuration...\n    default: Adapter 1: nat\n==&gt; default: Forwarding ports...\n    default: 22 (guest) =&gt; 2222 (host) (adapter 1)\n==&gt; default: Booting VM...\n==&gt; default: Waiting for machine to boot. This may take a few minutes...\n    default: SSH address: 127.0.0.1:2222\n    default: SSH username: vagrant\n    default: SSH auth method: private key\n</code></pre>\n<p>正常的情况下，不到一分钟应该就能启动成功了。</p>\n<h3 id=\"63-查看虚机状态\">6.3 查看虚机状态</h3>\n<p>执行下面的命令可以查看虚机的状态：</p>\n<pre><code class=\"language-java\">vagrant status\n\nCurrent machine states:\n\ndefault                   running (virtualbox)\n\nThe VM is running. To stop this VM, you can run `vagrant halt` to\nshut it down forcefully, or you can run `vagrant suspend` to simply\nsuspend the virtual machine. In either case, to restart it again,\nsimply run `vagrant up`.\n</code></pre>\n<p>该命令还提示了如何操作虚机，我们继续一一介绍</p>\n<h3 id=\"64-连接虚机\">6.4 连接虚机</h3>\n<p>如果启动没问题，接下来执行 <code>vagrant ssh</code> 就能以 <code>vagrant</code> 用户直接登入虚机中。</p>\n<p>root 用户没有默认密码，也不能直接登录。需要 root 权限的命令可以通过在命令前添加 <code>sudo</code> 来执行，也可以执行 <code>sudo -i</code> 直接切换到 root 用户。</p>\n<p>这时候打开 <code>VirtualBox</code> 程序，可以看到自动创建的虚机：<br />\n<img src=\"https://img-blog.csdnimg.cn/20210308120126381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>我们也可以在 VirtualBox 的终端上登录系统，默认的登录用户名和密码<strong>都是</strong> <code>vagrant</code>。</p>\n<p>当然还可以使用其它的 SSH 连接工具例如 XShell，SecureCRT 连接，但是这里默认网卡使用的是 NAT 模式，没有指定 IP，实际应用并不方便，我们在后面介绍网络配置时再详细介绍如何连接虚机。</p>\n<p><strong>停止虚机</strong><br />\n执行下面的命令可以关闭虚机：</p>\n<pre><code class=\"language-java\">vagrant halt\n</code></pre>\n<p>直接在 VirtualBox 上关闭虚机，或者直接在虚机内部执行 poweroff 命令也都是可以的。</p>\n<p><strong>暂停虚机</strong><br />\n执行下面的命令可以暂停虚机：</p>\n<pre><code class=\"language-java\">vagrant suspend\n</code></pre>\n<p><strong>恢复虚机</strong><br />\n执行下面的命令把暂停状态的虚机恢复运行：</p>\n<pre><code class=\"language-java\">vagrant resume\n</code></pre>\n<p>注意： 不管虚机是关闭还是暂停状态，甚至是 error 状态，都可以执行 vagrant up 来让虚机恢复运行。</p>\n<p><strong>重载虚机</strong><br />\n执行下面的命令会重启虚机，并且重新加载 Vagrantfile 中的配置信息：</p>\n<pre><code class=\"language-java\">vagrant reload\n</code></pre>\n<p><strong>删除虚机</strong><br />\n最后，执行下面的命令可以彻底删除虚机，包括整个虚机文件：</p>\n<pre><code class=\"language-java\">vagrant destroy\n</code></pre>\n<p>注意： 在当前这个小例子中，上面所有的 vagrant 命令都需要在 Vagrantfile 所在的目录下执行。</p>\n<h2 id=\"7自定义配置-vagrantfile\">7.自定义配置 Vagrantfile</h2>\n<p>端口转发（Port forward）又叫端口映射，就是把虚机的某个端口，映射到宿主机的端口上。这样就能在宿主机上访问到虚拟机中的服务。</p>\n<p>例如启动虚机时，默认的 <code>22 (guest) =&gt; 2222 (host) (adapter 1)</code> 就是把虚机的 SSH 服务端口（22）映射到宿主机的 2222 端口，这样直接在宿主机通过 ssh 客户端访问 <code>127.0.0.1:2222</code> 端口就等价于访问虚拟机的 22 端口。</p>\n<p>默认的网络连接方式是网络地址转换NAT（端口转发），如果其他主机要访问虚拟机，必须由windows端口如3333断发给虚拟机端口如3306。这样每在linux里安一个软件都要进行端口映射，不方便，（也可以在virualBox里挨个设置）。我们想要给虚拟机一个固定的ip地址，windows和虚拟机可以互相ping通。</p>\n<p><strong>方式1是在虚拟机中配置静态ip。</strong></p>\n<p>也可以更改<code>Vagrantfile</code>更改虚拟机ip，修改其中的<code>config.vm.network``&quot;private_network&quot;,ip:&quot;192.168.56.10&quot;，</code>这个ip需要在windows的<code>ipconfig</code>中查到<code>vitualbox</code>的虚拟网卡ip，然后更改下最后一个数字就行（不能是1，1是我们的主机）。配置完后<code>vagrant reload</code>重启虚拟机。在虚拟机中<code>ip addr</code>就可以查看到地址了。互相ping也能ping通。</p>\n<p>关掉防火墙，<code>VirualBox</code>中第一个网卡设置<code>NAT</code>，第二个网卡设置仅主机</p>\n<p>如果ping不了baidu</p>\n<ul>\n<li><code>cd /etc/sysconfig/network-scripts</code></li>\n<li>ls 一般有<code>ifcfg-eth0 1</code></li>\n<li><code>ip addr</code> 看哪个网格是<code>192.168.56</code>网段，然后vim他</li>\n<li><code>vim ifcfg-eth1</code> 加入</li>\n</ul>\n<pre><code>GATEWAY=192.168.56.1\nDNS1=114.114.114.114\nDNS2=8.8.8.8\n</code></pre>\n<ul>\n<li><code>service network restart</code></li>\n</ul>\n<p>默认只允许ssh登录方式，为了后来操作方便，文件上传等，我们可以配置允许账号密码登录</p>\n<pre><code class=\"language-java\">vim /etc/ssh/sshd_config\n修改\nPasswordAuthentication yes\n重启\nservice sshd restart\n账号root\n密码vagrant\n</code></pre>\n<p>配置源</p>\n<pre><code class=\"language-java\"># 备份原yum源\n\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n# 使用新yum源\ncurl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.163.com/.help/CentOS7-Base-163.repo\n# 生成缓存\nyum makecache\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p>费了莫大的力气，终于可以比较愉快地玩耍了。虽然也只是刚把基础镜像搞定了，后面可能还要针对不同用途的环境编写更加复杂的 Vagrantfile。</p>\n<p>现在很多人刚认识到 Vagrant 之后都会问，<strong>Vagrant 和 Docker 的区别是什么？</strong></p>\n<p>在容器流行之前，Vagrant 就是用来编排虚机和自动部署开发环境的，有了 Docker/Kubernetes 之后，直接用容器来编排应用确实更香。但是还有一些工作，例如容器平台自身的安装，多节点集群的部署测试等，更方便用虚机解决。</p>\n<p>此外，现在 Windows 中还可以通过 WSL 使用 Linux 系统，但是使用场景上还是有所不同。Vagrant 更多地用于快速搭建可重用的开发环境，从这个角度看，Vagrant 其实好比 IaaS 云平台，只不过规模局限在个人电脑上。</p>\n', 1, '', 0, 0, 1, '2021-03-10 18:17:11', '2022-05-21 18:06:00');
INSERT INTO `tb_article` VALUES (150, 1, 7, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5887', '918农业信息化考研资料', '<h2 id=\"%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A\" tabindex=\"-1\">名词解释</h2>\n<p><strong>信息：</strong> 事物之间相互联系、相互作用的状态的描述。</p>\n<p><strong>信息技术：</strong> 是指计算机硬件技术、计算机软件和通信技术的总称。</p>\n<p><strong>信息系统：</strong> 是由计算机硬件、网络和通讯设备、计算机软件、信息资源、信息用户和规章制度组成的以处理信息流为目的的人机一体化系统。</p>\n<p><strong>农业信息：</strong> 是指人们利用农业生产资源进行农产品生产、加工和营销等活动的一切消息、情报、数据等的总称。</p>\n<p><strong>农业信息技术：</strong> 包括农业信息的获取技术（如遥感技术）、处理技术（如数据的并行处理技术）、模拟技术（如作物生长模拟）、自动识别技术、人工智能技术等等。</p>\n<p><strong>农业信息系统：</strong> 一般由农业生物信息、农业环境信息、农业技术知识信息和农业经济信息等四个信息子系统构成。</p>\n<p><strong>农业信息学：</strong> 农业科学与信息科学相互交叉融合形成的一门学科。可以定义为：以农业科学为基本理论基础，以农业信息为对象，以信息技术支撑，研究农业信息的采集、处理、分析、存储、传输及其运动变化规律，为农业生产服务的科学和技术。</p>\n<p><strong>信息再生：</strong> 指运用信息技术和科学方法对本原信息进行加工处理而产生出新的信息的工作过程。</p>\n<p><strong>数据库：</strong> 存放数据的仓库（顾名思义/不准确的含义）尽管数据库技术已发展成熟，但还没有一个普遍接受的、严格的定义。</p>\n<p><strong>数据库系统：</strong> 基于数据库的计算机应用系统。</p>\n<p><strong>数据模型：</strong> 是数据特征的抽象，在数据库系统中，数据模型是它的核心与基础。数据模型描述数据的结构，定义在其上的操作以及约束条件。它从概念层面上描述了系统的静态特征、动态特征和约束条件，为数据库系统的信息表示与操作提供一个抽象框架。</p>\n<p><strong>关系模型：</strong> 用关系表示（不需用指针）实体和实体之间联系的模型称为关系模型。<br />\n<strong>农业专家系统：</strong> 也叫农业智能系统，是一个拥有大量权威农业专家的知识、经验、资料、数据与成果构成的知识库，并能利用其中的知识模拟农业专家解决问题的思维方法尽心判断、推理，求得解决农业生产问题答案的智能程序系统。</p>\n<p><strong>农业模拟模型：</strong> 利用系统分析方法和计算机模拟技术，对农业系统中的生物与非生物过程及其与环境和农业技术措施之间的动态关系进行定量描述和预测。</p>\n<p><strong>系统分析法：</strong> 是把将要研究的目标当做一个统一的整体，并把这个整体分解为若干个子系统，揭示影响子系统的各项因素及相互关系，并进行数量化描述，以此为基础，对获取的信息进行综合整理、分析、判断和加工，选择出最优的因素组合，优化系统或设计新系统。</p>\n<p><strong>精确农业：</strong> 是由信息技术支持的、根据空间变异定位、定时、定量的实施一整套现代化农事</p>\n<p><strong>农业物流：</strong> 是指以农业生产为核心而发生的一系列物品从供应地向接受地的实体流动和与之有关的技术、组织、管理活动。</p>\n<p><strong>电子商务：</strong> 广义上讲，电子商务是电子工具再商务活动中的应用。<br />\n狭义上讲：电子商务是在技术、经济高度发达的现代社会里掌握信息技术和商务规则的人、系统化应用电子工具高效率、低成本地从事以商品交换为中心的葛洪活动的总称。</p>\n<p><strong>物联网：</strong> 物联网被视为互联网的应用扩展，应用创新是物联网的发展的核心，以用户体验为核心的创新是物联网发展的灵魂。</p>\n<p><strong>农业信息化：</strong> 其内涵应包括农业资源环境信息化、农业生产管理信息化、农业市场流通信息化、农业科技与教育信息化、农业产业经营信息化。</p>\n<h2 id=\"%E7%AE%80%E7%AD%94\" tabindex=\"-1\">简答</h2>\n<p><strong>1、	信息有哪些主要性质特征</strong><br />\n真实性、时效性、不完全性、等级性、层次性、对性习惯、价值性、共享性、寄载性</p>\n<p><strong>2、	什么是信息量？如何度量信息量？</strong><br />\n信息量是指从N个相等可能事件中选出一个事件所需要的信息度量或含量，也就是在辨识N个事件中特定的一个事件的过程中所需要提问&quot;是或否&quot;的最少次数.<br />\n信息的度量是利用概率来度量信息。</p>\n<p><strong>3、	农业信息有哪些主要特征？</strong><br />\n1,农业生物的自身特性：农业生产的种子、种苗、种禽等原材料．都是由农业自身提供的．这些农业生物有机体有其自身的生长、发育特性和自然再生产的规律．从事农业生产经营活动，必须掌握农业生物信息，符合农业生物自然再生产的规律．<br />\n2,农业依赖环境的特性：农业生物依赖农业环境而生长、发育、繁衍后代．光、热、水、气、风、霜、雨、雪、土壤质地以及地形地貌等环境信息，对农业生产经营起着促进或制约作用．<br />\n3,农业生产的季节性：春种、夏管、秋收、冬藏，农业生产具有强烈的季节性．按农时组织农业生产经营，要求掌握农时信息，提供农时信息．<br />\n4,农业生产的地域性：农人们按照农业生物适地适生的信息．做到因地制宜的组织农业生产经营活动．<br />\n5,农业生产的周期性：农业生物有其自身的生命周期．农业生产是遵循生物体生命周期规律的有目的的生产活动．为此，人类应掌捏农业生物的生命信息，生命周期的连续信息，以获取农业经济效益和生态效益。<br />\n6,农业生产的系统性：农业生产是生物、环境、经济、技术和人类共同参与活动的系统工程，各方面的信息同时存在，相互渗透，共同作用，推动或制约整个系统的运行.<br />\n7,农业生产的分散性：我国农付地域宽广，由几亿农民从事农业，产生信息的信源分散；将信息传输至信宿．也同样分散．要在广大农村建立信息网络，收集和传输信息，其难度较大．</p>\n<p><strong>4、	农业信息收集有哪些主要途径？</strong><br />\n主要有两类途径：<br />\n（1）	关系途径：沿着各种与信源相关的事物进行收集，如人际关系。<br />\n（2）	技术途径：利用各种技术直接或间接收集信息，如网络技术等。</p>\n<p><strong>5、	农业信息收集有哪些主要方法？</strong><br />\n收集信息的方法主要可分为人工收集法和技术收集方法，</p>\n<ol>\n<li>人工收集法：信息收集者人工地进行收集，如实验、考察、手工查阅文献等。</li>\n<li>技术收集法：通过各种技术手段自动收集，包括计算机技术、微电子技术（传感器）、感、卫星技术等等。</li>\n</ol>\n<p><strong>6、	简述农信息整理加工的基本要求和基本内容。</strong><br />\n基本要求：应符合真实、标准、及时、合适、有效等要求。<br />\n基本内容：<br />\n（1）原始信息的汇集、筛选、分析、鉴别<br />\n（2）信息变换、载体结合、信道选配<br />\n（3）信息分类、排序、编码、录制、储存<br />\n（4）信息再生、转化、进入终端显示、利用等</p>\n<p><strong>7、	简述数据额模型的三要素。</strong><br />\n（1）数据结构——描述数据额的静态特征，包括对数据结构和数据间联系的描述、<br />\n通常按照数据结构的类型来命名数据模型：<br />\n层次结构——层次模型    网状结构——网状模型    关系结构——关系模型<br />\n（2）数据操作——描述数据的动态特征和，一组定义在数据上的操作（包括操作的含义、操作符、运算规则及其语言等），主要操作：检索和更新（插入、删除、修改）<br />\n（3）数据的约束条件——完整性规则的集合，数据库中的数据必须满足这组规则。约束条件的主要目的是使数据库与它所描述的现实系统相符合。</p>\n<p><strong>8、	简述E-R数据模型。</strong><br />\nE-R模型是一种重要的数据模型，它结构简单，语义表现力丰富，描述力强，同时又能方便的转换为其他经常使用的网状、层次或关系模型，所以，再数据库设计中得到广泛应用。</p>\n<p><strong>9、	简述数据库系统的开发流程。</strong><br />\n目前信息系统开发经常采用周期法，该方法将整个信息系统的开发过程分为若干阶段，预先规定每个阶段的目标和任务，按一定准则顺次完成。AMIS的开发可采用生命周期法，其开发过程分为下图所示的六个阶段，即可行性研究、系统分析、系统总体方案设计、系统技术方案分析、系统实施、系统评价与维护。同时，再每个阶段都进行及时讨论和信息反馈。</p>\n<p><strong>10、简述农业专家系统的开发流程。</strong><br />\n包括知识获取，即从农业领域专家收集整理归纳有关的专业知识和经验、数据，并经农业专家系统开发人员消化、整理、归纳写成一条符号表示的形式；确定知识表示和推理方法；建立知识库；编写推理程序，然后调试、运行和修改等步骤。</p>\n<p><strong>11、写出SAS统计分析软件进行多重比较的程序。</strong><br />\nDATA A;<br />\nDO I=1 TO 5;<br />\nDO J=1 TO 10;<br />\nINPUT X @@;<br />\nOUTPUT;<br />\nEND;<br />\nEND;<br />\nDROP J;<br />\nCARDS;<br />\n…<br />\nPROC ANOVA;<br />\nCLASS I;<br />\nMODEL X=I;<br />\nMEANS VLSD;<br />\nRUN.</p>\n<p><strong>12、简述3S技术及其基本原理。</strong></p>\n<p><strong>3S技术是指</strong>遥感技术、地理信息技术、和全球定位系统。是空间技术、传感器技术、卫星定位与导航技术和计算机技术、通讯技术相结合，多学科高度集成的对空间信息进行采集、处理、管理、分析、表达、传播和应用的现在信息技术。</p>\n<p><strong>遥感技术原理：</strong> 直接接触目标物，在距地物几公里到几百公里、甚至上千公里的飞机、飞船、卫星上，使用光学或者电子光学仪器接受地面物体反射或者辐射的电磁波信号，并以图像胶片或数据磁带形式记录下来，形成数字影像。该影像传输到地面，经过各种校正后，进行影像分类、翻译，最后获取所需要的信息。</p>\n<p><strong>地理信息技术原理：</strong> 是在计算机硬件、软件及网络等支持下，对有关空间数据进行获取、存贮、查询检索、处理、分析、显示、更新和提供应用的技术系统。</p>\n<p><strong>全球定位系统原理：</strong> 共24颗卫星，其中3颗备用，分布在6个轨道面上。轨道面对地球赤道面的倾角为55°，各轨道平面升交点赤经相差60°，相邻轨道上卫星的升交距相差30°，轨道平均高度约20200km，均为近圆形轨道，运行周期11h58m。</p>\n<p><strong>13、地物空间数据矢量化的方法有哪些？</strong><br />\n矢量结构是通过记录坐标的方式来表达点线面等地理实体。获取方法：（1）手工数字化法；（2）手扶跟踪数字化法；（3）数据结构转换法。<br />\n（栅格数据结构：栅格结构是以规则的阵列来表示空间地物或现象分布的数据组织，组织中的符复合数据表示地理要素的非几合属性特征。获取方法：1手工网格法2扫描数字化法3分类影像输入法47数据结构转换法。）</p>\n<p><strong>14、简述农业模拟模型的研制步骤。</strong><br />\n（1）	模型选择与系统定义。弄清研究目的、研究水平和研究对象。<br />\n（2）	资料来源。①自己积累或文献资料②从同行专家处获取③补充试验或支持研究<br />\n（3）	模块设计与模型设计。编程语言的选择、算法编程、界面编程、输入输出内容和形式。<br />\n（4）	模型检验与改进。①敏感性分析  分析模型对主要参数和变量反应的灵敏度②校正  调整模型的参数和关系，使得模型符合特定的环境和资料参数③核实  将模拟结果与实际结果进行相关回归分析；将实际结果与模拟结果按同一时间坐标绘1:1图进行比较；检查模拟结果与实际结果的平均误差。</p>\n<p><strong>15、简述农业信息服务的基本原理和基本内容。</strong><br />\n基本内容：1.农业资源信息服务2.农业教育服务3.农业咨询服务4.农业物流服务</p>\n<p><strong>16、实现精确农业的关键技术有哪些？</strong><br />\n精确农业的支持技术除地理信息系统（GIS）、遥感技术（RS）、全球定位系统（GPS）外，还包括决策支持系统（DSS）和变量投入技术（VRT），以上几个关键技术互相补充，共同构建精确农业的技术体系。</p>\n<h1 id=\"%E7%BB%BC%E5%90%88%E9%A2%98\" tabindex=\"-1\">综合题</h1>\n<p><strong>1、	结合专业，谈谈学习农业信息学的意义（不能少于300字）<br />\n2、	结合专业，谈谈在我国如何实现农业的信息化。</strong></p>\n', 1, '', 0, 0, 1, '2021-08-30 10:24:09', '2022-05-21 17:44:21');
INSERT INTO `tb_article` VALUES (151, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=9917', '《计算机网络》复习要点', '<p>《计算机网络》复习要点<br />\n一、概述（远看、近看互联网）<br />\n计算机网络的定义、功能<br />\n组成、分类、拓扑结构<br />\n互联网（因特网）的多级结构、接入方式<br />\n二、物理层<br />\n模拟数据与数字数据、模拟信号与数字信号、模拟信道与数字信道<br />\n不归零码、归零码、曼彻斯特编码、差分曼彻斯特编码<br />\n数据传输率、带宽、信道容量、误码率、时延<br />\n多路复用技术：频分、时分、波分<br />\n交换技术：电路、分组（原理、区别）<br />\n介质：双绞线、同轴电缆、光纤<br />\n三、网络体系结构<br />\n分层原理（为何分层、层间关系、数据在层间传递、封转的过程）<br />\n网络协议的概念、组成元素<br />\nOSI体系结构（每层功能）<br />\nTCP/IP体系结构（每层功能、每层主要协议）<br />\nOSI与 TCP/IP体系结构的比较、综合的五层体系结构<br />\n四、数据链路层（以太网）<br />\n以太网特点、拓扑结构、要解决的问题<br />\nIEEE802标准<br />\nMAC层功能、MAC地址、MAC帧格式<br />\nCSMA/CD工作原理<br />\n交换机（网桥）的工作原理、特点、转发表的建立方法<br />\n交换机与集线器的区别<br />\nVLAN的概念、特点、好处、划分方法<br />\n局域网的搭建、VLAN的划分（实践环节）<br />\n五、网络层（网络互联）<br />\n网络互联的思路、工作原理<br />\n路由器的作用、工作原理<br />\n路由表的基本内容和查表方法<br />\nIP分组的格式、router处理IP分组基本过程<br />\nIP地址（分类地址、子网划分地址）<br />\n单播地址、广播地址、组播地址、特殊IP地址<br />\n子网掩码的作用、使用方法<br />\nIP地址与硬件地址的区别与关系<br />\nARP的功能、原理、有效范围<br />\nICMP功能、特点<br />\nPing、tracert的原理<br />\nRIP的功能、工作原理、优缺点<br />\nOSPF、BGP的功能、特点<br />\n组建互联网、配置地址、路由的基本方法（实践环节）<br />\n六、端到端传输<br />\n传输层的作用、服务类型（可靠传输、不可靠传输）<br />\n端口、端口号的作用、特点、知名端口<br />\nTCP的服务特点、报文格式<br />\nTCP可靠传输的措施（滑动窗口、流量控制、慢开始、拥塞避免算法等）<br />\nUDP的特点、报文格式、应用场景<br />\n七、网络应用<br />\n客户/服务器工作模式的特点<br />\nDNS（域名结构、域名服务器的层次结构、解析过程）</p>\n', 1, '', 0, 0, 1, '2021-08-30 10:42:30', '2021-08-30 10:42:30');
INSERT INTO `tb_article` VALUES (152, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7460', '下载库不库', '<table>\n<thead>\n<tr>\n<th>安装包列表清单👉👉👉</th>\n<th>👇</th>\n<th>👇</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F05%2F07%2FFroit5NB_mysql-installer-community-5.7.28.0.msi?Expires=1652584202\" target=\"_blank\">MySQL</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F08%2F18%2FVFSexUgC_CentOS-7-x86_64-DVD-2003.iso?Expires=1652584306\" target=\"_blank\">Centos7</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F09%2F28%2FMkIuEzVA_%E8%A1%A8%E6%83%85%E5%8C%85.rar?Expires=1652584333\" target=\"_blank\">表情包</a></td>\n</tr>\n<tr>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F05%2F07%2FkSuZFcV0_Redis-x64-3.2.100.zip?Expires=1652584447\" target=\"_blank\">Redis</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F05%2F07%2FhuKw8WI7_jdk-8u201-windows-x64.exe?Expires=1652584467\" target=\"_blank\">JDK8-win64</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F05%2F07%2Fy9YB1Fox_jdk-8u181-linux-x64.tar.gz?Expires=1652584495\" target=\"_blank\">JDK8-Linux</a></td>\n</tr>\n<tr>\n<td><a href=\"http://cloud.henaumcw.top/#/s/ZbCP\" target=\"_blank\">截图工具</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2022%2F06%2F01%2Ff9wuuLPb_wiztree_3_29_setup.exe?Expires=1654090488\" target=\"_blank\">磁盘树分析</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2022%2F06%2F01%2F9FCoSfiA_attahcmentName_findDuplicateClass.exe?Expires=1654090530\" target=\"_blank\">jar包冲突分析工具</a></td>\n</tr>\n<tr>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2022%2F06%2F01%2FrLd8HhNt_mqttfx-1.7.1-windows-x64%20%281%29.exe?Expires=1654090571\" target=\"_blank\">MQTT.FX 1.7.1</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2022%2F06%2F01%2FUPpiUJjH_Listary.exe?Expires=1654090607\" target=\"_blank\">Lisary</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F07%2F21%2FYs5dI2fb_WinMTR-v092%20%281%29.rar?Expires=1654090780\" target=\"_blank\">WinMTR路由追踪</a></td>\n</tr>\n</tbody>\n</table>\n', 1, '', 0, 0, 1, '2022-05-15 09:16:51', '2022-06-01 21:45:57');
INSERT INTO `tb_article` VALUES (153, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5232', 'Hello Halo', '<h2 id=\"hello-halo\">Hello Halo</h2>\n<p>如果你看到了这一篇文章，那么证明你已经安装成功了，感谢使用 <a href=\"https://halo.run\">Halo</a> 进行创作，希望能够使用愉快。</p>\n<h2 id=\"相关链接\">相关链接</h2>\n<ul>\n<li>官网：<a href=\"https://halo.run\">https://halo.run</a></li>\n<li>社区：<a href=\"https://bbs.halo.run\">https://bbs.halo.run</a></li>\n<li>主题仓库：<a href=\"https://halo.run/s/themes\">https://halo.run/s/themes</a></li>\n<li>开源地址：<a href=\"https://github.com/halo-dev/halo\">https://github.com/halo-dev/halo</a></li>\n</ul>\n<p>在使用过程中，有任何问题都可以通过以上链接找寻答案，或者联系我们。</p>\n<blockquote>\n<p>这是一篇自动生成的文章，请删除这篇文章之后开始你的创作吧！</p>\n</blockquote>\n', 1, '', 0, 0, 1, '2020-04-24 18:38:38', '2022-05-21 18:21:34');
INSERT INTO `tb_article` VALUES (154, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5560', '关于我', '<h2 id=\"%E8%87%AA%E8%AF%AD\" tabindex=\"-1\">自语</h2>\n<ul>\n<li>大家好，我是一枚刚入门的后端开发工程师👨🏻‍💻，在读研究生，目前主攻Java后端开发.</li>\n<li>我希望用代码改变世界,我也在改变世界,自豪脸😏</li>\n<li>目前正走在成为一个<s>厉害</s>(Zhuang Bi)程序猿的路上. 前途很艰辛, 但是我会坚持!</li>\n<li>生活不止有撸码和工作, 也有诗和远方. 在快乐中生活, 在快乐中工作, 爱家人, 爱自己</li>\n</ul>\n<p><strong>子曰：生而知之者，上也；学而知之者，次也；困而学之，又其次也；困而不学，民斯为下矣。<br />\n人生得意须尽欢，莫使金樽空对月。<br />\n少小须勤学，文章可立身。满朝朱紫贵，尽是读书人。</strong></p>\n<h2 id=\"%E6%8A%80%E8%83%BD\" tabindex=\"-1\">技能</h2>\n<ul>\n<li>语言：Java, JavaScript, HTML, CSS</li>\n<li>数据库：MySQL, Redis, Oracle</li>\n<li>开发框架：Spring, Spring Boot, Spring Cloud Alibaba, MyBatis, Shiro, JQuery，Bootstrap，Layui，Vue</li>\n<li>交互协议：TCP/IP，Netty，MQTT，WebSocket</li>\n<li>中间件：Kafka, Zookeeper,MyCat</li>\n<li>构建工具： Maven, Tomcat</li>\n<li>环境： Centos, Linux, Git,Eclipse, Intellij IDEA</li>\n</ul>\n<h2 id=\"%E5%AD%A6%E4%B9%A0\" tabindex=\"-1\">学习</h2>\n<ul>\n<li>有道是学无止境，Java 后端开发的路很难走，但是既然走了这条路，那就得一直走下去。</li>\n<li>Java 相关的技术栈很多，学起来很不容易，最近两年的行情也是优胜劣汰，希望自己能够快速成长起来。</li>\n<li>夯实基础，学习源码。</li>\n<li>初识<strong>知识图谱</strong>，希望在这条路上也有所成长。</li>\n</ul>\n<p><ins>问渠哪得清如许？为有源头活水来。</ins></p>\n<blockquote>\n<p>要问为什么方塘的水会如此清澈？是由于有永不枯竭的源头为它源源不断地输送活水啊。<br />\n诗句常用来比喻知识是不断更新和发展的，需要不断积累，就像水源头一样，在人生的学习中不断地学习、运用和探索，才能使自己永葆先进和活力。</p>\n</blockquote>\n<h2 id=\"%E5%8D%9A%E5%AE%A2\" tabindex=\"-1\">博客</h2>\n<ul>\n<li>期望：平时生活和工作一种记录, 希望之后回过头再来看自己的博客也会有所收获或感想</li>\n<li>技术、感想与生活</li>\n<li>对生活和学习的一个记录</li>\n<li>希望自己越来越强大，为了自己所爱的人</li>\n</ul>\n<h2 id=\"%E5%88%86%E4%BA%AB\" tabindex=\"-1\">分享</h2>\n<p>最喜欢的一首诗，与你共勉：</p>\n<blockquote>\n<p><strong>大鹏一日同风起，抟摇直上九万里。<br />\n假令风歇时下来，犹能簸却沧溟水。<br />\n世人见我恒殊调，闻余大言皆冷笑。<br />\n宣父犹能畏后生，丈夫未可轻年少。</strong></p>\n</blockquote>\n', 1, '', 0, 0, 1, '2020-10-07 12:41:27', '2022-08-02 11:19:04');
INSERT INTO `tb_article` VALUES (155, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8331', 'Springboot多模块配置详细教程+源码案例+所遇到的坑', '<h3 id=\"springboot多模块配置详细教程\">Springboot多模块配置详细教程</h3>\n<blockquote>\n<p>这两天参考了下若依大神的后台管理项目，感觉程序的健壮性是真的强大，本人佩服的五体投地，很多程序设计技巧规范非常值得我去学习，其中第一个便是Springboot的多模块化配置，也正好项目中需要，所以特地学习一下，但是实际操作中遇到了很多问题，特此记录一下。</p>\n</blockquote>\n<h6 id=\"进行多模块配置的好处maven多模块项目通常由一个父模块和若干个子模块构成每个模块都对应着一个pomxml它们之间通过继承和聚合也称作多模块相互关联多模块适用于一些比较大的项目通过合理的模块拆分实现代码的复用便于维护和管理\">进行多模块配置的好处：maven多模块项目通常由一个父模块和若干个子模块构成，每个模块都对应着一个pom.xml。它们之间通过继承和聚合（也称作多模块）相互关联。多模块适用于一些比较大的项目，通过合理的模块拆分，实现代码的复用，便于维护和管理。</h6>\n<p>在开始动手之前，我们先捋一捋每个模块的作用，清楚需求做事才有目的。之后再说如何创建：<br />\n<img src=\"https://img-blog.csdnimg.cn/20191231180812711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n首先，如上图所示，我这里分了四个子模块和一个父模块。</p>\n<p>其中ww_system模块主要放entity、service、serviceImpl、mapper等文件。<br />\nww_common主要放一些公共的工具类，<br />\nww_blog是我的前台controller控制器<br />\nww_admin 是系统的web启动入口，包括系统后台controller都在这。是整个系统启动的入口。</p>\n<p>有心的朋友可以再单独把service也单独抽出来做一个模块，不过我觉得没有必要，用了mybatisplus之后service和mapper就很少写了。</p>\n<h3 id=\"如何创建\">如何创建？</h3>\n<h4 id=\"1创建父模块\">1，创建父模块</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20191231181705863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n父模块的创建和平常我们创建Springboot项目没法不同，一步一步来就行了，不过既然是父模块，那么它显然是不需要src目录的，所以创建后直接删掉它就行。其他的东西爱删不删，<strong>留下pom文件就行。</strong></p>\n<h4 id=\"2创建子模块\">2，创建子模块。</h4>\n<p>创建子模块的时候不要直接在左上角new -&gt;project来创建。要选择我们刚创建好的父模块项目，在它上面右击创建new module。<br />\n<img src=\"https://img-blog.csdnimg.cn/20191231182055709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n然后一直下一步就行，这里还没有什么要注意的地方，按照这种方式在父模块上右键创建其余的另外三个子模块。</p>\n<h4 id=\"3重点配置依赖\">3，重点：配置依赖</h4>\n<p>都创建好之后就是重点了，要配置我们几个模块之间的关联关系，<br />\n大致思路就是：所有的子模块都继承父模块<br />\nww_admin和ww_blog两个带控制器的模块要引用ww_system和ww_common公共模块。<br />\n公共模块ww_common不依赖任何模块，只补充它所需要的jar包坐标就行</p>\n<p>然后，父模块pom中不需要配置build打包配置</p>\n<h6 id=\"父模块pom文件内容\">父模块pom文件内容：</h6>\n<p><strong>注意模块引用和modules标签！！！！</strong></p>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.macw&lt;/groupId&gt;\n    &lt;artifactId&gt;wwblog&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n\n    &lt;name&gt;wwblog&lt;/name&gt;\n    &lt;url&gt;http://www.henaumcw.top&lt;/url&gt;\n    &lt;description&gt;马超伟●个人博客系统&lt;/description&gt;\n\n    &lt;properties&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n        &lt;macw.version&gt;1.0.0&lt;/macw.version&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n        &lt;shiro.version&gt;1.4.2&lt;/shiro.version&gt;\n        &lt;thymeleaf.extras.shiro.version&gt;2.0.0&lt;/thymeleaf.extras.shiro.version&gt;\n        &lt;druid.version&gt;1.1.14&lt;/druid.version&gt;\n    &lt;/properties&gt;\n\n    &lt;modules&gt;\n        &lt;module&gt;ww_admin&lt;/module&gt;\n        &lt;module&gt;ww_blog&lt;/module&gt;\n        &lt;module&gt;ww_system&lt;/module&gt;\n        &lt;module&gt;ww_common&lt;/module&gt;\n    &lt;/modules&gt;\n    &lt;packaging&gt;pom&lt;/packaging&gt;\n\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;!-- SpringBoot的依赖配置--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;\n                &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n                &lt;type&gt;pom&lt;/type&gt;\n                &lt;scope&gt;import&lt;/scope&gt;\n            &lt;/dependency&gt;\n            &lt;!--thymeleaf依赖--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n                &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--阿里数据库连接池 --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n                &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;\n                &lt;version&gt;${druid.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!-- 阿里JSON解析器 --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n                &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n                &lt;version&gt;${fastjson.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--系统模块--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.macw&lt;/groupId&gt;\n                &lt;artifactId&gt;ww_system&lt;/artifactId&gt;\n                &lt;version&gt;${macw.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--博客前台模块--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.macw&lt;/groupId&gt;\n                &lt;artifactId&gt;ww_blog&lt;/artifactId&gt;\n                &lt;version&gt;${macw.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--系统后台入口模块--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.macw&lt;/groupId&gt;\n                &lt;artifactId&gt;ww_admin&lt;/artifactId&gt;\n                &lt;version&gt;${macw.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--公共模块--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.macw&lt;/groupId&gt;\n                &lt;artifactId&gt;ww_common&lt;/artifactId&gt;\n                &lt;version&gt;${macw.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.1&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;source&gt;${java.version}&lt;/source&gt;\n                    &lt;target&gt;${java.version}&lt;/target&gt;\n                    &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n    &lt;!--配置阿里云国内镜像--&gt;\n    &lt;repositories&gt;\n        &lt;repository&gt;\n            &lt;id&gt;public&lt;/id&gt;\n            &lt;name&gt;aliyun nexus&lt;/name&gt;\n            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;\n            &lt;releases&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n            &lt;/releases&gt;\n        &lt;/repository&gt;\n    &lt;/repositories&gt;\n&lt;/project&gt;\n\n</code></pre>\n<h6 id=\"ww-systempom文件内容\">ww_system:pom文件内容：</h6>\n<p>注意parent标签和模块引用</p>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;wwblog&lt;/artifactId&gt;\n        &lt;groupId&gt;com.macw&lt;/groupId&gt;\n        &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;groupId&gt;com.macw&lt;/groupId&gt;\n    &lt;artifactId&gt;ww_system&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;name&gt;ww_system&lt;/name&gt;\n    &lt;description&gt;系统模块&lt;/description&gt;\n    &lt;dependencies&gt;\n        &lt;!-- Mysql驱动包 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- 通用工具--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.macw&lt;/groupId&gt;\n            &lt;artifactId&gt;ww_common&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--Mybatis plus--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;\n            &lt;version&gt;3.3.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-extension&lt;/artifactId&gt;\n            &lt;version&gt;3.3.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;\n            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;\n            &lt;version&gt;2.3.28&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n\n</code></pre>\n<h6 id=\"ww-common模块pom文件内容\">ww_common模块pom文件内容：</h6>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;wwblog&lt;/artifactId&gt;\n        &lt;groupId&gt;com.macw&lt;/groupId&gt;\n        &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;groupId&gt;com.macw&lt;/groupId&gt;\n    &lt;artifactId&gt;ww_common&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;name&gt;ww_common&lt;/name&gt;\n    &lt;description&gt;公共模块&lt;/description&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- Spring框架基本的核心工具 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- SpringWeb模块 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;${lombo.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n\n</code></pre>\n<h6 id=\"ww-admin模块pom文件内容\">ww_admin模块pom文件内容：</h6>\n<p><strong>注意这里的模块引用和build标签内容</strong></p>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;wwblog&lt;/artifactId&gt;\n        &lt;groupId&gt;com.macw&lt;/groupId&gt;\n        &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;groupId&gt;com.macw&lt;/groupId&gt;\n    &lt;artifactId&gt;ww_admin&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;name&gt;ww_admin&lt;/name&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n    &lt;description&gt;系统后台●总后台web服务入口模块&lt;/description&gt;\n  \n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- SpringBoot集成thymeleaf模板 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- spring-boot-devtools --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n            &lt;optional&gt;true&lt;/optional&gt; &lt;!-- 表示依赖不会传递 --&gt;\n        &lt;/dependency&gt;\n\n        &lt;!--公共模块--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.macw&lt;/groupId&gt;\n            &lt;artifactId&gt;ww_common&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;!--博客前台--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.macw&lt;/groupId&gt;\n            &lt;artifactId&gt;ww_blog&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;!--系统模块--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.macw&lt;/groupId&gt;\n            &lt;artifactId&gt;ww_system&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;3.3.0&lt;/version&gt;\n        &lt;/dependency&gt;\n\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;fork&gt;true&lt;/fork&gt; &lt;!-- 如果没有该配置，devtools不会生效 --&gt;\n                &lt;/configuration&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;repackage&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n        &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n\n</code></pre>\n<h4 id=\"4-启动入口配置\">4 启动入口配置</h4>\n<p>启动入口只在ww_admin下配置Application启动类就行了，其他模块下不需要。<br />\n需要注意的是启动类一定要放在模块的根目录下，<br />\n我之前就是放在了模块目录下然后就导致了bean注入失败等的许多错误，需要加上@ComponentScan等好几个来进行包扫描，及其麻烦</p>\n<p>所以最好的就是放在根目录下，如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20191231185137914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n如果遇到bean注释失败的错误，那么别问其他，就去找你的包扫描吧，肯定是路径的问题。我就在这里栽了好久好久。<br />\n添加控制器和连接池之后的目录大致是这样的<br />\n<img src=\"https://img-blog.csdnimg.cn/20191231185515837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n由于篇幅限制上面pom文件中删掉了很多与这篇文章讲解无用的依赖。如果报错或无法启动请参考本项目源码：<a href=\"https://gitee.com/macw/wwblog.git\">https://gitee.com/macw/wwblog.git</a></p>\n<p>今天先更新到这，其他有问题闲来再更新</p>\n', 1, '', 0, 0, 1, '2020-04-25 08:33:11', '2022-05-21 18:21:18');
INSERT INTO `tb_article` VALUES (156, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8802', 'centos7系统运行、停止java程序常用命令，springboot打包运行', '<p>﻿</p>\n<h4 id=\"对于spring-boot导出的jar包程序\">对于Spring Boot导出的jar包程序</h4>\n<p>当连接的远程服务器执行的时候，一旦关闭了当前终端，程序也被迫停止运行了。这显然是不行的<br />\n我想要的是让它常驻后台执行，不受启动其终端关闭与否的影响。</p>\n<h5 id=\"解决办法\">解决办法</h5>\n<p>在jar包文件所在的目录执行以下命令：</p>\n<pre><code> nohup java -jar springboot-0.0.1-SNAPSHOT.jar  &gt;nohup 2&gt;&amp;1 &amp;\n</code></pre>\n<p>nohup: 不挂断的执行命令，忽略所有的挂断信号。 运行后台命令 最后加 &amp;<br />\n在jar目录下会生成一个nohup.out文件，默认的log输出到这里了。</p>\n<h5 id=\"命令解释\">命令解释</h5>\n<p>以上命令是不输出启动日志的，运行后会只输出一个运行的进程号。<br />\n想要输出启动日志可以这样：</p>\n<pre><code>java -jar xx.jar &gt; log.file 2&gt;&amp;1 &amp;\n</code></pre>\n<p><strong>这里启动信息就输出到了日志文件上，注意的是log文件需要先创建chmod授权</strong><br />\n可以给日志一个777授权，测试阶段无所谓：</p>\n<pre><code>chmod 777 -R /home/logs\n</code></pre>\n<h5 id=\"21含义\">2&gt;&amp;1含义</h5>\n<p>&amp; 1 更准确的说是文件描述符 1,<br />\n而1 一般代表的就是STDOUT_FILENO,实际上这个操作就是一个dup2(2)调用<br />\n.他标准输出到all_result ,然后复制标准输出到文件描述符2(STDERR_FILENO)， 其后果就是文件描述符1和2指向同一个文件表项,也可以说错误的输出被合并了<br />\n.其中0表示键盘输入 1表示屏幕输出 2表示错误输出.把标准出错重定向到标准输出,然后扔到/DEV/NULL下面去。通俗的说，就是把所有标准输出和标准出错都扔到垃圾桶里面。<br />\n|值|含义  |<br />\n|--|--|<br />\n| 0 |标准输入（一般是键盘）  |<br />\n|1|标准输出（一般是显示屏，准确的说是用户终端控制台）|<br />\n|2|标准错误（出错信息输出）|</p>\n<p>最后一个&amp; ， 是让该命令在后台执行</p>\n<h4 id=\"查看进程\">查看进程</h4>\n<p><strong>查看全部进程</strong></p>\n<pre><code>ps -ef \n</code></pre>\n<p><strong>查看java进程</strong></p>\n<pre><code>ps -ef |grep java\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20200106122724191.png\" alt=\"在这里插入图片描述\" /><br />\n如图所示：<br />\n第一个进程是我jar包启动进程，第二个是java的查找进程不用管<br />\n前面的那个root是当前用户，第一个数字403是当前进程号<br />\n<strong>杀死当前进程</strong></p>\n<pre><code>kill -9 403\n</code></pre>\n<p><strong>只查询当前jar包程序的进程号：</strong></p>\n<pre><code>pgrep -f \'java -jar springboot-0.0.1-SNAPSHOT.jar\'\n</code></pre>\n<p>如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20200106123205274.png\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 15:30:30', '2022-05-21 18:21:05');
INSERT INTO `tb_article` VALUES (157, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=191', 'SpringBoot在自定义实现类中调用service层等Spring其他层报错为null的解决办法', '<p>﻿## 背景：<br />\n使用Springboot整合Netty写了一个TCP实现客户端服务端通信接收主板信息，然后需要将设备实时发送的检测数据等关键信息存储到数据库，也是为了能最快利用mybatis框架实现数据访问，然后在TCP服务器消息处理时，需要写数据库，直接调用DAO层，编译报错。改为调用Service层，编译正常，运行到调用的地方，报空指针异常，跟踪到异常位置，发现service为空，也就是按照之前controller层通过<br />\n@Autowired注入service层失效。<br />\n解决方案：</p>\n<h2 id=\"1不要用mybatis使用原生的jdbc连接数据库进行存储\">1.不要用mybatis,使用原生的jdbc连接数据库进行存储</h2>\n<p>代码如下：</p>\n<pre><code class=\"language-java\">blic class MessageHandler extends ChannelInboundHandlerAdapter {\n	private static Logger logger = LoggerFactory.getLogger(MessageHandler.class);\n	/**\n	 * 本方法用于读取客户端发送的信息\n	 * @param ctx\n	 * @param msg\n	 * @throws Exception\n	 */\n	@Override\n	public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n    System.out.println(&quot;输出接收过来的信息： &quot;+msg);\n        //将msg进行入库操作\n        //基础的jdbc连接操作，这里省去基础的连接方法\n        String str;\n        // 传递sql语句\n        Statement stt;\n        Connection conn = null;\n        String sql = &quot;insert into test_db(datas) values (\'&quot;+msg+&quot;\')&quot;;  //写SQL\n        try {\n            conn = mysqlimages.getConn();  //一个连接数据库的方法，这就不贴了，很简单的\n            //获取Statement对象\n            stt = conn.createStatement();\n            //执行sql语句\n            stt.executeUpdate(sql);\n            logger.info(&quot;&gt;&gt;&gt;插入数据库成功&quot;);\n            str = Const.SECCESS;\n        }catch (Exception e) {\n            logger.error(&quot;&lt;&lt;&lt;插入数据错误--&quot;+e.getMessage());\n            str = Const.ERROR;\n        }\n</code></pre>\n<p>这种方法可以实现，但是不推荐，本来这里数据量就大，再用jdbc没有连接池将会造成业务阻塞netty本身的worker工作线程。<br />\n所以推荐使用下一种方法：</p>\n<h2 id=\"2使用postconstruct静态初始化spring的成员变量\">2.使用@PostConstruct静态初始化spring的成员变量</h2>\n<p>代码如下：<br />\nchannelRead方法：</p>\n<pre><code class=\"language-java\">	//调用线程池处理大数据量问题\n	ExecutorService executor = Executors.newFixedThreadPool(5);\n    int num=0;\n    \n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        System.out.println();\n        log.info(&quot;加载客户端报文......&quot;);\n        log.info(&quot;【&quot; + ctx.channel().id() + &quot;】&quot; + &quot; :&quot; + msg);\n        /**\n         *  下面可以解析数据，保存数据，生成返回报文，将需要返回报文写入write函数\n         */\n        num++;\n        System.out.println(num);//输出当前已经接收过来的条数\n        //引入异步业务线程池的方式，避免长时间业务耗时业务阻塞netty本身的worker工作线程\n        executor.submit(new Callable&lt;Object&gt;() {\n            @Override\n            public Object call() throws Exception {\n                log.info(&quot;收到服务端发来的方法请求了--------------------------------------------&quot;);\n                ServerHandler handler = new ServerHandler();//这个类在下面\n                handler.test(msg.toString());\n                return null;\n            }\n        });\n        //响应客户端\n        this.channelWrite(ctx.channel().id(), msg);\n    }\n\n\n@Component \npublic class ServerHandler extends IoHandlerAdapter {\n\n    @Autowired\n    private ITest2StaticService test2StaticService;// 注入service方法\n\n    private static ServerHandler serverHandler;\n\n    @PostConstruct //通过@PostConstruct实现初始化bean之前进行的操作\n    //在初始化的时候初始化静态对象和它的静态成员变量healthDataService，原理是拿到service层bean对象，静态存储下来，防止被释放。\n    public void init() {\n        serverHandler = this;\n        serverHandler.test2StaticService = this.test2StaticService;\n        // 初使化时将已静态化的testService实例化\n    }\n\n    //测试调用\n    public void test(String msg) {\n        Test2Static test2Static = new Test2Static();\n        test2Static.setBb(Double.valueOf(msg));\n        test2Static.setCreateTime(LocalDateTime.now());\n        System.out.println(&quot;1111111111111111&quot;);\n        boolean b = serverHandler.test2StaticService.save(test2Static);\n        System.out.println(&quot;---! &quot;+b);\n    }\n\n}\n\nIoHandlerAdapter类 所用到的maven坐标：\n  &lt;!-- https://mvnrepository.com/artifact/org.apache.mina/mina-core --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.mina&lt;/groupId&gt;\n            &lt;artifactId&gt;mina-core&lt;/artifactId&gt;\n            &lt;version&gt;2.1.3&lt;/version&gt;\n        &lt;/dependency&gt;\n\n\n</code></pre>\n<p><strong>2.说明：</strong></p>\n<p>将需要调用Spring的Service层的类通过@Component注解为组件加载；<br />\n同样通过@Autowired获取Service层的Bean对象；<br />\n为类声明一个静态变量，方便下一步存储bean对象；<br />\n<strong>划重点：通过注解@PostConstruct ，在初始化的时候初始化静态对象和它的静态成员变量healthDataService，原理是拿到service层bean对象，静态存储下来，防止被释放。</strong></p>\n<p>找了好久，终于找到这个方法，本来以为很简单，却总是怎么也写不进去数据库。调用service一直为空，可困扰我好久。<br />\n特此记录。。。。。。。。。。。。。。。。。</p>\n<p><strong>那些浪费的时间，都是丢在真理路上的金子~~~~!</strong></p>\n', 1, '', 0, 0, 1, '2020-04-25 15:34:08', '2022-05-21 18:20:49');
INSERT INTO `tb_article` VALUES (158, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3178', 'java实现微信第三方登录流程源码详解，所遇到的坑', '<p>﻿&gt; 昨天在写一个手机版的web项目，要在微信客户端使用微信第三方登录，想着也没啥，看看就看看吧，但是可恶的微信官方文档给我画了很大的一个坑，特此记录</p>\n<h6 id=\"二次更新说明一下我这个是用我微信网页授权就是在微信客户端点开链接或菜单能弹出微信授权登录框的功能\">二次更新，说明一下我这个是用我微信网页授权，就是在微信客户端点开链接或菜单能弹出微信授权登录框的功能！</h6>\n<p><img src=\"https://img-blog.csdnimg.cn/20191219191009275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n前期准备工作我就不多说了，无非就是公众平台账号，填写相关资料耐心等待审核就好。</p>\n<p>这里要注意一点的是，网站应用创建好之后的<strong>授权回调域填写顶级域名就好</strong>，之前我一直写的二级域名，测试的时候回调总是过不来，后来回来看文档，微信说的就是，<strong>该域名下的所有页面都 可以回调</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20191219100843364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n创建好网站应用之后我们来看微信提供的接口文档</p>\n<p><a href=\"https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html\">微信开放平台第三方登录接口文档地址</a></p>\n<h4 id=\"第一步请求code\">第一步：请求CODE</h4>\n<p>根据官方文档，请求code这里要按照响应的参数进行拼接，参数就按照官方提供的，需要注意的是appid是你用哪个公众号登录就用哪个公众号的appid，<strong>这里不是开放平台的网站应用appid</strong></p>\n<p>然后另一个坑，redirect_uri，一定要用urlEncode对链接进行处理，这个链接是用户打开这个链接同意登录之后会跳转的地址，我们要跳转到后台对回调的信息就行处理，所以就要回调到我们域名下的controller控制器方法中，并且一定是要外网可访问。比如：<a href=\"http://www.test.com/callback\">www.test.com/callback</a><br />\n把链接进行Encode处理，<a href=\"http://www.jsons.cn/urlencode/\">这里提供一个 encode在线解码工具</a></p>\n<p>拼接好路径之后再微信客户端打开就应该会显示某某公众号的授权登录页面了，如果报错那就是路径没有拼接正确</p>\n<p>请求code的控制器如下所示：<br />\n参数是我自己的，换成你的参数就好</p>\n<pre><code class=\"language-java\">    @RequestMapping(&quot;/getCode&quot;)\n    public void getCode(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        //拼接url\n        StringBuilder url = new StringBuilder();\n        url.append(&quot;https://open.weixin.qq.com/connect/oauth2/authorize?&quot;);\n        //微信开放平台的appid\n        url.append(&quot;appid=&quot; + WeixinConfig.appId);\n        //转码\n        try {\n        	//回调地址 ,回调地址要进行Encode转码\n            String redirect_uri = URLEncoder.encode(WeixinConfig.REDIRECT_URI, &quot;utf-8&quot;);\n            System.out.println(&quot;redirect_uri==&quot; + redirect_uri);\n            url.append(&quot;&amp;redirect_uri=&quot; + redirect_uri);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        url.append(&quot;&amp;response_type=code&quot;);\n        url.append(&quot;&amp;scope=snsapi_userinfo&quot;);\n        url.append(&quot;&amp;state=&quot; + request.getSession().getId());\n        url.append(&quot;#wechat_redirect&quot;);\n        System.out.println(&quot;url===&quot; + url.toString());\n//        return &quot;redirect:&quot; + url.toString();\n        String s = url.toString();\n        response.sendRedirect(s);\n    }\n</code></pre>\n<p>返回说明</p>\n<p>用户允许授权后，将会重定向到redirect_uri的网址上，并且带上code和state参数</p>\n<p><strong>第二步：通过code换取网页授权access_token</strong></p>\n<p><strong>第三步：刷新access_token（如果需要）</strong></p>\n<p><strong>第四步：拉取用户信息(需scope为 snsapi_userinfo)</strong></p>\n<p>这三步我们应该在上面授权回调方法中调用，起初我在想每一个方法都要返回一个json，那么是不是我要三个控制器方法才行？，怎样才能在一个控制器里调用三个方法呢？</p>\n<p>感谢大神提供的发送GET请求的工具类：</p>\n<pre><code class=\"language-java\">public static JSONObject doGetJson(String url) throws Exception, IOException {\n        JSONObject jsonObject = null;\n        //初始化httpClient\n        DefaultHttpClient client = new DefaultHttpClient();\n        //用Get方式进行提交\n        HttpGet httpGet = new HttpGet(url);\n        //发送请求\n        HttpResponse response = client.execute(httpGet);\n\n        //获取数据\n        HttpEntity entity = response.getEntity();\n        //格式转换\n        if (entity != null) {\n            String result = EntityUtils.toString(entity, &quot;UTF-8&quot;);\n            jsonObject = JSONObject.fromObject(result);\n        }\n        //释放链接\n        httpGet.releaseConnection();\n        return jsonObject;\n    }\n</code></pre>\n<p>最后附上我的授权回调方法：</p>\n<pre><code class=\"language-java\">  /**\n     * 微信 授权登录回调\n     **/\n    @RequestMapping(&quot;/callback&quot;)\n    public void callback(String code, String state, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        System.out.println(&quot;====&quot; + code + &quot;===&quot; + state + &quot;====&quot;);\n        logger.debug(&quot;code===&quot; + code);\n        logger.debug(&quot;state===&quot; + state);\n        if (StringUtils.isNotEmpty(code)) {\n            logger.debug(&quot;sssssssss====&quot; + code);\n            StringBuilder url = new StringBuilder();\n            url.append(&quot;https://api.weixin.qq.com/sns/oauth2/access_token?&quot;);\n            //微信公众平台的AK和SK\n            url.append(&quot;appid=&quot; + WeixinConfig.appId);\n            url.append(&quot;&amp;secret=&quot; + WeixinConfig.appSecret);\n            //这是微信回调给你的code\n            url.append(&quot;&amp;code=&quot; + code);\n            url.append(&quot;&amp;grant_type=authorization_code&quot;);\n            System.out.println(&quot;url.toString()===&quot; + url.toString());\n            logger.debug(&quot;url.toString()===&quot; + url.toString());\n\n            JSONObject jsonObject = AuthUtil.doGetJson(url.toString());\n            logger.debug(&quot;jsonObject================&quot;+jsonObject);\n            //解析jsonStr的字符串\n            //1.获取微信用户的openid\n            String openid = jsonObject.getString(&quot;openid&quot;);\n\n            //2.获取获取access_token\n            String access_token = jsonObject.getString(&quot;access_token&quot;);\n\n            logger.debug(&quot;openid===&quot; + openid);\n            logger.debug(&quot;access_token===&quot; + access_token);\n\n            String infoUrl = &quot;https://api.weixin.qq.com/sns/userinfo?access_token=&quot; + access_token + &quot;&amp;openid=&quot; + openid\n                    + &quot;&amp;lang=zh_CN&quot;;\n            logger.debug(&quot;infoUrl===&quot; + infoUrl);\n\n            //3.获取微信用户信息\n            JSONObject userInfo = AuthUtil.doGetJson(infoUrl);\n            logger.debug(&quot;userInfo======================&quot;+userInfo);\n            //至此拿到了微信用户的所有信息,剩下的就是业务逻辑处理部分了\n            //保存openid和access_token到session\n            if (openid==null){\n                logger.debug(&quot;-------------------------微信授权回调，获取用户信息失败！=============================&quot;);\n                response.sendRedirect(&quot;http://m.huerdai.net/html/Program-error.html&quot;);\n                return;\n            }\n            request.getSession().setAttribute(&quot;openid&quot;, openid);\n            request.getSession().setAttribute(&quot;access_token&quot;, access_token);\n\n            logger.debug(&quot;openid===&quot; + openid);\n            logger.debug(&quot;access_token===&quot; + access_token);\n\n            String sessionid = getRequest().getSession().getId();\n            //去数据库查询有没有这个 openid\n            CustomerInfo customerInfoServiceOne = iCustomerInfoService.getOne(new QueryWrapper&lt;CustomerInfo&gt;().eq(&quot;openid&quot;, openid));\n            //如果没有这一个用户，则创建\n            if (customerInfoServiceOne == null) {\n                CustomerInfo customerInfo = new CustomerInfo();\n              	//省略实体set方法\n                boolean save = registerService.register(customerInfo);\n                if (save) {\n                    logger.debug(&quot;首次认证:http://m.huerdai.net&quot;);\n                    redisTemplate.opsForValue().set(sessionid, customerInfoServiceOne.getCustomerId());\n//                    response.sendRedirect(&quot;http://m.huerdai.net/index.html&quot;);\n                    response.sendRedirect(&quot;http://m.huerdai.net/html/bind-tel.html&quot;);\n                    return;\n                } else {\n                    logger.debug(&quot;认证失败！&quot;);\n                    response.sendRedirect(&quot;http://m.huerdai.net/error.html&quot;);\n                    return;\n                }\n            } else {\n                //已经授权过，没有绑定手机号，也是直接跳转到首页\n                redisTemplate.opsForValue().set(sessionid, customerInfoServiceOne.getCustomerId());\n                if (customerInfoServiceOne.getMobilePhone() == null) {\n                    logger.debug(&quot;已经授权过，没有绑定手机号，也是直接跳转到首页&quot;);\n                    //并且将用户信息存到Redis中\n//                    response.sendRedirect(&quot;http://m.huerdai.net/index.html&quot;);\n                    response.sendRedirect(&quot;http://m.huerdai.net/html/bind-tel.html&quot;);\n                    return;\n                } else {\n                    //已经授权过，并且已经绑定手机号\n                    logger.debug(&quot;有openid的跳转http://m.huerdai.net222222&quot;);\n                    response.sendRedirect(&quot;http://m.huerdai.net/index.html&quot;);\n                    return;\n                }\n\n            }\n\n        } else {\n            logger.debug(&quot;code获取失败！====&quot; + code);\n            // return new ModelAndView(&quot;redirect:http://m.huerdai.net/error.html&quot;);\n            response.sendRedirect(&quot;http://m.huerdai.net/error.html&quot;);\n        }\n    }\n</code></pre>\n<p>到这里就微信登录并且获取用户信息就算完成了，</p>\n<p>然后我遇到一个问题就是用户首次登录进来的时候会报openid找不到异常，第二次进来就好了，也没有其他报错信息，期待有大佬路过指正问题原因，感激不尽！</p>\n<p>这之间其他的一些问题异常和容易碰到的坑以后有时间再总结！</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:35:49', '2022-05-21 18:20:38');
INSERT INTO `tb_article` VALUES (159, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=6198', 'Springboot自定义注解实现操作日志管理', '<p>﻿## 操作日志的记录</p>\n<p><strong>为什么要有日志？</strong><br />\n因为我们不光要记录代码的运行，如（logback log4j），而且还应该记录用户的行为，这叫做<strong>业务运行日志</strong></p>\n<blockquote>\n<p>例如：记录 zhangsan 在项目中 调用了哪个方法， 什么时间调用的 。访问的ip地址，  访问了哪些数据，做了什么操作，以此当程序出现问题的时候更利于我们进行错误的排查！</p>\n</blockquote>\n<p><strong>业务运行日志的作用</strong></p>\n<ol>\n<li>记录用户的行为 用于后续的分析</li>\n<li>记录用户的所有的操作</li>\n</ol>\n<p><strong>业务运行日志最常用的使用场景：记录管理员所有的行为操作， 可以用于业务分析，事故恢复</strong></p>\n<h3 id=\"日志实现的思路\">日志实现的思路</h3>\n<h4 id=\"1我们需要记录哪些数据--存入数据库\">1.我们需要记录哪些数据  存入数据库</h4>\n<p>这里列出一个我所用的表结构，如下所示：</p>\n<table>\n<thead>\n<tr><th>字段</th><th>含义</th></tr>\n</thead>\n<tbody>\n<tr><td>log_id</td><td>主键</td></tr>\n<tr><td>log_date</td><td>时间</td></tr>\n<tr><td>log_content</td><td>操作内容  例如：查询全部菜单信息  添加用户数据</td></tr>\n<tr><td>log_name_id</td><td>用户的id</td></tr>\n<tr><td>log_ip</td><td>用户的ip地址</td></tr>\n<tr><td>log_type</td><td>操作类型</td></tr>\n</tbody>\n</table>\n<h4 id=\"2在项目中什么位置记录\">2.在项目中什么位置记录</h4>\n<blockquote>\n<p>日志记录是一个数据库的添加操作 是一段代码</p>\n</blockquote>\n<p><strong>通常，我们在Controller方法进行后置增强</strong><br />\n如下图所示，我们在需要记录操作的controller上使用aop配置一个切入点，以此来记录用户所进行的操作<br />\n<img src=\"https://img-blog.csdnimg.cn/20191211145643492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"3如何实现记录功能\">3.如何实现记录功能</h4>\n<p>实现方式：AOP</p>\n<h4 id=\"4aop日志记录-具体代码实现\">4.Aop日志记录 具体代码实现</h4>\n<p>aop的使用流程，这里使用注解式aop来实现<br />\n具体步骤：</p>\n<ol>\n<li>\n<p>设置切入点</p>\n<ol>\n<li>可以切在方法上</li>\n<li>可以切在注解上\n<pre><code>@Transactional 事务注解 注解加在类上 aop 切在注解上\n</code></pre>\n</li>\n</ol>\n</li>\n<li>\n<p>写增强 日志记录增强</p>\n<ol>\n<li>获取日志的相关信息<br />\n用户的id  ip地址，  时间，  操作的描述，  类型等信息</li>\n<li>将日志对象 添加到数据库</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"增强方法的编写\">增强方法的编写</h4>\n<p><strong>增强方法中获取session</strong><br />\n因为我们是通过aop来获取用户的请求的，所以就需要通过当前的请求拿到session，进而去获取用户的信息。<br />\n<img src=\"https://img-blog.csdnimg.cn/20191211150342156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>但是，操作的描述如何获取呢？</strong></p>\n<pre><code>比如 执行的方法不同  描述是不一样的\nlogin             管理员登录\nselectAllMenu  查询了所有的菜单\n</code></pre>\n<p>解决方案：<strong>使用自定义注解：</strong></p>\n<ol>\n<li>\n<p>在 目标 方法上添加自定义注解 （@Log） 如下</p>\n</li>\n<li>\n<p>在增强中获取注解(@Log)的value 和 type</p>\n</li>\n</ol>\n<p><strong>代码实现</strong></p>\n<p>自定义日志注解<br />\n<img src=\"https://img-blog.csdnimg.cn/20191211151108554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<pre><code class=\"language-java\">import java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * 元注解：加在自定义注解上的注解\n * @Target 定义注解可以添加的位置 METHOD 方法上 type 类上\n * @Retention RUNTIME 运行时  不管编译 还是 运行 这个注解都可以用\n *\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface LogAnnotation {\n    /**\n     * 写法类似于接口的方法 后面可以通过default 关键字给默认值\n     * 用法类似于属性\n     * @return\n     */\n    String value() default &quot;&quot;;\n    String type() default &quot;&quot;;\n}\n</code></pre>\n<p><strong>这里要注意什么是元注解，和 注解属性的定义方式</strong></p>\n<h5 id=\"2-在目标方法上使用注解\">2. 在目标方法上使用注解</h5>\n<p><img src=\"https://img-blog.csdnimg.cn/20191211150853141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n3. 在增强方法中获取注解的value 和 type<br />\n<img src=\"https://img-blog.csdnimg.cn/20191211151652465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<pre><code class=\"language-java\">        /**\n         * 操作的描述\n         *\n         * 执行的方法不同  描述是不一样的\n         * login         管理员登录\n         * selectAllGuru 查询了所有的上师\n         *\n         * 获取注解的值\n         */\n//        1.通过连接点获取方法签名 被切入方法的所有信息\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n//        2.获取被切入方法对象\n        Method method = signature.getMethod();\n//        3.获取方法上的注解\n        LogAnnotation annotation = method.getAnnotation(LogAnnotation.class);\n//        4.获取注解的值\n        String value = annotation.value();\n</code></pre>\n<h2 id=\"完整的aop的代码实现\">完整的aop的代码实现</h2>\n<pre><code class=\"language-java\">package com.tourism.hu.config;\n\n/**\n * @author 马超伟\n * @PROJECT_NAME: fzll\n * @Description:\n * @date 15:29\n * @Copyright: All rights Reserved, Designed By Huerdai  \n * Copyright:    Copyright(C) 2019-2020\n * Company       Huerdai Henan LTD.\n */\n\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.tourism.hu.entity.CustomerInfo;\nimport com.tourism.hu.entity.CustomerLoginLog;\nimport com.tourism.hu.service.ICustomerInfoService;\nimport com.tourism.hu.service.ICustomerLoginLogService;\nimport com.tourism.hu.util.IpAddressUtil;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\n\nimport javax.annotation.Resource;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpSession;\nimport java.lang.reflect.Method;\nimport java.time.LocalDateTime;\n\n/*** @Aspect 标记当前类为功能增强类 切面类 *\n *  @Configuration 标记当前类为配置类 这个注解包含了@Component的功能\n */\n@Aspect\n@Configuration\npublic class LogAop {\n\n    private  Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Resource\n    private ICustomerInfoService iCustomerInfoService;\n\n    @Resource\n    private RedisTemplate redisTemplate;\n\n    @Resource\n    private ICustomerLoginLogService iCustomerLoginLogService;\n\n    /**\n     * JoinPoint 连接点 就是切入点 通过这个对象可以获取切入点的相关所有信息 例如：被切入的方法和注解\n     *\n     * @param joinPoint ** 切入点的设置 切注解 @annotation *\n     */\n    @After(&quot;@annotation(com.tourism.hu.config.Log)&quot;)\n    public void logAfter(JoinPoint joinPoint) {\n    	//new 一个日志的实体，用来保存日志信息\n        CustomerLoginLog loginLog = new CustomerLoginLog();\n        // 1.获取日志相关的信息  用户的id session  ip  时间  操作的描述  类型  ctrl+H\n        /**\n         * 获取用户id\n         * 为什么不能装配session？因为服务器有多个session\n         * 通过 ServletRequestAttributes 可以获取当前请求\n         * 当前请求可以获取当前会话的session\n         */\n         //获取用户的请求\n        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = requestAttributes.getRequest();\n        //得到session\n        HttpSession session = request.getSession();\n        String sessionid = session.getId();\n        //通过sessionid去获取用户信息\n        Object obj = redisTemplate.opsForValue().get(sessionid);\n        String customerId = &quot;&quot;;\n        if(obj!=null) {\n            customerId=obj.toString();\n        }\n        //拿到用户对象\n        CustomerInfo customerInfo = iCustomerInfoService.getOne(new QueryWrapper&lt;CustomerInfo&gt;().eq(&quot;id&quot;, customerId));\n        if (customerInfo!=null){\n        	//将用户的id 存入到日志实体中\n            loginLog.setCustomerId(customerInfo.getCustomerId());\n        }\n         loginLog.setLoginTime(LocalDateTime.now());\n        /**\n         * 获取用户的ip\n         * 通过工具类 ip\n         */\n        loginLog.setLoginIp(IpAddressUtil.getIp());\n\n        /**\n         * 操作的描述\n         * 执行的方法不同  描述是不一样的\n         * login         管理员登录\n         * 获取注解的值\n         */\n//        1.通过连接点获取方法签名 被切入方法的所有信息\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n//        2.获取被切入方法对象\n        Method method = signature.getMethod();\n//        3.获取方法上的注解\n        Log annotation = method.getAnnotation(Log.class);\n//        4.获取注解的值\n        String value = annotation.value();\n        loginLog.setLogContent(value);\n        // 获取注解的类型\n        String type = annotation.type();\n        if (type!=null){\n            loginLog.setLoginType(type);\n        }\n//        2.将日志对象 添加到数据库\n        System.out.println(loginLog);\n        logger.debug(&quot;loginLog====&quot;+loginLog);\n        boolean save = iCustomerLoginLogService.save(loginLog);\n        logger.debug(&quot;保存日志------&quot;+save);\n    }\n}\n\n</code></pre>\n<h4 id=\"所用到的工具类\">所用到的工具类</h4>\n<p>获取ip地址的工具类IpAddressUtil</p>\n<pre><code class=\"language-java\">  public static String getIp() {\n        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();\n        String ip = &quot;null&quot;;\n        try {\n            ip = request.getHeader(&quot;x-forwarded-for&quot;);\n            if (StringUtils.isEmpty(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getHeader(&quot;Proxy-Client-IP&quot;);\n            }\n            if (StringUtils.isEmpty(ip) || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);\n            }\n            if (StringUtils.isEmpty(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getHeader(&quot;HTTP_CLIENT_IP&quot;);\n            }\n            if (StringUtils.isEmpty(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);\n            }\n            if (StringUtils.isEmpty(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getRemoteAddr();\n            }\n        } catch (Exception e) {\n            logger.error(&quot;IPUtils ERROR &quot;, e);\n        }\n        //使用代理，则获取第一个IP地址\n        if(StringUtils.isNotEmpty(ip) &amp;&amp; ip.length() &gt; 15) {\n          if(ip.indexOf(&quot;,&quot;) &gt; 0) {\n              ip = ip.substring(0, ip.indexOf(&quot;,&quot;));\n          }\n      }\n        return ip;\n    }\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:36:30', '2022-05-21 18:20:19');
INSERT INTO `tb_article` VALUES (160, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5483', 'Linux-Centos7,开放相应端口命令', '<p>﻿今天在配置阿里云服务器的时候，发现我明明已经开放了云服务器防火墙的8080端口，然而Tomcat还是无法访问，然后意思到可能是Linux系统的防火墙的8080端口可能还没有打开，于是查询总结了以下命令：</p>\n<h2 id=\"现在linux防火墙有两种服务\">现在Linux防火墙有两种服务</h2>\n<h2 id=\"--1service-firewalld\">- 1.service firewalld</h2>\n<h2 id=\"--2service-iptables\">- 2.service iptables</h2>\n<h4 id=\"一就firewalld来说\">一.就firewalld来说</h4>\n<ul>\n<li>查看开放的端口命令：</li>\n</ul>\n<pre><code>netstat -anp\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20191117124820976.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>查询防火墙状态</li>\n</ul>\n<pre><code>systemctl status firewalld\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20191117124948744.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>如果防火墙关闭了，就开启</li>\n</ul>\n<pre><code> systemctl start firewalld\n</code></pre>\n<ul>\n<li>查询对应端口号</li>\n</ul>\n<pre><code>firewall-cmd --query-port=8080/tcp\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2019111712524287.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>如果显示no，则开启</li>\n</ul>\n<pre><code>firewall-cmd --add-port=8080/tcp --permanent\n</code></pre>\n<p>注意这条命令是 --add,加入端口号，上面那个是query查询端口号<br />\n<img src=\"https://img-blog.csdnimg.cn/20191117125331279.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>然后重启防火墙</li>\n</ul>\n<pre><code>firewall-cmd --reload\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20191117125437520.png\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"二service-iptables\">二.service iptables</h2>\n<ol>\n<li>开放端口命令： /sbin/iptables -I INPUT -p tcp --dport 8085 -j ACCEPT<br />\n2.保存：/etc/rc.d/init.d/iptables save<br />\n3.重启服务：/etc/init.d/iptables restart<br />\n4.查看端口是否开放：/sbin/iptables -L -n</li>\n</ol>\n<h5 id=\"最后附上云服务器打开端口号的配置\">最后附上云服务器打开端口号的配置</h5>\n<p><img src=\"https://img-blog.csdnimg.cn/20191117125617767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 15:37:01', '2022-05-21 18:20:08');
INSERT INTO `tb_article` VALUES (161, 1, 8, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7454', '省市区管理sql数据表设计、以及全国省市区全部最新数据', '<p>﻿使用Mysql数据库，主要字段有：<br />\n区域主键、区域名称、区域上级标识、地名简称、区域等级、区域编码、邮政编码、组合名称、经度、维度、拼音，<br />\n其页面展示效果图如下：<br />\n<img src=\"https://img-blog.csdnimg.cn/2019101611124889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n建表sql为：</p>\n<pre><code class=\"language-sql\">CREATE TABLE `region`  (\n  `id` int(11) NOT NULL COMMENT \'区域主键\',\n  `name` varchar(40) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'区域名称\',\n  `pid` int(11) NULL DEFAULT NULL COMMENT \'区域上级标识\',\n  `sname` varchar(40) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'地名简称\',\n  `level` int(11) NULL DEFAULT NULL COMMENT \'区域等级\',\n  `citycode` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'区域编码\',\n  `yzcode` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'邮政编码\',\n  `mername` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'组合名称\',\n  `Lng` float NULL DEFAULT NULL COMMENT \'经度\',\n  `Lat` float NULL DEFAULT NULL COMMENT \'维度\',\n  `pinyin` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'拼音\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n\n</code></pre>\n<h3 id=\"插入全国最新数据地址库\">插入全国最新数据地址库：</h3>\n<p>由于CSDN篇幅限制，数据一篇放不下，<br />\nsql文件下载地址为：<a href=\"https://download.csdn.net/download/macwx/11869084\">https://download.csdn.net/download/macwx/11869084</a><br />\n下面只是部分数据，全部数据请下载文件，是CSDN篇幅限制不让我全部复制下来啊~~~~</p>\n<pre><code class=\"language-sql\">\nINSERT INTO `fz_region` VALUES (100000, \'中国\', 0, \'中国\', 0, \'\', \'\', \'中国\', 116.368, 39.9151, \'China\');\nINSERT INTO `fz_region` VALUES (110000, \'北京\', 100000, \'北京\', 1, \'\', \'\', \'中国,北京\', 116.405, 39.905, \'Beijing\');\nINSERT INTO `fz_region` VALUES (110100, \'北京市\', 110000, \'北京\', 2, \'010\', \'100000\', \'中国,北京,北京市\', 116.405, 39.905, \'Beijing\');\nINSERT INTO `fz_region` VALUES (110101, \'东城区\', 110100, \'东城\', 3, \'010\', \'100010\', \'中国,北京,北京市,东城区\', 116.41, 39.9316, \'Dongcheng\');\nINSERT INTO `fz_region` VALUES (110102, \'西城区\', 110100, \'西城\', 3, \'010\', \'100032\', \'中国,北京,北京市,西城区\', 116.36, 39.9305, \'Xicheng\');\nINSERT INTO `fz_region` VALUES (110105, \'朝阳区\', 110100, \'朝阳\', 3, \'010\', \'100020\', \'中国,北京,北京市,朝阳区\', 116.485, 39.9484, \'Chaoyang\');\nINSERT INTO `fz_region` VALUES (110106, \'丰台区\', 110100, \'丰台\', 3, \'010\', \'100071\', \'中国,北京,北京市,丰台区\', 116.286, 39.8585, \'Fengtai\');\nINSERT INTO `fz_region` VALUES (110107, \'石景山区\', 110100, \'石景山\', 3, \'010\', \'100043\', \'中国,北京,北京市,石景山区\', 116.223, 39.9056, \'Shijingshan\');\nINSERT INTO `fz_region` VALUES (110108, \'海淀区\', 110100, \'海淀\', 3, \'010\', \'100089\', \'中国,北京,北京市,海淀区\', 116.298, 39.9593, \'Haidian\');\nINSERT INTO `fz_region` VALUES (110109, \'门头沟区\', 110100, \'门头沟\', 3, \'010\', \'102300\', \'中国,北京,北京市,门头沟区\', 116.101, 39.9404, \'Mentougou\');\nINSERT INTO `fz_region` VALUES (110111, \'房山区\', 110100, \'房山\', 3, \'010\', \'102488\', \'中国,北京,北京市,房山区\', 116.143, 39.7479, \'Fangshan\');\nINSERT INTO `fz_region` VALUES (110112, \'通州区\', 110100, \'通州\', 3, \'010\', \'101149\', \'中国,北京,北京市,通州区\', 116.657, 39.9097, \'Tongzhou\');\nINSERT INTO `fz_region` VALUES (110113, \'顺义区\', 110100, \'顺义\', 3, \'010\', \'101300\', \'中国,北京,北京市,顺义区\', 116.654, 40.1302, \'Shunyi\');\nINSERT INTO `fz_region` VALUES (110114, \'昌平区\', 110100, \'昌平\', 3, \'010\', \'102200\', \'中国,北京,北京市,昌平区\', 116.231, 40.2207, \'Changping\');\nINSERT INTO `fz_region` VALUES (110115, \'大兴区\', 110100, \'大兴\', 3, \'010\', \'102600\', \'中国,北京,北京市,大兴区\', 116.341, 39.7267, \'Daxing\');\nINSERT INTO `fz_region` VALUES (110116, \'怀柔区\', 110100, \'怀柔\', 3, \'010\', \'101400\', \'中国,北京,北京市,怀柔区\', 116.632, 40.316, \'Huairou\');\nINSERT INTO `fz_region` VALUES (110117, \'平谷区\', 110100, \'平谷\', 3, \'010\', \'101200\', \'中国,北京,北京市,平谷区\', 117.121, 40.1406, \'Pinggu\');\nINSERT INTO `fz_region` VALUES (110228, \'密云县\', 110100, \'密云\', 3, \'010\', \'101500\', \'中国,北京,北京市,密云县\', 116.843, 40.3762, \'Miyun\');\nINSERT INTO `fz_region` VALUES (110229, \'延庆县\', 110100, \'延庆\', 3, \'010\', \'102100\', \'中国,北京,北京市,延庆县\', 115.975, 40.4567, \'Yanqing\');\nINSERT INTO `fz_region` VALUES (120000, \'天津\', 100000, \'天津\', 1, \'\', \'\', \'中国,天津\', 117.19, 39.1256, \'Tianjin\');\nINSERT INTO `fz_region` VALUES (120100, \'天津市\', 120000, \'天津\', 2, \'022\', \'300000\', \'中国,天津,天津市\', 117.19, 39.1256, \'Tianjin\');\nINSERT INTO `fz_region` VALUES (120101, \'和平区\', 120100, \'和平\', 3, \'022\', \'300041\', \'中国,天津,天津市,和平区\', 117.215, 39.1172, \'Heping\');\nINSERT INTO `fz_region` VALUES (120102, \'河东区\', 120100, \'河东\', 3, \'022\', \'300171\', \'中国,天津,天津市,河东区\', 117.226, 39.1232, \'Hedong\');\nINSERT INTO `fz_region` VALUES (120103, \'河西区\', 120100, \'河西\', 3, \'022\', \'300202\', \'中国,天津,天津市,河西区\', 117.223, 39.1096, \'Hexi\');\nINSERT INTO `fz_region` VALUES (120104, \'南开区\', 120100, \'南开\', 3, \'022\', \'300110\', \'中国,天津,天津市,南开区\', 117.151, 39.1382, \'Nankai\');\nINSERT INTO `fz_region` VALUES (120105, \'河北区\', 120100, \'河北\', 3, \'022\', \'300143\', \'中国,天津,天津市,河北区\', 117.197, 39.1482, \'Hebei\');\nINSERT INTO `fz_region` VALUES (120106, \'红桥区\', 120100, \'红桥\', 3, \'022\', \'300131\', \'中国,天津,天津市,红桥区\', 117.151, 39.1671, \'Hongqiao\');\nINSERT INTO `fz_region` VALUES (120110, \'东丽区\', 120100, \'东丽\', 3, \'022\', \'300300\', \'中国,天津,天津市,东丽区\', 117.314, 39.0863, \'Dongli\');\nINSERT INTO `fz_region` VALUES (120111, \'西青区\', 120100, \'西青\', 3, \'022\', \'300380\', \'中国,天津,天津市,西青区\', 117.009, 39.1412, \'Xiqing\');\nINSERT INTO `fz_region` VALUES (120112, \'津南区\', 120100, \'津南\', 3, \'022\', \'300350\', \'中国,天津,天津市,津南区\', 117.385, 38.9914, \'Jinnan\');\nINSERT INTO `fz_region` VALUES (120113, \'北辰区\', 120100, \'北辰\', 3, \'022\', \'300400\', \'中国,天津,天津市,北辰区\', 117.132, 39.2213, \'Beichen\');\nINSERT INTO `fz_region` VALUES (120114, \'武清区\', 120100, \'武清\', 3, \'022\', \'301700\', \'中国,天津,天津市,武清区\', 117.044, 39.3842, \'Wuqing\');\nINSERT INTO `fz_region` VALUES (120115, \'宝坻区\', 120100, \'宝坻\', 3, \'022\', \'301800\', \'中国,天津,天津市,宝坻区\', 117.31, 39.7176, \'Baodi\');\nINSERT INTO `fz_region` VALUES (120116, \'滨海新区\', 120100, \'滨海新区\', 3, \'022\', \'300451\', \'中国,天津,天津市,滨海新区\', 117.702, 39.0267, \'Binhaixinqu\');\nINSERT INTO `fz_region` VALUES (120221, \'宁河县\', 120100, \'宁河\', 3, \'022\', \'301500\', \'中国,天津,天津市,宁河县\', 117.826, 39.3305, \'Ninghe\');\nINSERT INTO `fz_region` VALUES (120223, \'静海县\', 120100, \'静海\', 3, \'022\', \'301600\', \'中国,天津,天津市,静海县\', 116.974, 38.9458, \'Jinghai\');\nINSERT INTO `fz_region` VALUES (120225, \'蓟县\', 120100, \'蓟县\', 3, \'022\', \'301900\', \'中国,天津,天津市,蓟县\', 117.408, 40.0457, \'Jixian\');\n\n\n\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:37:24', '2022-05-21 18:19:51');
INSERT INTO `tb_article` VALUES (162, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5758', 'Spring Boot 封装文件上传工具类', '<p>﻿springboot 实现文件的上传这里我用的是commins-io依赖：<br />\n坐标如下：</p>\n<pre><code class=\"language-java\"> &lt;dependency&gt;\n      &lt;groupId&gt;commons-io&lt;/groupId&gt;\n      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;\n      &lt;version&gt;2.4&lt;/version&gt;\n    &lt;/dependency&gt;\n</code></pre>\n<p>引入这个依赖之后就可以使用下面这个工具类进行文件上传的操作了：<br />\n如下：</p>\n<pre><code class=\"language-java\">package com.tourism.fzll.util;\n\nimport java.io.File;\nimport java.util.UUID;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\nimport org.springframework.web.multipart.MultipartFile;\n\npublic class FileUploadUtil {\n	\n	public static String upload(MultipartFile file) {\n		try {\n			String extName = file.getOriginalFilename();\n			// 获取文件后缀\n			if (extName.lastIndexOf(&quot;.&quot;) &lt;= 0) {\n				throw new RuntimeException(&quot;不支持该文件类型&quot;);\n			}\n			extName = extName.substring(extName.lastIndexOf(&quot;.&quot;));\n			String webUrl = getWebUrl();\n			String fileName = getFileName();\n			String sysPath = System.getProperty(&quot;catalina.home&quot;) + &quot;/webapps&quot;;\n			// 获取文件名字\n			fileName = getFileName() + extName;\n			// 获取文件地址\n			String filePath = &quot;/content/&quot; + fileName;\n			String Url = sysPath +&quot;/content/&quot;;\n			File file2 = new File(Url);\n			if (!file2.exists()) {\n				file2.mkdirs();\n			}\n			file.transferTo(new File(sysPath + filePath));\n			return webUrl + filePath;\n		} catch (Exception e) {\n			throw new RuntimeException(e);\n		}\n	}\n	/**\n	 * \n	 * @Title: upload \n	 * @Description: (将文件保存到指定的路径下) \n	 * @param file\n\n	 * @return  \n	 * @date 2019年9月30日 上午10:22:31\n	 * @author 马超伟\n	 */\n	public static String upload(MultipartFile file,String specifiedPath) {\n		try {\n			String extName = file.getOriginalFilename();\n			// 获取文件后缀\n			if (extName.lastIndexOf(&quot;.&quot;) &lt;= 0) {\n				throw new RuntimeException(&quot;不支持该文件类型&quot;);\n			}\n			extName = extName.substring(extName.lastIndexOf(&quot;.&quot;));\n			String fileName = getFileName();\n			// 获取文件名字\n			fileName = getFileName() + extName;\n			File file2 = new File(specifiedPath);\n			if (!file2.exists()) {\n				file2.mkdirs();\n			}\n			file.transferTo(new File(specifiedPath + File.separator+ fileName));\n			return fileName;\n		} catch (Exception e) {\n			throw new RuntimeException(e);\n		}\n	}\n\n	/**\n	 * 获取文件名\n	 * @return\n	 */\n	public static String getFileName() {\n		String uuid = UUID.randomUUID().toString();\n		uuid = uuid.replace(&quot;-&quot;, &quot;&quot;);\n		return uuid.toLowerCase();\n	}\n\n	public static String getWebUrl() {\n		HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();\n		return  request.getServletContext().getRealPath(&quot;/img&quot;);\n	}\n	\n	public static String getWebProUrl() {\n		HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();\n		return request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() +request.getContextPath();\n	}\n	\n}\n\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:37:53', '2021-08-30 10:00:30');
INSERT INTO `tb_article` VALUES (163, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=6600', 'layui 树形表格 treeTable使用详细指南，不能折叠解决办法', '<p>﻿最近在写一个商品分类管理的功能，本来想用layui的树形组件来写，但发现layui原生的tree只能展示title，而分类的其他字段无法展示，这就有点不适用了，无意中看到一位大神自定义写的一个树形表格组件，正好满足我的要求，特此将使用方法以及其中遇到的一些坑记录下来。。。</p>\n<h3 id=\"首先看下treetable的\">首先看下treeTable的</h3>\n<p><a href=\"https://whvse.gitee.io/treetable-lay/\">演示地址</a></p>\n<p><a href=\"https://gitee.com/whvse/treetable-lay\">项目地址</a></p>\n<p>好了，如果看完演示到这里你觉得正好符合你的功能要求，就可以继续往下看了，</p>\n<p>虽然项目地址中已经把使用介绍的很详细了，但是我在这里要补充一下我遇到的坑：</p>\n<h2 id=\"使用方法\">使用方法</h2>\n<h4 id=\"1引入模块\">1，引入模块</h4>\n<p>打开项目地址，将整个项目下载下来，项目中其他文件可以参考，我们主要用的就是treetable-lay这个文件夹的内容。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190925170811464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n下载好项目后把treetable-lay放在我们自己项目的任意位置，但是尽量和layui文件夹放一块，好找！<br />\n下面是我放的位置，如图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190925171552808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"2初始化模块配置\">2，初始化模块配置</h4>\n<p>要扩展layui的模块使用我们引入的js模块，注意base路径是treetable-lay文件夹所在的父路径，这里出错会报404，extend内容最好不要改。<br />\n下面我先每个重点注意事项单独列出来，最后放完整代码。</p>\n<pre><code class=\"language-java\">   layui.config({\n        base: \'${pageContext.request.contextPath}/layuiadmin/modules/\' //   资源所在路径\n    }).extend({\n        treetable: \'treetable-lay/treetable\'\n    }).use([\'treetable\', \'table\', \'layer\'], function () {\n        var treetable = layui.treetable;\n        var layer = layui.layer;\n        var table = layui.table;\n        var $ = layui.jquery;\n});\n</code></pre>\n<p>如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/201909251720347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"3动态渲染表格\">3，动态渲染表格</h4>\n<p>数据是从后台查询出来，数据格式不需要做处理，只需要查询所有就行了，官方文档给了json格式，我自己也做了一个简单的封装，一会儿再说json格式。</p>\n<p>这里要注意的是treeIdName和treePidName这两个属性，要对应自己查询出来的id和pid。支持自定义这点非常好</p>\n<pre><code class=\"language-java\"> &lt;%--树形表格--%&gt;\n &lt;table class=&quot;layui-table&quot; id=&quot;Lay_category_treeTable&quot; lay-filter=&quot;Lay_category_treeTable&quot;&gt;&lt;/table&gt;\n    \n    //js如下：\n    layui.use([\'treetable\', \'table\', \'layer\'], function () {\n        var treetable = layui.treetable;\n        var layer = layui.layer;\n        var table = layui.table;\n        var $ = layui.jquery;\n\n        var re;\n        // 渲染表格\n        var renderTable = function () {\n            layer.load(3);    //这里好像是要加载几层 ，我的是3层，就写了个3，\n            re = treetable.render({\n                elem: \'#Lay_category_treeTable\',\n                url: \'${basepath}/goodscategory/selectTreeTable\',\n                treeColIndex: 1,          // 树形图标显示在第几列\n                treeSpid: 0,             // 最上级的父级id\n                treeIdName: \'classId\',       // 	id字段的名称\n                treePidName: \'parentId\',    // 	pid字段的名称\n                treeDefaultClose: true,     //是否默认折叠\n                page: false,\n                //treeLinkage: true,      //父级展开时是否自动展开所有子级\n                cols: [[\n                    {type: \'numbers\'},\n                    {title: &quot;分类名称&quot;, field: &quot;className&quot;,align:&quot;left&quot;},\n                    {title: &quot;分类编码&quot;, field: &quot;classCode&quot;},\n                    //  {title: &quot;分类层级&quot;, field: &quot;classIdLevel&quot;},\n                    {title: &quot;分类状态&quot;, field: &quot;classIdStatus&quot;,templet: \'#classIdStatusTpl\'},\n                    {title: &quot;创建人&quot;, field: &quot;createUser&quot;},\n                    {\n                        title: &quot;创建时间&quot;,\n                        field: &quot;createTime&quot;,\n                        templet: \'&lt;div&gt;{{# if(d.createTime!=null){ }} {{ layui.util.toDateString(d.createTime,\\\'yyyy-MM-dd HH:mm:ss\\\')  }} {{# } }}&lt;/div&gt;\'\n                    },\n                    {title: &quot;更新人员&quot;, field: &quot;updateUser&quot;},\n                    {\n                        title: &quot;更新时间&quot;,\n                        field: &quot;updateTime&quot;,\n                        templet: \'&lt;div&gt;{{# if(d.updateTime!=null){ }} {{ layui.util.toDateString(d.updateTime,\\\'yyyy-MM-dd HH:mm:ss\\\')  }} {{# } }}&lt;/div&gt;\'\n                    },\n                    {title: &quot;操作&quot;, templet: &quot;#updateAndDelete&quot;}\n                ]],\n                done: function () {\n                    layer.closeAll(\'loading\');\n                }\n            })\n        };\n</code></pre>\n<p>可以使用url传递数据，也可以使用data传递数据，如果使用url传递数据，参数是where字段，<br />\n跟layui数据表格的使用方式一致。</p>\n<h4 id=\"4参数说明这里直接复制官方的\">4，参数说明，（这里直接复制官方的）</h4>\n<p>layui数据表格的所有参数都可以用，除此之外treetable新增的参数有：</p>\n<table>\n<thead>\n<tr><th>参数</th><th>类型</th><th>是否必填</th><th>描述</th><th> </th></tr>\n</thead>\n<tbody>\n<tr><td>treeColIndex</td><td>int</td><td>是</td><td>树形图标显示在第几列</td><td> </td></tr>\n<tr><td>treeSpid</td><td>object</td><td>是</td><td>最上级的父级id</td><td> </td></tr>\n<tr><td>treeIdName</td><td>string</td><td>否</td><td>id字段的名称</td><td> </td></tr>\n<tr><td>treePidName</td><td>string</td><td>否</td><td>pid字段的名称</td><td> </td></tr>\n<tr><td>treeDefaultClose</td><td>boolean</td><td>否</td><td>是否默认折叠</td><td> </td></tr>\n<tr><td>treeLinkage</td><td>boolean</td><td>否</td><td>父级展开时是否自动展开所有子级</td><td> </td></tr>\n</tbody>\n</table>\n<p> <strong>treeColIndex</strong></p>\n<p> 树形图标（箭头和文件夹、文件的图标）显示在第几列， 索引值是cols数组的下标。</p>\n<p> <strong>treeSpid</strong></p>\n<p> 最上级的父级id，比如你可以规定pid为0或-1的是最顶级的目录。</p>\n<p> <strong>treeIdName</strong></p>\n<p> treetable是以id和pid字段来渲染树形结构的，如果你的数据没有id和pid字段，你可以指定id和pid字段的名称。</p>\n<p> <strong>treePidName</strong></p>\n<p> pid在你的数据字段中的名称。</p>\n<p> <strong>treeDefaultClose</strong></p>\n<p> 默认是全部展开的，如果需要默认全部关闭，加上treeDefaultClose:true即可。</p>\n<p> <strong>treeLinkage</strong></p>\n<p> 父级展开时是否自动展开所有子级</p>\n<h4 id=\"注意事项\">注意事项</h4>\n<ul>\n<li>不能使用分页功能，即使写了page:true，也会忽略该参数。</li>\n<li>不能使用排序功能，不要开启排序功能。</li>\n<li>table.reload()不能实现刷新，请参考demo的刷新。</li>\n<li>除了文档上写的treetable.xxx的方法之外，其他数据表格的方法都使用table.xxx。</li>\n<li>建议删除和修改请求完后台之后请刷新（重新渲染）表格，最好不要使用obj.delete方式删除。</li>\n</ul>\n<h4 id=\"5其他方法\">5，其他方法</h4>\n<p>这里除了layui的方法新增的方法有展开所有，折叠所有，刷新表格 ，三种方法，使用方法如下：</p>\n<pre><code class=\"language-java\"> &lt;div class=&quot;layui-btn-group&quot;&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-expand&quot;&gt;全部展开&lt;/button&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-fold&quot;&gt;全部折叠&lt;/button&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-refresh&quot;&gt;刷新表格&lt;/button&gt;\n &lt;/div&gt;\n\n	 renderTable();   //这个就是上面的渲染表格 var renderTable = function () {...}\n        //展开所有\n        $(\'#btn-expand\').click(function () {\n            //alert(0)\n            treetable.expandAll(\'#Lay_category_treeTable\');\n        });\n        //折叠所有\n        $(\'#btn-fold\').click(function () {\n           // alert(1)\n            treetable.foldAll(\'#Lay_category_treeTable\');\n        });\n        //刷新表格\n        $(\'#btn-refresh\').click(function () {\n            renderTable();\n        });\n\n</code></pre>\n<h4 id=\"6content图标\">6，content图标。</h4>\n<p>图标这个从gitee码云的源码上看吧，不再详细说，也没啥可说的。</p>\n<h2 id=\"7我遇到的坑\">7，我遇到的坑</h2>\n<p>我照着他给的教程一步步弄下来页面也显示出来了，但就是不能折叠，不管是我用折叠方法还是点那个三角图片还是设置为默认折叠，就是不管用，<br />\n不能折叠，可把我给气坏了。<br />\n苦思冥想找不到问题，最后我去研究treetable.js这个文件</p>\n<p>发现其中有一段代码他给注释掉了，如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190925174505180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n然后我把注释的这一段代码打开，哎，好了，展开折叠正常了，不知道什么原因，不知道有没有其他人遇到过。。。</p>\n<h5 id=\"最后分享一下我写的不成熟的这个页面的功能汇总做个记录\">最后，分享一下我写的不成熟的这个页面的功能汇总，做个记录：</h5>\n<p>主要功能有，树形表格展示，添加，修改，删除，批量删除，搜索，layui时间日期自定义格式列，表格全部展开、折叠、刷新表格等功能，有兴趣的看下吧~~<br />\n效果图如下所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190925175823787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>全部代码在这~：</strong></p>\n<pre><code class=\"language-java\">&lt;%--\n  Created by IntelliJ IDEA.\n  User: Administrator\n  Date: 2019/9/23\n  Time: 13:25\n  To change this template use File | Settings | File Templates.\n--%&gt;\n\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;\n&lt;%@ include file=&quot;../meta.jsp&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;商品分类管理&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;${basepath}layuiadmin/layui/css/layui.css&quot; media=&quot;all&quot;&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;${basepath}layuiadmin/modules/treetable-lay/treetable.css&quot;&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;${basepath}js/jquery-1.12.0.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;${basepath}js/cookies.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;${basepath}layuiadmin/layui/layui.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;${basepath}layuiadmin/modules/treetable-lay/treetable.js&quot;&gt;&lt;/script&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n        .layui-table-cell {\n            height: auto;\n            line-height: 30px;\n        }\n\n    &lt;/style&gt;\n\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=&quot;layui-card-body&quot;&gt;\n    &lt;div style=&quot;padding-bottom: 10px;&quot; id=&quot;LAY_lay_add&quot;&gt;\n        &lt;button type=&quot;button&quot; class=&quot;layui-btn layui-btn-danger&quot; onclick=&quot;doMultiDelete()&quot;&gt;\n            &lt;i class=&quot;layui-icon layui-icon-delete&quot;&gt;&lt;/i&gt; 批量删除\n        &lt;/button&gt;\n        &lt;button class=&quot;layui-btn layuiadmin-btn-role &quot; data-type=&quot;add&quot; onclick=&quot;toOpenAddLayer()&quot;&gt;\n            &lt;i class=&quot;layui-icon layui-icon-add-circle-fine&quot;&gt;&lt;/i&gt; 添加\n        &lt;/button&gt;\n        &amp;nbsp;\n        &lt;div class=&quot;layui-input-inline&quot; style=&quot;width: 200px;&quot;&gt;\n            &lt;input type=&quot;text&quot; name=&quot;search&quot; id=&quot;Lay_toSearch_input&quot; placeholder=&quot;请输入分类名称&quot; autocomplete=&quot;off&quot;\n                   class=&quot;layui-input&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;layui-input-inline&quot; style=&quot;width: 100px;&quot;&gt;\n            &lt;button type=&quot;button&quot; class=&quot;layui-btn layui-btn-normal&quot; id=&quot;btn-search&quot;&lt;%-- onclick=&quot;doSearch()&quot;--%&gt;&gt;\n                &lt;i class=&quot;layui-icon layui-icon-search&quot;&gt;&lt;/i&gt; 搜索\n            &lt;/button&gt;\n        &lt;/div&gt;\n        &amp;nbsp;\n        &lt;div class=&quot;layui-btn-group&quot;&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-expand&quot;&gt;全部展开&lt;/button&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-fold&quot;&gt;全部折叠&lt;/button&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-refresh&quot;&gt;刷新表格&lt;/button&gt;\n        &lt;/div&gt;\n        &lt;%--\n                &lt;button type=&quot;button&quot; class=&quot;layui-btn layui-btn-normal  change-icon&quot;&gt;随机更换小图标&lt;/button&gt;\n        --%&gt;\n    &lt;/div&gt;\n\n    &lt;%--树形表格--%&gt;\n    &lt;table class=&quot;layui-table&quot; id=&quot;Lay_category_treeTable&quot; lay-filter=&quot;Lay_category_treeTable&quot;&gt;&lt;/table&gt;\n\n    &lt;%--树形菜单--%&gt;\n    &lt;div id=&quot;Lay_category_tree&quot; lay-filter=&quot;Lay_category_tree&quot;&gt;&lt;/div&gt;\n\n    &lt;%--Table表格--%&gt;\n    &lt;%-- &lt;table id=&quot;Lay_back_table&quot; lay-filter=&quot;Lay_back_table&quot;&gt;&lt;/table&gt;--%&gt;\n\n\n&lt;/div&gt;\n\n&lt;script type=&quot;text/html&quot; id=&quot;updateAndDelete&quot;&gt;\n    &lt;button type=&quot;button&quot; class=&quot;layui-btn  layui-btn-normal&quot; onclick=&quot;toOpenUpdateLayer(\'{{d.classId}}\')&quot;&gt;\n        &lt;i class=&quot;layui-icon layui-icon-edit&quot;&gt;&lt;/i&gt;修改\n    &lt;/button&gt;\n    &lt;button type=&quot;button&quot; class=&quot;layui-btn layui-btn-danger&quot; onclick=&quot;doDelete(\'{{d.classId}}\')&quot;&gt;\n        &lt;i class=&quot;layui-icon layui-icon-delete&quot;&gt;&lt;/i&gt; 删除\n    &lt;/button&gt;\n&lt;/script&gt;\n\n&lt;%--弹出层--%&gt;\n\n&lt;form id=&quot;addForm&quot; class=&quot;layui-form&quot;&gt;\n    &lt;div class=&quot;layui-form&quot; lay-filter=&quot;layuiconfig-form-role&quot; id=&quot;layuiconfig-form-role&quot;\n         style=&quot;padding: 20px 30px 0 0;display: none&quot;&gt;\n        &lt;div class=&quot;layui-form-item&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;分类名称&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;input name=&quot;className&quot; id=&quot;className&quot; class=&quot;layui-input&quot;&gt;\n                &lt;input name=&quot;classId&quot; id=&quot;classId&quot; lay-type=&quot;hide&quot; type=&quot;hidden&quot; class=&quot;layui-input&quot;&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;layui-form-item&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;分类编码&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;input name=&quot;classCode&quot; id=&quot;classCode&quot; class=&quot;layui-input&quot;&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;layui-form-item&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;分类状态&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;input type=&quot;checkbox&quot; lay-skin=&quot;switch&quot; lay-text=&quot;启用|禁用&quot; value=&quot;1&quot; checked name=&quot;classIdStatus&quot;\n                       id=&quot;classIdStatus&quot; class=&quot;layui-input&quot;&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=&quot;layui-form-item&quot; id=&quot;Lay_select_Level&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;请选择分类级别&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;select name=&quot;classIdLevel&quot; lay-verify=&quot;required&quot; lay-filter=&quot;classIdLevel&quot;&gt;\n                    &lt;option value=&quot;&quot;&gt;&lt;/option&gt;\n                    &lt;option value=&quot;1&quot; selected&gt;一级分类&lt;/option&gt;\n                    &lt;option value=&quot;2&quot;&gt;二级分类&lt;/option&gt;\n                    &lt;option value=&quot;3&quot;&gt;三级分类&lt;/option&gt;\n                &lt;/select&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n\n        &lt;div class=&quot;layui-form-item&quot; style=&quot;display: none&quot; id=&quot;Lay_One_Level&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;请选择所属的一级分类&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;select name=&quot;parentId&quot; id=&quot;parentId&quot;  lay-filter=&quot;parent_classIdLevel_One&quot;&gt;\n                    &lt;option value=&quot;&quot;&gt;&lt;/option&gt;\n                &lt;/select&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=&quot;layui-form-item&quot; style=&quot;display: none&quot; id=&quot;Lay_Two_Level&quot; &gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;请选择所属的二级分类&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;select name=&quot;parentId2&quot; id=&quot;Two_parentId&quot;  lay-filter=&quot;parent_classIdLevel_Two&quot;&gt;\n                    &lt;option value=&quot;&quot;&gt;&lt;/option&gt;\n                &lt;/select&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n\n        &lt;div class=&quot;layui-form-item&quot; style=&quot;text-align: right&quot;&gt;\n            &lt;button class=&quot;layui-btn &quot; lay-submit lay-filter=&quot;LAY-sysconfig-submit&quot; id=&quot;LAY-sysconfig-submit&quot;&gt;确认添加\n            &lt;/button&gt;\n            &lt;button lay-submit lay-filter=&quot;updateSubmitBtn&quot; class=&quot;layui-btn&quot; id=&quot;updateSubmitBtn&quot;&gt;确认修改&lt;/button&gt;\n\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/form&gt;\n\n&lt;script type=&quot;text/html&quot; id=&quot;classIdStatusTpl&quot;&gt;\n    {{#  if(d.classIdStatus==1){ }}\n    启用\n    {{#  } else { }}\n    &lt;i style=&quot;color: red;&quot;&gt;禁用&lt;/i&gt;\n    {{#  } }}\n&lt;/script&gt;\n\n&lt;script type=&quot;text/javascript&quot;&gt;\n\n    layui.config({\n        base: \'${pageContext.request.contextPath}/layuiadmin/modules/\' //   资源所在路径\n    }).extend({\n        treetable: \'treetable-lay/treetable\'\n    }).use([\'treetable\', \'table\', \'layer\'], function () {\n        var treetable = layui.treetable;\n        var layer = layui.layer;\n        var table = layui.table;\n        var $ = layui.jquery;\n\n        var re;\n\n        // 渲染表格\n        var renderTable = function () {\n            layer.load(3);\n            re = treetable.render({\n                elem: \'#Lay_category_treeTable\',\n                url: \'${basepath}/goodscategory/selectTreeTable\',\n                treeColIndex: 1,          // 树形图标显示在第几列\n                treeSpid: 0,             // 最上级的父级id\n                treeIdName: \'classId\',       // 	id字段的名称\n                treePidName: \'parentId\',    // 	pid字段的名称\n                treeDefaultClose: true,     //是否默认折叠\n                page: false,\n                //treeLinkage: true,      //父级展开时是否自动展开所有子级\n                cols: [[\n                    {type: \'numbers\'},\n                    {title: &quot;分类名称&quot;, field: &quot;className&quot;,align:&quot;left&quot;},\n                    {title: &quot;分类编码&quot;, field: &quot;classCode&quot;},\n                    //  {title: &quot;分类层级&quot;, field: &quot;classIdLevel&quot;},\n                    {title: &quot;分类状态&quot;, field: &quot;classIdStatus&quot;,templet: \'#classIdStatusTpl\'},\n                    {title: &quot;创建人&quot;, field: &quot;createUser&quot;},\n                    {\n                        title: &quot;创建时间&quot;,\n                        field: &quot;createTime&quot;,\n                        templet: \'&lt;div&gt;{{# if(d.createTime!=null){ }} {{ layui.util.toDateString(d.createTime,\\\'yyyy-MM-dd HH:mm:ss\\\')  }} {{# } }}&lt;/div&gt;\'\n                    },\n                    {title: &quot;更新人员&quot;, field: &quot;updateUser&quot;},\n                    {\n                        title: &quot;更新时间&quot;,\n                        field: &quot;updateTime&quot;,\n                        templet: \'&lt;div&gt;{{# if(d.updateTime!=null){ }} {{ layui.util.toDateString(d.updateTime,\\\'yyyy-MM-dd HH:mm:ss\\\')  }} {{# } }}&lt;/div&gt;\'\n                    },\n                    {title: &quot;操作&quot;, templet: &quot;#updateAndDelete&quot;}\n                ]],\n                done: function () {\n                    layer.closeAll(\'loading\');\n                }\n\n            })\n        };\n\n        renderTable();\n        //展开所有\n        $(\'#btn-expand\').click(function () {\n            //alert(0)\n            treetable.expandAll(\'#Lay_category_treeTable\');\n        });\n        //折叠所有\n        $(\'#btn-fold\').click(function () {\n           // alert(1)\n            treetable.foldAll(\'#Lay_category_treeTable\');\n        });\n        //刷新表格\n        $(\'#btn-refresh\').click(function () {\n            renderTable();\n        });\n\n        $(\'#btn-search\').click(function () {\n            var keyword = $(\'#Lay_toSearch_input\').val();\n            //alert(keyword);\n           // var searchName = $(\'#Lay_toSearch_input\').val();\n            var searchCount = 0;\n            $(\'#Lay_category_treeTable\').next(\'.treeTable\').find(\'.layui-table-body tbody tr td\').each(function () {\n                $(this).css(\'background-color\', \'transparent\');\n                var text = $(this).text();\n                if (keyword != \'\' &amp;&amp; text.indexOf(keyword) &gt;= 0) {\n                    $(this).css(\'background-color\', \'rgba(250,230,160,0.5)\');\n                    if (searchCount == 0) {\n                        treetable.expandAll(\'#Lay_category_treeTable\');\n                        $(\'html,body\').stop(true);\n                        $(\'html,body\').animate({scrollTop: $(this).offset().top - 150}, 500);\n                    }\n                    searchCount++;\n                }\n            });\n            if (keyword == \'\') {\n                layer.msg(&quot;请输入搜索内容&quot;, {icon: 5});\n            } else if (searchCount == 0) {\n                layer.msg(&quot;没有匹配结果&quot;, {icon: 5});\n            }\n        });\n    });\n\n\n    //这是一棵树，\n    layui.use([\'table\', \'tree\', &quot;layer&quot;, \'jquery\', \'form\'], function () {\n        var table = layui.table;\n        var layer = layui.layer;\n        var form = layui.form;\n        var tree = layui.tree;\n        var $ = layui.jquery;\n\n        $.ajax({\n            url: &quot;${pageContext.request.contextPath}/goodscategory/selectTree&quot;,\n            success: function (data) {\n                //console.log(data);\n                //渲染\n                var inst1 = tree.render({\n                    elem: \'#Lay_category_tree\',  //绑定元素\n                    data: data.data,\n                    showCheckbox: true\n                    // accordion:true\n                });\n            }\n        });\n    });\n\n\n    //搜索操作\n    function doSearch() {\n        //1.获取到输入框中输入的内容\n        var searchName = $(\'#Lay_toSearch_input\').val();\n        //发送请求，并且接收数据\n        layui.use(\'table\', function () {\n            var table = layui.table;\n            table.reload(\'Lay_back_table\', {\n                where: {&quot;platform&quot;: searchName}\n            });\n        });\n    }\n\n    //执行编辑修改\n    function toOpenUpdateLayer(classId) {\n        //alert(classId);\n        //1.获取当前行数据===》发送ajax请求，获取当前行数据\n        $.ajax({\n            url: &quot;${pageContext.request.contextPath}/goodscategory/selectOne&quot;,\n            data: &quot;aid=&quot; + classId,\n            success: function (data) {\n                $(&quot;#className&quot;).val(data.className);\n                $(&quot;#classId&quot;).val(data.classId);\n                $(&quot;#classCode&quot;).val(data.classCode);\n                // $(&quot;#classIdStatus&quot;).val(data.classIdStatus);\n                $(&quot;#classIdStatus&quot;).selected(data.classIdStatus);\n\n            }\n        });\n\n        //2.把数据填充到修改弹出层中==&gt;弹出层显示\n        layui.use([\'layer\', \'form\', \'table\'], function () {\n            var form = layui.form;\n            var layer = layui.layer;\n            var table = layui.table;\n            var $ = layui.jquery;\n\n            $(&quot;#Lay_select_Level&quot;).hide();\n            layer.open({\n                title: &quot;修改配置&quot;,\n                content: $(&quot;#layuiconfig-form-role&quot;),\n                type: 1,\n                maxmin: true,\n                area: [\'500px\', \'480px\'],\n                end:function(){\n                    window.location.reload();\n                }\n            });\n\n            $(&quot;#LAY-sysconfig-submit&quot;).hide();\n            $(&quot;#updateSubmitBtn&quot;).show();\n\n            //3.提交表单\n            form.on(&quot;submit(updateSubmitBtn)&quot;, function (data) {\n                // console.log(data);\n                $.ajax({\n                    url: &quot;${pageContext.request.contextPath}/goodscategory/updateGoods&quot;,\n                    data: data.field,\n                    type: &quot;post&quot;,\n                    //4.接收后台修改响应回来的数据；关闭弹出层、提示修改信息、刷新table\n                    success: function (data) {\n                        //1.关闭掉添加弹出层\n                        layer.closeAll(\'page\');\n                        //2.提示修改成功\n                        layer.alert(&quot;修改&quot; + data.msg+&quot;，请点击右上角刷新表格后生效！&quot;, {time: 3000});\n                        //刷新table\n                      //  table.reload(&quot;Lay_category_treeTable&quot;);\n                    }\n                });\n                return false;//阻止跳转；\n            })\n        });\n\n    }\n\n    //执行添加\n    function toOpenAddLayer() {\n        layui.use([&quot;form&quot;, &quot;layer&quot;, &quot;table&quot;], function () {\n            var form = layui.form;\n            var layer = layui.layer;\n            var table = layui.table;\n\n            layer.open({\n                title: &quot;添加配置&quot;,\n                content: $(&quot;#layuiconfig-form-role&quot;),\n                type: 1,\n                maxmin: true,\n                area: [\'500px\', \'480px\'],\n                end: function () {\n                    window.location.reload();\n                }\n            });\n\n            $(&quot;#updateSubmitBtn&quot;).hide();\n            $(&quot;#LAY-sysconfig-submit&quot;).show();\n\n            form.on(\'select(classIdLevel)\', function (data) {\n                //console.log(data.elem); //得到select原始DOM对象\n                console.log(&quot;data.value = &quot;+data.value); //得到被选中的值\n                //console.log(data.othis); //得到美化后的DOM对象\n                if(data.value == 1){\n                    // alert(1);\n                    $(&quot;#Lay_One_Level&quot;).hide();\n                    $(&quot;#Lay_Two_Level&quot;).hide();\n                }\n                if (data.value == 2) {\n                    // alert(2);\n                    $(&quot;#Lay_One_Level&quot;).show();\n                    $(&quot;#Lay_Two_Level&quot;).hide();\n                    $.ajax({\n                        url: \'${basepath}goodscategory/selectOneLevel\',\n                        dataType: \'json\',\n                        type: \'post\',\n                        success: function (data) {\n                            $.each(data, function (index, item) {\n                                //console.log(&quot;000 &quot; + index);\n                                //console.log(&quot;111 &quot; + item);\n                                $(\'#parentId\').append(new Option(item.className, item.classId));//往下拉菜单里添加元素\n                            });\n                            form.render();//菜单渲染 把内容加载进去\n                        }\n                    })\n                }\n                if (data.value == 3) {\n                    // alert(3);\n                    $(&quot;#Lay_One_Level&quot;).hide();\n                   // form.on(\'select(parent_classIdLevel_One)\', function (data2){\n                        $(&quot;#Lay_Two_Level&quot;).show();\n                        $.ajax({\n                            url: \'${basepath}goodscategory/selectTwoLevel\',\n                            dataType: \'json\',\n                            type: \'post\',\n                            success: function (data) {\n                                $.each(data, function (index, item) {\n                                    //console.log(&quot;000 &quot; + index);\n                                    //console.log(&quot;111 &quot; + item);\n                                    $(\'#Two_parentId\').append(new Option(item.className, item.classId));//往下拉菜单里添加元素\n                                });\n                                form.render();//菜单渲染 把内容加载进去\n                            }\n                        })\n                   // })\n                }\n            });\n\n            //当点击提交按钮的时候，会进入到这个函数\n            form.on(&quot;submit(LAY-sysconfig-submit)&quot;, function (data) {\n                 console.log(data.field);\n                $.ajax({\n                    url: &quot;${pageContext.request.contextPath}/goodscategory/addGoodsCategory&quot;,\n                    data: data.field,\n                    type: &quot;post&quot;,\n                    success: function (data) {\n                        //1.关闭掉添加弹出层\n                        layer.closeAll(\'page\');\n                        //2.提示添加成功\n                        layer.alert(&quot;添加&quot; + data.msg, {time: 3000});\n                        //3.刷新table\n                        table.reload(&quot;Lay_back_table&quot;);\n\n                    }\n                });\n                return false;//阻止跳转；\n            })\n        })\n    }\n\n    function doDelete(classId) {\n       // alert(classId);\n        //确认；如果点击确认删除；否则不删除\n        layui.use([\'layer\', \'table\'], function () {\n            var table = layui.table;\n            var layer = layui.layer;\n\n            layer.confirm(\'确定要删除吗？\', {icon: 3, title: \'确认删除\'}, function (index) {\n                $.ajax({\n                    url: &quot;${pageContext.request.contextPath}/goodscategory/deletecl&quot;,\n                    data: &quot;aid=&quot; + classId,\n                    success: function (data) {\n                        layer.alert(&quot;删除&quot; + data.msg, {time: 2000});\n                        // table.reload(&quot;Lay_back_table&quot;);\n                        layer.close(index);\n                    }\n                })\n            });\n        });\n    }\n\n    function doMultiDelete() {\n        //获取到选中的内容的id===》table模块中找方法\n        layui.use([\'layer\', \'table\'], function () {\n            var table = layui.table;\n            var layer = layui.layer;\n            //获取到选中的数据\n            var checkStatus = table.checkStatus(\'Lay_back_table\'); //idTest 即为基础参数 id 对应的值\n            // console.log(checkStatus.data);//获取选中行的数据\n            var data = checkStatus.data;\n\n            if (data.length == 0) {\n                layer.alert(&quot;请选中要删除的数据&quot;);\n            } else {\n                layer.confirm(&quot;确定要删除选中的所有数据&quot;, function (index) {\n                    //把所有选中的数据的id封装到一个数组中\n                    var ids = new Array(data.length);\n                    for (var i = 0; i &lt; ids.length; i++) {\n                        ids[i] = data[i].id;\n                    }\n                    console.log(&quot;ids===&quot; + ids);\n                    //执行删除操作\n                    $.ajax({\n                        url: &quot;${pageContext.request.contextPath}/prefixThird/deleteMany&quot;,\n                        data: &quot;ids=&quot; + ids,\n                        success: function (data) {\n                            //删除确认框关闭掉\n                            layer.close(index);\n                            //删除提示\n                            layer.alert(&quot;删除&quot; + data.msg+&quot;，请点击右上角刷新表格后生效！&quot;, {time: 2000});\n                            //刷新table\n                            // table.reload(&quot;Lay_back_table&quot;);\n                            // renderTable();\n                        }\n                    })\n                });\n            }\n        });\n    }\n\n\n&lt;/script&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:38:19', '2022-05-21 18:19:34');
INSERT INTO `tb_article` VALUES (164, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7338', 'CSDN-markdown编辑器 使用大全（备份记录快捷键使用方法）', '<p>﻿@<a href=\"这里写自定义目录标题\">TOC</a></p>\n<h1 id=\"欢迎使用markdown编辑器\">欢迎使用Markdown编辑器</h1>\n<p>你好！ 这是你第一次使用 <strong>Markdown编辑器</strong> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</p>\n<h2 id=\"新的改变\">新的改变</h2>\n<p>我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：</p>\n<ol>\n<li><strong>全新的界面设计</strong> ，将会带来全新的写作体验；</li>\n<li>在创作中心设置你喜爱的代码高亮样式，Markdown <strong>将代码片显示选择的高亮样式</strong> 进行展示；</li>\n<li>增加了 <strong>图片拖拽</strong> 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；</li>\n<li>全新的 <strong>KaTeX数学公式</strong> 语法；</li>\n<li>增加了支持<strong>甘特图的mermaid语法[^1]</strong> 功能；</li>\n<li>增加了 <strong>多屏幕编辑</strong> Markdown文章功能；</li>\n<li>增加了 <strong>焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置</strong> 等功能，功能按钮位于编辑区域与预览区域中间；</li>\n<li>增加了 <strong>检查列表</strong> 功能。<br />\n[^1]: <a href=\"https://mermaidjs.github.io/\">mermaid语法说明</a></li>\n</ol>\n<h2 id=\"功能快捷键\">功能快捷键</h2>\n<p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br />\n重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br />\n加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br />\n斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br />\n标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br />\n无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br />\n有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br />\n检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br />\n插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br />\n插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br />\n插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd><br />\n查找：<kbd>Ctrl/Command</kbd> + <kbd>F</kbd><br />\n替换：<kbd>Ctrl/Command</kbd> + <kbd>G</kbd></p>\n<h2 id=\"合理的创建标题有助于目录的生成\">合理的创建标题，有助于目录的生成</h2>\n<p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br />\n输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br />\n以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p>\n<h2 id=\"如何改变文本的样式\">如何改变文本的样式</h2>\n<p><em>强调文本</em> <em>强调文本</em></p>\n<p><strong>加粗文本</strong> <strong>加粗文本</strong></p>\n<p>==标记文本==</p>\n<p><del>删除文本</del></p>\n<blockquote>\n<p>引用文本</p>\n</blockquote>\n<p>H~2~O is是液体。</p>\n<p>2<sup>10</sup> 运算结果是 1024.</p>\n<h2 id=\"插入链接与图片\">插入链接与图片</h2>\n<p>链接: <a href=\"https://mp.csdn.net\">link</a>.</p>\n<p>图片: <img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw\" alt=\"Alt\" /></p>\n<p>带尺寸的图片: ![Alt](<a href=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw\">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw</a> =30x30)</p>\n<p>居中的图片: <img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center\" alt=\"Alt\" /></p>\n<p>居中并且带尺寸的图片: ![Alt](<a href=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center\">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center</a> =30x30)</p>\n<p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p>\n<h2 id=\"如何插入一段漂亮的代码片\">如何插入一段漂亮的代码片</h2>\n<p>去<a href=\"https://mp.csdn.net/configure\">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.</p>\n<pre><code class=\"language-javascript\">// An highlighted block\nvar foo = \'bar\';\n</code></pre>\n<h2 id=\"生成一个适合你的列表\">生成一个适合你的列表</h2>\n<ul>\n<li>项目\n<ul>\n<li>项目\n<ul>\n<li>项目</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>项目1</li>\n<li>项目2</li>\n<li>项目3</li>\n</ol>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;计划任务</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;完成任务</li>\n</ul>\n<h2 id=\"创建一个表格\">创建一个表格</h2>\n<p>一个简单的表格是这么创建的：<br />\n项目     | Value<br />\n-------- | -----<br />\n电脑  | $1600<br />\n手机  | $12<br />\n导管  | $1</p>\n<h3 id=\"设定内容居中居左居右\">设定内容居中、居左、居右</h3>\n<p>使用<code>:---------:</code>居中<br />\n使用<code>:----------</code>居左<br />\n使用<code>----------:</code>居右<br />\n| 第一列       | 第二列         | 第三列        |<br />\n|:-----------:| -------------:|:-------------|<br />\n| 第一列文本居中 | 第二列文本居右  | 第三列文本居左 |</p>\n<h3 id=\"smartypants\">SmartyPants</h3>\n<p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：<br />\n|    TYPE   |ASCII                          |HTML<br />\n|----------------|-------------------------------|-----------------------------|<br />\n|Single backticks|<code>\'Isn\'t this fun?\'</code>            |\'Isn\'t this fun?\'            |<br />\n|Quotes          |<code>&quot;Isn\'t this fun?&quot;</code>            |&quot;Isn\'t this fun?&quot;            |<br />\n|Dashes          |<code>-- is en-dash, --- is em-dash</code>|-- is en-dash, --- is em-dash|</p>\n<h2 id=\"创建一个自定义列表\">创建一个自定义列表</h2>\n<p>Markdown<br />\n:  Text-to-HTML conversion tool</p>\n<p>Authors<br />\n:  John<br />\n:  Luke</p>\n<h2 id=\"如何创建一个注脚\">如何创建一个注脚</h2>\n<p>一个具有注脚的文本。<a href=\"注脚的解释\">^2</a></p>\n<h2 id=\"注释也是必不可少的\">注释也是必不可少的</h2>\n<p>Markdown将文本转换为 HTML。</p>\n<p>*[HTML]:   超文本标记语言</p>\n<h2 id=\"katex数学公式\">KaTeX数学公式</h2>\n<p>您可以使用渲染LaTeX数学表达式 <a href=\"https://khan.github.io/KaTeX/\">KaTeX</a>:</p>\n<p>Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\forall<br />\nn\\in\\mathbb N$ 是通过欧拉积分</p>\n<p>$$<br />\n\\Gamma(z) = \\int_0<sup z-1=\"\">\\infty t</sup>e^{-t}dt,.<br />\n$$</p>\n<blockquote>\n<p>你可以找到更多关于的信息 <strong>LaTeX</strong> 数学表达式<a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\">here</a>.</p>\n</blockquote>\n<h2 id=\"新的甘特图功能丰富你的文章\">新的甘特图功能，丰富你的文章</h2>\n<div class=\"mermaid\">\ngantt\n        dateFormat  YYYY-MM-DD\n        title Adding GANTT diagram functionality to mermaid\n        section 现有任务\n        已完成               :done,    des1, 2014-01-06,2014-01-08\n        进行中               :active,  des2, 2014-01-09, 3d\n        计划一               :         des3, after des2, 5d\n        计划二               :         des4, after des3, 5d\n</div>\n<ul>\n<li>关于 <strong>甘特图</strong> 语法，参考 <a href=\"https://mermaidjs.github.io/\">这儿</a>,</li>\n</ul>\n<h2 id=\"uml-图表\">UML 图表</h2>\n<p>可以使用UML图表进行渲染。 <a href=\"https://mermaidjs.github.io/\">Mermaid</a>. 例如下面产生的一个序列图：</p>\n<div class=\"mermaid\">\nsequenceDiagram\n张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?\n李四--&gt;&gt;王五: 你最近怎么样，王五？\n李四--x 张三: 我很好，谢谢!\n李四-x 王五: 我很好，谢谢!\nNote right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.\n\n李四--&gt;&gt;张三: 打量着王五...\n张三-&gt;&gt;王五: 很好... 王五, 你怎么样?\n</div>\n<p>这将产生一个流程图。:</p>\n<div class=\"mermaid\">\ngraph LR\nA[长方形] -- 链接 --&gt; B((圆))\nA --&gt; C(圆角长方形)\nB --&gt; D{菱形}\nC --&gt; D\n</div>\n<ul>\n<li>关于 <strong>Mermaid</strong> 语法，参考 <a href=\"https://mermaidjs.github.io/\">这儿</a>,</li>\n</ul>\n<h2 id=\"flowchart流程图\">FLowchart流程图</h2>\n<p>我们依旧会支持flowchart的流程图：</p>\n<div class=\"mermaid\">\nflowchat\nst=&gt;start: 开始\ne=&gt;end: 结束\nop=&gt;operation: 我的操作\ncond=&gt;condition: 确认？\n\nst-&gt;op-&gt;cond\ncond(yes)-&gt;e\ncond(no)-&gt;op\n</div>\n<ul>\n<li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href=\"http://adrai.github.io/flowchart.js/\">这儿</a>.</li>\n</ul>\n<h2 id=\"导出与导入\">导出与导入</h2>\n<h3 id=\"导出\">导出</h3>\n<p>如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <strong>文章导出</strong> ，生成一个.md文件或者.html文件进行本地保存。</p>\n<h3 id=\"导入\">导入</h3>\n<p>如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，<br />\n继续你的创作。</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:38:37', '2020-04-25 15:38:37');
INSERT INTO `tb_article` VALUES (165, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7795', 'git从入门配置到常用基本命令，傻瓜式操作一步步命令总结', '<p>﻿### 1，git的下载安装<br />\n下载地址：<a href=\"https://git-scm.com/download/win\">git官方下载地址https://git-scm.com/download/win</a></p>\n<p>安装，双击安装包，一直不停的下一步就安装好了。</p>\n<p>检验是否安装成功：在电脑的任何位置 右键 Git Bash Here （打开Git命令窗口）</p>\n<h3 id=\"2配置本地git\">2，配置本地git</h3>\n<p>name是你自己的名字<br />\n邮箱要是你在github或者码云上注册的邮箱</p>\n<pre><code class=\"language-git\">git config --global user.name &quot;Your Name&quot;  \ngit config --global user.email &quot;email@example.com&quot;\n</code></pre>\n<h3 id=\"3基本命令\">3，基本命令</h3>\n<p>1，在自己电脑上创建一个文件夹，就是版本库<br />\n创建一个本地版本库  写一个文档  交给git管理（添加到本地版本库）</p>\n<p>2，进入文件夹内部， 右键 Git Bash Here （打开Git命令窗口）输入</p>\n<pre><code>git init \n</code></pre>\n<p>命令。初始化本地版本库。如果你的电脑不显示这个文件夹，请打开显示隐藏的项目，</p>\n<p>3，随便创建一个txt文件，添加test.tx文件到本地版本库</p>\n<p>添加当前文件夹 所有的文件 到暂存区</p>\n<pre><code>git add .\n</code></pre>\n<p>添加指定的文件</p>\n<pre><code>git add test.txt\n</code></pre>\n<p>将暂存区文件提交到本地版本库</p>\n<pre><code class=\"language-git\">git commit -m &quot;v1.0 写版本描述信息 必须写&quot;\n</code></pre>\n<p>查看所有的版本信息</p>\n<pre><code>git log   #查看日志 所有的版本信息\ngit reflog   #查看日志 所有的版本信息\n</code></pre>\n<p>区别</p>\n<ol>\n<li>git log 只显示当前版本 和 之前的所有的版本</li>\n<li>git reflog 显示所有版本 和 所有的操作信息</li>\n</ol>\n<p>更新文件，添加第二个版本</p>\n<pre><code>git add . \ngit commit -m &quot;v2.0 写版本信息 必须写&quot; \n</code></pre>\n<p>回到第一个版本</p>\n<pre><code>   git reset --hard HEAD^   ^回退一个版本 ^^回退100个版本\n   git reset --hard HEAD~100 回退100个版本\n</code></pre>\n<p>再从版本1 回到 版本2</p>\n<pre><code>git reset --hard 版本的编号（不需要写全 5 6位数字就可以）\n</code></pre>\n<p>如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826204103589.png\" alt=\"在这里插入图片描述\" /></p>\n<h3 id=\"版本库的结构\">版本库的结构</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20190826204236680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>查看当前版本库和工作区的文件状态</strong></p>\n<p>git status</p>\n<ol>\n<li>文件 显示红色 文件中有修改  没有做添加 也没有提交<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826204404213.png\" alt=\"在这里插入图片描述\" /></li>\n<li>文件 显示绿色 文件添加了 位于暂存区 没有提交<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826204445349.png\" alt=\"在这里插入图片描述\" /></li>\n<li>没有文件需要提交<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826204509671.png\" alt=\"在这里插入图片描述\" /></li>\n</ol>\n<p><strong>版本撤销</strong></p>\n<p>git checkout  版本撤销</p>\n<ol>\n<li>文件没有添加到暂存区 红色状态  会删除所有新增的内容</li>\n<li>文件添加到暂存区之后 新增的内容是撤销不了的</li>\n</ol>\n<h2 id=\"本地git-集成码云\">本地git 集成码云</h2>\n<ol>\n<li>注册码云</li>\n<li>在本地电脑执行命令生成SSH公钥 输入命令一直回车<br />\n获取公钥命令，然后一直回车就好</li>\n</ol>\n<pre><code>       ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot; \n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190826205114559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\nid_rea是秘钥，不要轻易给别人<br />\nid_rea.pub 公钥，给谁无所谓</p>\n<p>3，在码云配置公钥<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826205234866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>仓库相关的操作</strong></p>\n<ol>\n<li>创建一个仓库<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826205324719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n将整个仓库 克隆（下载） 到本地<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826205347200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></li>\n</ol>\n<p>复制 SSH 连接<br />\n在本地执行克隆的命令</p>\n<pre><code>git clone 粘贴你负责的ssh连接\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190826205439777.png\" alt=\"在这里插入图片描述\" /><br />\n<strong>将之前测试的本地文件推送到远程仓库：</strong></p>\n<pre><code>git add .\ngit commit -m &quot;v2.0 test&quot;\ngit push\n</code></pre>\n<p>在远程写一个文件  更新到本地</p>\n<pre><code>git pull\n</code></pre>\n<h2 id=\"分支的使用\">分支的使用</h2>\n<h5 id=\"常用分支命令\">常用分支命令</h5>\n<pre><code>查看分支,查看当前拥有多少个分支\n	git branch  \n\n创建分支 \n	git branch 要创建的分支的名称  \n\n切换分支 \n	git checkout 要去往的分支名称\n</code></pre>\n<p><strong>删除分支</strong>,慎用，不要轻易删除分支<br />\ngit branch -d 分支名<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826210311773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" />	<br />\n<strong>开发的时候用到的dev分支</strong></p>\n<pre><code>git checkout -b dev // 创建并切换到dev分支\n\ngit push --set-upstream origin dev // 将dev分支推送到远程仓库\n</code></pre>\n<p><strong>合并dev分支至master</strong></p>\n<pre><code>git checkout master // 切换到master分支\n\ngit merge dev // 合并dev分支到当前分支（master）\n</code></pre>\n<h5 id=\"在idea中使用git遇到的一个问题\">在idea中使用Git遇到的一个问题</h5>\n<p>报错：</p>\n<blockquote>\n<p>Push rejected: Push to origin/master was rejected</p>\n</blockquote>\n<p>意思是git拒绝合并两个不相干的东西<br />\n此时你需要在打开Git Bash，然后进入相应的目录，然后敲git命令</p>\n<pre><code>$ git pull origin master --allow-unrelated-histories\n</code></pre>\n<p>出现类似于这种信息就说明pull成功了：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190827191650505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n然后再执行push命令。就可以成功了！</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:39:22', '2022-05-21 18:19:23');
INSERT INTO `tb_article` VALUES (166, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5980', 'SpringBoot集成shiro认证，实现Shiro认证的登录操作', '<p>﻿### 什么是Shiro权限管理？</p>\n<blockquote>\n<p>Apache Shiro 是 Java 的一个安全框架。目前，使用 Apache Shiro 的人越来越多，因为它相 当简单，对比<br />\nSpring Security，可能没有 Spring Security 做的功能强大，但是在实际工作时<br />\n可能并不需要那么复杂的东西，所以使用小而简单的 Shiro 就足够了。对于它俩到底哪个 好，这个不必纠结，能更简单的解决项目问题就好了。</p>\n</blockquote>\n<p>权限管理分为认证和授权</p>\n<h1 id=\"认证\">认证</h1>\n<h4 id=\"认证的基本概念\">认证的基本概念</h4>\n<p>身份认证：校验用户是不是系统合法用户的过程（比如登录操作）</p>\n<blockquote>\n<p><strong>身份认证，就是判断一个用户是否为合法用户的处理过程</strong>。</p>\n<p><strong>最常用的简单身份认证方式是系统通过核对用户输入的用户名和密码，看其是否与系统中存储的该用户的用户名和密码是否一致，来判断用户身份是否正确。</strong></p>\n<p>对于采用指纹等系统，则出示指纹；对于硬件Key等刷卡系统，则需要刷卡。通过二维码等等都是认证的过程</p>\n</blockquote>\n<h4 id=\"认证基本的对象\">认证基本的对象</h4>\n<h5 id=\"subject-主体\">Subject 主体</h5>\n<p>官方给出的解释是这样的：</p>\n<blockquote>\n<p>Without question, the most important concept in Apache Shiro is the Subject. ‘Subject’ is just a security term that means a security-specific ‘view’ of an application user. A Shiro Subject instance represents both security state and operations for a single application user.<br />\n翻译过来就是：<br />\n毫无疑问，<strong>shiro中最重要的概念就是subject（主体）</strong>。subject是一个虚拟的用户对象（就是相当于我们之前的User Admin对象等）。</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20190825173535988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>使用Subject的之后的流程变化</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190825173552565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>其实，<br />\n<strong>Subject可以认为就是Admin  User这些类</strong><br />\n另外subject中还有两个重要概念：</p>\n<blockquote>\n<p><strong>Credential 凭证信息  就是密码的意思</strong></p>\n<p><strong>Principal 身份信息 就是账号的意思</strong></p>\n</blockquote>\n<p>扩展阅读：（看一下官方的解释为什么叫Subject而不叫User）</p>\n<blockquote>\n<p>We originally wanted to call it ‘User’ since that “just makes sense”, but we decided against it: too many applications have existing APIs that already have their own User classes/frameworks, and we didn’t want to conflict with those. Also, in the security world, the term ‘Subject’ is actually the recognized nomenclature.<br />\n翻译如下：<br />\n我们最初是想把它叫做User的，这样很容易理解，但是大部分的应用程序都已经有了User类，为了不和这些原有的api发生冲突，我们最后决定不这么做。</p>\n</blockquote>\n<h4 id=\"认证的登录操作案例springboot集成shiro\">认证的登录操作案例：SpringBoot集成shiro</h4>\n<p>下面开始使用Shiro实现带认证的登录操作</p>\n<h6 id=\"导入依赖\">导入依赖</h6>\n<pre><code class=\"language-xml\">&lt;!--shiro相关依赖--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;\n    &lt;version&gt;1.3.2&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;\n    &lt;version&gt;1.3.2&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;\n    &lt;version&gt;1.3.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h5 id=\"第一个demo\">第一个demo</h5>\n<p>基本思路</p>\n<blockquote>\n<p>用户输入的账号密码  和 数据库中存储的账号密码 比对</p>\n<p>注意：shiro 默认不支持连接数据库  默认通过配置文件获取数据<br />\n所以我们要重写Realm中的方法，实现对数据库的连接</p>\n</blockquote>\n<ol>\n<li>接收用户输入的账号密码,</li>\n<li>要重写Realm中的方法，实现对数据库的连接和数据获取</li>\n<li>写Springboot的配置类，创建并将重写的Realm设置放进去安全管理器， 将安全管理器 和Subject建立联系</li>\n<li>将用户输入的账号密码给Subject</li>\n<li>调用Subject的login方法完成登录</li>\n</ol>\n<p><strong>代码实现流程</strong></p>\n<h6 id=\"重写realm的代码\">重写Realm的代码</h6>\n<pre><code class=\"language-java\">package com.macw.realm;\n\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.macw.entity.Admin;\nimport com.macw.mapper.AdminMapper;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.*;\nimport org.apache.shiro.realm.AuthenticatingRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Resource;\n\n/**\n * @author maCw\n * @version 1.0\n * @date 2019/8/22 16:13\n */\n\npublic class MyRealm extends AuthenticatingRealm {\n\n    @Resource\n    private AdminMapper adminMapper;\n    /**\n     * 记录日志\n     */\n    Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        //1，获取令牌中的数据，账号\n        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;\n        String username = token.getUsername();\n        //2，通过账号查询获取数据库中对应的账号信息\n        Admin admin = adminMapper.selectOne(new QueryWrapper&lt;Admin&gt;().eq(&quot;username&quot;, username));\n        logger.info(&quot;---&quot;+admin);\n        Subject subject = SecurityUtils.getSubject();\n        //将查询的对象放进去subject自带的session中去\n        subject.getSession().setAttribute(&quot;admins&quot;, admin);\n        //如果有数据，对象为非null，说明查询到了数据，封装account返回\n        if (admin != null){\n            SimpleAccount simpleAccount = new SimpleAccount(admin.getUsername(), admin.getPassword(), this.getName());\n            return simpleAccount;\n        }else {\n            //如果对象为空，return null就会抛出账户不存在异常\n            return null;\n        }\n    }\n}\n\n</code></pre>\n<h5 id=\"在springboot中配置shiro\">在SpringBoot中配置shiro</h5>\n<pre><code class=\"language-java\">package com.macw.config;\n\nimport com.macw.realm.MyRealm;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.spring.web.ShiroFilterFactoryBean;\nimport org.apache.shiro.web.config.WebIniSecurityManagerFactory;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.Map;\n\n\n/**\n * @Configuration 标记当前类为配置类  相当于spring.xml\n */\n@Configuration\npublic class ShiroConfig {\n\n    /**\n     * @Bean 声明创建对象  并把对象放在工厂中  相当于bean标签\n     * 如果形参类型对应的对象在工厂中有  会自动装配上\n     * @return\n     */\n    @Bean\n    public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultSecurityManager defaultSecurityManager){\n        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\n        /**\n         * 过滤器链 过滤拦截规则 哪些页面拦截  哪些页面不拦截\n         */\n        Map map = new HashMap();\n        /**\n         * anon 代表匿名可访问 就是不用登录就可以访问  登录页面  登录的url\n         * authc 认证可访问 代表登录后才能访问\n         *\n         * 支持通配符*\n         * 注意拦截规则 一个一个配置\n         */\n        map.put(&quot;/login.jsp&quot;,&quot;anon&quot;);\n        map.put(&quot;/login/*&quot;,&quot;anon&quot;);\n\n        map.put(&quot;/main/*&quot;, &quot;authc&quot;);\n        map.put(&quot;/guru/*&quot;, &quot;authc&quot;);\n        map.put(&quot;/menu/*&quot;, &quot;authc&quot;);\n\n        shiroFilterFactoryBean.setFilterChainDefinitionMap(map);\n\n        /**\n         * 设置安全管理器，将创建的安全管理器放进shiroFilterFactoryBean过滤工厂里面\n         */\n        shiroFilterFactoryBean.setSecurityManager(defaultSecurityManager);\n        return shiroFilterFactoryBean;\n    }\n\n    /**\n     * 创建安全管理器,并将自定义的Realm放进去管理器\n     * @return\n     */\n    @Bean\n    public DefaultSecurityManager getDefaultSecurityManager(MyRealm myRealm){\n        DefaultSecurityManager defaultSecurityManager = new DefaultWebSecurityManager();\n//        需要赋值一个Realm\n        defaultSecurityManager.setRealm(myRealm);\n        return defaultSecurityManager;\n    }\n\n    /**\n     * 创建自定义的Realm\n     */\n    @Bean\n    public MyRealm getMyRealm(){\n        return new MyRealm();\n    }\n}\n</code></pre>\n<p>如果引用到其他项目的话这里需要修改的是 拦截规则  和  自定义的Realm</p>\n<h5 id=\"修改原来的登录方法\">修改原来的登录方法</h5>\n<p>在控制器里的登录方法中修改：</p>\n<pre><code class=\"language-java\">    /**\n     * 使用shiro登录\n     * @param username\n     * @param password\n     * @return\n     */\n    @RequestMapping(&quot;adminLogin&quot;)\n    public String adminLogin(String username,String password){\n//        1.将用户输入的账号密码 封装在token中\n        UsernamePasswordToken token = new UsernamePasswordToken(username, password);\n\n//        2.获取Subject\n        Subject subject = SecurityUtils.getSubject();\n\n//        3.通过Subject 的login方法 完成登录\n        try {\n            subject.login(token);\n            //到这里如果没有异常说明登录成功，\n            return &quot;redirect:/main/main.jsp&quot;;\n        }catch (Exception e){\n            //有异常说明登录失败，重定向到登录页面\n            return &quot;redirect:/login.jsp&quot;;\n        }\n    }\n</code></pre>\n<h5 id=\"shiro中session的使用\">shiro中Session的使用</h5>\n<p><strong>方案1：HttpSession</strong></p>\n<p><strong>方案2：shiro中的session</strong></p>\n<pre><code>Session session1 = SecurityUtils.getSubject().getSession();\n</code></pre>\n<p>注意：方案1  和 方案2 都可以 使用  但是只能使用一种方案  不要混合使用</p>\n<h4 id=\"登录认证总结\">登录认证总结</h4>\n<p><strong>认证：登录，身份认证，校验用户是不是系统合法用户的过程</strong></p>\n<p><strong>主体Subject：就是Admin，User这些类，但是和之前自己定义的User Admin稍以后区别，Subject不仅封装用户和认证相关的数据（账号密码），还封装了和认证相关的方法（login方法）</strong></p>\n<p><strong>Credential 凭证信息  就是密码的意思</strong></p>\n<p><strong>Principal 身份信息 就是账号的意思</strong></p>\n<p><strong>重写Realm中的方法</strong></p>\n<ol>\n<li>\n<p><strong>为什么要重写Realm中的方法</strong></p>\n<p><strong>默认不支持连接数据库  默认的实现是查询配置文件</strong></p>\n</li>\n<li>\n<p><strong>解决方案</strong></p>\n<p><strong>shiro默认的doGetAuthenticationInfo方法是查询配置文件，由于这个方法是父类的一个抽象方法，通过继承和多态，可以继承父类，覆盖这个方法（在方法中写入我们新的方法实现 连接数据库 查询数据库中的账号信息）</strong></p>\n</li>\n</ol>\n<p><strong>集成项目的基本流程</strong></p>\n<ol>\n<li>\n<p>写shiro的配置类（创建对象）</p>\n<p><strong>注意：拦截规则 和 自定义的Realm 需要根据自己项目的情况调整</strong></p>\n</li>\n<li>\n<p>修改原来的登录方法</p>\n</li>\n</ol>\n', 1, '', 0, 0, 1, '2020-04-25 15:39:42', '2022-05-21 18:18:00');
INSERT INTO `tb_article` VALUES (167, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=9835', '详解Redis，Redis缓存，Redis分布式锁', '<p>﻿</p>\n<h3 id=\"1redis基本知识\">1、Redis基本知识</h3>\n<h4 id=\"简介\">简介</h4>\n<p>Redis是一个支持网络、基于内存、可选持久性的NoSql数据库，目前在很多的系统中都使用了Redis，尤其是在实现缓存功能的时候应用的尤其广泛（缓存功能也是很多人对Redis的认识），那么Redis到底有哪些优点和缺点，为什么会被广泛应用呢？</p>\n<h4 id=\"redis的优点\">Redis的优点</h4>\n<p>Redis的第一个优点就是<strong>速度快</strong>，Redis使用C语言实现，基于内存，数据的读写效率非常的高，这也是为什么很多系统的缓存功能使用Redis来实现，<em><strong>但是需要明确的是Redis是一个数据库，缓存只是它的一项应用而已。</strong></em></p>\n<p>Redis的第二个优点是<strong>单线程模型</strong>，所谓单线程模型就是每一个请求都会有一个全新的线程来进行处理，这一点类似于Struts2，每一个请求都会有一个新的线程来进行处理。这样做的好处就是避免了线程频繁切换带来的系统开销，同时也避免了让人头疼的多线程问题。</p>\n<p>Redis的第三个优点就是使用了<strong>非阻塞I/O</strong> （NIO），不在网络上浪费时间，进一步提高了效率。</p>\n<p>Redis的第四个优点就是支持多种的<strong>数据类型</strong>，并且每一种数据类型都提供了丰富的操作命令，适用于很多特殊的场景，并且支持自定义命令创建个性化的操作命令。</p>\n<h2 id=\"2redis持久化机制\">2、redis持久化机制</h2>\n<p>redis服务器宕机，内存数据是会丢失了，为了保证数据不丢失需要对数据做备份，所备份就是持久化，Redis的持久化即将内存中的数据同步到硬盘，主要包括两种方式RDB、AOF。</p>\n<p><strong>RDB持久化机制，(默认使用)</strong>：做当前内存数据的全本快照，<br />\n将内存中的数据以快照的方式写入到二进制文件dump.rdb,<br />\n在redis.conf中可以设置发起快照保存的条件。在指定的时间内如果有超过指定数量的key被修改，则会发起快照保存。</p>\n<p>这种方式在数据的实时性上不高，在突然断电的情况下，可能会出现部分数据的丢失，即最后一次快照之后在内存中发生修改的数据。</p>\n<p>简单来说：RDB就是将redis上的所有数据做个备份，存储的是二进制的数据。</p>\n<p><strong>AOF持久化机制，(默认是关闭)</strong>：</p>\n<p>AOF是将Redis内存数据库中更改的数据都记录到指定的文件appendonly.aof。在redis.conf中可以进行写磁盘的相关设置。</p>\n<p>在突然断电的情况下，由于在appendonly.aof中保存了最后一次写磁盘之后redis内存发生数据修改的指令，所以在这个Redis重启后，基本不会发生数据丢失，比RDB具有更好的数据安全性。</p>\n<p>appendfsync always   接收到更改数据的命令，立即将其记录到appendonly.aof中，能保证数据持久化，数据完全不丢失，但效率相对最低。</p>\n<p>appendfsync everysec   每秒钟将redis内存数据修改的命令记录到appendonly.aof中，在性能和持久化上做了折中。因频繁执行磁盘操作，在仅存在单个Master执行写操作时，效率可能存在问题。但在多个Master执行写操作的Redis集群中，效率会提升。</p>\n<p>appendfsync no  依赖于操作系统，因不会频繁执行磁盘操作而性能最好，但redis内存数据修改持久化没有保证，无法保证数据可靠性</p>\n<p><strong>如何开启AOF持久化：</strong><br />\n将redis.conf文件中 appendonly 改成 yes ，自动创建appendonly.aof，该文件存储的客户端执行过<strong>增删改操作的命令</strong></p>\n<br/>\n<h3 id=\"3-redis的数据结构\">3、 Redis的数据结构</h3>\n<p>redis数据库存储数据使用的key-value，键值对方式存储<br />\nkey是string类型 value的数据结构支持5个string、set、sorted_set、list、hash<br />\n<img src=\"https://img-blog.csdnimg.cn/20190820092223845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"4redis-的常用命令\">4、Redis 的常用命令</h4>\n<h5 id=\"string可以存数字\">String(可以存数字)</h5>\n<p>可以实现原子性的自增（数据安全）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820092339194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>这是最基本的类型了，没啥可说的，就是普通的set和get，做简单的k-v缓存</p>\n<h5 id=\"hash\">hash</h5>\n<p>这个是类似map的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在redis里，然后每次读写缓存的时候，可以就操作hash里的某个字段。</p>\n<pre><code>key=150\n\n\n\nvalue={\n\n “id”: 150,\n\n “name”: “zhangsan”,\n\n “age”: 20\n\n}\n\n</code></pre>\n<p>hash类的数据结构，主要是用来存放一些对象，把一些简单的对象给缓存起来，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值</p>\n<pre><code>value={\n\n “id”: 150,\n\n “name”: “zhangsan”,\n\n “age”: 21\n\n}\n\n</code></pre>\n<h5 id=\"list\">list</h5>\n<p>有序列表，这个是可以玩儿出很多花样的</p>\n<p>微博，某个大v的粉丝，就可以以list的格式放在redis里去缓存</p>\n<pre><code>key=某大v\n\nvalue=[zhangsan, lisi, wangwu]\n\nkey=书名\n\nvalue=[评论1, 评论2, 评论3]\n</code></pre>\n<p>比如可以通过list存储一些列表型的数据结构，类似粉丝列表了、文章的评论列表了之类的东西</p>\n<p>比如可以通过<strong>lrange命令</strong>，就是从某个元素开始读取多少个元素，可以基于list实现分页查询，这个很棒的一个功能，基于redis实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走</p>\n<p>比如可以搞个简单的消息队列，从list头怼进去，从list尾巴那里弄出来</p>\n<h5 id=\"set\">set</h5>\n<p>无序集合，自动去重</p>\n<p>直接基于set将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于jvm内存里的HashSet进行去重，但是如果你的某个系统部署在多台机器上呢？</p>\n<p>得基于redis进行全局的set去重</p>\n<p>可以基于set玩儿交集、并集、差集的操作，比如交集吧，可以把两个人的粉丝列表整一个交集，看看俩人的共同好友是谁？对吧</p>\n<p>把两个大v的粉丝都放在两个set中，对两个set做交集</p>\n<h5 id=\"sorted-set-跳表\">sorted set 跳表</h5>\n<p>排序的set，去重但是可以排序，写进去的时候给一个分数，自动根据分数排序，这个可以玩儿很多的花样，最大的特点是有个分数可以自定义排序规则</p>\n<p>比如说你要是想根据时间对数据排序，那么可以写入进去的时候用某个时间作为分数，人家自动给你按照时间排序</p>\n<p>排行榜：将每个用户以及其对应的什么分数写入进去，zadd board score username，接着zrevrange board 0 99，就可以获取排名前100的用户；zrank board username，可以看到用户在排行榜里的排名</p>\n<p><strong>总结：优先掌握 String 即可</strong><br />\n<br/></p>\n<h4 id=\"5数据失效时间\">5、数据失效时间</h4>\n<p>场景：</p>\n<p>手机验证码登录  手机验证码注册</p>\n<p>验证码后台生成  Redis</p>\n<ol>\n<li>集中存储</li>\n<li>可以设置过期时间</li>\n</ol>\n<pre><code>验证码  \n\nkey = 手机号 \nvalue = 验证码  \n\n设置3分钟过期\n</code></pre>\n<p>Redis中可以设置数据的存活时间</p>\n<p>命令</p>\n<pre><code>expire key 存活时间的秒\nttl key 查看key对应的数据的存活时间.\npexipre key 存活时间的毫秒\npttl key 查看key对应的数据的存活时间,毫秒单位\n</code></pre>\n<p><strong>expire key 存活时间的秒</strong></p>\n<p>失效的原理</p>\n<ol>\n<li>\n<p><strong>定期随机删除+惰性删除</strong></p>\n<pre><code>key  \n1    1分钟\n2    1分钟  \n3    1分钟\n4    1分钟\n5\n6\n\nredis 每过100ms 随机抽取一定数量的设置了失效时间的key 将过期的删除\n\n有些key过期了 每次都没有随机到  就一直删不掉  怎么办？\n\n惰性删除 get key 的时候 先判断 key是否过期 如果过期 返回数据为空\n\n</code></pre>\n<p>定期随机删除  例如100ms</p>\n<p>查询的时候 先检查key</p>\n</li>\n<li>\n<p><strong>内存淘汰机制</strong></p>\n<p>如果redis的内存占用过多的时候，此时会进行内存淘汰，有如下一些策略：</p>\n<p>redis 10个key，现在已经满了，redis需要删除掉5个key</p>\n<p>1个key，最近1分钟被查询了100次</p>\n<p>1个key，最近10分钟被查询了50次</p>\n<p>1个key，最近1个小时被查询了1次</p>\n<ol>\n<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了</li>\n<li><strong>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</strong></li>\n<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊</li>\n<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）</li>\n<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key</li>\n<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除</li>\n</ol>\n<p>LRU算法  扩展视野</p>\n</li>\n</ol>\n<br/>\n<h4 id=\"6redis的基本应用\">6、Redis的基本应用！！！</h4>\n<h5 id=\"二级缓存\">二级缓存</h5>\n<ol>\n<li>\n<p>为什么要做缓存</p>\n</li>\n<li>\n<p>缓存的选择（二级缓存）</p>\n</li>\n<li>\n<p>二级缓存的基本概念</p>\n<ol>\n<li>是什么</li>\n<li>如何开启</li>\n</ol>\n</li>\n<li>\n<p>二级缓存的缺点</p>\n</li>\n<li>\n<p>使用Redis集成二级缓存的步骤</p>\n<ol>\n<li>实现cache接口</li>\n</ol>\n</li>\n</ol>\n<p><strong>缓存的作用</strong></p>\n<ol>\n<li>数据从内存获取,提升数据获取速度.</li>\n<li>减轻了数据库读操作的访问压力(数据基本不变)</li>\n</ol>\n<p><strong>MyBatis二级缓存机制(开启)</strong></p>\n<p>机制：</p>\n<ol>\n<li>\n<p>Java本地缓存空间.(jar)</p>\n</li>\n<li>\n<p>mybaits事务提交后操作缓存</p>\n</li>\n<li>\n<p>Mybatis根据Mapper文件的namespace划分多个缓存空间.</p>\n</li>\n<li>\n<p>mybatis会将查询语句执行结果,缓存在 sql所在mapper文件对应的namespace对应的缓存空间中.</p>\n<p>会将执行的查询sql(对sql处理后产生的对象)作为key.</p>\n</li>\n<li>\n<p>MyBatis执行DML,在事务提交之后,默认清空当前sql所在的mapper文件对应的namespace对应的缓存空间中</p>\n<p>A Mapper   User表  脏读</p>\n<p>B Mapper   User表  删除  缓存清空</p>\n<p>缓存空间融合</p>\n<ol>\n<li><strong>所有关于User表的操作都写在一个Mapper中</strong></li>\n<li>Mapper配置 融合缓存空间（基本没有人使用）</li>\n<li>第三方的缓存空间\n<ol>\n<li>ehcache</li>\n<li><strong>Redis</strong></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093046989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>MyBatis缓存实现原理(源码)</strong></p>\n<p><code>org.apache.ibatis.cache.impl.PerpetualCache.class</code></p>\n<ol>\n<li>\n<p>根据namepace划分缓存空间(id)</p>\n</li>\n<li>\n<p>MyBatis二级缓存本质是一个Map结构</p>\n<p>key :和执行的sql先关</p>\n<p>value:查询结果相关</p>\n</li>\n<li>\n<p>存放数据的功能: select语句(key)----查询结果(value)</p>\n</li>\n<li>\n<p>获得数据的功能: 根据key</p>\n</li>\n<li>\n<p>清空缓存的功能: clear</p>\n</li>\n<li>\n<p>MyBatis管理每个缓存,使用Map管理 key:id(namespace)  value:PerpetualCache</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093242240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>MyBatis缓存的问题?(缓存数据量不能太多)</strong></p>\n<ol>\n<li>mybatis缓存在tomcat的jvm内部分配的缓存空间.</li>\n<li>缓存数据过多,挤占java运行期间需要的内存.</li>\n</ol>\n<p>解决办法:</p>\n<p>将Mybatis的二级缓存空间转移到Redis数据库中</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093258936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>Mybatis二级缓存空间划分</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093309465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>Redis缓存空间的划分设计</strong></p>\n<p>核心:</p>\n<ol>\n<li>每个缓存空间是一个map</li>\n<li>每个缓存空间对应一个namespace.(管理多个cache空间)</li>\n</ol>\n<p>方案:</p>\n<ol>\n<li>将mybatis的namespace作为redis的key</li>\n<li>将key对应的value作为hash数据结构使用.(替换PerpetualCache)</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093323489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>自定义Redis缓存实现</strong></p>\n<p><strong>自定义缓存实现类</strong></p>\n<ol>\n<li>\n<p>自定义MyBatis二级缓存</p>\n<ol>\n<li>自定缓存类实现Cache接口</li>\n<li>导入redis操作相关的工具(jar,JedisUtil,jedis.properties)</li>\n<li>必须具备如下功能:</li>\n</ol>\n</li>\n<li>\n<p>根据namepace划分缓存空间(id)</p>\n</li>\n<li>\n<p>MyBatis二级缓存本质是一个Map结构</p>\n<p>key :和执行的sql先关</p>\n<p>value:查询结果相关</p>\n</li>\n<li>\n<p>存放数据的功能: select语句(key)----查询结果(value)</p>\n</li>\n<li>\n<p>获得数据的功能: 根据key</p>\n</li>\n<li>\n<p>清空缓存的功能: clear</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093345829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>使用自定义的缓存</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093414993.png\" alt=\"在这里插入图片描述\" /></p>\n<h5 id=\"session共享\">Session共享</h5>\n<p><strong>为何要实现session共享？</strong></p>\n<p>nginx负载均衡,希望兼顾权重的按照硬件性能分配访问压力的优势,又想保证多个tomcat使用同一个session应该怎么解决？<br />\n<img src=\"https://img-blog.csdnimg.cn/20190820093754832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>ip_hash</li>\n<li>session复制</li>\n<li>Redis</li>\n</ol>\n<p><strong>解决方案</strong></p>\n<p>使用redis管理负载均衡中多个tomcat的session.(Redis共享session)</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093811946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>如何实现Redis管理Session</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093611617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>配置步骤</strong></p>\n<ol>\n<li>tomcat使用redis管理session的jar</li>\n</ol>\n<p>将jar拷贝tomcat中lib</p>\n<ol start=\"2\">\n<li>配置tomcat的session管理方式为RedisSessionManager</li>\n</ol>\n<pre><code class=\"language-xml\">1. tomcat 配置文件context.xml\n\n&lt;!--注册session管理工具--&gt;\n&lt;Manager className=&quot;session管理工具全类名&quot;\n         host=&quot;redis的ip地址&quot;\n         port=&quot;端口&quot;\n         maxInactiveInterval=&quot;session存活时间 秒 1800&quot; 秒\n         /&gt;\n\n&lt;!--将session管理工具使用在tomcat操作过程中--&gt;\n&lt;Valve className=&quot;RedisSessionHandlerValve在tomcat中使用session管理工具&quot;/&gt;\n</code></pre>\n<p><strong>重启两个tomcat</strong></p>\n<h4 id=\"缓存问题\">缓存问题</h4>\n<ol>\n<li>\n<p>缓存穿透</p>\n</li>\n<li>\n<p>缓存雪崩</p>\n<pre><code>User\n\n根据主键查询 \n\nkey\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n1W  -id  缓存中都没有 \n\n2000个查询  每秒 可以认为是安全的\n</code></pre>\n</li>\n</ol>\n<h5 id=\"缓存穿透\">缓存穿透</h5>\n<p>缓存击穿  大量不存在的key攻击</p>\n<p>只需要极少的空间就可以判断一个元素是不是在一个集合之内，这正好是我们所需要的场景啊：判断key是否存在<br />\n<img src=\"https://img-blog.csdnimg.cn/2019082009405750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n解决方案</p>\n<ol>\n<li>\n<p>空值缓存 （非恶意攻击）</p>\n<pre><code>key  value\n-1   null\n</code></pre>\n</li>\n<li>\n<p>布隆过滤器</p>\n<p>可以判断key是否在数据库中存在</p>\n<p>缺点：可能会判断出错 概率不高 但是会</p>\n</li>\n</ol>\n<h5 id=\"缓存雪崩\">缓存雪崩</h5>\n<p>微博</p>\n<pre><code>key = 鹿晗微博1  value = 相关信息 评论  追评 点赞 等\nkey = 鹿晗微博2  value = 相关信息 评论  追评 点赞 等\nkey = 鹿晗微博3  value = 相关信息 评论  追评 点赞 等\nkey = 鹿晗微博4  value = 相关信息 评论  追评 点赞 等\nkey = 鹿晗微博5  value = 相关信息 评论  追评 点赞 等\nkey = 吃瓜群众1 \nkey = 吃瓜群众2 \nkey = 吃瓜群众3 \nkey = 吃瓜群众4 \nkey = 吃瓜群众5\n\n上千万key 这些key一定会设置失效 失效时间设置的不合理  同一时间大量key过期了（500W）  如果发生在平时 无所谓\n不巧的是  上热搜了 突然间 大量的用户来访问 相关的信息\n</code></pre>\n<p>大量key同一时间失效 将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820094117131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>大量流量  且数据失效  导致不存在的数据每次请求都要到存储层去查询  一模一样的SQL   数据库崩溃</p>\n<ol>\n<li>合理的设置过期时间  单体架构</li>\n<li>分布式锁</li>\n<li>多级缓存</li>\n</ol>\n<p>分布式的锁，谁获得了这把锁，谁就可以访问数据库</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820094139437.png\" alt=\"在这里插入图片描述\" /></p>\n<p>大型项目中</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820094222330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>如果说用户查不到数据  降级服务</p>\n<ol>\n<li>先等着  两三秒</li>\n<li>能直接  返回固定数据</li>\n<li>等等</li>\n</ol>\n<h3 id=\"7redis-分布式锁\">7、Redis 分布式锁</h3>\n<h4 id=\"什么是分布式锁\">什么是分布式锁</h4>\n<p>一种逻辑处理</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820094239766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"redis-分布式锁\">Redis 分布式锁</h4>\n<p>分布式锁本质上要实现的目标就是在 Redis 里面占一个“茅坑”，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。</p>\n<p>占坑一般是使用 <strong>setnx(set if not exists) 指令</strong>，只允许被一个客户端占坑。先来先占， 用完了，再调用 del 指令释放茅坑。</p>\n<pre><code>// 这里的冒号:就是一个普通的字符，没特别含义，它可以是任意其它字符，不要误解\n&gt; setnx lock:codehole true\nOK\n... do something critical ...\n&gt; del lock:codehole\n(integer) 1\n</code></pre>\n<p>但是有个问题，如果逻辑执行到中间出现异常了，可能会导致 del 指令没有被调用，这样就会陷入死锁，锁永远得不到释放。</p>\n<p>于是我们在拿到锁之后，再给<strong>锁加上一个过期时间</strong>，比如 5s，这样即使中间出现异常也可以保证 5 秒之后锁会自动释放。</p>\n<pre><code>&gt; setnx lock:codehole true\nOK\n&gt; expire lock:codehole 5\n... do something critical ...\n&gt; del lock:codehole\n(integer) 1\n</code></pre>\n<p>但是以上逻辑还有问题。如果在 setnx 和 expire 之间服务器进程突然挂掉了，可能是因为机器掉电或者是被人为杀掉的，就会导致 expire 得不到执行，也会造成死锁。</p>\n<p>这种问题的根源就在于 setnx 和 expire 是两条指令而不是原子指令。如果这两条指令可以一起执行就不会出现问题。也许你会想到用 Redis 事务来解决。但是这里不行，因为 expire 是依赖于 setnx 的执行结果的，如果 setnx 没抢到锁，expire 是不应该执行的。事务里没有 if-else 分支逻辑，事务的特点是一口气执行，要么全部执行要么一个都不执行。</p>\n<p>为了解决这个疑难，Redis 开源社区涌现了一堆分布式锁的 library，专门用来解决这个问题。实现方法极为复杂，小白用户一般要费很大的精力才可以搞懂。如果你需要使用分布式锁，意味着你不能仅仅使用 Jedis 或者 redis-py 就行了，还得引入分布式锁的 library。</p>\n<p><strong>为了治理这个乱象，Redis 2.8 版本中作者加入了 set 指令的扩展参数，使得 setnx 和 expire 指令可以一起执行，彻底解决了分布式锁的乱象。从此以后所有的第三方分布式锁 library 可以休息了。</strong></p>\n<pre><code>&gt; set lock:codehole true ex 5 nx\nOK\n... do something critical ...\n&gt; del lock:codehole\n</code></pre>\n<p>上面这个指令就是 setnx 和 expire 组合在一起的原子指令，它就是分布式锁的奥义所在。</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:40:11', '2022-05-21 18:17:42');
INSERT INTO `tb_article` VALUES (168, 1, 4, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8728', 'Java随机生成【用户对象】：中文姓名、全国随机省市居住地、随机邮箱、手机号、注册时间工具类', '<p>﻿### 话不多说，先上工具类，下面再解释：<br />\nJava随机生成【用户对象】：<br />\n中文姓名、全国随机省市居住地、随机邮箱、手机号、注册时间<br />\nGenerateUserUtil.java工具类</p>\n<pre><code class=\"language-java\">package com.macw.util;\n\nimport com.macw.entity.User;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Random;\n\n/**\n * @author 超伟\n */\npublic class GenerateUserUtil {\n\n    private static final String place[][] = {\n            {&quot;北京&quot;, &quot;市辖区&quot;, &quot;市辖县&quot;},\n            {&quot;天津&quot;, &quot;市辖区&quot;, &quot;市辖县&quot;},\n            {&quot;安徽&quot;, &quot;安庆市&quot;, &quot;蚌埠市&quot;, &quot;亳州市&quot;, &quot;巢湖市&quot;, &quot;池州市&quot;, &quot;滁州市&quot;, &quot;阜阳市&quot;, &quot;合肥市&quot;, &quot;淮北市&quot;, &quot;淮南市&quot;, &quot;黄山市&quot;, &quot;六安市&quot;, &quot;马鞍山市&quot;, &quot;宿州市&quot;, &quot;铜陵市&quot;, &quot;芜湖市&quot;, &quot;宣城市&quot;},\n            {&quot;澳门&quot;, &quot;澳门&quot;},\n            {&quot;香港&quot;, &quot;香港&quot;},\n            {&quot;福建&quot;, &quot;福州市&quot;, &quot;龙岩市&quot;, &quot;南平市&quot;, &quot;宁德市&quot;, &quot;莆田市&quot;, &quot;泉州市&quot;, &quot;厦门市&quot;, &quot;漳州市&quot;},\n            {&quot;甘肃&quot;, &quot;白银市&quot;, &quot;定西市&quot;, &quot;甘南藏族自治州&quot;, &quot;嘉峪关市&quot;, &quot;金昌市&quot;, &quot;酒泉市&quot;, &quot;兰州市&quot;, &quot;临夏回族自治州&quot;, &quot;陇南市&quot;, &quot;平凉市&quot;, &quot;庆阳市&quot;, &quot;天水市&quot;, &quot;武威市&quot;, &quot;张掖市&quot;},\n            {&quot;广东&quot;, &quot;潮州市&quot;, &quot;东莞市&quot;, &quot;佛山市&quot;, &quot;广州市&quot;, &quot;河源市&quot;, &quot;惠州市&quot;, &quot;江门市&quot;, &quot;揭阳市&quot;, &quot;茂名市&quot;, &quot;梅州市&quot;, &quot;清远市&quot;, &quot;汕头市&quot;, &quot;汕尾市&quot;, &quot;韶关市&quot;, &quot;深圳市&quot;, &quot;阳江市&quot;, &quot;云浮市&quot;, &quot;湛江市&quot;, &quot;肇庆市&quot;, &quot;中山市&quot;, &quot;珠海市&quot;},\n            {&quot;广西&quot;, &quot;百色市&quot;, &quot;北海市&quot;, &quot;崇左市&quot;, &quot;防城港市&quot;, &quot;贵港市&quot;, &quot;桂林市&quot;, &quot;河池市&quot;, &quot;贺州市&quot;, &quot;来宾市&quot;, &quot;柳州市&quot;, &quot;南宁市&quot;, &quot;钦州市&quot;, &quot;梧州市&quot;, &quot;玉林市&quot;},\n            {&quot;贵州&quot;, &quot;安顺市&quot;, &quot;毕节地区&quot;, &quot;贵阳市&quot;, &quot;六盘水市&quot;, &quot;黔东南苗族侗族自治州&quot;, &quot;黔南布依族苗族自治州&quot;, &quot;黔西南布依族苗族自治州&quot;, &quot;铜仁地区&quot;, &quot;遵义市&quot;},\n            {&quot;海南&quot;, &quot;海口市&quot;, &quot;三亚市&quot;, &quot;省直辖县级行政区划&quot;},\n            {&quot;河北&quot;, &quot;保定市&quot;, &quot;沧州市&quot;, &quot;承德市&quot;, &quot;邯郸市&quot;, &quot;衡水市&quot;, &quot;廊坊市&quot;, &quot;秦皇岛市&quot;, &quot;石家庄市&quot;, &quot;唐山市&quot;, &quot;邢台市&quot;, &quot;张家口市&quot;},\n            {&quot;河南&quot;, &quot;安阳市&quot;, &quot;鹤壁市&quot;, &quot;焦作市&quot;, &quot;开封市&quot;, &quot;洛阳市&quot;, &quot;漯河市&quot;, &quot;南阳市&quot;, &quot;平顶山市&quot;, &quot;濮阳市&quot;, &quot;三门峡市&quot;, &quot;商丘市&quot;, &quot;新乡市&quot;, &quot;信阳市&quot;, &quot;许昌市&quot;, &quot;郑州市&quot;, &quot;周口市&quot;, &quot;驻马店市&quot;},\n            {&quot;黑龙江&quot;, &quot;大庆市&quot;, &quot;大兴安岭地区&quot;, &quot;哈尔滨市&quot;, &quot;鹤岗市&quot;, &quot;黑河市&quot;, &quot;鸡西市&quot;, &quot;佳木斯市&quot;, &quot;牡丹江市&quot;, &quot;七台河市&quot;, &quot;齐齐哈尔市&quot;, &quot;双鸭山市&quot;, &quot;绥化市&quot;, &quot;伊春市&quot;},\n            {&quot;湖北&quot;, &quot;鄂州市&quot;, &quot;恩施土家族苗族自治州&quot;, &quot;黄冈市&quot;, &quot;黄石市&quot;, &quot;荆门市&quot;, &quot;荆州市&quot;, &quot;十堰市&quot;, &quot;随州市&quot;, &quot;武汉市&quot;, &quot;咸宁市&quot;, &quot;襄樊市&quot;, &quot;孝感市&quot;, &quot;宜昌市&quot;},\n            {&quot;湖南&quot;, &quot;长沙市&quot;, &quot;常德市&quot;, &quot;郴州市&quot;, &quot;衡阳市&quot;, &quot;怀化市&quot;, &quot;娄底市&quot;, &quot;邵阳市&quot;, &quot;湘潭市&quot;, &quot;湘西土家族苗族自治州&quot;, &quot;益阳市&quot;, &quot;永州市&quot;, &quot;岳阳市&quot;, &quot;张家界市&quot;, &quot;株洲市&quot;},\n            {&quot;吉林&quot;, &quot;白城市&quot;, &quot;白山市&quot;, &quot;长春市&quot;, &quot;吉林市&quot;, &quot;辽源市&quot;, &quot;四平市&quot;, &quot;松原市&quot;, &quot;通化市&quot;, &quot;延边朝鲜族自治州&quot;},\n            {&quot;江苏&quot;, &quot;常州市&quot;, &quot;淮安市&quot;, &quot;连云港市&quot;, &quot;南京市&quot;, &quot;南通市&quot;, &quot;苏州市&quot;, &quot;宿迁市&quot;, &quot;泰州市&quot;, &quot;无锡市&quot;, &quot;徐州市&quot;, &quot;盐城市&quot;, &quot;扬州市&quot;, &quot;镇江市&quot;},\n            {&quot;江西&quot;, &quot;抚州市&quot;, &quot;赣州市&quot;, &quot;吉安市&quot;, &quot;景德镇市&quot;, &quot;九江市&quot;, &quot;南昌市&quot;, &quot;萍乡市&quot;, &quot;上饶市&quot;, &quot;新余市&quot;, &quot;宜春市&quot;, &quot;鹰潭市&quot;},\n            {&quot;辽宁&quot;, &quot;鞍山市&quot;, &quot;本溪市&quot;, &quot;朝阳市&quot;, &quot;大连市&quot;, &quot;丹东市&quot;, &quot;抚顺市&quot;, &quot;阜新市&quot;, &quot;葫芦岛市&quot;, &quot;锦州市&quot;, &quot;辽阳市&quot;, &quot;盘锦市&quot;, &quot;沈阳市&quot;, &quot;铁岭市&quot;, &quot;营口市&quot;},\n            {&quot;内蒙古&quot;, &quot;阿拉善盟&quot;, &quot;巴彦淖尔市&quot;, &quot;包头市&quot;, &quot;赤峰市&quot;, &quot;鄂尔多斯市&quot;, &quot;呼和浩特市&quot;, &quot;呼伦贝尔市&quot;, &quot;通辽市&quot;, &quot;乌海市&quot;, &quot;乌兰察布市&quot;, &quot;锡林郭勒盟&quot;, &quot;兴安盟&quot;},\n            {&quot;宁夏&quot;, &quot;固原市&quot;, &quot;石嘴山市&quot;, &quot;吴忠市&quot;, &quot;银川市&quot;, &quot;中卫市&quot;},\n            {&quot;青海&quot;, &quot;果洛藏族自治州&quot;, &quot;海北藏族自治州&quot;, &quot;海东地区&quot;, &quot;海南藏族自治州&quot;, &quot;海西蒙古族藏族自治州&quot;, &quot;黄南藏族自治州&quot;, &quot;西宁市&quot;, &quot;玉树藏族自治州&quot;},\n            {&quot;山东&quot;, &quot;滨州市&quot;, &quot;德州市&quot;, &quot;东营市&quot;, &quot;菏泽市&quot;, &quot;济南市&quot;, &quot;济宁市&quot;, &quot;莱芜市&quot;, &quot;聊城市&quot;, &quot;临沂市&quot;, &quot;青岛市&quot;, &quot;日照市&quot;, &quot;泰安市&quot;, &quot;威海市&quot;, &quot;潍坊市&quot;, &quot;烟台市&quot;, &quot;枣庄市&quot;, &quot;淄博市&quot;},\n            {&quot;山西&quot;, &quot;长治市&quot;, &quot;大同市&quot;, &quot;晋城市&quot;, &quot;晋中市&quot;, &quot;临汾市&quot;, &quot;吕梁市&quot;, &quot;朔州市&quot;, &quot;太原市&quot;, &quot;忻州市&quot;, &quot;阳泉市&quot;, &quot;运城市&quot;},\n            {&quot;陕西&quot;, &quot;安康市&quot;, &quot;宝鸡市&quot;, &quot;汉中市&quot;, &quot;商洛市&quot;, &quot;铜川市&quot;, &quot;渭南市&quot;, &quot;西安市&quot;, &quot;咸阳市&quot;, &quot;延安市&quot;, &quot;榆林市&quot;},\n            {&quot;四川&quot;, &quot;阿坝藏族羌族自治州&quot;, &quot;巴中市&quot;, &quot;成都市&quot;, &quot;达州市&quot;, &quot;德阳市&quot;, &quot;甘孜藏族自治州&quot;, &quot;广安市&quot;, &quot;广元市&quot;, &quot;乐山市&quot;, &quot;凉山彝族自治州&quot;, &quot;泸州市&quot;, &quot;眉山市&quot;, &quot;绵阳市&quot;, &quot;内江市&quot;, &quot;南充市&quot;, &quot;攀枝花市&quot;, &quot;遂宁市&quot;, &quot;雅安市&quot;, &quot;宜宾市&quot;, &quot;资阳市&quot;, &quot;自贡市&quot;},\n            {&quot;西藏&quot;, &quot;阿里地区&quot;, &quot;昌都地区&quot;, &quot;拉萨市&quot;, &quot;林芝地区&quot;, &quot;那曲地区&quot;, &quot;日喀则地区&quot;, &quot;山南地区&quot;},\n            {&quot;新疆&quot;, &quot;阿克苏地区&quot;, &quot;阿勒泰地区&quot;, &quot;巴音郭楞蒙古自治州&quot;, &quot;博尔塔拉蒙古自治州&quot;, &quot;昌吉回族自治州&quot;, &quot;哈密地区&quot;, &quot;和田地区&quot;, &quot;喀什地区&quot;, &quot;克拉玛依市&quot;, &quot;克孜勒苏柯尔克孜自治州&quot;, &quot;塔城地区&quot;, &quot;吐鲁番地区&quot;, &quot;乌鲁木齐市&quot;, &quot;伊犁哈萨克自治州&quot;, &quot;自治区直辖县级行政区划&quot;},\n            {&quot;云南&quot;, &quot;保山市&quot;, &quot;楚雄彝族自治州&quot;, &quot;大理白族自治州&quot;, &quot;德宏傣族景颇族自治州&quot;, &quot;迪庆藏族自治州&quot;, &quot;红河哈尼族彝族自治州&quot;, &quot;昆明市&quot;, &quot;丽江市&quot;, &quot;临沧市&quot;, &quot;怒江僳僳族自治州&quot;, &quot;普洱市&quot;, &quot;曲靖市&quot;, &quot;文山壮族苗族自治州&quot;, &quot;西双版纳傣族自治州&quot;, &quot;玉溪市&quot;, &quot;昭通市&quot;},\n            {&quot;浙江&quot;, &quot;杭州市&quot;, &quot;湖州市&quot;, &quot;嘉兴市&quot;, &quot;金华市&quot;, &quot;丽水市&quot;, &quot;宁波市&quot;, &quot;衢州市&quot;, &quot;绍兴市&quot;, &quot;台州市&quot;, &quot;温州市&quot;, &quot;舟山市&quot;},\n            {&quot;重庆&quot;, &quot;市辖区&quot;, &quot;市辖县&quot;, &quot;县级市&quot;},\n            {&quot;台湾&quot;, &quot;台北市&quot;, &quot;高雄市&quot;, &quot;基隆市&quot;, &quot;台中市&quot;, &quot;台南市&quot;, &quot;新竹市&quot;, &quot;嘉义市&quot;},\n    };\n\n    private static String base = &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;;\n    private static String firstName = &quot;赵钱孙李周吴郑王冯陈褚卫蒋沈韩杨朱秦尤许何吕施张孔曹严华金魏陶姜戚谢邹喻柏水窦章云苏潘葛奚范彭郎鲁韦昌马苗凤花方俞任袁柳酆鲍史唐费廉岑薛雷贺倪汤滕殷罗毕郝邬安常乐于时傅皮卞齐康伍余元卜顾孟平黄和穆萧尹姚邵湛汪祁毛禹狄米贝明臧计伏成戴谈宋茅庞熊纪舒屈项祝董梁杜阮蓝闵席季麻强贾路娄危江童颜郭梅盛林刁钟徐邱骆高夏蔡田樊胡凌霍虞万支柯咎管卢莫经房裘缪干解应宗宣丁贲邓郁单杭洪包诸左石崔吉钮龚程嵇邢滑裴陆荣翁荀羊於惠甄魏加封芮羿储靳汲邴糜松井段富巫乌焦巴弓牧隗山谷车侯宓蓬全郗班仰秋仲伊宫宁仇栾暴甘钭厉戎祖武符刘姜詹束龙叶幸司韶郜黎蓟薄印宿白怀蒲台从鄂索咸籍赖卓蔺屠蒙池乔阴郁胥能苍双闻莘党翟谭贡劳逄姬申扶堵冉宰郦雍却璩桑桂濮牛寿通边扈燕冀郏浦尚农温别庄晏柴瞿阎充慕连茹习宦艾鱼容向古易慎戈廖庚终暨居衡步都耿满弘匡国文寇广禄阙东殴殳沃利蔚越夔隆师巩厍聂晁勾敖融冷訾辛阚那简饶空曾毋沙乜养鞠须丰巢关蒯相查后江红游竺权逯盖益桓公万俟司马上官欧阳夏侯诸葛闻人东方赫连皇甫尉迟公羊澹台公冶宗政濮阳淳于仲孙太叔申屠公孙乐正轩辕令狐钟离闾丘长孙慕容鲜于宇文司徒司空亓官司寇仉督子车颛孙端木巫马公西漆雕乐正壤驷公良拓拔夹谷宰父谷粱晋楚阎法汝鄢涂钦段干百里东郭南门呼延归海羊舌微生岳帅缑亢况后有琴梁丘左丘东门西门商牟佘佴伯赏南宫墨哈谯笪年爱阳佟第五言福百家姓续&quot;;\n    private static String girl = &quot;秀娟英华慧巧美娜静淑惠珠翠雅芝玉萍红娥玲芬芳燕彩春菊兰凤洁梅琳素云莲真环雪荣爱妹霞香月莺媛艳瑞凡佳嘉琼勤珍贞莉桂娣叶璧璐娅琦晶妍茜秋珊莎锦黛青倩婷姣婉娴瑾颖露瑶怡婵雁蓓纨仪荷丹蓉眉君琴蕊薇菁梦岚苑婕馨瑗琰韵融园艺咏卿聪澜纯毓悦昭冰爽琬茗羽希宁欣飘育滢馥筠柔竹霭凝晓欢霄枫芸菲寒伊亚宜可姬舒影荔枝思丽 &quot;;\n    private static String boy = &quot;伟刚勇毅俊峰强军平保东文辉力明永健世广志义兴良海山仁波宁贵福生龙元全国胜学祥才发武新利清飞彬富顺信子杰涛昌成康星光天达安岩中茂进林有坚和彪博诚先敬震振壮会思群豪心邦承乐绍功松善厚庆磊民友裕河哲江超浩亮政谦亨奇固之轮翰朗伯宏言若鸣朋斌梁栋维启克伦翔旭鹏泽晨辰士以建家致树炎德行时泰盛雄琛钧冠策腾楠榕风航弘&quot;;\n    private static final String[] email_suffix = &quot;@gmail.com,@yahoo.com,@msn.com,@hotmail.com,@aol.com,@ask.com,@live.com,@qq.com,@0355.net,@163.com,@163.net,@263.net,@3721.net,@yeah.net,@googlemail.com,@126.com,@sina.com,@sohu.com,@yahoo.com.cn&quot;.split(&quot;,&quot;);\n    private static String[] sexs = {&quot;男&quot;, &quot;女&quot;};\n\n    private static int getNum(int start, int end) {\n        return (int) (Math.random() * (end - start + 1) + start);\n    }\n//    获得随机数的方法\n\n    private static int getRandom(int length) {\n        Random random = new Random();\n        return random.nextInt(length);\n    }\n\n\n    /**\n     * 返回Email\n     *\n     * @param lMin 最小长度\n     * @param lMax 最大长度\n     * @return\n     */\n    private static String getEmail(int lMin, int lMax) {\n        int length = getNum(lMin, lMax);\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i &lt; length; i++) {\n            int number = (int) (Math.random() * base.length());\n            sb.append(base.charAt(number));\n        }\n        sb.append(email_suffix[(int) (Math.random() * email_suffix.length)]);\n        return sb.toString();\n    }\n\n    /**\n     * 返回手机号码\n     */\n    private static String[] telFirst = &quot;134,135,136,137,138,139,150,151,152,157,158,159,130,131,132,155,156,133,153&quot;.split(&quot;,&quot;);\n\n    private static String getTel() {\n        int index = getNum(0, telFirst.length - 1);\n        String first = telFirst[index];\n        String second = String.valueOf(getNum(1, 888) + 10000).substring(1);\n        String third = String.valueOf(getNum(1, 9100) + 10000).substring(1);\n        return first + second + third;\n    }\n\n    /**\n     * 返回中文姓名\n     */\n    private static String name_sex = &quot;&quot;;\n\n    private static String getChineseName() {\n        int index = getNum(0, firstName.length() - 1);\n        String first = firstName.substring(index, index + 1);\n        int sex = getNum(0, 1);\n        String str = boy;\n        int length = boy.length();\n        if (sex == 0) {\n            str = girl;\n            length = girl.length();\n            name_sex = &quot;女&quot;;\n        } else {\n            name_sex = &quot;男&quot;;\n        }\n        index = getNum(0, length - 1);\n        String second = str.substring(index, index + 1);\n        int hasThird = getNum(0, 1);\n        String third = &quot;&quot;;\n        if (hasThird == 1) {\n            index = getNum(0, length - 1);\n            third = str.substring(index, index + 1);\n        }\n        return first + second + third;\n    }\n\n\n    /**\n     * 生成随机时间\n     *\n     * @param beginDate\n     * @param endDate\n     * @return\n     */\n    private static Date randomDate(String beginDate, String endDate) {\n\n        try {\n\n            SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);\n//构造开始日期 \n            Date start = format.parse(beginDate);\n//构造结束日期 \n            Date end = format.parse(endDate);\n\n//getTime()表示返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 \n\n            if (start.getTime() &gt;= end.getTime()) {\n\n                return null;\n\n            }\n\n            long date = random(start.getTime(), end.getTime());\n\n            return new Date(date);\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n\n        }\n\n        return null;\n\n    }\n\n    private static long random(long begin, long end) {\n\n        long rtn = begin + (long) (Math.random() * (end - begin));\n\n        //如果返回的是开始时间和结束时间，则递归调用本函数查找随机值 \n\n        if (rtn == begin || rtn == end) {\n\n            return random(begin, end);\n\n        }\n\n        return rtn;\n\n    }\n\n    /**\n     * 生成用户对象\n     *\n     * @return\n     */\n    public static User getUser() {\n        User cmfzUser = new User();\n        cmfzUser.setUserName(getChineseName());\n        cmfzUser.setUserNickname(&quot;大圣&quot;);\n        cmfzUser.setUserTelphone(getTel());\n        cmfzUser.setUserPassword(&quot;123456&quot;);\n        cmfzUser.setUserStatus(0);\n        cmfzUser.setGuruId(1);\n        cmfzUser.setUserSex(sexs[getRandom(sexs.length)]);\n        String[] strings = place[getRandom(place.length)];\n        cmfzUser.setUserProvince(strings[0]);\n        cmfzUser.setUserCity(strings[getRandom(strings.length)]);\n        cmfzUser.setUserAutograph(&quot;岁月静好&quot;);\n        cmfzUser.setUserImage(&quot;hhh.jpg&quot;);\n        cmfzUser.setUserCreateDate(randomDate(&quot;2019-03-01&quot;, &quot;2019-8-15&quot;));\n        return cmfzUser;\n    }\n\n}\n\n</code></pre>\n<p>这里我所创建的用户对象是：</p>\n<pre><code class=\"language-java\">\n/**\n * @author macw\n * @since 2019-08-13\n */\n@Data\n@EqualsAndHashCode(callSuper = false)\n@Accessors(chain = true)\n@TableName(&quot;cmfz_user&quot;)\npublic class User implements Serializable {\n\n    @TableId(value = &quot;user_id&quot;, type = IdType.AUTO)\n    @Excel(name = &quot;用户编号&quot;)\n    private Integer userId;\n    @Excel(name = &quot;手机号&quot;)\n    private String userTelphone;\n    @Excel(name = &quot;密码&quot;)\n    private String userPassword;\n    @Excel(name = &quot;头像&quot;)\n    private String userImage;\n    @Excel(name = &quot;用户昵称&quot;)\n    private String userNickname;\n    @Excel(name = &quot;用户名&quot;)\n    private String userName;\n    @Excel(name = &quot;性别&quot;)\n    private String userSex;\n    @Excel(name = &quot;个性签名&quot;)\n    private String userAutograph;\n    @Excel(name = &quot;省份&quot;)\n    private String userProvince;\n    @Excel(name = &quot;城市&quot;)\n    private String userCity;\n    @Excel(name = &quot;所属小组&quot;)\n    private Integer guruId;\n    @Excel(name = &quot;用户状态&quot;,replace = {&quot;男_1&quot;,&quot;女_0&quot;})\n    private Integer userStatus;\n    @TableField(&quot;user_create_date&quot;)\n    @Excel(name = &quot;注册时间&quot;)\n    private Date userCreateDate;\n    @TableField(exist = false)\n    private Integer count;\n\n}\n\n</code></pre>\n<p>然后就可以直接调用生成十万条用户数据了！<br />\n调用测试类如下：</p>\n<pre><code class=\"language-java\">  @Test\n    public void test1(){\n        SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n        long start = System.currentTimeMillis();\n        System.out.println(&quot;-----&quot;+date);\n        int insert = 0;\n        for (int i = 0; i &lt; 10000; i++) {\n            User user = GenerateUserUtil.getUser();\n            insert += userMapper.insert(user);\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;成功添加： &quot;+insert+&quot; 条数据，所用时间：&quot;+(end-start)+&quot;ms&quot;);\n    }\n</code></pre>\n<p>如此，就可轻轻松松向数据库添加十万条数据了，</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:40:35', '2022-05-21 18:17:29');
INSERT INTO `tb_article` VALUES (169, 1, 8, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5384', 'MySQL数据库4种常用优化方式，sql语句书写优化规范', '<p>﻿<strong>MySQL数据库优化</strong></p>\n<p><a href=\"#引言\">1. 引言</a></p>\n<p><a href=\"#数据库优化手段\">2. 数据库优化手段</a></p>\n<p><a href=\"#优化储备知识\">3. 优化储备知识</a></p>\n<p><a href=\"#慢查询\">3.1 慢查询</a></p>\n<p><a href=\"#执行计划\">3.2 执行计划</a></p>\n<p><a href=\"#索引优化\">4. 索引优化</a></p>\n<p><a href=\"#索引语法\">4.1 索引语法</a></p>\n<p><a href=\"#索引应用场景\">4.2 索引应用场景</a></p>\n<p><a href=\"#查询缓存\">5. 查询缓存</a></p>\n<p><a href=\"#sql优化\">6. SQL优化</a></p>\n<p><a href=\"#读写分离\">7. 读写分离</a></p>\n<p><a href=\"#centos中linux的安装\">7.1 CentOS中linux的安装</a></p>\n<p><a href=\"#mysql主从复制\">7.2 MySQL主从复制</a></p>\n<p><a href=\"#读写分离基于mycat实现\">7.3 读写分离(基于MyCat实现)</a></p>\n<h1 id=\"引言\">引言</h1>\n<p>实际项目中，我们的数据往往存储在数据库中，但是由于数据库本身是持久化存储，数据的查询速度受到磁盘IO瓶颈的限制，同时，随着数据量的增长，数据的查询也会因为单表数据量的巨大，影响查询速度。所以我们需要对数据库进行优化，提高系统的响应效率。</p>\n<h1 id=\"数据库优化手段\">数据库优化手段</h1>\n<ol>\n<li>\n<p>索引优化。</p>\n</li>\n<li>\n<p>添加查询缓存。</p>\n</li>\n<li>\n<p>优化数据库SQL语句。</p>\n</li>\n<li>\n<p>数据库Cluster(搭建数据库集群环境)。</p>\n</li>\n</ol>\n<h1 id=\"优化储备知识\">优化储备知识</h1>\n<h2 id=\"31-慢查询\">3.1 慢查询</h2>\n<blockquote>\n<p>慢查询就是查看我们每条sql语句查询所用的时间，<br />\n开启慢查询的目的是将我们每次查询所用的时间记录在日志里进行观察检测，如果检测到查询的时间到达超过一定的预定时间（比如查询时间超过1秒的语句），将被记录下来进行优化！</p>\n</blockquote>\n<ol>\n<li>查看慢查询的信息状态</li>\n</ol>\n<blockquote>\n<p>show variables like \'%quer%\';</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818165456174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>开启慢查询</li>\n</ol>\n<blockquote>\n<p>set global slow_query_log=on;</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818170417988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>修改慢查询最短时间为1s</li>\n</ol>\n<blockquote>\n<p>set GLOBAL long_query_time = 1;</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818170539243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>查看MySQL执行过的慢查询SQL语句。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818170706476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"32-执行计划\">3.2 执行计划</h2>\n<p>补充： 数据库查询优化中需要了解MySQL执行计划命令，查看sql的执行效率</p>\n<p>进行一条查询语句，点下左上角的解释看语句解释：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190818170730136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"索引优化\">索引优化</h1>\n<h2 id=\"41-索引语法\">4.1 索引语法</h2>\n<ol>\n<li>索引的作用</li>\n</ol>\n<blockquote>\n<p>加快以索引字段为条件的查询效率。</p>\n</blockquote>\n<ol>\n<li>创建索引</li>\n</ol>\n<blockquote>\n<p>create index  索引名字 on 表(字段)</p>\n</blockquote>\n<ol>\n<li>删除索引</li>\n</ol>\n<blockquote>\n<p>drop index  索引名字</p>\n</blockquote>\n<ol>\n<li>查询某张表创建了哪些索引</li>\n</ol>\n<blockquote>\n<p>Show index from 表名;</p>\n</blockquote>\n<ol>\n<li>索引的特点</li>\n</ol>\n<blockquote>\n<p>①索引会占用存储空间，虽然比较少，但是也占用了。</p>\n</blockquote>\n<blockquote>\n<p>②MySQL会自动为primary 主键列和unique 唯一列自动增加索引。</p>\n</blockquote>\n<blockquote>\n<p>③MySQL数据库对数据做DML操作时，需要同时做维护索引的操作。</p>\n</blockquote>\n<blockquote>\n<p><strong>隐含之意，就是索引会降低数据库增删改的效率。</strong></p>\n</blockquote>\n<ol>\n<li>使用原则：</li>\n</ol>\n<blockquote>\n<p>一般会对sql中的where条件字段或者order by字段建立索引。</p>\n</blockquote>\n<h2 id=\"42-索引应用场景\">4.2 索引应用场景</h2>\n<p>实际项目中，如果从业务角度出发，发现经常会用到某个字段，对表数据进行查询，或者根据经常用到某个字段的排序，则该数据是需要增加索引的。</p>\n<h1 id=\"在这里插入图片描述查询缓存\"><img src=\"https://img-blog.csdnimg.cn/20190818171131437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n查询缓存</h1>\n<ol>\n<li>在数据库操作对象DAO处增加查询缓存。</li>\n</ol>\n<blockquote>\n<p><em>参考Ehcache缓存，或者MyBatis+Ehcache整合方案、Hibernate二级缓存Ehcache。</em></p>\n</blockquote>\n<ol start=\"2\">\n<li>需要注意的问题是，要注意数据的一致性，所以缓存思路如下：</li>\n</ol>\n<blockquote>\n<p>① 只对查询结果进行缓存</p>\n</blockquote>\n<blockquote>\n<p>②<br />\n缓存结果存放要以业务逻辑相关为划分单位。比如，如果是单表，则可以创建一个缓存区域，与该表对应，如果业务中涉及到表连接操作，要将查询结果缓存在这多张表的查询结果都要缓存在对应的一个缓存区域中。</p>\n</blockquote>\n<ol start=\"3\">\n<li>\n<p>当执行增删改的时候，为了避免出现脏数据。</p>\n</li>\n<li>\n<p>基于以上的特点，缓存原则是对那些查询需求远大于增删改需求的数据，进行缓存。</p>\n</li>\n</ol>\n<blockquote>\n<p>例如：新闻网站的首页数据、电商的类别数据等。</p>\n</blockquote>\n<h1 id=\"sql优化\">SQL优化</h1>\n<ol>\n<li>\n<p>尽量不要在要给在SQL语句的where子句中使用函数，这样会使索引失效。</p>\n</li>\n<li>\n<p>如果已经确定查询结果只有一条数据（当表中数据的该字段是唯一的），在查询SQL末尾增加<br />\nlimit    1，这样MySQL的查询执行引擎在找到1条数据之后就会停止搜索，提高效率。（mysql5.6之后有效）<br />\n例如：</p>\n</li>\n</ol>\n<blockquote>\n<p>select * from t_department where department_name = \'研发部\' limit 1;</p>\n</blockquote>\n<ol start=\"3\">\n<li>\n<p>模糊查询尽量使用右模糊：‘xx%’，这样可以利用上索引，而使用‘%xx’这种模糊查询会导致该查询字段上的索引失效。</p>\n</li>\n<li>\n<p>如果非要使用表连接，最好要保证连接的两个字段都是创建了索引的。</p>\n</li>\n<li>\n<p>查询的时候最好用什么数据查询什么数据，避免使用select<br />\n*,原因是数据库访问往往是远程通过网络来访问，这也就意味着，查询结果也是通过网络来传输的，如果查询了额外的无用的数据，他们会额外占用网络带宽，数据传输效率也会降低。</p>\n</li>\n<li>\n<p>尽量使用非空 not<br />\nnull，可以使用‘’空串代替null。因为‘’不占用空间，null会占用空间的。</p>\n</li>\n<li>\n<p>使用!= 或者&lt;&gt; 数据库会放弃索引。</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/2019081817164678.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"6\">\n<li>在SQL语句中不要有运算，否则MySQL会放弃索引。（mysql在执行查询时，会自动过滤当前语句，当效率大于使用索引时，则默认不使用索引）</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818171706234.png\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>\n<p>对于百万级以上的表数据，如果要做表连接查询，一定要对表先分页，然后对分页结果再做表连接。</p>\n</li>\n<li>\n<p>尽量避免大事务操作，这样会降低系统的并发能力。在满足实际业务的前提下，尽量缩短事务的边界。</p>\n</li>\n<li>\n<p>Where子句多条件and连接的情况，要把精确条件放在最先执行的位置，提高效率。Oracle中是从右至左。MySQL中是从左至右。<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081817175944.jpg\" alt=\"在这里插入图片描述\" /></p>\n</li>\n</ol>\n<h1 id=\"mysql集群环境之------读写分离主从复制\">MySql集群环境之------读写分离、主从复制</h1>\n<p>搭建MySQL的集群环境来优化查询<br />\n详细的使用搭建步骤可参考我之前文章：</p>\n<p><a href=\"https://blog.csdn.net/MacWx/article/details/98778719\"> Centos 7使用MyCat搭建 MySQL-读写分离</a></p>\n<a href=\"https://blog.csdn.net/MacWx/article/details/98777361\">\nCentos 7搭建MySQL-主从复制</a>\n', 1, '', 0, 0, 1, '2020-04-25 15:40:58', '2022-05-21 18:17:14');
INSERT INTO `tb_article` VALUES (170, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7863', 'POI简介，以及使用POI技术实现Excel文件的导入导出案例', '<p>﻿### 1、什么是POI？<br />\nApache POI 是 Apache 软件基金会的开放源码函式库，POI 提供 API 给 Java 程序对<br />\nMicrosoft Office 格式档案读和写的功能。</p>\n<p><strong>常用的两种java操作Excel技术POi和JXL的对比：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190814211200494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>POI 和 JXL 对 Excel 抽象出来的对象对比</strong><br />\n|                  |       POI        |   JXL    |<br />\n| :--------------: | :--------------: | :------: |<br />\n|    Excel 文档    |   HSSFWorkbook   | Workbook |<br />\n|  Excel 的工作表  |    HSSFSheet     |  Sheet   |<br />\n|    Excel 的行    |     HSSFRow      |    无    |<br />\n| Excel 中的单元格 |     HSSFCell     |   Cell   |<br />\n|    Excel 字体    |     HSSFFont     |          |<br />\n| Excel 单元格样式 |  HSSFCellStyle   |          |<br />\n|    Excel 颜色    |    HSSFColor     |          |<br />\n|    合并单元格    | CellRangeAddress |          |</p>\n<h3 id=\"2使用poi实现excel的导入导出\">2、使用POI实现Excel的导入导出</h3>\n<p>先来回忆一下window使用Excel和POi对Excel抽象出来的对象</p>\n<ol>\n<li>创建一个Excel文件 HSSFWorkbook</li>\n<li>创建一张工作表 HSSFSheet</li>\n<li>选中一行  HSSFRow</li>\n<li>选中一个单元格  HSSFCell</li>\n<li>在单元格中写入数据</li>\n<li>保存</li>\n</ol>\n<h4 id=\"第一个demo-excel导出\">第一个demo Excel导出</h4>\n<p><strong>1，导入POI依赖</strong></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;\n    &lt;artifactId&gt;poi&lt;/artifactId&gt;\n    &lt;version&gt;3.11&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p><strong>2，POI工具类实现导出</strong><br />\n案例1：</p>\n<pre><code class=\"language-java\">package com.macw;\n\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\nimport org.junit.Test;\n\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class PoiTest {\n\n    @Test\n    public void test1() throws IOException {\n//        1.创建一个文件对象\n        HSSFWorkbook hssfWorkbook = new HSSFWorkbook();\n\n//        2.创建一个表对象 通过文件对象创建表对象\n        HSSFSheet sheet = hssfWorkbook.createSheet(&quot;表名：excel数据表&quot;);\n\n//        3.获取行对象 下标从0开始\n        HSSFRow row = sheet.createRow(0);\n\n//        4.获取第1个单元格  下标从0开始\n        HSSFCell cell = row.createCell(0);\n\n//        5.在单元格中写入数据\n        cell.setCellValue(&quot;Hello Wolld&quot;);\n\n//        6.保存在磁盘中 流  文件名的后缀必须有.xls\n        hssfWorkbook.write(new FileOutputStream(&quot;E://demo.xls&quot;));\n    }\n}\n```java\n案例2：\n模拟从数据库查到的所有用户及用户信息导出到excel文件中\n</code></pre>\n<pre><code>@RequestMapping(&quot;/exportAll&quot;)\npublic void exportAll(HttpServletResponse resp){\n    //模拟从数据库查到的所有用户及用户信息\n    List&lt;User&gt; users = new ArrayList&lt;User&gt;();\n    User user = new User(&quot;1&quot;,&quot;张三 1&quot;,&quot;2019-8-10&quot;);\n    User user1 = new User(&quot;2&quot;,&quot;张三 2&quot;,&quot;2019-8-10&quot;);\n    User user2 = new User(&quot;3&quot;,&quot;张三 3&quot;,&quot;2019-8-10&quot;);\n    User user3 = new User(&quot;4&quot;,&quot;张三 4&quot;,&quot;2019-8-10&quot;);\n    User user4 = new User(&quot;5&quot;,&quot;张三 5&quot;,&quot;2019-8-10&quot;);\n    User user5 = new User(&quot;6&quot;,&quot;张三 6&quot;,&quot;2019-8-10&quot;);\n    User user6 = new User(&quot;7&quot;,&quot;张三 7&quot;,&quot;2019-8-10&quot;);\n    User user7 = new User(&quot;8&quot;,&quot;张三 8&quot;,&quot;2019-8-10&quot;);\n    users.add(user);\n    users.add(user1);\n    users.add(user2);\n    users.add(user3);\n    users.add(user4);\n    users.add(user5);\n    users.add(user6);\n    users.add(user7);\n    //创建工作薄\n    HSSFWorkbook workbook = new HSSFWorkbook();\n    //创建工作表\n    HSSFSheet sheet = workbook.createSheet(&quot;用户信息&quot;);\n    //设置列宽 第一个参数：列索引 第二个参数：列宽\n    sheet.setColumnWidth(2, 4500);\n    //创建导出样式\n    HSSFCellStyle cellStyle = workbook.createCellStyle();\n    //创建字体\n    HSSFFont font = workbook.createFont();\n    //设置字体颜色\n    font.setColor(HSSFFont.COLOR_RED);\n    //设置加粗\n    font.setBold(true);\n   \n    //设置字体\n    font.setFontName(&quot;宋体&quot;);\n    //设置居中\n    cellStyle.setAlignment(CellStyle.ALIGN_CENTER);\n    //管理字体样式\n    cellStyle.setFont(font);\n    //创建标题栏\n    HSSFRow row = sheet.createRow(0);\n    HSSFCell cell = null;\n    String[] titles = {&quot;编号&quot;,&quot;真实姓名&quot;,&quot;出生年月&quot;};\n    for (int i = 0; i &lt; titles.length; i++) {\n        cell = row.createCell(i);\n        cell.setCellValue(titles[i]);\n    //标题行使用样式\n        cell.setCellStyle(cellStyle);\n    }\n    for (int i = 1; i &lt;= users.size(); i++) {\n         //创建数据行对象\n        row = sheet.createRow(i);\n        //数据行第一列设值\n        cell = row.createCell(0);\n        cell.setCellValue(users.get(i-1).getUserId());\n        //数据行第二列设值\n        cell = row.createCell(1);\n        cell.setCellValue(users.get(i-1).getRealname());\n        //数据行第三列设值\n        cell = row.createCell(2);\n        cell.setCellValue(users.get(i-1).getDharmaName());\n    }\n    String fileName = &quot;用户报表(&quot;+new\n            SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date())+&quot;).xls&quot;;\n    //处理中文下载名乱码\n    try {\n        fileName = new  String(fileName.getBytes(&quot;utf-8&quot;),&quot;utf-8&quot;);\n        //设置 response\n        resp.setContentType(&quot;application/vnd.ms-excel&quot;);\n        resp.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename=&quot;+fileN\n                ame);\n       \n        workbook.write(resp.getOutputStream());\n        workbook.close();\n    } catch (Exception e) {\n    // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n}\n</code></pre>\n<h3 id=\"3poi导入\">3、POI导入</h3>\n<pre><code class=\"language-java\"> @RequestMapping(&quot;/uploadIn&quot;)\n    @ResponseBody\n    public Map uploadIn(MultipartFile multipartFile) throws IOException {\n        //输出文件名\n        logger.info(&quot;----------文件名为： &quot;+multipartFile.getOriginalFilename());\n        //1，获取流对象\n        InputStream inputStream = multipartFile.getInputStream();\n\n//        2.通过poi解析流 得到 Excel文件对象\n        HSSFWorkbook workbook = new HSSFWorkbook(inputStream);\n\n//        3.通过对象获取数据 得到表\n        HSSFSheet sheet = workbook.getSheetAt(0);\n\n//        4.通过表 得到行\n        int lastRowNum = sheet.getLastRowNum();\n        //定义计数器，计算批量导入多少条数据\n        int sum = 0;\n        for (int i = 1; i &lt;= lastRowNum; i++) {\n            Guru guru = new Guru();\n            HSSFRow row = sheet.getRow(i);\n//            获取单元格\n            double guruId = row.getCell(0).getNumericCellValue();\n            guru.setGuruId((int) guruId);\n\n            guru.setGuruName(row.getCell(1).getStringCellValue());\n            guru.setGuruImage(row.getCell(2).getStringCellValue());\n            guru.setGuruNickname(row.getCell(3).getStringCellValue());\n            guru.setGuruStatus((int) row.getCell(4).getNumericCellValue());\n            System.out.println(guru);\n			//执行添加的SQL\n            int insert = guruMapper.insert(guru);\n            //统计添加成功的条数\n            sum+=insert;\n        }\n        Map map = new HashMap();\n        map.put(&quot;flag&quot;, sum+&quot;&quot;);\n        return map;\n    }\n</code></pre>\n<p>页面代码：</p>\n<pre><code class=\"language-html\">&lt;div id=&quot;insertFile&quot; class=&quot;easyui-dialog&quot; data-options=&quot;closed:true&quot;&gt;\n    &lt;form id=&quot;insertFileForm&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;\n        上传Excel文件：&lt;input class=&quot;easyui-filebox&quot; name=&quot;multipartFile&quot;\n                         data-options=&quot;required:true,missingMessage:\'请选择文件\'&quot;/&gt;&lt;br/&gt;&lt;br/&gt;\n        &lt;a href=&quot;javascript:void(0)&quot; class=&quot;easyui-linkbutton&quot; iconCls=&quot;icon-save&quot; onClick=&quot;insertFileConfirm()&quot;&gt;上传&lt;/a&gt;\n    &lt;/form&gt;\n&lt;/div&gt;\n\n\njs代码：\n\n //批量上传的文件提交\n    function insertFileConfirm() {\n        $(&quot;#insertFileForm&quot;).form(&quot;submit&quot;, {\n            url: &quot;${pageContext.request.contextPath}/guru/uploadIn&quot;,\n            success: function (data) {\n               console.log(data);\n                alert(&quot;成功添加：&quot;+data.flag+&quot; 条数据&quot;);\n                $(&quot;#insertFile&quot;).dialog(&quot;close&quot;);\n                $(&quot;#guruManager&quot;).datagrid(&quot;reload&quot;);\n            }\n        })\n    }\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:41:41', '2022-05-21 18:16:54');
INSERT INTO `tb_article` VALUES (171, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=6523', 'Maven仓库 一键自动删除失效jar包，没事儿点点_', '<p>﻿因为网路等各种原因，使用maven仓库下载jar包可能会下载失败，或者下载一半停止，</p>\n<p>下载失效的jar包会严重影响我们程序的运行，<br />\n看着明明没问题，但是一运行就报错，而且还很难找到错误问题原因，</p>\n<p><strong>所以及时得清理失效的jar包会使我们从程序减少出错的可能；</strong></p>\n<p>如何清理失效的jar包呢，<br />\n失效的jar在我们的maven仓库 都有一个.lastUpdated结尾的后缀，、</p>\n<p>只要是有这个后缀的文件夹里面的jar包就都是失效的，</p>\n<p>下面说一个使用windows的批处理清理带.lastUpdated结尾的失效jar包的解决办法：</p>\n<p>新建一个记事本，输入一下命名：</p>\n<pre><code>@echo  off\nrem create by sunhao(sunhao.java@gmail.com)\nrem crazy coder\nset REPOSITORY_PATH=D:\\Maven\\repository\nrem 正在搜索...\nfor /f &quot;delims=&quot; %%i in (\'dir /b /s &quot;%REPOSITORY_PATH%\\*lastUpdated*&quot;\') do (\n    del /s /q %%i\n)\nrem 搜索完毕\npause\n</code></pre>\n<p>其中的：<br />\n<strong>set REPOSITORY_PATH=D:\\Maven\\repository</strong><br />\n改为你的本地仓库路径地址</p>\n<p><strong>然后将这个txt文件另存为：删除失效jar包工具没事儿点点.bat<br />\n一定要是.bat结尾的批处理文件才行啊，</strong></p>\n<p>然后就可以把 这个东西发送到桌面快捷方式，闲着没事就点点清理jar包</p>\n<p>如果双击不运行的话就右键以管理员身份打开~</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:41:44', '2022-05-21 18:16:24');
INSERT INTO `tb_article` VALUES (172, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3989', 'Redis持久化机制RDB 和AOF', '<p>﻿## redis持久化机制</p>\n<p>redis服务器宕机，内存数据是会丢失了，为了保证数据不丢失需要对数据做备份，所备份就是持久化，Redis的持久化即将内存中的数据同步到硬盘，主要包括两种方式RDB、AOF。</p>\n<p><strong>RDB持久化机制，(默认使用)</strong>：做当前内存数据的全本快照，<br />\n将内存中的数据以快照的方式写入到二进制文件dump.rdb,<br />\n在redis.conf中可以设置发起快照保存的条件。在指定的时间内如果有超过指定数量的key被修改，则会发起快照保存。</p>\n<p>这种方式在数据的实时性上不高，在突然断电的情况下，可能会出现部分数据的丢失，即最后一次快照之后在内存中发生修改的数据。</p>\n<p>简单来说：RDB就是将redis上的所有数据做个备份，存储的是二进制的数据。</p>\n<p><strong>AOF持久化机制，(默认是关闭)</strong>：</p>\n<p>AOF是将Redis内存数据库中更改的数据都记录到指定的文件appendonly.aof。在redis.conf中可以进行写磁盘的相关设置。</p>\n<p>在突然断电的情况下，由于在appendonly.aof中保存了最后一次写磁盘之后redis内存发生数据修改的指令，所以在这个Redis重启后，基本不会发生数据丢失，比RDB具有更好的数据安全性。</p>\n<p>appendfsync always   接收到更改数据的命令，立即将其记录到appendonly.aof中，能保证数据持久化，数据完全不丢失，但效率相对最低。</p>\n<p>appendfsync everysec   每秒钟将redis内存数据修改的命令记录到appendonly.aof中，在性能和持久化上做了折中。因频繁执行磁盘操作，在仅存在单个Master执行写操作时，效率可能存在问题。但在多个Master执行写操作的Redis集群中，效率会提升。</p>\n<p>appendfsync no  依赖于操作系统，因不会频繁执行磁盘操作而性能最好，但redis内存数据修改持久化没有保证，无法保证数据可靠性</p>\n<p><strong>如何开启AOF持久化：</strong><br />\n将redis.conf文件中 appendonly 改成 yes ，自动创建appendonly.aof，该文件存储的客户端执行过<strong>增删改操作的命令</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190811162518765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"什么是aof重写\">什么是AOF重写？</h2>\n<p>当命令存储了一定程度的时候，有一些命令可能是已经无效的了<br />\n例如set usernname xx  del usename,添加一条数据，后又删除，所以这两条命令备份的备份的时候就都是无效的<br />\n所有redis会对AOF文件进行优化，把一些没有对于数据恢复没有意义的命令优化掉<br />\n默认AOF是关闭的，需要在redis.conf中进行开启<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081116254741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 15:41:47', '2022-05-21 18:16:11');
INSERT INTO `tb_article` VALUES (173, 1, 5, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=967', 'Mybatis中$ {} 和 # {}的区别，动态SQL之if、where、set、trim、foreach标签的使用', '<p>﻿## 一．Mapper文件的补充细节</p>\n<p><strong>a)	Xml的特殊字符</strong><br />\n在mapper文件中，小于号用&amp; lt;代替， 大于号用 &amp; gt;代替</p>\n<pre><code>i.	&lt;   &amp;lt;  \nii.	&gt;  &amp;gt; \n</code></pre>\n<p><strong>b)	$ {} 和 # {}的区别</strong><br />\ni.	使用上，$ {}要获取的参数值，对应的参数必须使用Param注解<br />\nii.	底层上，<br />\n${}使用字符串拼接<br />\n#{}使用?占位符</p>\n<ol>\n<li>字符串拼接，可以拼接表名 列名 sql关键字</li>\n<li>?占位符，只能绑定数据，但可以避免sql注入攻击</li>\n</ol>\n<h2 id=\"二动态sql\">二．动态SQL</h2>\n<p>什么是动态SQL？就是能够根据不同的条件，产生不同 的SQL语句。</p>\n<blockquote>\n<p>比如我们常见的多条件搜索框，可以根据姓名、性别、年龄、工资范围等按照一定的条件进行搜素，<br />\n但如果我只输入姓名搜素呢，或者按照姓名+年龄进行搜素呢，这样排列组合情况就太多了，我们不可能一个条件去写一个SQL的，<br />\n所以就需要我们根据用户输入的条件来动态的生成一条SQL语句。</p>\n</blockquote>\n<p><strong>Mapper文件中动态SQL常用的几个标签</strong><br />\n&lt; if&gt; 作用：<br />\n满足条件时执行sql，不满足则不执行</p>\n<p>&lt; where&gt; 作用：</p>\n<ol>\n<li>会自动删除if动态sql产生的多余的and or前缀</li>\n<li>会在if动态sql语句前添加where关键字</li>\n</ol>\n<p>如下SQL语句所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728141308831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>&lt; set&gt;作用：<br />\n1.会自动if动态sql产生的多余的逗号后缀<br />\n2.会在if动态sql语句前添加set关键字</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190728141444363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>&lt; trim&gt;作用：<br />\n可以自定义前缀和后缀：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019072814165010.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>&lt; foreach&gt; 循环遍历，<br />\n常用来做批量删除的时候用</strong><br />\n如下图所示：<br />\ncollection:相当于集合名，<br />\nitem表示集合中的一个元素，<br />\nopen是循环之前要加的东西，<br />\nclose是循环结束的时候要加的东西，<br />\nseparator:元素间使用什么分隔。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728141835696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:17', '2022-05-21 18:15:56');
INSERT INTO `tb_article` VALUES (174, 1, 5, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4803', '简单理解什么是Spring中的IOC控制反转和DI依赖注入，Spring对象的三种创建方式', '<p>﻿IOC ：Inversion of Control     控制反转<br />\nDI  :  dependency Injection   依赖注入</p>\n<p>咋一听，控制反转、依赖注入，似乎很高大上的名字，概念比较抽象，但其实慢慢分析，转换成自己的话也不难理解：</p>\n<p><strong>IOC的理解：</strong></p>\n<p><em>在原始社会的时候，我们需要自己生火、自己挖井。这个时候主动权在自己手里。随着时代的发展我们现在有燃气公司和水利公司。我们现在想喝水直接扭水龙头水就流出来了，但是水这个来源的控制权交给自来水公司了，这个过程称之为控制反转</em></p>\n<p>对于Spring来说，以前自己创建的对象UserService service = new UserServiceImpl(),<br />\nservice.xxx()<br />\n而现在，对象的创建交给Spring工厂，用的时候去工厂中获取，<br />\nClassPathXmlApplicationContext ac = new ...;</p>\n<p>从之前自己创建对象，到现在交给Spring工厂创建对象，包括给属性赋值也交给Spring工厂来完成，这个由我们自己完成一些事情转移到Spring框架完成这些事情的过程，Spring称之为控制反转（IOC）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190728145347156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>DI (依赖注入):</strong></p>\n<p>如果我们站在spring工厂的角度，工厂创建需要的对象，并且还可以给程序员中的类的属性赋值，对象由工厂创建，最终由程序员使用，这就是spring的依赖注入<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728145414207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<blockquote>\n<p>IOC和DI实际上是等同的概念，如果要进行区分的话，IOC和DI可以理解为同一个东西的不同角度看法，IOC<br />\n站在程序员的角度，以前创建对象是我们自己new出来的，现在让容器自己创建，控制权交给了容器，对于<br />\n我们来说控制权反转了。<br />\nDI是站在容器的角度，从Spring角度来看，用到的所有的对象都是自己创建的，并且对象在创建的时候需要<br />\n依赖的参数也是容器注入的，而这种维持对象之间依赖关系的方式就是依赖注入。</p>\n</blockquote>\n<blockquote>\n<p>所以IOC和DI实际上都是指容器负责创建对象和维护对象之间依赖关系的这种行为。</p>\n</blockquote>\n<h3 id=\"说到这里再来分析一下spring创建对象的三种方式\">说到这里，再来分析一下Spring创建对象的三种方式：</h3>\n<p><strong>1，通过构造方法创建，采用默认的构造函数，</strong><br />\n也就是通过xml+bean标签，bean标签要写class的类的全限定名，其原理是通过java类的反射机制创建对象。<br />\nindex : 参数的索引,从0 开始<br />\nname: 参数名<br />\ntype:类型(区分开关键字和封装类int 和Integer)</p>\n<pre><code>&lt;bean id=&quot;peo&quot; class=&quot;com.macw.pojo.People&quot;&gt;\n&lt;!-- ref 引用另一个bean value 基本数据类型或String 等--&gt;\n    &lt;constructor-arg index=&quot;0&quot; name=&quot;id&quot; type=&quot;int&quot;  value=&quot;123&quot;&gt;&lt;/constructor-arg&gt;\n    &lt;constructor-arg index=&quot;1&quot; name=&quot;name&quot; type=&quot;java.lang.String&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>在早期Spring1.0版本，还没有注解的时候，Spring能够帮我们创建对象和管理对象，<br />\n但是没有注解每创建一个对象就要配置一个xml，其实还没有我们直接new一个对象来得快呢，</p>\n<p>但是为什么spring框架仍然有他的极大优势呢，因为他最重要的一个特性是能够帮我们管理对象，<br />\n自己new对象在类中多处调用会造成程序模块之间耦合性太强，不利于维护更新。而spring帮我们管理对象通过依赖注入声明的是管理对象的关系。</p>\n<p><strong>2、通过实例工厂创建对象<br />\n也就是 工厂设计模式：帮助创建类对象，一个工厂可以生产多个对象</strong></p>\n<pre><code>// 工厂，创建对象\npublic class StudentFactory {\n    // 实例方法创建对象\n    public Student getInstance() {\n        return new User(001,&quot;学生工厂：调用实例方法&quot;);\n    }\n\n    // 静态方法创建对象\n    public static Student getStaticInstance() {\n        return new Student(002,&quot; 学生工厂：调用静态方法&quot;);\n    }\n}\n\n配置文件：\n\n&lt;!-- # 3.1 工厂类，实例方法 --&gt;\n    &lt;!-- 先创建工厂 --&gt;\n    &lt;bean id=&quot;factory&quot; class=&quot;com.macw.StudentFactory&quot;&gt;&lt;/bean&gt;\n    &lt;!-- 在创建student对象，用factory方的实例方法 --&gt;\n    &lt;bean id=&quot;student2&quot; factory-bean=&quot;factory&quot; factory-method=&quot;getInstance&quot;&gt;&lt;/bean&gt;\n</code></pre>\n<p>其中： factory-bean=”factory”指定工厂。factory-method=”getInstance”指定工厂的哪个方法。</p>\n<p><strong>3.静态工厂创建对象，不需要创建工厂，快速创建对象</strong></p>\n<p>实现步骤：编写一个静态工厂（在方法上添加static）</p>\n<pre><code>public class StudentFactory{\n    public static Student newInstance(){\n        return new Student(001,&quot;studentTest&quot;);\n    }\n}\n\n在applicationContext.xml中\n&lt;bean  id = &quot;student2&quot;  class = &quot;com.macw.pojo.StudentFactory&quot;  factory-method = &quot;newInstance&quot;&gt;&lt;/bean&gt;\n\n</code></pre>\n<p>在spring2.0之后采用注解的形式开发，减少了大量 的xml配置文件，开发的形式变为xml+bean配置数据源，大量使用第三方框架，通过组件注解配置自己的类。</p>\n<p>spring3.0之后采用配置类+bean注解来创建对象，目的想取代xml配置文件，也就是springboot自动装配的底层原理</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:22', '2022-05-21 18:15:42');
INSERT INTO `tb_article` VALUES (175, 1, 6, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5893', '面试题：BeanFactory和FactoryBean有啥关系_', '<p>﻿没啥太大关系!</p>\n<p>BeanFactory(对象工厂)，他是spring框架中的工厂类，spring的工厂设计的比较复杂，BeanFactory被抽象成了一个接口，我们经常写代码叫做ClassPathXmlApplicationContext是BeanFactory的实现类</p>\n<p>FactoryBean也是一个接口，主要用于特殊对象的创建，例如Connectoin和SqlSession对象，由于他们是一个接口，这些对象的创建需要使用代码完成，所以需要一个类实现FactoryBean接口间接创建这些类的对象</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:26', '2022-05-21 18:15:29');
INSERT INTO `tb_article` VALUES (176, 1, 6, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5963', '使用代理模式实现Spring AOP的面向切面编程，动态代理的四种增强处理', '<p>﻿<strong>什么是代理类？</strong><br />\n代理就是代替我们去执行一些额外的工作。</p>\n<p><strong>目标类:只有核心功能的类</strong></p>\n<p>比如我们在写service的时候，<strong>调用dao方法是我们的核心业务</strong>，<strong>而service类中的日志记录，事务处理，异常处理等都属于额外的功能</strong>，每个service方法中都要写一次这些额外功能也会造成大量代码的冗余，</p>\n<p><strong>而面向切面编程的意思就是说把这些公共的、额外的代码功能抽取出来，每个service里面只写我们的核心业务</strong>，这样就提高了我们的开发效率。</p>\n<p><strong>为什么代理类和目标类要实现相同的接口？</strong><br />\n1.从代码的角度来说,代理类对象能够赋值给接口类型的变量<br />\n2.要保证代理类和目标类有相同的功能</p>\n<p>有了代理类:<br />\n程序员可以只关心核心功能</p>\n<p><strong>额外功能+目标类 =代理类</strong></p>\n<p>以上这种说法就是叫做静态代理，<br />\n静态代理就是在代码编译时,代理类已经存在<br />\n好处:程序员可以只关心核心功能<br />\n不好:多个代理类 ，    没有解决代码冗余的问题</p>\n<h2 id=\"什么是动态代理\">什么是动态代理？</h2>\n<p>运行时,动态创建出来代理对象<br />\nSpringAOP通过动态代理,让程序猿只关心核心代码,同时代码不再冗余</p>\n<p><strong>springAOP的开发步骤:</strong><br />\n1.写核心功能(目标类)<br />\n核心功能就是调用dao方法：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728174629656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2.配置目标类<br />\n要在SpringApplication.xml文件中配置目标类所在路径</p>\n<pre><code> &lt;!--配置目标类--&gt;\n    &lt;bean id=&quot;bookService&quot; class=&quot;com.macw.serviceImpl.bookServiceImpl&quot;&gt;\n        &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p><strong>3.写额外功能(增强处理)</strong><br />\n(公共功能:日志处理/事务处理/异常处理/性能分析....) 等</p>\n<p>前置增强(MethodBeforeAdvice):在核心功能之前执行的额外功能<br />\n后置增强:在核心功能之后执行的额外功能</p>\n<p>环绕增强:在核心功能之前以及之后执行的额外功能<br />\n异常增强:在核心功能发生异常时执行的额外功能</p>\n<p><strong>前置增强的配置使用：</strong><br />\n1，声明一个类，需要实现	MethodBeforeAdvice接口：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728175452663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2，spring配置文件中,配置声明的增强功能类</p>\n<pre><code>	&lt;!--额外功能--&gt;\n   &lt;bean id=&quot;myBeforeAdvice&quot; class=&quot;com.macw.advice.myBeforeAdvice&quot;&gt;&lt;/bean&gt;\n</code></pre>\n<p>3，在spring配置文件中,通过aop标签做配置(需要添加aop命名空间以及schema验证文档):<br />\n.在哪些方法上面做增强处理<br />\n.在需要增强处理的方法上面,加哪个增强处理<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728180128311.png\" alt=\"在这里插入图片描述\" /><br />\n4.让spring在运行的时候,帮我们创建代理对象()<br />\n<img src=\"https://img-blog.csdnimg.cn/2019072817590249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>详解advice<br />\nMethodBeforeAdvice前置增强的before方法</strong><br />\n实现MethodBeforeAdvice接口必须要要实现before方法，这个方法有三个参数，<br />\narg0：目标方法，<br />\narg1:目标方法参数，<br />\narg2:目标类，<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728180359181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2.AfterReturningAdvice:后置增强<br />\n<img src=\"https://img-blog.csdnimg.cn/2019072818044361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n3.ThrowsAdvice:异常增强<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728180513201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>4.MethodInterceptor:环绕增强,目标方法执行之前以及之后做的增强处理</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190728180541273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n总结：<br />\n<strong>Spring AOP:Aspect Oriented Program 面向切面编程</strong><br />\n几个重要概念：</p>\n<p>1.切入点:需要把增强处理加在的位置;service层的方法上面;需要在配置文件中配置<br />\n2.增强处理:额外功能(公共功能) ,通知/建议(advice)<br />\n3.目标类:核心功能所在的类(原始类)<br />\n4.切面:把增强处理,放在切入点的位置,形成的一个概念<br />\n5.编织/织入:把增强处理放置在切入点的过程</p>\n<p><strong>AOP使用场景:</strong><br />\n1.把功能内容抽取出来,形成advice;在配置文件中中做配置====&gt;程序猿只关心核心功能;解决冗余<br />\n2.在原有功能基础之上,做功能扩展===&gt;在不改变原有代码的基础上做功能扩展</p>\n<p>AOP实现:代理模式的使用</p>\n<p>代理类的产生原理<br />\n类加载ClassLoader<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728181445489.png\" alt=\"在这里插入图片描述\" /></p>\n<p>代理类的生成:由jdk动态代理生成<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728181529670.png\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"springaop实现原理\">SpringAOP实现原理:</h2>\n<p>1.底层通过字节码技术,把目标对象以及额外功能动态封装,生成代理对象  ==&gt;动态代理<br />\n使用了JDK动态代理以及cglib动态代理<br />\n2.为什么通过id得到的是代理对象<br />\nspring工厂创建对象之后,由BeanPostProcessor进行处理<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728181629605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:28', '2020-10-07 13:09:55');
INSERT INTO `tb_article` VALUES (177, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8819', 'idea新手好用的几个插件、让你快速掌握IDEA', '<p>﻿从Myeclipse突然转到idea，最让我们感到不顺手的就是快捷键的使用变了，</p>\n<p>习惯了一个东西再去接受另一个新事物是很难接受的，虽然我们可以让idea切换成eclipse的快捷键，</p>\n<p>但是仍然有很多功能的快捷键的我们所不知道的，</p>\n<p>所以我要推荐的第一个插件就是：</p>\n<h2 id=\"1key-promoter-x\">1、Key promoter X</h2>\n<blockquote>\n<p>显示点击某个功能选项的快捷键（如果有的话）<br />\n前期新手使用确实对idea的快捷键感到头疼，有了这个的话就能帮助我们很快的掌握各种快捷键<br />\n等到使用熟练之后再把这个关掉就好了</p>\n</blockquote>\n<p>Key Promoter (X)其实这里是指2个插件，分别为Key Promoter X 和Key Promoter ，主要功能差不多的，都是一个提示插件，当你在IDEA里面使用鼠标的时候，如果这个鼠标操作是能够用快捷键替代的，那么Key Promoter X会在右下角弹出一个提示框，Key Promoter 会在左上角弹出一个提示框告，<strong>并且当你想看看一个功能的快捷键的时候你只需要把鼠标放上去不动他就会提示你这个功能的快捷键是啥</strong>、<strong>或者告知你这个鼠标操作可以用什么快捷键替代</strong>。当然，对于Key Promoter X还有一个官方功能解释那就是用来统计你鼠标操作的次数，然后在一个窗口中展示出来。对于想完全使用快捷键在IDEA的，这个插件就很有用。</p>\n<p><strong>安装：</strong><br />\n安装这个插件很简单，只需要打开Settings,然后找到Plugins那一栏目,然后输入key promoter,点击install就行，安装好会让你重启生效，<br />\n<img src=\"https://img-blog.csdnimg.cn/20190730090501863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"idea安装插件\" /><br />\n这是我已经安装过了。<br />\n如果找不到，就直接到仓库里找即可。</p>\n<h2 id=\"2jrebel-for-intellij\">2，JRebel for IntelliJ</h2>\n<blockquote>\n<p>一款热部署插件，只要不是修改了项目的配置文件，用它都可以实现热部署。<br />\n在没有这个之前频繁的重启和reply搞得我烦不胜烦。而这个简直没有太方便，节省了大量的重启程序的等待时间<br />\n只不过是收费的，但是目前已经有好多破解方法了，不过功能确实很强大。算是开发必备神器了。</p>\n</blockquote>\n<p><strong>安装：</strong><br />\n安装和上面安装步骤一样，打开Settings,然后找到Plugins那一栏目,然后输入Jrebel,一般第一个就是,点击install安装重启就能用，安装好如下图所示会在setting下面出现JRebel的配置信息：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190730091920369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n我这个是已经激活过了，<br />\n激活流程可以参考这篇大神写的文章：<a href=\"https://blog.csdn.net/songfei_dream/article/details/90921505\">https://blog.csdn.net/songfei_dream/article/details/90921505</a></p>\n<p><strong>使用：</strong><br />\n这个安装完之后会在右上角启动哪里多两个启动项，如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/2019073010052628.png\" alt=\"在这里插入图片描述\" /><br />\n再次启动程序的时候我们就可以通过jrebel启动tomcat了，实现真正 的热部署。快捷键是crtl+F10</p>\n<h2 id=\"3mybatis-plugin\">3,Mybatis plugin</h2>\n<blockquote>\n<p>可以在mapper接口中和mapper的xml文件中来回跳转，就想接口跳到实现类那样简单。<br />\n这个是免费版的，有收费要破解的，不过功能都差不多</p>\n</blockquote>\n<p><strong>安装：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190730101011297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>效果：</strong><br />\n点击箭头就可以实现dao和mapper文件之间的跳转<br />\n<img src=\"https://img-blog.csdnimg.cn/2019073011004642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"4alibaba-java-coding--guidelines\">4、Alibaba java Coding  Guidelines</h2>\n<blockquote>\n<p>阿里巴巴java开发规范手册<br />\n规范代码，从小开始<br />\n这个插件会智能时时的提醒你哪里写的不规范，并且命名哪里不好，建议你怎样怎样改，等等。<br />\n开发必备，很重要，习惯一旦养成很难再修改的，从开始就要规范代码书写风格<br />\n<img src=\"https://img-blog.csdnimg.cn/20190731104714623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<h2 id=\"5装饰插件activate-power-mode\">5，装饰插件：activate-power-mode</h2>\n<blockquote>\n<p>这是一款让你在编码的时候，整个屏幕都为之颤抖的插件。<br />\n敲的越快，抖动越厉害，并且会统计你在不停歇的情况下一口气敲了多少次键盘<br />\n不过这个插件晃的我头晕，</p>\n</blockquote>\n<p><strong>效果</strong></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNzcyNzQzLzIwMTgwNC83NzI3NDMtMjAxODA0MTEyMzIxMzAzNzQtMjA4NzI3MTU1MC5naWY\" alt=\"在这里插入图片描述\" /><br />\n重点还是前4个好用哈，最后一个就是玩玩~</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:31', '2021-08-30 09:58:46');
INSERT INTO `tb_article` VALUES (178, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7899', 'Nginx搭建负载均衡详细操作', '<p>﻿</p>\n<p><strong>什么是负载均衡?</strong></p>\n<p>互联网早期，业务流量比较小并且业务逻辑比较简单，<strong>单台服务器</strong>便可以满足基本的需求；但随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台机器的性能问题以及单点问题凸显了出来，因此需要<strong>多台机器</strong>来进行性能的水平扩展以及避免单点故障。但是要如何将不同的用户的流量分发到不同的服务器上面呢？</p>\n<p>那么通过使用nginx搭建的负载均衡器即可解决该问题</p>\n<p>客户端的流量首先会到达负载均衡服务器，由负载均衡服务器通过一定的调度算法将流量分发到不同的应用服务器上面，同时负载均衡服务器也会对应用服务器做周期性的健康检查，当发现故障节点时便动态的将节点从应用服务器集群中剔除，以此来保证应用的高可用。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190801211348483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>搭建步骤以及准备条件：</strong></p>\n<ol>\n<li>搭建三台Linux服务器</li>\n<li>一台安装Nginx,另外两台各安装Tomcat</li>\n<li>对Nginx的/etc/nginx/conf.d/default.conf进行配置</li>\n<li>测试负载均衡</li>\n</ol>\n<p>这里我用的是使用Vmware创建三台Linux服务器，其中一台安装Nginx，为其使用dhclient分配ip为：192.168.248.128<br />\n另外两台安装jdk+Tomcat.，分别为其分配IP为：192.168.129和129.168.248.130.</p>\n<p>结果如下图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019080121244254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"详细操作\">详细操作：</h2>\n<h4 id=\"1克隆三台linux服务器\">1.克隆三台Linux服务器</h4>\n<p>​     1.1 以上图为例 dhclient 分配 ip地址</p>\n<p>​            安装tomcat的两台服务器ip分别为192.168.30.128、192.168.30.130</p>\n<p>​            安装的nginx的服务器ip为192.168.30.131</p>\n<h4 id=\"2安装jdk和tomcat\">2.安装JDK和Tomcat</h4>\n<p>在192.168.30.128、192.168.30.130上先安装JDK，在安装tomcat</p>\n<p>安装tomcat需要依赖JDK</p>\n<p>安装步骤参考之前的文章</p>\n<h4 id=\"3安装nginx\">3.安装Nginx</h4>\n<p>​    在192.168.30.131安装Nginx</p>\n<h4 id=\"4配置负载均衡\">4.配置负载均衡</h4>\n<p>在192.168.30.131安装Nginx的服务器上， 打开/etc/nginx/conf.d/default.conf文件</p>\n<pre><code>#新增\nupstream aa{\n    server 192.168.30.128:8080;\n    server 192.168.30.130:8080;\n}\n\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n        #新增一行\n        proxy_pass  http://aa;\n    }\n}\n\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190801212805182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"5关闭nginx上的安全组\">5.关闭Nginx上的安全组</h4>\n<p>使用  vi  /etc/selinux/config<br />\n编辑config文件，修改SELNUX=disabled<br />\n如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190801213601273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>注意：修改过安全组要把系统重启reboot下生效！<br />\n重启之后如果不能访问就要禁用掉防火墙：systemctl stop firewalld<br />\n并且开启Nginx：stystemctl start nginx</p>\n<h4 id=\"6测试\">6.测试</h4>\n<p>通过  <a href=\"http://192.168.30.131:80\">http://192.168.30.131:80</a> 访问Nginx,即可看到实际访问了tomcat</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190801212929871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"负载均衡的策略\">负载均衡的策略</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190801213815648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>\n<p>轮询 （默认）</p>\n<p>特点：一个一个挨着访问，tomcat服务器会被依次访问</p>\n</li>\n<li>\n<p>权重</p>\n<p>weight=数字越大权重越大，被访问的几率越高</p>\n<p>下边的配置上边的机器访问2次，下边的访问1次</p>\n</li>\n</ol>\n<p>​    <img src=\"https://img-blog.csdnimg.cn/20190801213027809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n​</p>\n<ol start=\"3\">\n<li>\n<p>ip黏着</p>\n<p>根据用户的ip,绑定到一台tomcat服务器<br />\n根据客户端用户的ip地址计算出一个可以被访问的tomcat服务器<br />\n如果客户端用户的ip地址不变，那么访问的tomcat就固定了</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190801213058161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>原理:把用户的ip进行hash处理(取用户ip的hash值),对tomcat总数量取模,然后根据得到的值,对应找到要访问的Tomcat</p>\n<h2 id=\"反向代理和正向代理的区别\">反向代理和正向代理的区别</h2>\n<p>代理如果在服务器端就是反向代理，如果放在客户端就是正向代理<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080121444414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"反向代理-和-负载均衡-的关系\">反向代理 和 负载均衡 的关系？</h2>\n<p>什么是负载均衡？ 搭建多个tomcat服务器，在用户访问量大的时候，可以访问不同的tomcat，减少某个tomcat的访问压力</p>\n<p>在nginx中如果想实现负载均衡，需要借助反向代理机制</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:36', '2021-08-30 09:58:33');
INSERT INTO `tb_article` VALUES (179, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1743', 'Centos7安装JDK和Tomcat详细步骤', '<p>﻿</p>\n<p><strong>安装步骤</strong></p>\n<ol>\n<li>将JDK安装包上传到/opt下</li>\n<li>解压</li>\n<li>配置JDK的环境变量</li>\n<li>使配置生效</li>\n<li>测试JDK是否安装成功</li>\n</ol>\n<h4 id=\"1上传jdk安装包到centos系统中的opt目录下\">1.上传JDK安装包到Centos系统中的/opt目录下</h4>\n<p>1.1 使用xftp软件和服务器建立传输</p>\n<p><img src=\"https://img-blog.csdnimg.cn/201908020841059.png\" alt=\"[外链图片转存失败(img-CtHs62Ir-1564705402590)(assets\\1563577470477.png)]\" /></p>\n<p>1.2 建立会话</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084124185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-aak5tZci-1564705402592)(assets\\1563577590105.png)]\" /></p>\n<p>1.3 填写连接会话的参数</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084201723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-CTZFFQe9-1564705402594)(assets\\1563578003459.png)]\" /><br />\n<img src=\"https://img-blog.csdnimg.cn/20190802084218687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-QoTSsKd0-1564705402598)(assets\\1563578266172.png)]\" /></p>\n<p>1.4 上传JDK的安装包到Linux系统中的/opt目录下</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084249307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-XJtwQDjf-1564705402601)(assets\\1563578083307.png)]\" /></p>\n<h4 id=\"2对上传后的jdk进行解压操作\">2.对上传后的JDK进行解压操作</h4>\n<p>2.1 进入/opt目录，查看上传后的JDK安装包</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084321703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-n0qkNEmT-1564705402603)(assets\\1563578357662.png)]\" /></p>\n<p>2.2 使用tar命令对安装包进行解压安装操作</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084348488.png\" alt=\"[外链图片转存失败(img-sWXS2ocl-1564705402604)(assets\\1563578725269.png)]\" /></p>\n<p>2.3 解压后查看结果</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084400475.png\" alt=\"​	[外链图片转存失败(img-0JMcmAyB-1564705402604)(assets\\1563578770033.png)]\" /></p>\n<p>2.4 对解压包进行重命名，此步骤不是必须的，主要是为了方便后边配置环境变量</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084415519.png\" alt=\"[外链图片转存失败(img-WRGm8lhb-1564705402605)(assets\\1563578859303.png)]\" /></p>\n<h4 id=\"3配置环境变量\">3.配置环境变量</h4>\n<p>3.1 编辑/etc/profile文件</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084429531.png\" alt=\"[外链图片转存失败(img-B4O5MFI5-1564705402605)(assets\\1563579105923.png)]\" /></p>\n<p>3.2 来到profile文件末尾，按i进入编辑模式</p>\n<p>3.3 增加JAVA_HOME和PATH两个环境变量</p>\n<pre><code># JAVA_HOME\nexport JAVA_HOME=/opt/jdk1.8\n# PATH\nexport PATH=$PATH:$JAVA_HOME/bin\n解释： $PATH是获取本身已经配置的path环境变量   \n      :(冒号)是分隔符的作用，相当于windows系统中配置的逗号\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084914896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-ZNrtSdAZ-1564705402606)(assets\\1563579389001.png)]\" /></p>\n<p>编辑完成保存退出</p>\n<p>3.4 使用source命令配置文件生效</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084942990.png\" alt=\"[外链图片转存失败(img-q9UO9DAk-1564705402607)(assets\\1563579423623.png)]\" /></p>\n<p>3.5 测试javac和java命令是否可用</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802085045546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-K7rZKudz-1564705402607)(assets\\1563579582383.png)]\" /></p>\n<p>使用java -version命令查看当前安装的jdk版本</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802085108870.png\" alt=\"[外链图片转存失败(img-VzAF0eDj-1564705402608)(assets\\1563579655693.png)]\" /></p>\n<p>到此，jdk1.8就算安装完成了，接下来安装tomcat</p>\n<h2 id=\"tomcat安装步骤\">Tomcat安装步骤：</h2>\n<ul>\n<li>上传tomcat到/opt下</li>\n<li>解压</li>\n<li>启动tomcat</li>\n<li>使用windows系统的浏览器访问Linux服务器的tomcat</li>\n</ul>\n<p><strong>1.上传tomcat到Linux系统的/opt目录下</strong><br />\n1.1 打开xftp连接到Linux系统上，将tomcat上传至/opt目录下<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085521524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>2.对于上传后的tomcat，进行解压安装</strong><br />\n2.1 查看上传后的tomcat，并且使用tar命令解压<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080208554144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2.2 查看解压后的tomcat<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085552895.png\" alt=\"在这里插入图片描述\" /><br />\n<strong>3.启动tomcat</strong><br />\n3.1 进入解压后的tomcat中bin子目录<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085615441.png\" alt=\"在这里插入图片描述\" /><br />\n3.2 执行./startup.sh命令启动tomcat<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085812211.png\" alt=\"在这里插入图片描述\" /><br />\n4.访问tomcat<br />\n4.1 在windows系统中打开浏览器输入 <a href=\"http://ip:8080\">http://ip:8080</a> 访问已经启动的tomcat<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085914846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>注意事项：如果不能访问就关闭linux系统的防火墙</strong><br />\nsystemctl stop firewalld<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085941311.png\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:12:15', '2020-10-07 13:06:41');
INSERT INTO `tb_article` VALUES (180, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=6371', 'Centos7安装Nginx详细安装步骤', '<p>﻿</p>\n<h2 id=\"centos7安装nginx步骤\">Centos7安装Nginx步骤</h2>\n<ol>\n<li>手动配置nginx的yum仓库</li>\n<li>使用yum命令安装nginx</li>\n<li>启动nginx</li>\n<li>访问nginx</li>\n</ol>\n<h4 id=\"1指定nginx的yum仓库\">1.指定nginx的yum仓库</h4>\n<p>说明：centos系统中默认的yum仓库中没有nginx的安装包，<br />\n<strong>所以要想安装nginx需要单独指定它的仓库地址</strong></p>\n<p>1.1 将nginx.repo上传到Linux服务器下的/etc/yum.repos.d/下</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095154684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-Le4aM6gZ-1564710569597)(assets\\1563680660832.png)]\" /></p>\n<p>nginx.repo文件内容说明（了解）：</p>\n<p>name=     #一个描述，随意。<br />\nbaseurl=   #设置资源库的地址<br />\ngpkcheck=0 表示对从这个源下载的rpm包不进行校验  ， 1是校验；<br />\nenable=1 表示启用这个源 ， 0是禁用。</p>\n<pre><code class=\"language-xml\">[nginx]\nname=nginx repo\nbaseurl=http://nginx.org/packages/centos/7/x86_64/\ngpgcheck=0\nenabled=1\n</code></pre>\n<h4 id=\"2安装nginx\">2.安装nginx</h4>\n<p>2.1 使用yum install nginx 安装nginx</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095217158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-XwWjM2JW-1564710569604)(assets\\1563681894366.png)]\" /></p>\n<p>输入y</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095227875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-tPhk5gH7-1564710569604)(assets\\1563681901148.png)]\" /></p>\n<p>安装完成</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095238959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-xfGPm3C9-1564710569605)(assets\\1563681914220.png)]\" /></p>\n<p>可以查看whereis nginx查看安装位置</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095250383.png\" alt=\"[外链图片转存失败(img-sL0CGaE1-1564710569606)(assets\\1563681972621.png)]\" /></p>\n<p>nginx安装配置文件位置(重要):</p>\n<p>配置文件位置: /etc/nginx/nginx.conf</p>\n<p>配置文件路径: /etc/nginx/conf.d/default.conf (默认加载)</p>\n<h3 id=\"3启动nginx\">3.启动nginx</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095304135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-nrRDw8Jq-1564710569606)(assets\\1563682067852.png)]\" /></p>\n<p>启动Nginx<br />\nsystemctl start nginx<br />\n停止Nginx<br />\nsystemctl stop nginx<br />\n查看Nginx启动状态<br />\nsystemctl status nginx</p>\n<h4 id=\"4访问nginx\">4.访问nginx</h4>\n<p>在windows中打开浏览器输入<a href=\"http://ip:80\">http://ip:80</a></p>\n<p>说明：80是http协议的默认端口号，当端口号为80时可以省略不写</p>\n<p>[外链图片转存失败(img-vgBkRSr7-1564710569607)(assets\\1563711413922.png)]</p>\n<p><a href=\"p://ip:80\">p://ip:80</a></p>\n<p>说明：80是http协议的默认端口号，当端口号为80时可以省略不写</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095346272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存中...(img-vgBkRSr7-1564710569607)]\" /><br />\n到此，Centos7安装Nginx就完成啦</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:12:18', '2020-10-07 13:06:06');
INSERT INTO `tb_article` VALUES (181, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4974', 'Yum命令使用，使用yum安装vim案例演示yum的使用', '<p>﻿</p>\n<h4 id=\"何为yum-\">何为Yum ?</h4>\n<p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。</p>\n<p>基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>\n<p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>\n<blockquote>\n<p>简单说：从指定服务器自动下载并安装，使用简单方便</p>\n</blockquote>\n<p>1.安装指定的软件命令：yum install &lt;package_name&gt;</p>\n<p>2.更新指定的软件命令：yum update &lt;package_name&gt;</p>\n<p>3.删除软件包命令：yum remove &lt;package_name&gt;</p>\n<p>4.查找软件包 命令：yum search <keyword></p>\n<p>5.列出所有可安裝的软件清单命令：yum list</p>\n<h4 id=\"下边以vim的安装为例演示yum的使用\">下边以Vim的安装为例，演示Yum的使用</h4>\n<p>Vim是一个类似于Vi的著名的功能强大、高度可定制的文本编辑器，在Vi的基础上改进和增加了很多特性。</p>\n<p>1.1 使用Yum命令安装Vim</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095654938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-PZSCRNhs-1564710956716)(assets\\1563677444298.png)]\" /></p>\n<p>1.2 输入y，确定安装</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095716576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-cEviKAHX-1564710956718)(assets\\1563677490574.png)]\" /></p>\n<p>再输入一个y</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095725494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-IhB43gIF-1564710956718)(assets\\1563677545056.png)]\" /></p>\n<p>出现这个提示说明vim ，以及vim需要的依赖都安装完成</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095738125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-DdonWFH8-1564710956721)(assets\\1563677584819.png)]\" /></p>\n<p>1.3 通过vim命令修改某个文件，可以发现内容有颜色，说明vim已经正常安装并且可以使用了</p>\n<p>​      此处主要是为了介绍yum安装，vim的使用不再介绍，vim的基本使用和vi是一样</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095750451.png\" alt=\"[外链图片转存失败(img-Zc1KZtCS-1564710956723)(assets\\1563677748821.png)]\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/201908020958026.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-oXMPAesr-1564710956726)(assets\\1563677754841.png)]\" /></p>\n<h4 id=\"yum安装的原理介绍\">yum安装的原理介绍</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095812908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-wqcOkbSo-1564710956727)(assets\\1563679844231.png)]\" /></p>\n', 1, '', 0, 0, 1, '2020-09-29 17:24:57', '2020-12-19 17:11:42');
INSERT INTO `tb_article` VALUES (182, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5431', 'Spring boot 整合mybatis报错ClassNotFoundException_ org.mybatis.logging.LoggerFactory', '<p>﻿<strong>使用spring boot整合mybatis需要加入依赖：</strong></p>\n<pre><code>&lt;dependency&gt;\n      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n      &lt;version&gt;1.3.2&lt;/version&gt;\n    &lt;/dependency&gt;\n</code></pre>\n<p>这时候项目是没有任何问题的，正常运行！</p>\n<h2 id=\"但是\">但是</h2>\n<p>但是后来我使用<strong>Lombok</strong>和<strong>MyBatis-Plus</strong>进行开发，然后就引入了一个叫做<strong>mybatis-plus-boot-starter</strong>的依赖，再次运行测试的时候就一直报错：</p>\n<p>java.lang.IllegalStateException: Failed to load ApplicationContext</p>\n<p><strong>Caused by: java.lang.ClassNotFoundException: org.mybatis.logging.LoggerFactory</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190806202954276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n百度了一下其他人说是少了commons-logging 的jar包，我加上后依旧报错</p>\n<p>有人说是少了slf4j-api的jar包，我加上后也是依旧报错。</p>\n<p><strong>还有人说是少了mybatis-plus-boot-starter</strong>，到这里我似乎发现了什么，<br />\n<strong>使用mybatis-plus是让spring boot集成了mybatis，那么我在上面配置的mybatis-spring-boot-starter这个jar同样是集成mybatis的，这两个会不会有冲突？或者是因为这个jar导致了下面的mybatis-plus报错？</strong></p>\n<p>抱着试试的态度，我把mybatis-spring-boot-starter这个jar注释掉然后再运行，</p>\n<h2 id=\"然后就\">然后就，</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190806203918945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"大功告成\">大功告成！</h2>\n<p>后来我又测试，如果没有mybatis-plus提供的</p>\n<pre><code>   &lt;dependency&gt;\n        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n        &lt;version&gt;3.1.2&lt;/version&gt;\n    &lt;/dependency&gt;\n</code></pre>\n<p>这个依赖的话，同样会报ClassNotFoundException: org.mybatis.logging.LoggerFactory这个错！</p>\n<p>所以就能确定我的错误原因了！</p>\n<p>最后附一个lombok常用注解：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190806204243388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:12:32', '2020-10-07 13:05:32');
INSERT INTO `tb_article` VALUES (183, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8068', 'Centos 7搭建MySQL-主从复制', '<p>﻿## 什么是主从复制?</p>\n<p>如果数据库服务器一旦宕机，我们的项目将无法运行，如果数据库服务器硬盘损坏还将面临数据丢失的问题!!!</p>\n<p><strong>将MySQL数据库主机的数据复制到MySQL从机上(备份)</strong></p>\n<p>原理：将MySQL主机的SQL语句以日志的方式记录下来，通过网络将日志文件复制到从机上，执行日志中的SQL语句同步主机的操作和数据</p>\n<p>搭建步骤</p>\n<ol>\n<li>创建三台Linux服务器</li>\n<li>分别安装MySQL数据库</li>\n<li>配置主节点（Mysql主机操作）</li>\n<li>配置从节点（Mysql从机操作）</li>\n</ol>\n<h4 id=\"1搭建三台linux服务器\">1.搭建三台Linux服务器</h4>\n<p>一台作为mysql数据库的主节点(master)</p>\n<p>另外两台作为mysql数据库的从节点(slave)</p>\n<h4 id=\"2分别安装mysql数据库\">2.分别安装mysql数据库</h4>\n<p>说明：可以先安装一台，然后在克隆两台</p>\n<p>2.1 上传mysql的yum源</p>\n<p>2.2 使用yum install 命令安装</p>\n<p>2.3 启动mysql数据库，修改密码，设置允许远程访问</p>\n<p>2.4 关闭防火墙</p>\n<p>或者上传rpm安装包离线安装</p>\n<p>可参考之前文章Linux上安装mysql教程：<br />\n<a href=\"https://blog.csdn.net/MacWx/article/details/98171109\">https://blog.csdn.net/MacWx/article/details/98171109</a></p>\n<h4 id=\"3配置主从\">3.配置主从</h4>\n<p>3.1 在主节点（也就是Mysql主机）</p>\n<p>vi /etc/my.cnf</p>\n<p>增加</p>\n<pre><code>server-id=132\nlog_bin\n\n#需要同步的数据库\nbinlog-do-db=baizhi\n#忽略(不需要)同步的数据库\nbinlog-ignore-db=mysql\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807193853293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-EzkAqLnM-1565177567068)(assets\\1563789758573.png)]\" /></p>\n<p>重启主节点的mysql数据库</p>\n<p>登录，查看主机状态</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194339252.png\" alt=\"[外链图片转存失败(img-KKS7eoUF-1565177567069)(assets\\1563789882250.png)]\" /></p>\n<p>3.2 从节点</p>\n<p>说明：如果是克隆的需要先删除从机上的/var/lib/mysql/auto.cnf文件</p>\n<pre><code>rm -f  /var/lib/mysql/auto.cnf\n</code></pre>\n<p>vi /etc/my.cnf</p>\n<p>增加</p>\n<pre><code>server-id=133\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2019080719440416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-R1q40Q0I-1565177567069)(assets\\1563789981959.png)]\" /></p>\n<p>重启mysql数据库       systemctl restart mysqld</p>\n<p>登录mysql数据库       mysql -uroot -p</p>\n<p>关闭从机状态              stop slave</p>\n<p>设置和主机建立连接</p>\n<p>语法</p>\n<pre><code>change master to master_host=\'主机ip地址\',master_user=主机用户名,master_password=主机密码,master_log_file=\'主机日志文件名\',master_log_pos=日志文件的位置\n</code></pre>\n<p>示例</p>\n<pre><code>change master to master_host=’192.168.152.133’,master_user=’root’,master_password=’123456’,master_log_file=’mysqld-bin.000001’,master_log_pos=241\n</code></pre>\n<p>查看从机状态              show slave status \\G;</p>\n<h4 id=\"4测试\">4.测试</h4>\n<p>在主节点创建一个叫做baizhi的数据库，然后在该数据库中创建一张表，添加一条测试数据</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194430611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-GOAwJ4fR-1565177567070)(assets\\1563868813155.png)]\" /></p>\n<p>在从节点查看</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194442918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-UwygxUPF-1565177567071)(assets\\1563868782868.png)]\" /></p>\n<p>看到我们在Mysql主机添加一条记录，从机也有了相应的记录，这就实现了mysql的主从复制！</p>\n', 1, '', 0, 0, 1, '2020-10-07 13:03:14', '2020-12-21 14:50:26');
INSERT INTO `tb_article` VALUES (184, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3527', 'Centos 7使用MyCat搭建 MySQL-读写分离', '<p>﻿</p>\n<h2 id=\"什么是读写分离\">什么是读写分离?</h2>\n<p>只有mysql的主机接收增删改SQL语句，从机接收查询语句，分担主机的查询压力</p>\n<p><strong>搭建步骤</strong></p>\n<ol>\n<li>新建一台Linux服务器、关闭防火墙</li>\n<li>上传mycat的安装包到服务器、解压安装</li>\n<li>配置mycat的环境变量</li>\n<li>修改mycat的server.xml和schema.xml配置文件</li>\n<li>启动mycat</li>\n<li>测试</li>\n</ol>\n<h4 id=\"1上传mycat安装包到-usr目录下\">1.上传mycat安装包到 /usr目录下</h4>\n<p>使用Shell上传文件<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807194804651.png\" alt=\"[外链图片转存失败(img-RxcePQqK-1565178387515)(assets\\1563939118812.png)]\" /></p>\n<h4 id=\"2解压安装\">2.解压安装</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194829867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-azuw4Fis-1565178387516)(assets\\1563939127063.png)]\" /></p>\n<h4 id=\"3配置环境变量\">3.配置环境变量</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194842945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-M3lz6kTq-1565178387517)(assets\\1563939234079.png)]\" /></p>\n<p>在profile文件中添加以下内容：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194853939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-0SxjIG8z-1565178387518)(assets\\1563939258590.png)]\" /></p>\n<p>使用source使profile生效</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019080719491061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-KlZcok9I-1565178387524)(assets\\1563939334854.png)]\" /><br />\n测试mycat命令已经可以正常使用！！！<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807195045279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"4修改mycat的配置文件\">4.修改mycat的配置文件</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195058987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-Y5sHEbse-1565178387525)(assets\\1563939427059.png)]\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195118274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-ggyxZ0dJ-1565178387525)(assets\\1563939587312.png)]\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195134837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-ukQkcW8t-1565178387526)(assets\\1563939932919.png)]\" /></p>\n<p>关闭防火墙</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195145851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-ZtqO2hDx-1565178387526)(assets\\1563939991140.png)]\" /></p>\n<p>测试<br />\n在windows主机上使用navicat连接mysql进行测试<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807195203899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-QsAmFHId-1565178387527)(assets\\1563940150731.png)]\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195304645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>连接成功后我们之后再进行增删改查操作就可以只连接mycat主机进行操作</strong>，mycat会自动的进行对mysql的主机接收增删改SQL语句，从机接收查询语句，分担主机的查询压力。</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:09', '2020-10-07 13:02:54');
INSERT INTO `tb_article` VALUES (185, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3951', 'Linux 常用基本命令总结', '<p>﻿## Linux 常用基本命令总结</p>\n<p>1.1  <strong>ls</strong><br />\n作用：查看目录下的所有文件</p>\n<p>ls -a    -后边的参数   命令可以跟参数<br />\n作用：可以查询被隐藏的文件<br />\n<strong>ls -l</strong><br />\n作用：查看文件的详细信息</p>\n<p>通常我们结合起来使用：<br />\n查询文件夹下的全部文件信息：<strong>ls -la</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203216430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\nr:可读权限<br />\nw：可写权限<br />\nx：可执行权限</p>\n<p>三个为一组，其中前三个为当前用户对该文件的权限<br />\n中间三个为root管理员用户的权限<br />\n最后三个是其他用户的权限</p>\n<p>例如，如果设置为只可读：r--<br />\n只可读写：rw-<br />\n等<br />\n1.2 <strong>cd  切换目录</strong></p>\n<p>绝对路径   以 /  开头<br />\n相对路径   从当前所在的目录开始</p>\n<p>cd .   一个.代表当前目录<br />\ncd ..   两个..代表上一级目录<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080720354164.png\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>1.3 mkdir</strong><br />\n作用：创建文件夹<br />\n用法： mkdir  文件夹名称(可以是相对或者绝对路径)<br />\nmkdir  a1  在当前文件夹中创建a1文件夹<br />\nmkdir -p a1/b1  创建b1文件夹，如果父文件夹不存在可以一并创建</p>\n<p><strong>1.4 touch</strong>   (了解)<br />\n作用：创建空白文件<br />\ntouch 1.txt  创建一个空白的1.txt文件</p>\n<p><strong>1.5 echo</strong><br />\n作用：打印<br />\necho hello   向控制台打印hello字符串</p>\n<p><strong>1.6  &gt;  &gt;&gt;</strong><br />\n作用：指定输出的文件<br />\necho hello &gt; 1.txt  向1.txt文件中输出hello<br />\n区别 &gt; 是覆盖原有文件的内容  &gt;&gt; 在原有文件中追加新的内容</p>\n<p><strong>1.7 cat</strong><br />\n作用：查看文件内容<br />\ncat  1.txt  在控制台打印1.txt文件中的内容</p>\n<p><strong>1.8 cp</strong><br />\n作用：复制<br />\n在tmp目录下创建一个文件1.txt<br />\n[root@localhost  tmp] cp  1.txt  /1.txt  将当前目录下的1.txt 复制到根目录下</p>\n<p><strong>1.9 mv</strong><br />\n作用：移动和重命名<br />\n[root@localhost  tmp] mv  1.txt  2.txt  将当前目录下的1.txt 重命名为2.txt<br />\n[root@localhost  tmp] mv  2.txt  /     将当前目录下的2.txt 移动到 跟目录下</p>\n<p><strong>2.0 rm</strong><br />\n作用：删除<br />\n有询问的删除!!<br />\nrm 文件名<br />\nrm -r 文件夹      -r 是递归<br />\n不带询问的删除 -f<br />\nrm -f 文件名    直接删除文件，不询问<br />\nrm -rf 文件夹    直接删除文件夹，不询问</p>\n<p><strong>2.2 pwd</strong><br />\n作用：打印当前所在的目录路径<br />\n可以获取当前路径进行复制使用<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080720355591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2.3 cat、more、less、head、tail</strong><br />\n作用：查看文件的内容<br />\ncat特点：展示文件中所有内容</p>\n<p>more和less 特点：分页展示文件中内容<br />\n回车往下一行 ，空格往下翻一页</p>\n<pre><code> more只能往下翻， less还可以通过键盘上的上下键 上下翻\n 使用less查看，使用q键退出查看\n</code></pre>\n<p>head特点：查看文件的前n行<br />\nhead  -n  5  /etc/profile  查看文件的前5行</p>\n<p>tail特点：查看文件的最后几行<br />\ntail的特殊作用：查看日志文件 tail -f xxx.txt  可以监听文件，打印出新生产的日志信息</p>\n<p><strong>2.3 tab键</strong>  （键盘上的一个快捷键）<br />\n作用：自动补全命令 文件路径等<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080720361717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2.4 grep</strong><br />\n作用：根据关键字查找<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203652730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>2.5 find</strong><br />\n作用：从系统中进行查找<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203702947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>2.6 systemctl  (system control)</strong><br />\n作用：开启、关闭、查看、重启系统的服务<br />\n语法：systemctl  start     服务名<br />\nsystemctl  restart   服务名<br />\nsystemctl  stop     服务名<br />\nsystemctl  status    服务名</p>\n<p>例如：以防火墙为例，进行服务器的开启，关闭等操作</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807203715174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>在centos6  services iptables stop  (了解)<br />\n重启虚拟机防火墙会自动开启</p>\n<p>在实际的阿里云服务器中可以不关闭防火墙，只开启指定端口(通过图形界面完成)</p>\n<p><strong>2.7 ps -ef</strong><br />\n作用：查看虚拟机正在运行的进程<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203737801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2.8 kill -9 进程id</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807203800657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n如果当前虚拟机ip丢失，dhclient命令又无法使用<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203811609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>3.0 tar 命令</strong><br />\n作用：对文件进行压缩和解压缩操作<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203821896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"2vi编辑器\">2.VI编辑器</h2>\n<p>作用：linux操作的一款编辑器，只能用键盘操作，无法使用鼠标</p>\n<p>使用 vi 文件名     进入vi编辑器<br />\n输入i、A、a、O、o都可进入编辑模式，进入编辑模式左下角会变成insert<br />\n按下Esc键盘左上角的退出键退出编辑模式<br />\n：冒号进入末行模式<br />\nq，不保存退出vi<br />\nq! ,不保存强制退出<br />\nwq保存退出vi<br />\nwq！，保存并强制退出</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019080720390785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"命令补充\">命令补充</h2>\n<p>权限相关：groupadd  组名<br />\nuseradd -g 组名 用户名<br />\npasswd 用户名<br />\nsu 用户名<br />\nchmod u=rwx,g=rwx,o=rwx 文件</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:13', '2020-10-07 13:01:43');
INSERT INTO `tb_article` VALUES (186, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7538', 'Redis数据库的介绍、安装、数据结构、常用命令', '<p>﻿## 1、 redis是什么呢？</p>\n<p>redis是非关系型数据库(nosql)，基于内存读写的数据库,采用key-value的方式存储数据<br />\n<strong>nosql：  not noly sql</strong> ，没有表的SQL</p>\n<p>在目前的企业开发中会用关系型数据库（Oracale+MySQL）+非关系型数据库(Redis 、MongoDB、Memcache)共同开发项目</p>\n<p><strong>为什么使用NoSQL</strong></p>\n<p>现在存在数据格式非常多样，不适合应用表格进行存储。<br />\n表格数据称之为 结构化数据<br />\n非表格数据称之为 半结构化 （kv json)  非结构化数据 音频 视频</p>\n<p>Redis是基于内存读写的数据库，<br />\n硬盘读取速度 大约几百M<br />\n内存读取速度 大约 上千M<br />\n所以Redis相对来说是要比关系型数据库要快很多</p>\n<p>Redis的应用场景：查询读取操作非常频繁的业务<br />\n例如：缓存</p>\n<h2 id=\"2redis的下载安装\">2、Redis的下载安装</h2>\n<p>Redis可从<br />\n<a href=\"https://redis.io/download\">https://redis.io/download</a><br />\n官网进行下载，有windows版和linux版，<br />\n都是下载直接解压就可使用<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807210547190.png\" alt=\"在这里插入图片描述\" /><br />\n解压后的目录如下：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807211247767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n不过需要注意的是：<br />\n在windows系统上，我们要修改redis.windows.conf这个文件，将appendonly no改为appendonly yes<br />\n因为redis是忘往内存上面存储数据的，改完这个可以使数据直接同步到硬盘上。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807211152164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n而启动的时候也不要双击redis-server.exe进行启动，因为这样启动是不能加载到redis.windows.conf这个配置文件的，<br />\n所以启动的时候我们要在redis解压的目录下进入cmd，<br />\n输入：redis-server  redis.windows.conf  启动redis服务<br />\n如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807211617774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n这样就启动了Redis服务，再双击redis-cli.exe就启动了Redis的客户端</p>\n<p>Linux系统下启动Redis服务要进到解压目录的src下，<br />\n输入./redis-server  ../redis.conf<br />\n进行启动，如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807212204837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"3redis的数据结构常用命令\">3、Redis的数据结构、常用命令</h2>\n<p><strong>redis数据库存储数据使用的key-value</strong><br />\n<strong>key是string类型  value的数据结构支持5个string、set、sorted_set、list、hash</strong></p>\n<p>value最大占用空间 1GB<br />\nredis支持的数据结构比较丰富、对不同的数据结构，还拥有不同的操作命令</p>\n<p>set、get、del<br />\nkeys *  打印所有的key</p>\n<p>基础命令 （key value）</p>\n<p>keys *</p>\n<p>命令的作用：显示redis中 所有的key<br />\nkeys  name*  name后面可以有0---多个任意字符<br />\nkeys  name?  name后面必须只存在一个字符</p>\n<p><strong>exists key</strong><br />\n判断 key是否存在 若返回 1 则存在 0 不存在</p>\n<p><strong>del key</strong><br />\n作用：删除 某一个key</p>\n<p><strong>help 命令</strong><br />\n帮助命令</p>\n<p><strong>flushall</strong> 清空所有数据库中的内容</p>\n<p>退出 <strong>exit|quit</strong> 退出redis的服务器</p>\n<h2 id=\"redis中值是字符串类型-string-数字\">Redis中值是字符串类型 （String 数字）</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213239589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>set</strong><br />\n用于设置 一个字符串类型的  key value</p>\n<p><strong>get</strong><br />\n根据key获取值</p>\n<p><strong>mset</strong><br />\n一次性设置多个 key value</p>\n<p>mget<br />\nstrlen<br />\nappend<br />\ngetrange 截取子串<br />\ngetrange name 0 3<br />\nsetex 设置一个key的存活有效期 (秒) psetex 作用与 setex 一致 但是毫秒<br />\nsetnx<br />\n如果当前没有这个key的话 那么 setnx等价于 set命令<br />\n如果当前存在这个key的话 那么 setnx不起作用<br />\ndecr 针对数字类型 做 -1操作 另外 desr key 数字 根据数字做减法操作<br />\nincr incrby incrbyfloat</p>\n<blockquote>\n<p>应用场景：缓存查询结果(json或者序列化) 用户访问记录 例如：通过记录ip-访问次数来显示ip的访问<br />\n统计粉丝数、点击次数、点赞</p>\n</blockquote>\n<h2 id=\"redis中值是set类型在这里插入图片描述\">Redis中值是set类型<img src=\"https://img-blog.csdnimg.cn/20190807213452727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></h2>\n<h2 id=\"c-list类型的数据操作的命令\">c) List类型的数据操作的命令</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213545465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\ni.	lpush 栈式结构<br />\nlpush name suns[2]<br />\nlpush name xiaohei[1]<br />\nlpush name xiaowb[0]<br />\nii.	lpushx 如果操作的key不存在 则不起作用<br />\n如果操作的key存在 则等同于lpush<br />\niii.	rpush 操作的内容 等效 java List<br />\n第一个操作的元素 就放置在第一个位置<br />\n依次类推<br />\n应用场景：关注列表、消息队列</p>\n<h2 id=\"hash类型的数据操作的命令\">hash类型的数据操作的命令</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213752596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"zset-sorted-set类型的数据操作的命令\">zset (sorted_set)类型的数据操作的命令</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213813240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"7-redis命令的补充部分\">7. Redis命令的补充部分</h2>\n<p>a)	只有set命令 可以操作 任意类型的数据</p>\n<p>b)	注意Redis中会有数据库概念 默认存在16数据库 0 ---- 15</p>\n<p>默认所使用的数据库 0 如果要选择使用别的数据库 select 编号</p>\n<p>注意：不同数据库所创建的key 相互隔离 互补干扰的。通过flushall 清空的是所有数据库中的key. 清空当前的数据库 flushdb这个命令<br />\n如何该表Redis中对于数据库的支持呢？编辑 redis.conf</p>\n<p>**	expire相关命令  （促销 秒杀  手机验证码倒计时 排行榜  Cache）**<br />\ni.	在Redis创建key value 默认都是持久化的 永久保存。<br />\nii.	可以通过expire 命令 指定 key 存活时间<br />\nexpire key seconds</p>\n<p><strong>查看某一个key的存活时常</strong><br />\npersist 作用 可以把 一个应用了expire命令key 再次转换持久化的key<br />\nexpireat key  unix 时间戳 毫秒数iii.</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213646467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:20', '2021-08-30 09:57:06');
INSERT INTO `tb_article` VALUES (187, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8724', '面试题：说一下HashMap和HashSet的实现原理？', '<p>﻿## HashMap 的实现原理：</p>\n<p><strong>HashMap是基于Hash算法实现的，</strong><br />\n我们通过put（key，value）存储数据，通过get（key）来获取数据</p>\n<p>当传入key时，HashMap会根据Key.hashCode()计算出Hash值，根据Hash值将value保存在bucket里	，。</p>\n<p><strong>当计算出相同的Hash值时，我们称之为Hash冲突</strong>，HashMap 的做法是用链表和红黑树存储相同Hash值的value，<br />\n当hash冲突的个数比较少时，使用链表存储，<br />\n否则使用红黑树。</p>\n<h2 id=\"hashset-的实现原理\">HashSet 的实现原理：</h2>\n<p>HashSet是基于HashMap实现的，HashSet 底层使用HashMap来保存所有元素，<br />\n因此HashSet 的实现比较简单，相关HashSet 的操作，基本上都是直接调用底层HashMap的相关方法来完成，HashSet不允许有重复的值，并且元素是无序的。</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:25', '2021-08-30 09:53:48');
INSERT INTO `tb_article` VALUES (188, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5088', '多线程相关面试题_并行和并发的区别、线程和进程、线程的创建方式、运行状态', '<p>﻿<strong>1，并行和并发有什么区别</strong></p>\n<p>并行：多个处理器或多核处理器同时处理多个任务。<br />\n并发：多个任务在同一个CPU核上，按细分的时间片轮流（交替）执行，从逻辑上来看并发的任务是同时执行；</p>\n<p>简而言之：<br />\n并发=两个队列和一台处理器<br />\n并发=两个队列和两个处理器</p>\n<p><strong>2、线程和进程的区别</strong></p>\n<p>一个程序下至少有一个进程，<br />\n一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p>\n<p><strong>3.守护线程是什么?</strong></p>\n<p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在Java中垃圾回收线程就是特殊的守护线程。</p>\n<p><strong>4.创建线程有哪几种方式?</strong></p>\n<p>创建线程有三种方式:</p>\n<pre><code>  ●继承Thread重写run方法;\n\n  ●实现Runnable接口;\n\n  ●实现Callable接口。\n</code></pre>\n<p><strong>5.线程有哪些状态?线程的状态:</strong></p>\n<pre><code>   NEW尚未启动\n\n   RUNNABLE正在执行中\n\n   BLOCKED阻塞的(被同步锁或者I0锁阻塞)\n\n   WAITING永久等待状态\n\n  TIMED_ WAITING 等待指定的时间重新被唤醒的状态\n</code></pre>\n<p><strong>6，sleep（）和 wait（）的区别</strong></p>\n<p>类的不同，sleep（）来自Thred ，wait（）来着Object，<br />\n释放锁，sleep（）不释放锁，而wait（）释放锁<br />\n用法不同，sleep（）到时间会自动醒来，自动回复线程，而wait（）需要用notify（）/  notifyAll()来唤醒线程。</p>\n<p><strong>7，线程的run（）和start（）方法有什么区别</strong></p>\n<p>start（）方法用于启动线程，<br />\nrun（）方法用于执行线程的运行时代码，<br />\nrun（）可以重复使用，而start（）只能调用一次。</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:52', '2021-08-30 09:53:36');
INSERT INTO `tb_article` VALUES (189, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8701', 'tomcat集群环境下如何保证session一致性', '<p>﻿## 为什么集群环境下，会出现session不一致问题？</p>\n<p>答：使用nginx的负载均衡之后，不确定访问哪个tomcat，导致客户端存储的jsessionid携带到集群环境下的其他tomcat是无效的。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811142904838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>关于集群环境下，解决session不一致问题?</strong></p>\n<p>方式1：负载均衡的策略ip黏着：在nginx的default.conf配置<strong>ip_hash</strong>,这样客户端会固定的访问某一台服务器</p>\n<p>方式2：使用redis管理集群环境的session，session对象不在存储在tomcat服务器，而是redis数据库中,如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811143147501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>实现原理描述:</strong><br />\n客户端访问nginx，分配到tomcat-1服务器，创建session对象，jsessionid,将jsessionid作为key，session对象作为value存到redis数据库中，随着响应将jsessionid返回给客户端浏览器，该客户端浏览器向nginx在次发出请求，写cookie(包含jsessionid),到nginx后被分配到tomcat-2服务器，tomcat-2获取cookie中的jsessionid，去redis数据库查找对应的session对象并且返回使用</p>\n<h2 id=\"实现步骤\">实现步骤：</h2>\n<p>1.将下边三个jar上传到tomcat服务器中的lib目录下<br />\n要重写tomcat的session实现方法，将session管理到redis服务器中<br />\n如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811143509147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2. 修改tomcat中conf目录下的context.xml<br />\n原因1：我们上传的jar中的类，替换了tomcat中的代码，需要让tomcat知道我们的类叫什么名字<br />\n原因2：配置redis数据库所在服务器的ip地址和redis数据库的端口号</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190811143631510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n3. 重启tomcat服务<br />\n进入bin目录 ,先执行./shutdown.sh 再执行./startup.sh</p>\n<p>注意：以上操作集群中的tomcat(有几个就操作几个)都是相同的操作</p>\n<p>4，测试<br />\n做一个登陆页面，测试一下上面的操作有没有成功</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:58', '2020-12-21 14:52:10');
INSERT INTO `tb_article` VALUES (190, 1, 5, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3685', 'mybatis的二级缓存，以及如何利用redis优化mybatis缓存？', '<p>﻿学习redis，缓存是很重要的一块</p>\n<p><strong>1.1 为什么要使用缓存？</strong></p>\n<p>为mybatis增加缓存功能，可有利用减少数据库访问</p>\n<p>系统运行的瓶颈很重要的一个因素就是数据库，<br />\n减少数据库的访问压力，可以提高整个系统的吞吐量。</p>\n<p><strong>什么是缓存？</strong></p>\n<p>将SQL语句，以及对应的查询结果存在服务器内存中，这一块内存存储区域，被我们称之为缓存。</p>\n<p>如果之后再执行该同样的SQL语句，则直接从缓存中去取，不再去查询数据库，可减小数据库的访问压力。</p>\n<p><strong>缓存的核心使用思路</strong></p>\n<ol>\n<li>开启缓存</li>\n<li>缓存的作用范围 缓存中的数据可以使用的范围</li>\n<li>脏数据的处理<br />\n脏数据：缓存是数据库中热点数据的备份，当数据库中的热点数据发生变化时，缓存也要和数据库保持一致，否则相应的数据成为脏数据。</li>\n</ol>\n<h2 id=\"12-mybatis现有的缓存\">1.2 mybatis现有的缓存</h2>\n<p><strong>mybatis的缓存分成一级缓存和二级缓存</strong></p>\n<p>一级缓存也称之为SqlSession级别的缓存，默认开启，只一次查询有效，作用范围太小，意义不大。<br />\n脏数据的处理 ：执行增删改有可能造成脏数据，一旦执行增删改立刻清空缓存。</p>\n<p>二级缓存称之为SqlSessionFactory级别的缓存,<br />\n通常我们所说的缓存默认指的就是二级缓存。</p>\n<p>二级缓存使用步骤</p>\n<ol>\n<li>开启二级缓存 (如果和spring整合，默认已经开启)<br />\n若没有，要在mybatis-config.xml中配置一下信息：</li>\n</ol>\n<pre><code>&lt;settings&gt;\n	&lt;setting name = &quot;cacheEnabled&quot;  value=&quot;true&quot; /&gt; \n&lt;/settings&gt;\n</code></pre>\n<ol start=\"2\">\n<li>在mapper文件增加 &lt; cache/&gt;</li>\n</ol>\n<p>*Mapper.xml中配置：</p>\n<pre><code>&lt;cache /&gt;\n</code></pre>\n<p>只有添加了cache标签的mapper文件中的查询结果才会放置到对应的二级缓存中</p>\n<ol start=\"3\">\n<li>\n<p>将需要存储到缓存中的对象实现序列化接口</p>\n</li>\n<li>\n<p>二级缓存作用范围<br />\n同1个namespace下</p>\n</li>\n<li>\n<p>脏数据的处理<br />\n执行同1个namespace下的增删改，自动清空该namespace下的缓存</p>\n</li>\n</ol>\n<p>内置的二级缓存通常也不用。<br />\n内置的二级缓存本身有namespace的问题，并且不支持持久化。<br />\n所以平时主要用：Ehcache 独立的缓存组件，使用纯Java编写。<br />\n准备工作：引入相关jar包 ehcache-core.jar   mybatis-ehcache.jar</p>\n<p>使用步骤：</p>\n<ol>\n<li>开启 缓存，Config.xml中配置和上面一样</li>\n<li>mapper.xml中配置，cache标签要加一个type属性指向我们自定义的cache<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081115082521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></li>\n<li>src下添加ehcache.xml<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811150937127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\nEncache作用于整个项目中 。<br />\n对脏数据的处理：执行增删改，立刻清空缓存中的数据。</li>\n</ol>\n<p>注意：低版本的mybatis配合ehcache有问题，需要升级mybatis到3.2以上<br />\n另外ehcache.xml 需要添加updateCheck=”false” 禁用检查更新<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811151048191.png\" alt=\"在这里插入图片描述\" /></p>\n<p>说了这么多，</p>\n<h2 id=\"如何使用redis优化mybatis缓存\">如何使用redis优化mybatis缓存</h2>\n<p>mybatis已经实现了二级缓存，为什么使用redis对其优化？？？</p>\n<p>mybatis本身二级缓存的查询结果要存储在当前服务器的JVM虚拟机中，如果缓存的数据量过大会造成jvm服务器臃肿缓慢，大量占用内存空间。</p>\n<p>所以我们最好将缓存的数据从tomcat服务器上转移到redis服务器上，redis存取速度快，并且是一个独立进程和jvm没有关系。</p>\n<p><strong>实现步骤</strong></p>\n<ol>\n<li>添加jar包<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081115272444.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在mapper文件中，增加自定义二级缓存的实现类配置<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081115302038.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></li>\n<li>在src下，增加一个redis.properties配置文件，指明要连接redis数据库的ip和端口号<br />\n默认是连接本地的redis<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811153210940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n总结：为了减少mysql数据库的查询压力，借助mybatis二级缓存，让多用户共享查询结果<br />\n前提执行的SQL语句是相同的。但是项目运行过程中，发现二级缓存存储的数据量越来越大，大量占用了当前JVM的空间，为了解决这个问题，使用redis数据库存储缓存的数据</li>\n</ol>\n', 1, '', 0, 0, 1, '2020-10-07 12:56:29', '2022-05-21 18:13:56');
INSERT INTO `tb_article` VALUES (191, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=657', 'spring boot 实现文件的上传下载', '<p>﻿## spring boot实现文件的上传，</p>\n<p>我是使用maven搭建的spring boot项目，页面集成的jsp。<br />\n页面结构如下：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811160646759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n准备工作：在webapp下新建一个目录叫upload</p>\n<p><strong>1，页面，upload.jsp</strong></p>\n<pre><code>&lt;body&gt;\n&lt;form method=&quot;post&quot; action=&quot;${pageContext.request.contextPath}/file/upload&quot; enctype=&quot;multipart/form-data&quot;&gt;\n    &lt;input type=&quot;file&quot; name=&quot;files&quot;&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n</code></pre>\n<p><strong>2) 控制器 ,FileController.java</strong></p>\n<pre><code>@Controller\n@RequestMapping(&quot;/file&quot;)\npublic class FileController {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RequestMapping(&quot;/upload&quot;)\n    public String upLoad(MultipartFile files, HttpSession session) throws IOException {\n        logger.info(&quot;upload 方法执行了&quot;);\n        //获取上传文件的路径\n        String realPath = session.getServletContext().getRealPath(&quot;upload&quot;);\n        System.out.println(&quot;--------&quot;+realPath);\n        //获取上传的文件名，\n        File file1 = new File(realPath, files.getOriginalFilename());\n        //执行文件上传复制\n        files.transferTo(file1);\n        //跳到下载页面\n        return &quot;/download.jsp&quot;;\n\n    }\n}\n</code></pre>\n<p><strong>3) 修改上传文件大小的限制，application.properties</strong></p>\n<pre><code>//配置tomcat端口号\nserver.port=8080\n//项目访问路径\nserver.servlet.context-path=/maven_springboot\n//jsp页面热部署\nserver.servlet.jsp.init-parameters.development=true\n//修改上传文件大小限制为10Mb\nspring.servlet.multipart.max-file-size=10485760\n\n</code></pre>\n<h2 id=\"2下载\">2，下载</h2>\n<p><strong>1) 页面 download.jsp</strong><br />\n这里的fileName应该是要从数据库读取出来，包括上传也是应该把上传的文件信息存到数据库，这里我就不写了。<br />\n就直接把文件写死了，</p>\n<pre><code>&lt;body&gt;\n&lt;a href=&quot;${pageContext.request.contextPath}/file/download?fileName=aaa.png&quot;&gt;下载&lt;/a&gt;\n&lt;/body&gt;\n</code></pre>\n<p><strong>2）控制器, FileController</strong></p>\n<pre><code> @RequestMapping(&quot;/download&quot;)\n    public void Download(String fileName, HttpServletResponse response,HttpSession session) throws Exception {\n   //设置下载响应头\n        response.setHeader(&quot;content-disposition&quot;,&quot;attachment;fileName&quot;+ URLEncoder.encode(fileName,&quot;UTF-8&quot;));\n    //获取文件路径\n        String uploadPath = session.getServletContext().getRealPath(&quot;upload&quot;);\n\n        File file = new File(uploadPath,fileName);\n        ServletOutputStream outputStream = response.getOutputStream();\n        FileUtils.copyFile(file,response.getOutputStream());\n\n    }\n</code></pre>\n<p>这里要用到一个jar包，commons-io包的FileUtils工具类，<br />\npom引入该依赖如下：</p>\n<pre><code> &lt;dependency&gt;\n      &lt;groupId&gt;commons-io&lt;/groupId&gt;\n      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;\n      &lt;version&gt;2.4&lt;/version&gt;\n    &lt;/dependency&gt;\n\n</code></pre>\n<p>如此，一个简单的上传下载demo就算完成了</p>\n', 1, '', 0, 0, 1, '2020-09-29 17:25:27', '2020-12-21 14:53:59');
INSERT INTO `tb_article` VALUES (192, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=898', 'Centos Linux系统使用vsftpd搭建ftp服务', '<p>﻿## Linux，Centos系统使用vsftpd搭建ftp服务</p>\n<h3 id=\"一安装vsftpd\">一、安装vsftpd</h3>\n<ol>\n<li>运行以下命令安装vsftpd。</li>\n</ol>\n<pre><code class=\"language-powershell\">yum install -y vsftpd\n</code></pre>\n<p>返回如下图所示界面时，表示安装成功。<br />\n<img src=\"https://img-blog.csdnimg.cn/20201011163459305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"2\">\n<li>运行以下命令设置FTP服务开机自启动。</li>\n</ol>\n<pre><code class=\"language-powershell\">systemctl enable vsftpd.service\n</code></pre>\n<ol start=\"3\">\n<li>启动FTP服务。</li>\n</ol>\n<pre><code class=\"language-powershell\">systemctl start vsftpd.service\n</code></pre>\n<ol start=\"4\">\n<li>运行以下命令查看FTP服务监听的端口。</li>\n</ol>\n<pre><code class=\"language-powershell\">netstat -antup | grep ftp\n</code></pre>\n<p>出现如下图所示界面，表示FTP服务已启动，监听的端口号为 21。此时，vsftpd默认已开启匿名访问功能，您无需输入用户名密码即可登录FTP服务器，但没有修改或上传文件的权限。<br />\n<img src=\"https://img-blog.csdnimg.cn/20201011163555146.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h3 id=\"二配置vsftpd\">二、配置vsftpd</h3>\n<blockquote>\n<p>vsftpd（very secure FTP<br />\ndaemon）是一款在Linux发行版中最受推崇的FTP服务器。vsftpd支持匿名访问和本地用户模式两种访问方式。匿名访问方式任何用户都可以访问搭建的FTP服务；本地用户模式只支持添加的本地用户访问搭建的FTP服务。</p>\n</blockquote>\n<ul>\n<li>说明: 匿名用户模式和本地用户模式只可同时配置一种。</li>\n</ul>\n<h4 id=\"21-匿名用户模式\">2.1 匿名用户模式</h4>\n<ol>\n<li>修改配置文件vsftpd.conf。</li>\n</ol>\n<pre><code class=\"language-powershell\">vim /etc/vsftpd/vsftpd.conf\n</code></pre>\n<p>按 i 键进入编辑模式，将匿名上传权限 anon_upload_enable=YES 的注释解开。<br />\n<img src=\"https://img-blog.csdnimg.cn/20201011163821978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"2\">\n<li>\n<p>按ESC键退出编辑模式，输入:wq 保存并退出vim。</p>\n</li>\n<li>\n<p>更改/var/ftp/pub目录的权限，为FTP用户添加写权限。</p>\n</li>\n</ol>\n<pre><code class=\"language-powershell\">chmod o+w /var/ftp/pub/\n</code></pre>\n<ol start=\"4\">\n<li>重启FTP服务。</li>\n</ol>\n<pre><code class=\"language-powershell\">systemctl restart vsftpd.service\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20201011163953415.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"22-本地用户模式\">2.2 本地用户模式</h4>\n<ol>\n<li>为FTP服务创建一个Linux用户。</li>\n</ol>\n<pre><code class=\"language-powershell\">adduser ftptest\n</code></pre>\n<p>为用户设置密码。</p>\n<pre><code class=\"language-powershell\">passwd ftptest\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20201011164202186.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"2\">\n<li>创建一个供FTP服务使用的文件目录。</li>\n</ol>\n<pre><code class=\"language-powershell\">mkdir /var/ftp/test\n</code></pre>\n<ol start=\"3\">\n<li>更改/var/ftp/test目录的拥有者为ftptest。</li>\n</ol>\n<pre><code class=\"language-powershell\">chown -R ftptest:ftptest /var/ftp/test\n</code></pre>\n<ol start=\"4\">\n<li>修改vsftpd.conf配置文件。</li>\n</ol>\n<p>配置FTP为主动模式请执行如下命令:</p>\n<pre><code class=\"language-powershell\">sed -i \'s/anonymous_enable=YES/anonymous_enable=NO/\' /etc/vsftpd/vsftpd.conf #禁止匿名登录FTP服务器 \nsed -i \'s/listen=NO/listen=YES/\' /etc/vsftpd/vsftpd.conf #监听IPv4 sockets \nsed -i \'s/listen_ipv6=YES/#listen_ipv6=YES/\' /etc/vsftpd/vsftpd.conf #关闭监听IPv6 sockets \nsed -i \'s/#chroot_local_user=YES/chroot_local_user=YES/\' /etc/vsftpd/vsftpd.conf #全部用户被限制在主目录 \nsed -i \'s/#chroot_list_enable=YES/chroot_list_enable=YES/\' /etc/vsftpd/vsftpd.conf #启用例外用户名单 \nsed -i \'s/#chroot_list_file=/chroot_list_file=/\' /etc/vsftpd/vsftpd.conf #指定例外用户列表文件，列表中的用户不被锁定在主目录 \necho &quot;allow_writeable_chroot=YES&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf \necho &quot;local_root=/var/ftp/test&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置本地用户登录后所在的目录\n</code></pre>\n<p>配置FTP为被动模式请执行如下命令：</p>\n<pre><code class=\"language-powershell\">sed -i \'s/anonymous_enable=YES/anonymous_enable=NO/\' /etc/vsftpd/vsftpd.conf #禁止匿名登录FTP服务器 \nsed -i \'s/listen=NO/listen=YES/\' /etc/vsftpd/vsftpd.conf #监听IPv4 sockets \nsed -i \'s/listen_ipv6=YES/#listen_ipv6=YES/\' /etc/vsftpd/vsftpd.conf #关闭监听IPv6 sockets \nsed -i \'s/#chroot_local_user=YES/chroot_local_user=YES/\' /etc/vsftpd/vsftpd.conf #全部用户被限制在主目录 \nsed -i \'s/#chroot_list_enable=YES/chroot_list_enable=YES/\' /etc/vsftpd/vsftpd.conf #启用例外用户名单 \nsed -i \'s/#chroot_list_file=/chroot_list_file=/\' /etc/vsftpd/vsftpd.conf #指定例外用户列表文件，列表中的用户不被锁定在主目录 \necho &quot;allow_writeable_chroot=YES&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf \necho &quot;local_root=/var/ftp/test&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置本地用户登录后所在的目录 \n\necho &quot;pasv_enable=YES&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #开启被动模式 \necho &quot;pasv_address=&lt;FTP服务器公网IP地址&gt;&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #本教程中为ECS服务器弹性IP \necho &quot;pasv_min_port=20&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置被动模式下，建立数据传输可使用的端口范围的最小值 \necho &quot;pasv_max_port=21&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置被动模式下，建立数据传输可使用的端口范围的最大值\n</code></pre>\n<ol start=\"5\">\n<li>在/etc/vsftpd目录下创建chroot_list文件，并在文件中写入例外用户名单。</li>\n</ol>\n<pre><code class=\"language-powershell\">#使用vim命令编辑chroot_list文件，添加例外用户名单。此名单中的用户不会被锁定在主目录，可以访问其他目录。\nvim /etc/vsftpd/chroot_list\n</code></pre>\n<p>说明: 没有例外用户时，也必须创建chroot_list文件，内容可为空。</p>\n<ol start=\"6\">\n<li>重启FTP服务。</li>\n</ol>\n<pre><code class=\"language-powershell\">systemctl restart vsftpd.service\n</code></pre>\n<h2 id=\"三客户端测试\">三、客户端测试</h2>\n<p>FTP客户端、Windows命令行工具或浏览器均可用来测试FTP服务器。（此步骤仅适用于本地用户，匿名模式无需进行测试操作）</p>\n<p>说明：使用浏览器访问FTP服务器出错时，建议您清除浏览器缓存后再尝试。</p>\n<ol>\n<li>\n<p>打开Chrom浏览器，在地址栏中输入<a href=\"ftp://&lt;\">ftp://&lt;</a>FTP服务器公网IP地址&gt;:FTP端口，FTP服务器公网IP地址为ECS服务器的弹性IP地址。例如：ftp://139.0.0.1:21。</p>\n</li>\n<li>\n<p>在弹出的对话框中，输入用户名和密码。</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20201011164412400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"3\">\n<li>登录成功界面如下，此时可对FTP文件进行相应权限的操作。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20201011164418652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-10-14 15:43:49', '2022-05-21 18:14:31');
INSERT INTO `tb_article` VALUES (193, 1, 10, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3795', '在VUE中使用RSA加密解密加签解签', '</font>\n<p>@<a href=\"目录\">TOC</a></p>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h1 id=\"前言\">前言</h1>\n<font >\n项目中部分隐私参数要前后端对接交互时，出于安全性考虑，我们会对重要的参数进行加密后再进行传输，一般采用的加密方式是非对称性加密RSA算法。\n</font>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<p><font color=#999AAA >提示：以下是本篇文章正文内容，下面案例可供参考</p>\n<h1 id=\"一什么是rsa加密\">一、什么是RSA加密？</h1>\n<p><font color=#999AAA >RSA加密是一种非对称加密。<br />\n可以在不直接传递密钥的情况下，完成解密。<br />\n这能够确保信息的安全性，避免了直接传递密钥所造成的被破解的风险。<br />\nRSA是由一对密钥来进行加解密的过程，分别称为公钥和私钥。<br />\n两者之间有数学相关，该加密算法的原理就是对一极大整数做因数分解的困难性来保证安全性。<br />\n通常个人保存私钥，公钥是公开的（可能同时多人持有）。</p>\n<h1 id=\"二加密过程\">二、加密过程</h1>\n<ul>\n<li>（1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。</li>\n<li>（2）A传递自己的公钥给B，B用A的公钥对消息进行加密。</li>\n<li>（3）A接收到B加密的消息，利用A自己的私钥对消息进行解密。<br />\n　<br />\n在这个过程中，只有2次传递过程，第一次是A传递公钥给B，第二次是B传递加密消息给A，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行解密，防止了消息内容的泄露。</li>\n</ul>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h1 id=\"三在vue中使用步骤\">三、在Vue中使用步骤</h1>\n<p>一般是客户端初始化时访问服务端时，服务端会生成一对RSA对，及公钥和密钥。</p>\n<ul>\n<li>如果前端只需要将要传给后端的数据进行<strong>加密</strong>后传输，那么前端可以只要公钥，通过公钥对要传输的参数进行加密后把加密的字符串发给后端即可，后端自有办法解密。</li>\n<li>如果前端要获取后端传过来的已经加密后的字符串，并且<strong>解密</strong>使用，那么前端就需要拿到RSA对立面的私钥进行解密后使用了。</li>\n</ul>\n<h3 id=\"使用步骤\">使用步骤：</h3>\n<h4 id=\"1安装依赖\">1、安装依赖</h4>\n<p>首先引入jsencrypt</p>\n<pre><code class=\"language-powershell\">npm install jsencrypt --save\n</code></pre>\n<h4 id=\"2在mainjs中引入\">2、在main.js中引入</h4>\n<pre><code class=\"language-powershell\">import JsEncrypt from \'jsencrypt\'\nVue.prototype.$jsEncrypt = JsEncrypt\n</code></pre>\n<h4 id=\"3将加密解密方法封装到通用的js内\">3、将加密解密方法封装到通用的js内</h4>\n<pre><code class=\"language-javascript\">let publicKey = \'这里是封装的公钥\'\nlet privateKey = \'这里是封装的私钥\'\n//加密方法\n  RSAencrypt(pas){\n    //实例化jsEncrypt对象\n    let jse = new JSEncrypt();\n    //设置公钥\n    jse.setPublicKey(publicKey);\n     console.log(\'加密：\'+jse.encrypt(pas))\n    return jse.encrypt(pas);\n  },\n  \n//解密方法\n  RSAdecrypt(pas){\n    let jse = new JSEncrypt();\n    // 私钥\n    jse.setPrivateKey(privateKey)\n     console.log(\'解密：\'+jse.decrypt(pas))\n    return jse.decrypt(pas);\n  },\n\n</code></pre>\n<p>我在项目中的使用如下图：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201216153329749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在VUE中使用RSA加密解密加签解签\" /></p>\n<h4 id=\"运行结果\">运行结果</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20201216153523787.png\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"总结\">总结</h1>\n<p>后端的使用Springboot对RSA进行加解密的过程可以看我的另一篇博客</p>\n', 1, '', 0, 0, 1, '2020-12-17 15:32:34', '2020-12-17 15:32:34');
INSERT INTO `tb_article` VALUES (194, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4329', 'SpringBoot集成WebSocket，实现后台向前端推送信息', '<p>@<a href=\"目录\">TOC</a></p>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h1 id=\"前言\">前言</h1>\n<p><font color=#999AAA >在一次项目开发中，使用到了Netty网络应用框架，以及MQTT进行消息数据的收发，这其中需要后台来将获取到的消息主动推送给前端，于是就使用到了MQTT，特此记录一下。</p>\n<h1 id=\"一什么是websocket\">一、什么是websocket？</h1>\n<p><font color=#999AAA >WebSocket协议是基于TCP的一种新的网络协议。它实现了客户端与服务器全双工通信，学过计算机网络都知道，既然是全双工，就说明了<strong>服务器可以主动发送信息给客户端</strong>。这与我们的推送技术或者是多人在线聊天的功能不谋而合。<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217170824701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>为什么不使用HTTP 协议呢？这是因为HTTP是单工通信，通信只能由客户端发起，客户端请求一下，服务器处理一下，这就太麻烦了。于是websocket应运而生。<br />\n<img src=\"https://img-blog.csdnimg.cn/2020121717094782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>下面我们就直接开始使用Springboot开始整合。以下案例都在我自己的电脑上测试成功，你可以根据自己的功能进行修改即可。<br />\n我的项目结构如下：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217173226396.png\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"二使用步骤\">二、使用步骤</h1>\n<h2 id=\"1添加依赖\">1.添加依赖</h2>\n<p><font color=#999AAA >Maven依赖：</p>\n<pre><code class=\"language-xml\">	&lt;dependency&gt;  \n           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  \n           &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;  \n    &lt;/dependency&gt; \n</code></pre>\n<h2 id=\"2启用springboot对websocket的支持\">2.启用Springboot对WebSocket的支持</h2>\n<p><font color=#999AAA >启用WebSocket的支持也是很简单，几句代码搞定：</p>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.socket.server.standard.ServerEndpointExporter;\n/**\n * @ Auther: 马超伟\n * @ Date: 2020/06/16/14:35\n * @ Description: 开启WebSocket支持\n */\n@Configuration\npublic class WebSocketConfig {\n    @Bean\n    public ServerEndpointExporter serverEndpointExporter() {\n        return new ServerEndpointExporter();\n    }\n}\n</code></pre>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h2 id=\"3核心配置websocketserver\">3.核心配置：WebSocketServer</h2>\n<p><font color=#999AAA >因为WebSocket是类似客户端服务端的形式(采用ws协议)，那么这里的WebSocketServer其实就相当于一个ws协议的Controller</p>\n<ul>\n<li>@ ServerEndpoint 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端, 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端</li>\n<li>新建一个ConcurrentHashMap webSocketMap 用于接收当前userId的WebSocket，方便传递之间对userId进行推送消息。</li>\n</ul>\n<p>下面是具体业务代码：</p>\n<pre><code class=\"language-java\">package cc.mrbird.febs.external.webScoket;\n\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Service;\n\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.time.LocalDateTime;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n/**\n * Created with IntelliJ IDEA.\n * @ Auther: 马超伟\n * @ Date: 2020/06/16/14:35\n * @ Description:\n * @ ServerEndpoint 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端,\n * 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端\n */\n@Component\n@Slf4j\n@Service\n@ServerEndpoint(&quot;/api/websocket/{sid}&quot;)\npublic class WebSocketServer {\n    //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。\n    private static int onlineCount = 0;\n    //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。\n    private static CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketSet = new CopyOnWriteArraySet&lt;WebSocketServer&gt;();\n\n    //与某个客户端的连接会话，需要通过它来给客户端发送数据\n    private Session session;\n\n    //接收sid\n    private String sid = &quot;&quot;;\n\n    /**\n     * 连接建立成功调用的方法\n     */\n    @OnOpen\n    public void onOpen(Session session, @PathParam(&quot;sid&quot;) String sid) {\n        this.session = session;\n        webSocketSet.add(this);     //加入set中\n        this.sid = sid;\n        addOnlineCount();           //在线数加1\n        try {\n            sendMessage(&quot;conn_success&quot;);\n            log.info(&quot;有新窗口开始监听:&quot; + sid + &quot;,当前在线人数为:&quot; + getOnlineCount());\n        } catch (IOException e) {\n            log.error(&quot;websocket IO Exception&quot;);\n        }\n    }\n\n    /**\n     * 连接关闭调用的方法\n     */\n    @OnClose\n    public void onClose() {\n        webSocketSet.remove(this);  //从set中删除\n        subOnlineCount();           //在线数减1\n        //断开连接情况下，更新主板占用情况为释放\n        log.info(&quot;释放的sid为：&quot;+sid);\n        //这里写你 释放的时候，要处理的业务\n        log.info(&quot;有一连接关闭！当前在线人数为&quot; + getOnlineCount());\n\n    }\n\n    /**\n     * 收到客户端消息后调用的方法\n     * @ Param message 客户端发送过来的消息\n     */\n    @OnMessage\n    public void onMessage(String message, Session session) {\n        log.info(&quot;收到来自窗口&quot; + sid + &quot;的信息:&quot; + message);\n        //群发消息\n        for (WebSocketServer item : webSocketSet) {\n            try {\n                item.sendMessage(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    /**\n     * @ Param session\n     * @ Param error\n     */\n    @OnError\n    public void onError(Session session, Throwable error) {\n        log.error(&quot;发生错误&quot;);\n        error.printStackTrace();\n    }\n\n    /**\n     * 实现服务器主动推送\n     */\n    public void sendMessage(String message) throws IOException {\n        this.session.getBasicRemote().sendText(message);\n    }\n\n    /**\n     * 群发自定义消息\n     */\n    public static void sendInfo(String message, @PathParam(&quot;sid&quot;) String sid) throws IOException {\n        log.info(&quot;推送消息到窗口&quot; + sid + &quot;，推送内容:&quot; + message);\n\n        for (WebSocketServer item : webSocketSet) {\n            try {\n                //这里可以设定只推送给这个sid的，为null则全部推送\n                if (sid == null) {\n//                    item.sendMessage(message);\n                } else if (item.sid.equals(sid)) {\n                    item.sendMessage(message);\n                }\n            } catch (IOException e) {\n                continue;\n            }\n        }\n    }\n\n    public static synchronized int getOnlineCount() {\n        return onlineCount;\n    }\n\n    public static synchronized void addOnlineCount() {\n        WebSocketServer.onlineCount++;\n    }\n\n    public static synchronized void subOnlineCount() {\n        WebSocketServer.onlineCount--;\n    }\n\n    public static CopyOnWriteArraySet&lt;WebSocketServer&gt; getWebSocketSet() {\n        return webSocketSet;\n    }\n}\n</code></pre>\n<h2 id=\"4测试controller\">4.测试Controller</h2>\n<pre><code class=\"language-java\">\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Created with IntelliJ IDEA.\n *\n * @ Auther: 马超伟\n * @ Date: 2020/06/16/14:38\n * @ Description:\n */\n@Controller(&quot;web_Scoket_system&quot;)\n@RequestMapping(&quot;/api/socket&quot;)\npublic class SystemController {\n    //页面请求\n    @GetMapping(&quot;/index/{userId}&quot;)\n    public ModelAndView socket(@PathVariable String userId) {\n        ModelAndView mav = new ModelAndView(&quot;/socket1&quot;);\n        mav.addObject(&quot;userId&quot;, userId);\n        return mav;\n    }\n\n    //推送数据接口\n    @ResponseBody\n    @RequestMapping(&quot;/socket/push/{cid}&quot;)\n    public Map pushToWeb(@PathVariable String cid, String message) {\n        Map&lt;String,Object&gt; result = new HashMap&lt;&gt;();\n        try {\n            WebSocketServer.sendInfo(message, cid);\n            result.put(&quot;code&quot;, cid);\n            result.put(&quot;msg&quot;, message);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n}\n\n</code></pre>\n<h2 id=\"5测试页面indexhtml\">5.测试页面index.html</h2>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n	&lt;head&gt;\n		&lt;meta charset=&quot;utf-8&quot;&gt;\n		&lt;title&gt;Java后端WebSocket的Tomcat实现&lt;/title&gt;\n		&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;\n	&lt;/head&gt;\n\n	&lt;body&gt;\n		&lt;div id=&quot;main&quot; style=&quot;width: 1200px;height:800px;&quot;&gt;&lt;/div&gt;\n		Welcome&lt;br/&gt;&lt;input id=&quot;text&quot; type=&quot;text&quot; /&gt;\n		&lt;button onclick=&quot;send()&quot;&gt;发送消息&lt;/button&gt;\n		&lt;hr/&gt;\n		&lt;button onclick=&quot;closeWebSocket()&quot;&gt;关闭WebSocket连接&lt;/button&gt;\n		&lt;hr/&gt;\n		&lt;div id=&quot;message&quot;&gt;&lt;/div&gt;\n	&lt;/body&gt;\n	&lt;script type=&quot;text/javascript&quot;&gt;\n		var websocket = null;\n		//判断当前浏览器是否支持WebSocket\n		if(\'WebSocket\' in window) {\n			//改成你的地址\n			websocket = new WebSocket(&quot;ws://192.168.100.196:8082/api/websocket/100&quot;);\n		} else {\n			alert(\'当前浏览器 Not support websocket\')\n		}\n\n		//连接发生错误的回调方法\n		websocket.onerror = function() {\n			setMessageInnerHTML(&quot;WebSocket连接发生错误&quot;);\n		};\n\n		//连接成功建立的回调方法\n		websocket.onopen = function() {\n			setMessageInnerHTML(&quot;WebSocket连接成功&quot;);\n		}\n		var U01data, Uidata, Usdata\n		//接收到消息的回调方法\n		websocket.onmessage = function(event) {\n			console.log(event);\n			setMessageInnerHTML(event);\n			setechart()\n		}\n\n		//连接关闭的回调方法\n		websocket.onclose = function() {\n			setMessageInnerHTML(&quot;WebSocket连接关闭&quot;);\n		}\n\n		//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。\n		window.onbeforeunload = function() {\n			closeWebSocket();\n		}\n\n		//将消息显示在网页上\n		function setMessageInnerHTML(innerHTML) {\n			document.getElementById(\'message\').innerHTML += innerHTML + \'&lt;br/&gt;\';\n		}\n\n		//关闭WebSocket连接\n		function closeWebSocket() {\n			websocket.close();\n		}\n\n		//发送消息\n		function send() {\n			var message = document.getElementById(\'text\').value;\n			websocket.send(\'{&quot;msg&quot;:&quot;\' + message + \'&quot;}\');\n			setMessageInnerHTML(message + &quot;&amp;#13;&quot;);\n		}\n	&lt;/script&gt;\n\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"6结果展示\">6.结果展示</h2>\n<p>后台：<br />\n如果有连接请求<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217181325920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>前台显示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217181300879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"总结\">总结</h1>\n<p><font color=#999AAA >这中间我遇到一个问题，就是说WebSocket启动的时候优先于spring容器，从而导致在WebSocketServer中调用业务Service会报空指针异常</p>\n<p>所以需要在WebSocketServer中将所需要用到的service给静态初始化一下：<br />\n如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217181723382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n还需要做如下配置：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217181921591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-12-18 11:40:54', '2022-05-21 18:06:14');
INSERT INTO `tb_article` VALUES (195, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8206', '留言', '<h3 id=\"留言板说明\">留言板说明</h3>\n<p>有什么话要对我说吗？这里是你畅所欲言的地方，可以咨询，可以交流，可以感叹，可以发飙，但不可以订外卖。</p>\n<p><img src=\"http://file.henaumcw.top/blog/image_1608350101016.png\" alt=\"image.png\" /></p>\n', 1, '', 0, 0, 1, '2020-12-19 10:30:42', '2020-12-19 11:55:06');
INSERT INTO `tb_article` VALUES (196, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3777', '新浪随机图片壁纸API接口 刷新网页换背景接口', '<p>新浪随机图片壁纸API接口 刷新网页换背景接口<br />\n在这里插入图片描述</p>\n<p>刷新一次页面换一次图片，可以调用到你的网站背景里面去，多炫酷啊，刷新一下本页看下效果哦。</p>\n<p>说明：随机图片壁纸api，调用的是新浪api，速度不用担心，图片资源也很多</p>\n<p>电脑动漫图片：<a href=\"http://api.btstu.cn/sjbz/?lx=dongman\">http://api.btstu.cn/sjbz/?lx=dongman</a></p>\n<p>电脑美女图片：<a href=\"http://api.btstu.cn/sjbz/?lx=meizi\">http://api.btstu.cn/sjbz/?lx=meizi</a></p>\n<p>电脑随机动漫妹子：<a href=\"http://api.btstu.cn/sjbz/?lx=suiji\">http://api.btstu.cn/sjbz/?lx=suiji</a></p>\n<p>手机动漫图片：<a href=\"http://api.btstu.cn/sjbz/?lx=m_dongman\">http://api.btstu.cn/sjbz/?lx=m_dongman</a></p>\n<p>手机美女图片：<a href=\"http://api.btstu.cn/sjbz/?lx=m_meizi\">http://api.btstu.cn/sjbz/?lx=m_meizi</a></p>\n<p>手机随机动漫妹子：<a href=\"http://api.btstu.cn/sjbz/?m_lx=suiji\">http://api.btstu.cn/sjbz/?m_lx=suiji</a></p>\n<p>手机电脑自动判断，电脑显示适合电脑的壁纸，手机显示适合手机的壁纸 <a href=\"http://api.btstu.cn/sjbz/zsy.php\">http://api.btstu.cn/sjbz/zsy.php</a></p>\n', 1, '', 0, 0, 1, '2020-12-19 16:31:05', '2021-08-30 09:53:11');
INSERT INTO `tb_article` VALUES (197, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5052', '超详细的 Vagrant 上手指南，搭建Linux虚拟机别再用VMware Workstation了！', '<p>﻿<br />\n@<a href=\"文章目录\">TOC</a></p>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h1 id=\"前言\">前言</h1>\n<p><font color=#999AAA >也许你已经习惯了 docker，习惯了在 XX 云上快速创建云主机，但是如果你想在个人电脑上安装虚拟机来搭建开发/测试环境，Vagrant 仍然不失高效之选。</font></p>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<p><font color=#999AAA >下面说下搭建的主要步骤：</p>\n<h1 id=\"一安装virtualbox\">一、安装VirtualBox</h1>\n<p><font color=#999AAA >VirtualBox 是一个跨平台的虚拟化工具，支持多个操作系统，根据自己的情况选择对应的版本下载即可。</p>\n<p>进入 VirtualBox 的主页<a href=\"https://www.virtualbox.org/\">https://www.virtualbox.org/</a>，点下载按钮，即可进入下载页面。</p>\n<p>进行安装需要<strong>cpu开启虚拟化</strong>，在开机启动的时候设置主板，CPU configuration，然后点击Intel Vitualization Technology。重启电脑</p>\n<h1 id=\"二vagrant\">二、Vagrant</h1>\n<h2 id=\"1安装vagrant\">1.安装Vagrant</h2>\n<p>在 Vagant 网站<a href=\"https://www.vagrantup.com/\">https://www.vagrantup.com/</a>下载最新的版本，根据自己的操作系统选择对应的版本下载即可。</p>\n<p>注意，Vagrant 是没有图形界面的，所以安装完成后也没有桌面快捷方式。具体使用方法，接下来会详细说明。</p>\n<p><font color=#99AA >Vagrant 的安装程序会自动把安装路径加入到 PATH 环境变量，所以，这时候可以通过命令行执行 <strong>vagrant version</strong> 检查是否安装成功：</p>\n<pre><code class=\"language-c\">C:\\Users\\ma&gt;vagrant version\n==&gt; vagrant: A new version of Vagrant is available: 2.2.14 (installed version: 2.2.5)!\n==&gt; vagrant: To upgrade visit: https://www.vagrantup.com/downloads.html\n\nInstalled Version: 2.2.5\nLatest Version: 2.2.14\n</code></pre>\n<h2 id=\"配置虚机存放位置\">配置虚机存放位置</h2>\n<p>创建虚拟机会占用较多的磁盘空间，在 Windows 系统下默认的虚机创建位置是在 C 盘，所以最好配置到其它地方。</p>\n<h2 id=\"2配置-virtualbox\">2.配置 VirtualBox</h2>\n<p>启动 VirtualBox 后，通过菜单 <code>管理 -&gt; 全局设定</code>，或者按下快捷键 <code>Ctrl + g</code>，在全局设定对话框中，修改 <code>默认虚拟电脑位置</code>，指定一个容量较大的磁盘。<br />\n<img src=\"https://img-blog.csdnimg.cn/20210308113209588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"3配置-vagrant\">3.配置 Vagrant</h2>\n<p>通过 Vagrant 创建虚机需要先导入镜像文件，也就是 box，它们默认存储的位置在用户目录下的 <code>.vagrant.d</code> 目录下，对于 Windows 系统来说，就是 <code>C:\\Users\\用户名\\.vagrant.d</code>。</p>\n<p>如果后续可能会用到较多镜像，或者你的 C 盘空间比较紧缺，可以通过设置环境变量 <code>VAGRANT_HOME</code> 来设置该目录。</p>\n<p>在 Windows 系统中，可以这样操作：新建系统环境变量，环境变量名为 <code>VAGRANT_HOME</code>，变量值为 <code>你的其他盘的路径</code>。</p>\n<h2 id=\"4下载虚机镜像\">4.下载虚机镜像</h2>\n<p>使用 Vagrant 创建虚机时，需要指定一个镜像，也就是 box。开始这个 box 不存在，所以 Vagrant 会先从网上下载，然后缓存在本地目录中。</p>\n<p>Vagrant 有一个镜像网站<a href=\"https://app.vagrantup.com/boxes/search\">https://app.vagrantup.com/boxes/search</a>，里面列出了都有哪些镜像可以用，并且提供了操作文档。<br />\n<img src=\"https://img-blog.csdnimg.cn/20210308115510105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n输入<code>vagrant init centos/7</code>（<strong>仓库镜像名</strong>），即可初始化一个centos7系统。（注意这个命令在哪个目录下执行的，他的Vagrantfile就生成在哪里）这个命令是一键下载并初始化。<strong>后面会详细介绍</strong></p>\n<blockquote>\n<p>但是这里默认下载往往会比较慢，所以下面我会介绍如何在其它地方下载到基础镜像，然后按照自己的需要重置。如果网速较好，下载顺利的朋友可以选择性地跳过部分内容。</p>\n<p>下面我给出最常用的两个 Linux 操作系统镜像的下载地址：</p>\n<p><strong>CentOS</strong></p>\n<p>CentOS 的镜像下载网站是： <a href=\"http://cloud.centos.org/centos/\">http://cloud.centos.org/centos/</a></p>\n<p><strong>Ubuntu</strong></p>\n<p>Ubuntu 的镜像下载网站是： <a href=\"http://cloud-images.ubuntu.com\">http://cloud-images.ubuntu.com</a></p>\n</blockquote>\n<p>在其中选择自己想要下载的版本，列表中有一个 vagrant 目录，里面是专门为 vagrant 构建的镜像。选择其中的 .box 后缀的文件下载即可。这里可以使用下载工具，以较快的速度下载下来。</p>\n<h2 id=\"5添加-box\">5.添加 box</h2>\n<p><font color=#999AAA >以 CentOS 7 为例，使用其它版本操作系统的也可以参考。</p>\n<p>接下来我们需要将下载后的 <code>.box</code> 文件添加到 vagrant 中。</p>\n<p>Vagrant 没有 GUI，只能从命令行访问，先启动一个命令行，然后执行:</p>\n<pre><code class=\"language-java\">$ vagrant box list\nThere are no installed boxes! Use `vagrant box add` to add some.\n</code></pre>\n<p>提示现在还没有 box。如果这是第一次运行，此时 <code>VAGRANT_HOME</code> 目录下会自动生成若干的文件和文件夹，其中有一个 boxes 文件夹，这就是要存放 box 文件的地方。</p>\n<p>执行 <code>vagrant box add</code> 命令添加 box:</p>\n<pre><code class=\"language-java\">$ vagrant box add e:\\Downloads\\CentOS-7.box --name centos-7\n==&gt; box: Box file was not detected as metadata. Adding it directly...\n==&gt; box: Adding box \'centos-7\' (v0) for provider:\n    box: Unpacking necessary files from: file:///e:/Downloads/CentOS-7.box\n    box:\n==&gt; box: Successfully added box \'centos-7\' (v0) for \'virtualbox\'!\n</code></pre>\n<p>命令后面跟着的是下载的文件路径，并且通过 --name centos-7 为这个 box 指定一个名字。</p>\n<p>后面创建虚机都需要指定这个名字，所以尽量把名字取得简短一点，同时也要能标识出这个镜像的信息（我们后面会定制自己的基础镜像，所以这里可以简单点）。</p>\n<p>再次查询，可以看到有了一个 box：</p>\n<pre><code class=\"language-java\">$ vagrant box list\ncentos-7 (virtualbox, 0)\n</code></pre>\n<h2 id=\"6vagrant-基本操作\">6.Vagrant 基本操作</h2>\n<h3 id=\"61-新建虚机\">6.1 新建虚机</h3>\n<p>创建一个目录，先执行 <code>vagrant init</code>：</p>\n<pre><code class=\"language-java\">$ mkdir demo\n$ cd demo\n$ vagrant init centos-7\nA `Vagrantfile` has been placed in this directory. You are now\nready to `vagrant up` your first virtual environment! Please read\nthe comments in the Vagrantfile as well as documentation on\n`vagrantup.com` for more information on using Vagrant.\n</code></pre>\n<p>其中的 <code>centos-7</code> 就是我们要使用的 <code>box</code> 名字。</p>\n<p>这个命令只是为我们生成一个 <code>Vagrantfile</code>，所以，这里的名字没指定或者写错了都没关系，后面会介绍如何编辑这个 <code>Vagrantfile</code> 来修改。</p>\n<h3 id=\"62-启动虚机\">6.2 启动虚机</h3>\n<p>我们等会再来细看这个文件，现在直接按照提示执行 <code>vagrant up</code>：</p>\n<pre><code class=\"language-java\">$ vagrant up\nBringing machine \'default\' up with \'virtualbox\' provider...\n==&gt; default: Importing base box \'centos-7\'...\n==&gt; default: Matching MAC address for NAT networking...\n==&gt; default: Setting the name of the VM: demo_default_1588406874156_65036\n==&gt; default: Clearing any previously set network interfaces...\n==&gt; default: Preparing network interfaces based on configuration...\n    default: Adapter 1: nat\n==&gt; default: Forwarding ports...\n    default: 22 (guest) =&gt; 2222 (host) (adapter 1)\n==&gt; default: Booting VM...\n==&gt; default: Waiting for machine to boot. This may take a few minutes...\n    default: SSH address: 127.0.0.1:2222\n    default: SSH username: vagrant\n    default: SSH auth method: private key\n</code></pre>\n<p>正常的情况下，不到一分钟应该就能启动成功了。</p>\n<h3 id=\"63-查看虚机状态\">6.3 查看虚机状态</h3>\n<p>执行下面的命令可以查看虚机的状态：</p>\n<pre><code class=\"language-java\">vagrant status\n\nCurrent machine states:\n\ndefault                   running (virtualbox)\n\nThe VM is running. To stop this VM, you can run `vagrant halt` to\nshut it down forcefully, or you can run `vagrant suspend` to simply\nsuspend the virtual machine. In either case, to restart it again,\nsimply run `vagrant up`.\n</code></pre>\n<p>该命令还提示了如何操作虚机，我们继续一一介绍</p>\n<h3 id=\"64-连接虚机\">6.4 连接虚机</h3>\n<p>如果启动没问题，接下来执行 <code>vagrant ssh</code> 就能以 <code>vagrant</code> 用户直接登入虚机中。</p>\n<p>root 用户没有默认密码，也不能直接登录。需要 root 权限的命令可以通过在命令前添加 <code>sudo</code> 来执行，也可以执行 <code>sudo -i</code> 直接切换到 root 用户。</p>\n<p>这时候打开 <code>VirtualBox</code> 程序，可以看到自动创建的虚机：<br />\n<img src=\"https://img-blog.csdnimg.cn/20210308120126381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>我们也可以在 VirtualBox 的终端上登录系统，默认的登录用户名和密码<strong>都是</strong> <code>vagrant</code>。</p>\n<p>当然还可以使用其它的 SSH 连接工具例如 XShell，SecureCRT 连接，但是这里默认网卡使用的是 NAT 模式，没有指定 IP，实际应用并不方便，我们在后面介绍网络配置时再详细介绍如何连接虚机。</p>\n<p><strong>停止虚机</strong><br />\n执行下面的命令可以关闭虚机：</p>\n<pre><code class=\"language-java\">vagrant halt\n</code></pre>\n<p>直接在 VirtualBox 上关闭虚机，或者直接在虚机内部执行 poweroff 命令也都是可以的。</p>\n<p><strong>暂停虚机</strong><br />\n执行下面的命令可以暂停虚机：</p>\n<pre><code class=\"language-java\">vagrant suspend\n</code></pre>\n<p><strong>恢复虚机</strong><br />\n执行下面的命令把暂停状态的虚机恢复运行：</p>\n<pre><code class=\"language-java\">vagrant resume\n</code></pre>\n<p>注意： 不管虚机是关闭还是暂停状态，甚至是 error 状态，都可以执行 vagrant up 来让虚机恢复运行。</p>\n<p><strong>重载虚机</strong><br />\n执行下面的命令会重启虚机，并且重新加载 Vagrantfile 中的配置信息：</p>\n<pre><code class=\"language-java\">vagrant reload\n</code></pre>\n<p><strong>删除虚机</strong><br />\n最后，执行下面的命令可以彻底删除虚机，包括整个虚机文件：</p>\n<pre><code class=\"language-java\">vagrant destroy\n</code></pre>\n<p>注意： 在当前这个小例子中，上面所有的 vagrant 命令都需要在 Vagrantfile 所在的目录下执行。</p>\n<h2 id=\"7自定义配置-vagrantfile\">7.自定义配置 Vagrantfile</h2>\n<p>端口转发（Port forward）又叫端口映射，就是把虚机的某个端口，映射到宿主机的端口上。这样就能在宿主机上访问到虚拟机中的服务。</p>\n<p>例如启动虚机时，默认的 <code>22 (guest) =&gt; 2222 (host) (adapter 1)</code> 就是把虚机的 SSH 服务端口（22）映射到宿主机的 2222 端口，这样直接在宿主机通过 ssh 客户端访问 <code>127.0.0.1:2222</code> 端口就等价于访问虚拟机的 22 端口。</p>\n<p>默认的网络连接方式是网络地址转换NAT（端口转发），如果其他主机要访问虚拟机，必须由windows端口如3333断发给虚拟机端口如3306。这样每在linux里安一个软件都要进行端口映射，不方便，（也可以在virualBox里挨个设置）。我们想要给虚拟机一个固定的ip地址，windows和虚拟机可以互相ping通。</p>\n<p><strong>方式1是在虚拟机中配置静态ip。</strong></p>\n<p>也可以更改<code>Vagrantfile</code>更改虚拟机ip，修改其中的<code>config.vm.network``&quot;private_network&quot;,ip:&quot;192.168.56.10&quot;，</code>这个ip需要在windows的<code>ipconfig</code>中查到<code>vitualbox</code>的虚拟网卡ip，然后更改下最后一个数字就行（不能是1，1是我们的主机）。配置完后<code>vagrant reload</code>重启虚拟机。在虚拟机中<code>ip addr</code>就可以查看到地址了。互相ping也能ping通。</p>\n<p>关掉防火墙，<code>VirualBox</code>中第一个网卡设置<code>NAT</code>，第二个网卡设置仅主机</p>\n<p>如果ping不了baidu</p>\n<ul>\n<li><code>cd /etc/sysconfig/network-scripts</code></li>\n<li>ls 一般有<code>ifcfg-eth0 1</code></li>\n<li><code>ip addr</code> 看哪个网格是<code>192.168.56</code>网段，然后vim他</li>\n<li><code>vim ifcfg-eth1</code> 加入</li>\n</ul>\n<pre><code>GATEWAY=192.168.56.1\nDNS1=114.114.114.114\nDNS2=8.8.8.8\n</code></pre>\n<ul>\n<li><code>service network restart</code></li>\n</ul>\n<p>默认只允许ssh登录方式，为了后来操作方便，文件上传等，我们可以配置允许账号密码登录</p>\n<pre><code class=\"language-java\">vim /etc/ssh/sshd_config\n修改\nPasswordAuthentication yes\n重启\nservice sshd restart\n账号root\n密码vagrant\n</code></pre>\n<p>配置源</p>\n<pre><code class=\"language-java\"># 备份原yum源\n\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n# 使用新yum源\ncurl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.163.com/.help/CentOS7-Base-163.repo\n# 生成缓存\nyum makecache\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p>费了莫大的力气，终于可以比较愉快地玩耍了。虽然也只是刚把基础镜像搞定了，后面可能还要针对不同用途的环境编写更加复杂的 Vagrantfile。</p>\n<p>现在很多人刚认识到 Vagrant 之后都会问，<strong>Vagrant 和 Docker 的区别是什么？</strong></p>\n<p>在容器流行之前，Vagrant 就是用来编排虚机和自动部署开发环境的，有了 Docker/Kubernetes 之后，直接用容器来编排应用确实更香。但是还有一些工作，例如容器平台自身的安装，多节点集群的部署测试等，更方便用虚机解决。</p>\n<p>此外，现在 Windows 中还可以通过 WSL 使用 Linux 系统，但是使用场景上还是有所不同。Vagrant 更多地用于快速搭建可重用的开发环境，从这个角度看，Vagrant 其实好比 IaaS 云平台，只不过规模局限在个人电脑上。</p>\n', 1, '', 0, 0, 1, '2021-03-10 18:17:11', '2022-05-21 18:06:00');
INSERT INTO `tb_article` VALUES (198, 1, 7, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=2370', '918农业信息化考研资料', '<h2 id=\"%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A\" tabindex=\"-1\">名词解释</h2>\n<p><strong>信息：</strong> 事物之间相互联系、相互作用的状态的描述。</p>\n<p><strong>信息技术：</strong> 是指计算机硬件技术、计算机软件和通信技术的总称。</p>\n<p><strong>信息系统：</strong> 是由计算机硬件、网络和通讯设备、计算机软件、信息资源、信息用户和规章制度组成的以处理信息流为目的的人机一体化系统。</p>\n<p><strong>农业信息：</strong> 是指人们利用农业生产资源进行农产品生产、加工和营销等活动的一切消息、情报、数据等的总称。</p>\n<p><strong>农业信息技术：</strong> 包括农业信息的获取技术（如遥感技术）、处理技术（如数据的并行处理技术）、模拟技术（如作物生长模拟）、自动识别技术、人工智能技术等等。</p>\n<p><strong>农业信息系统：</strong> 一般由农业生物信息、农业环境信息、农业技术知识信息和农业经济信息等四个信息子系统构成。</p>\n<p><strong>农业信息学：</strong> 农业科学与信息科学相互交叉融合形成的一门学科。可以定义为：以农业科学为基本理论基础，以农业信息为对象，以信息技术支撑，研究农业信息的采集、处理、分析、存储、传输及其运动变化规律，为农业生产服务的科学和技术。</p>\n<p><strong>信息再生：</strong> 指运用信息技术和科学方法对本原信息进行加工处理而产生出新的信息的工作过程。</p>\n<p><strong>数据库：</strong> 存放数据的仓库（顾名思义/不准确的含义）尽管数据库技术已发展成熟，但还没有一个普遍接受的、严格的定义。</p>\n<p><strong>数据库系统：</strong> 基于数据库的计算机应用系统。</p>\n<p><strong>数据模型：</strong> 是数据特征的抽象，在数据库系统中，数据模型是它的核心与基础。数据模型描述数据的结构，定义在其上的操作以及约束条件。它从概念层面上描述了系统的静态特征、动态特征和约束条件，为数据库系统的信息表示与操作提供一个抽象框架。</p>\n<p><strong>关系模型：</strong> 用关系表示（不需用指针）实体和实体之间联系的模型称为关系模型。<br />\n<strong>农业专家系统：</strong> 也叫农业智能系统，是一个拥有大量权威农业专家的知识、经验、资料、数据与成果构成的知识库，并能利用其中的知识模拟农业专家解决问题的思维方法尽心判断、推理，求得解决农业生产问题答案的智能程序系统。</p>\n<p><strong>农业模拟模型：</strong> 利用系统分析方法和计算机模拟技术，对农业系统中的生物与非生物过程及其与环境和农业技术措施之间的动态关系进行定量描述和预测。</p>\n<p><strong>系统分析法：</strong> 是把将要研究的目标当做一个统一的整体，并把这个整体分解为若干个子系统，揭示影响子系统的各项因素及相互关系，并进行数量化描述，以此为基础，对获取的信息进行综合整理、分析、判断和加工，选择出最优的因素组合，优化系统或设计新系统。</p>\n<p><strong>精确农业：</strong> 是由信息技术支持的、根据空间变异定位、定时、定量的实施一整套现代化农事</p>\n<p><strong>农业物流：</strong> 是指以农业生产为核心而发生的一系列物品从供应地向接受地的实体流动和与之有关的技术、组织、管理活动。</p>\n<p><strong>电子商务：</strong> 广义上讲，电子商务是电子工具再商务活动中的应用。<br />\n狭义上讲：电子商务是在技术、经济高度发达的现代社会里掌握信息技术和商务规则的人、系统化应用电子工具高效率、低成本地从事以商品交换为中心的葛洪活动的总称。</p>\n<p><strong>物联网：</strong> 物联网被视为互联网的应用扩展，应用创新是物联网的发展的核心，以用户体验为核心的创新是物联网发展的灵魂。</p>\n<p><strong>农业信息化：</strong> 其内涵应包括农业资源环境信息化、农业生产管理信息化、农业市场流通信息化、农业科技与教育信息化、农业产业经营信息化。</p>\n<h2 id=\"%E7%AE%80%E7%AD%94\" tabindex=\"-1\">简答</h2>\n<p><strong>1、	信息有哪些主要性质特征</strong><br />\n真实性、时效性、不完全性、等级性、层次性、对性习惯、价值性、共享性、寄载性</p>\n<p><strong>2、	什么是信息量？如何度量信息量？</strong><br />\n信息量是指从N个相等可能事件中选出一个事件所需要的信息度量或含量，也就是在辨识N个事件中特定的一个事件的过程中所需要提问&quot;是或否&quot;的最少次数.<br />\n信息的度量是利用概率来度量信息。</p>\n<p><strong>3、	农业信息有哪些主要特征？</strong><br />\n1,农业生物的自身特性：农业生产的种子、种苗、种禽等原材料．都是由农业自身提供的．这些农业生物有机体有其自身的生长、发育特性和自然再生产的规律．从事农业生产经营活动，必须掌握农业生物信息，符合农业生物自然再生产的规律．<br />\n2,农业依赖环境的特性：农业生物依赖农业环境而生长、发育、繁衍后代．光、热、水、气、风、霜、雨、雪、土壤质地以及地形地貌等环境信息，对农业生产经营起着促进或制约作用．<br />\n3,农业生产的季节性：春种、夏管、秋收、冬藏，农业生产具有强烈的季节性．按农时组织农业生产经营，要求掌握农时信息，提供农时信息．<br />\n4,农业生产的地域性：农人们按照农业生物适地适生的信息．做到因地制宜的组织农业生产经营活动．<br />\n5,农业生产的周期性：农业生物有其自身的生命周期．农业生产是遵循生物体生命周期规律的有目的的生产活动．为此，人类应掌捏农业生物的生命信息，生命周期的连续信息，以获取农业经济效益和生态效益。<br />\n6,农业生产的系统性：农业生产是生物、环境、经济、技术和人类共同参与活动的系统工程，各方面的信息同时存在，相互渗透，共同作用，推动或制约整个系统的运行.<br />\n7,农业生产的分散性：我国农付地域宽广，由几亿农民从事农业，产生信息的信源分散；将信息传输至信宿．也同样分散．要在广大农村建立信息网络，收集和传输信息，其难度较大．</p>\n<p><strong>4、	农业信息收集有哪些主要途径？</strong><br />\n主要有两类途径：<br />\n（1）	关系途径：沿着各种与信源相关的事物进行收集，如人际关系。<br />\n（2）	技术途径：利用各种技术直接或间接收集信息，如网络技术等。</p>\n<p><strong>5、	农业信息收集有哪些主要方法？</strong><br />\n收集信息的方法主要可分为人工收集法和技术收集方法，</p>\n<ol>\n<li>人工收集法：信息收集者人工地进行收集，如实验、考察、手工查阅文献等。</li>\n<li>技术收集法：通过各种技术手段自动收集，包括计算机技术、微电子技术（传感器）、感、卫星技术等等。</li>\n</ol>\n<p><strong>6、	简述农信息整理加工的基本要求和基本内容。</strong><br />\n基本要求：应符合真实、标准、及时、合适、有效等要求。<br />\n基本内容：<br />\n（1）原始信息的汇集、筛选、分析、鉴别<br />\n（2）信息变换、载体结合、信道选配<br />\n（3）信息分类、排序、编码、录制、储存<br />\n（4）信息再生、转化、进入终端显示、利用等</p>\n<p><strong>7、	简述数据额模型的三要素。</strong><br />\n（1）数据结构——描述数据额的静态特征，包括对数据结构和数据间联系的描述、<br />\n通常按照数据结构的类型来命名数据模型：<br />\n层次结构——层次模型    网状结构——网状模型    关系结构——关系模型<br />\n（2）数据操作——描述数据的动态特征和，一组定义在数据上的操作（包括操作的含义、操作符、运算规则及其语言等），主要操作：检索和更新（插入、删除、修改）<br />\n（3）数据的约束条件——完整性规则的集合，数据库中的数据必须满足这组规则。约束条件的主要目的是使数据库与它所描述的现实系统相符合。</p>\n<p><strong>8、	简述E-R数据模型。</strong><br />\nE-R模型是一种重要的数据模型，它结构简单，语义表现力丰富，描述力强，同时又能方便的转换为其他经常使用的网状、层次或关系模型，所以，再数据库设计中得到广泛应用。</p>\n<p><strong>9、	简述数据库系统的开发流程。</strong><br />\n目前信息系统开发经常采用周期法，该方法将整个信息系统的开发过程分为若干阶段，预先规定每个阶段的目标和任务，按一定准则顺次完成。AMIS的开发可采用生命周期法，其开发过程分为下图所示的六个阶段，即可行性研究、系统分析、系统总体方案设计、系统技术方案分析、系统实施、系统评价与维护。同时，再每个阶段都进行及时讨论和信息反馈。</p>\n<p><strong>10、简述农业专家系统的开发流程。</strong><br />\n包括知识获取，即从农业领域专家收集整理归纳有关的专业知识和经验、数据，并经农业专家系统开发人员消化、整理、归纳写成一条符号表示的形式；确定知识表示和推理方法；建立知识库；编写推理程序，然后调试、运行和修改等步骤。</p>\n<p><strong>11、写出SAS统计分析软件进行多重比较的程序。</strong><br />\nDATA A;<br />\nDO I=1 TO 5;<br />\nDO J=1 TO 10;<br />\nINPUT X @@;<br />\nOUTPUT;<br />\nEND;<br />\nEND;<br />\nDROP J;<br />\nCARDS;<br />\n…<br />\nPROC ANOVA;<br />\nCLASS I;<br />\nMODEL X=I;<br />\nMEANS VLSD;<br />\nRUN.</p>\n<p><strong>12、简述3S技术及其基本原理。</strong></p>\n<p><strong>3S技术是指</strong>遥感技术、地理信息技术、和全球定位系统。是空间技术、传感器技术、卫星定位与导航技术和计算机技术、通讯技术相结合，多学科高度集成的对空间信息进行采集、处理、管理、分析、表达、传播和应用的现在信息技术。</p>\n<p><strong>遥感技术原理：</strong> 直接接触目标物，在距地物几公里到几百公里、甚至上千公里的飞机、飞船、卫星上，使用光学或者电子光学仪器接受地面物体反射或者辐射的电磁波信号，并以图像胶片或数据磁带形式记录下来，形成数字影像。该影像传输到地面，经过各种校正后，进行影像分类、翻译，最后获取所需要的信息。</p>\n<p><strong>地理信息技术原理：</strong> 是在计算机硬件、软件及网络等支持下，对有关空间数据进行获取、存贮、查询检索、处理、分析、显示、更新和提供应用的技术系统。</p>\n<p><strong>全球定位系统原理：</strong> 共24颗卫星，其中3颗备用，分布在6个轨道面上。轨道面对地球赤道面的倾角为55°，各轨道平面升交点赤经相差60°，相邻轨道上卫星的升交距相差30°，轨道平均高度约20200km，均为近圆形轨道，运行周期11h58m。</p>\n<p><strong>13、地物空间数据矢量化的方法有哪些？</strong><br />\n矢量结构是通过记录坐标的方式来表达点线面等地理实体。获取方法：（1）手工数字化法；（2）手扶跟踪数字化法；（3）数据结构转换法。<br />\n（栅格数据结构：栅格结构是以规则的阵列来表示空间地物或现象分布的数据组织，组织中的符复合数据表示地理要素的非几合属性特征。获取方法：1手工网格法2扫描数字化法3分类影像输入法47数据结构转换法。）</p>\n<p><strong>14、简述农业模拟模型的研制步骤。</strong><br />\n（1）	模型选择与系统定义。弄清研究目的、研究水平和研究对象。<br />\n（2）	资料来源。①自己积累或文献资料②从同行专家处获取③补充试验或支持研究<br />\n（3）	模块设计与模型设计。编程语言的选择、算法编程、界面编程、输入输出内容和形式。<br />\n（4）	模型检验与改进。①敏感性分析  分析模型对主要参数和变量反应的灵敏度②校正  调整模型的参数和关系，使得模型符合特定的环境和资料参数③核实  将模拟结果与实际结果进行相关回归分析；将实际结果与模拟结果按同一时间坐标绘1:1图进行比较；检查模拟结果与实际结果的平均误差。</p>\n<p><strong>15、简述农业信息服务的基本原理和基本内容。</strong><br />\n基本内容：1.农业资源信息服务2.农业教育服务3.农业咨询服务4.农业物流服务</p>\n<p><strong>16、实现精确农业的关键技术有哪些？</strong><br />\n精确农业的支持技术除地理信息系统（GIS）、遥感技术（RS）、全球定位系统（GPS）外，还包括决策支持系统（DSS）和变量投入技术（VRT），以上几个关键技术互相补充，共同构建精确农业的技术体系。</p>\n<h1 id=\"%E7%BB%BC%E5%90%88%E9%A2%98\" tabindex=\"-1\">综合题</h1>\n<p><strong>1、	结合专业，谈谈学习农业信息学的意义（不能少于300字）<br />\n2、	结合专业，谈谈在我国如何实现农业的信息化。</strong></p>\n', 1, '', 0, 0, 1, '2021-08-30 10:24:09', '2022-05-21 17:44:21');
INSERT INTO `tb_article` VALUES (199, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=6774', '《计算机网络》复习要点', '<p>《计算机网络》复习要点<br />\n一、概述（远看、近看互联网）<br />\n计算机网络的定义、功能<br />\n组成、分类、拓扑结构<br />\n互联网（因特网）的多级结构、接入方式<br />\n二、物理层<br />\n模拟数据与数字数据、模拟信号与数字信号、模拟信道与数字信道<br />\n不归零码、归零码、曼彻斯特编码、差分曼彻斯特编码<br />\n数据传输率、带宽、信道容量、误码率、时延<br />\n多路复用技术：频分、时分、波分<br />\n交换技术：电路、分组（原理、区别）<br />\n介质：双绞线、同轴电缆、光纤<br />\n三、网络体系结构<br />\n分层原理（为何分层、层间关系、数据在层间传递、封转的过程）<br />\n网络协议的概念、组成元素<br />\nOSI体系结构（每层功能）<br />\nTCP/IP体系结构（每层功能、每层主要协议）<br />\nOSI与 TCP/IP体系结构的比较、综合的五层体系结构<br />\n四、数据链路层（以太网）<br />\n以太网特点、拓扑结构、要解决的问题<br />\nIEEE802标准<br />\nMAC层功能、MAC地址、MAC帧格式<br />\nCSMA/CD工作原理<br />\n交换机（网桥）的工作原理、特点、转发表的建立方法<br />\n交换机与集线器的区别<br />\nVLAN的概念、特点、好处、划分方法<br />\n局域网的搭建、VLAN的划分（实践环节）<br />\n五、网络层（网络互联）<br />\n网络互联的思路、工作原理<br />\n路由器的作用、工作原理<br />\n路由表的基本内容和查表方法<br />\nIP分组的格式、router处理IP分组基本过程<br />\nIP地址（分类地址、子网划分地址）<br />\n单播地址、广播地址、组播地址、特殊IP地址<br />\n子网掩码的作用、使用方法<br />\nIP地址与硬件地址的区别与关系<br />\nARP的功能、原理、有效范围<br />\nICMP功能、特点<br />\nPing、tracert的原理<br />\nRIP的功能、工作原理、优缺点<br />\nOSPF、BGP的功能、特点<br />\n组建互联网、配置地址、路由的基本方法（实践环节）<br />\n六、端到端传输<br />\n传输层的作用、服务类型（可靠传输、不可靠传输）<br />\n端口、端口号的作用、特点、知名端口<br />\nTCP的服务特点、报文格式<br />\nTCP可靠传输的措施（滑动窗口、流量控制、慢开始、拥塞避免算法等）<br />\nUDP的特点、报文格式、应用场景<br />\n七、网络应用<br />\n客户/服务器工作模式的特点<br />\nDNS（域名结构、域名服务器的层次结构、解析过程）</p>\n', 1, '', 0, 0, 1, '2021-08-30 10:42:30', '2021-08-30 10:42:30');
INSERT INTO `tb_article` VALUES (200, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4134', '下载库不库', '<table>\n<thead>\n<tr>\n<th>安装包列表清单👉👉👉</th>\n<th>👇</th>\n<th>👇</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F05%2F07%2FFroit5NB_mysql-installer-community-5.7.28.0.msi?Expires=1652584202\" target=\"_blank\">MySQL</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F08%2F18%2FVFSexUgC_CentOS-7-x86_64-DVD-2003.iso?Expires=1652584306\" target=\"_blank\">Centos7</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F09%2F28%2FMkIuEzVA_%E8%A1%A8%E6%83%85%E5%8C%85.rar?Expires=1652584333\" target=\"_blank\">表情包</a></td>\n</tr>\n<tr>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F05%2F07%2FkSuZFcV0_Redis-x64-3.2.100.zip?Expires=1652584447\" target=\"_blank\">Redis</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F05%2F07%2FhuKw8WI7_jdk-8u201-windows-x64.exe?Expires=1652584467\" target=\"_blank\">JDK8-win64</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F05%2F07%2Fy9YB1Fox_jdk-8u181-linux-x64.tar.gz?Expires=1652584495\" target=\"_blank\">JDK8-Linux</a></td>\n</tr>\n<tr>\n<td><a href=\"http://cloud.henaumcw.top/#/s/ZbCP\" target=\"_blank\">截图工具</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2022%2F06%2F01%2Ff9wuuLPb_wiztree_3_29_setup.exe?Expires=1654090488\" target=\"_blank\">磁盘树分析</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2022%2F06%2F01%2F9FCoSfiA_attahcmentName_findDuplicateClass.exe?Expires=1654090530\" target=\"_blank\">jar包冲突分析工具</a></td>\n</tr>\n<tr>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2022%2F06%2F01%2FrLd8HhNt_mqttfx-1.7.1-windows-x64%20%281%29.exe?Expires=1654090571\" target=\"_blank\">MQTT.FX 1.7.1</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2022%2F06%2F01%2FUPpiUJjH_Listary.exe?Expires=1654090607\" target=\"_blank\">Lisary</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F07%2F21%2FYs5dI2fb_WinMTR-v092%20%281%29.rar?Expires=1654090780\" target=\"_blank\">WinMTR路由追踪</a></td>\n</tr>\n</tbody>\n</table>\n', 1, '', 0, 0, 1, '2022-05-15 09:16:51', '2022-06-01 21:45:57');
INSERT INTO `tb_article` VALUES (201, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=9723', '测试外链', '<p><a href=\"http://photo.henaumcw.top/\" target=\"_blank\">http://photo.henaumcw.top/</a></p>\n', 1, '', 0, 0, 1, '2022-05-15 18:28:16', '2022-08-09 17:43:55');
INSERT INTO `tb_article` VALUES (202, 1, 13, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4414', '知识图谱入门一：知识图谱介绍', '<p>﻿@<a href=\"知识图谱入门一：\">TOC</a></p>\n<h1 id=\"一知识图谱简介\">一、知识图谱简介</h1>\n<h2 id=\"11-引言\">1.1 引言</h2>\n<p>从一开始的Google搜索，到现在的聊天机器人、大数据风控、证券投资、智能医疗、自适应教育、推荐系统，无一不跟知识图谱相关。它在技术领域的热度也在逐年上升。</p>\n<p>早在 2010 年微软就开始构建知识图谱，包括 Satori 和 Probase；2012 年，Google 正式发布了 Google Knowledge Graph，现在规模已超 700 亿。目前微软和 Google 拥有全世界最大的通用知识图谱，Facebook 拥有全世界最大的社交知识图谱，而阿里巴巴和亚马逊则分别构建了商品知识图谱。<br />\n<img src=\"https://img-blog.csdnimg.cn/9054a66bfd6440faabeb18351edaf203.png\" alt=\"图 1 业内布局\" /><strong><center>图 1 业内布局</center></strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/2f2467ec95e44cb9bd60b9dc1bc68109.png\" alt=\"在这里插入图片描述\" /><br />\n<strong><center>图 2 业内应用</center></strong><br />\n本章以通俗易懂的方式来讲解知识图谱相关的知识、介绍从零开始搭建知识图谱过程当中需要经历的步骤以及每个阶段。本次组队学习还将动手实践一个关于kg在智能问答中的应用。</p>\n<h2 id=\"12-什么是知识图谱呢\">1.2 什么是知识图谱呢？</h2>\n<p>知识图谱是由 Google 公司在 2012 年提出来的一个新的概念。从学术的角度，我们可以对知识图谱给一个这样的定义：“知识图谱本质上是语义网络（Semantic Network）的知识库”。但这有点抽象，所以换个角度，从实际应用的角度出发其实可以简单地把知识图谱理解成多关系图（Multi-relational Graph）。</p>\n<h3 id=\"121-什么是图graph呢\">1.2.1 什么是图（Graph）呢？</h3>\n<ul>\n<li>图（Graph）是由节点（Vertex）和边（Edge）来构成，多关系图一般包含多种类型的节点和多种类型的边。</li>\n<li>实体（节点）指的是现实世界中的事物比如人、地名、概念、药物、公司等，</li>\n<li>关系（边）则用来表达不同实体之间的某种联系，比如人-“居住在”-北京、张三和李四是“朋友”、逻辑回归是深度学习的“先导知识”等等。<br />\n<img src=\"https://img-blog.csdnimg.cn/8620986eba194701a0dca830efb53f23.png\" alt=\"————————————————\n版权声明：本文为CSDN博主「越前浩波」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/weixin_44023658/article/details/112503294\" /><br />\n<strong><center>图 3 图（Graph）介绍</center></strong></li>\n</ul>\n<h3 id=\"122-什么是-schema-呢\">1.2.2 什么是 Schema 呢？</h3>\n<p>知识图谱另外一个很重要的概念是 Schema:</p>\n<ul>\n<li>\n<p>介绍：<strong>Schema（模式）</strong> 限定待加入知识图谱数据的格式；相当于某个领域内的数据模型，包含了该领域内有意义的概念类型以及这些类型的属性</p>\n</li>\n<li>\n<p>作用：规范结构化数据的表达，一条数据必须满足Schema预先定义好的实体对象及其类型，才被允许更新到知识图谱中， <strong>一图胜千言</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/49997f4c7e0a480397bc67c09a68a2b1.png\" alt=\"图 4 Schema定义\" /><br />\n<strong><center>图 4 Schema定义</center></strong></p>\n</li>\n<li>\n<p>图中的<strong>DataType</strong>限定了知识图谱节点值的类型为文本、日期、数字（浮点型与整型）</p>\n</li>\n<li>\n<p>图中的<strong>Thing</strong>限定了节点的类型及其属性（即图1-1中的边）</p>\n</li>\n<li>\n<p>举例说明：基于上图<strong>Schema</strong>构建的知识图谱中仅可含作品、地方组织、人物；其中作品的属性为电影与音乐、地方组织的属性为当地的商业（eg：饭店、俱乐部等）、人物的属性为歌手</p>\n</li>\n</ul>\n<h2 id=\"13-知识图谱的价值在哪呢\">1.3 知识图谱的价值在哪呢？</h2>\n<ul>\n<li>从图5中可以看出，知识图谱是人工智能很重要的一个分支, 人工智能的目标为了让机器具备像人一样理性思考及做事的能力 -&gt;</li>\n<li>在符号主义的引领下，知识工程（核心内容即建设专家系统）取得了突破性的进展 -&gt;</li>\n<li>在整个知识工程的分支下，知识表示是一个非常重要的任务 -&gt;<br />\n而知识图谱又恰恰是知识表示的重要一环<br />\n<img src=\"https://img-blog.csdnimg.cn/2ee44f5e78844320a8ea77f692aada7e.png\" alt=\"在这里插入图片描述\" /></li>\n</ul>\n<p><strong><center>图 5 学科概念</center></strong></p>\n<h1 id=\"二怎么构建知识图谱呢\">二、怎么构建知识图谱呢？</h1>\n<h2 id=\"21-知识图谱的数据来源于哪里\">2.1 知识图谱的数据来源于哪里？</h2>\n<p>知识图谱的构建是后续应用的基础，而且构建的前提是需要把数据从不同的数据源中抽取出来。对于垂直领域的知识图谱来说，它们的数据源主要来自两种渠道：</p>\n<p>第一种：业务本身的数据。这部分数据通常包含在公司内的数据库表并以结构化的方式存储，一般只需要简单预处理即可以作为后续AI系统的输入；<br />\n第二种：网络上公开、抓取的数据。这些数据通常是以网页的形式存在所以是非结构化的数据，一般需要借助于自然语言处理等技术来提取出结构化信息。<br />\n<img src=\"https://img-blog.csdnimg.cn/222b103a13694d7f83daa282f6a2e4b5.png\" alt=\"在这里插入图片描述\" /><strong><center>图 6 数据来源</center></strong><br />\n比如在下面的搜索例子里，Bill Gates和Malinda Gate的关系就可以从非结构化数据中提炼出来，比如维基百科等数据源。<br />\n<img src=\"https://img-blog.csdnimg.cn/4311a97f97674cbfaa267bf023351379.png\" alt=\"在这里插入图片描述\" /><strong><center>图 7 举例说明</center></strong></p>\n<h2 id=\"22-信息抽取的难点在哪里\">2.2 信息抽取的难点在哪里？</h2>\n<p>信息抽取的难点在于处理非结构化数据。在下面的图中，我们给出了一个实例。左边是一段非结构化的英文文本，右边是从这些文本中抽取出来的实体和关系。<br />\n<img src=\"https://img-blog.csdnimg.cn/1d4ed81dab8244239c0ae9c0b976966e.png\" alt=\"在这里插入图片描述\" /><strong><center>图 8 信息抽取的难点举例</center></strong></p>\n<h2 id=\"23-构建知识图谱所涉及的技术\">2.3 构建知识图谱所涉及的技术？</h2>\n<p>在构建类似的图谱过程当中，主要涉及以下几个方面的自然语言处理技术：</p>\n<ul>\n<li>实体命名识别（Name Entity Recognition）</li>\n<li>关系抽取（Relation Extraction）</li>\n<li>实体统一（Entity Resolution）</li>\n<li>指代消解（Coreference Resolution）</li>\n<li>…</li>\n</ul>\n<h2 id=\"24知识图谱的具体构建技术是什么\">2.4、知识图谱的具体构建技术是什么？</h2>\n<p>下面针对每一项技术解决的问题做简单的描述，至于这些是具体怎么实现的，不在这里一一展开。<br />\n<img src=\"https://img-blog.csdnimg.cn/f6cddfc32ebc41d6b606d1c7c29e38ae.png\" alt=\"在这里插入图片描述\" /></p>\n<h3 id=\"241-实体命名识别named-entity-recognition\">2.4.1 实体命名识别（Named Entity Recognition）</h3>\n<ul>\n<li>实体命名识别（英语：Named Entity Recognition），简称NER</li>\n<li>目标：就是从文本里提取出实体并对每个实体做分类/打标签；</li>\n<li>\n<ul>\n<li>举例说明：比如从上述文本里，我们可以提取出实体-“NYC”，并标记实体类型为 “Location”；我们也可以从中提取出“Virgil\'s BBQ”，并标记实体类型为“Restarant”。</li>\n</ul>\n</li>\n<li>这种过程称之为实体命名识别，这是一项相对比较成熟的技术，有一些现成的工具可以用来做这件事情。</li>\n</ul>\n<h3 id=\"242-关系抽取relation-extraction\">2.4.2 关系抽取（Relation Extraction）</h3>\n<ul>\n<li>关系抽取（英语：Relation Extraction），简称 RE</li>\n<li>介绍：通过关系抽取技术，把实体间的关系从文本中提取出来；</li>\n<li>举例说明：比如实体“hotel”和“Hilton property”之间的关系为“in”；“hotel”和“Time Square”的关系为“near”等等。<br />\n<img src=\"https://img-blog.csdnimg.cn/d65109814ab84828bcd9eda2b7ea5056.png\" alt=\"图 9 NER 和 RE 示例\" /><strong><center>图 9 NER 和 RE 示例</center></strong></li>\n</ul>\n<h3 id=\"243-实体统一entity-resolution\">2.4.3 实体统一（Entity Resolution）</h3>\n<ul>\n<li>实体统一（英语：Entity Resolution），简称 ER</li>\n<li>介绍：对于有些实体写法上不一样，但其实是指向同一个实体；</li>\n<li>举例说明：比如“NYC”和“New York”表面上是不同的字符串，但其实指的都是纽约这个城市，需要合并。</li>\n<li>价值：实体统一不仅可以减少实体的种类，也可以降低图谱的稀疏性（Sparsity）；</li>\n</ul>\n<h3 id=\"244-指代消解disambiguation\">2.4.4 指代消解（Disambiguation）</h3>\n<ul>\n<li>指代消解（英语：Disambiguation）</li>\n<li>介绍：文本中出现的“it”, “he”, “she”这些词到底指向哪个实体，比如在本文里两个被标记出来的“it”都指向“hotel”这个实体。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/02c96bbafcba40c0b061dd7f7207774d.png\" alt=\"图 10 ER 和 Disambiguation 示例\" /><strong><center>图 10 ER 和 Disambiguation 示例</center></strong></p>\n<h1 id=\"三知识图谱的存储\">三、知识图谱的存储</h1>\n<ul>\n<li>知识图谱主要有两种存储方式：\n<ul>\n<li>一种是基于RDF的存储；</li>\n<li>另一种是基于图数据库的存储。</li>\n</ul>\n</li>\n</ul>\n<p>它们之间的区别如下图所示。RDF一个重要的设计原则是数据的易发布以及共享，图数据库则把重点放在了高效的图查询和搜索上。其次，RDF以三元组的方式来存储数据而且不包含属性信息，但图数据库一般以属性图为基本的表示形式，所以实体和关系可以包含属性，这就意味着更容易表达现实的业务场景。其中Neo4j系统目前仍是使用率最高的图数据库，它拥有活跃的社区，而且系统本身的查询效率高，但唯一的不足就是不支持准分布式。相反，OrientDB和JanusGraph（原Titan）支持分布式，但这些系统相对较新，社区不如Neo4j活跃，这也就意味着使用过程当中不可避免地会遇到一些刺手的问题。如果选择使用RDF的存储系统，Jena或许一个比较不错的选择。<br />\n<img src=\"https://img-blog.csdnimg.cn/e2baaca77d3b4786910948451ab377f7.png\" alt=\"图 11 RDF的存储 和 基于图数据库的存储 的区别\" /><strong><center>图 11 RDF的存储 和 基于图数据库的存储 的区别</center></strong></p>\n<h1 id=\"四neo4j-介绍与安装\">四、Neo4J 介绍与安装</h1>\n<h2 id=\"41-引言\">4.1 引言</h2>\n<p>“工欲善其事，必先利其器”，知识图谱作为一种特殊的图结构，自然需要专门的图数据库进行存储。</p>\n<p>知识图谱由于其数据包含实体、属性、关系等，常见的关系型数据库诸如MySQL之类不能很好的体现数据的这些特点，因此知识图谱数据的存储一般是采用图数据库（Graph Databases）。而Neo4j是其中最为常见的图数据库。</p>\n<h2 id=\"42-neo4j-下载\">4.2 Neo4J 下载</h2>\n<p>首先在 <a href=\"https://neo4j.com/download/\">Neo4J官网</a> 下载 Neo4J。</p>\n<p>Neo4J分为社区版和企业版：</p>\n<ul>\n<li>企业版：收费，在横向扩展、权限控制、运行性能、HA等方面都比社区版好，适合正式的生产环境；</li>\n<li>社区版：免费，普通的学习和开发采用免费社区版就好。</li>\n</ul>\n<h2 id=\"43-neo4j-安装\">4.3 Neo4J 安装</h2>\n<ul>\n<li>在Mac或者Linux中，安装好jdk后，直接解压下载好的Neo4J包，运行命令</li>\n</ul>\n<pre><code> bin/neo4j start\n</code></pre>\n<ul>\n<li>windows系统下载好neo4j和jdk 1.8.0后，输入以下命令启动后neo4j</li>\n</ul>\n<pre><code> neo4j.bat console\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/a424e4e3acea4eb699a13a903e5481ff.png\" alt=\"图 12 Neo4j 运行结果\" /><strong><center>图 12 Neo4j 运行结果</center></strong></p>\n<h2 id=\"44-neo4j-web-界面-介绍\">4.4 Neo4J Web 界面 介绍</h2>\n<p>Neo4J提供了一个用户友好的 Web 界面，可以进行各项配置、写入、查询等操作，并且提供了可视化功能。类似<strong>ElasticSearch</strong>一样，我个人非常喜欢这种开箱即用的设计。</p>\n<p>打开浏览器，输入<a href=\"http://127.0.0.1:7474/browser/，如下图\">http://127.0.0.1:7474/browser/，如下图</a> 13 所示，界面最上方就是交互的输入框。<br />\n<img src=\"https://img-blog.csdnimg.cn/1f8dfddc7d4f4e5cb3cb45083294006c.png\" alt=\"图 13 Neo4J Web界面\" /><br />\n<strong><center>图 13 Neo4J Web界面</center></strong></p>\n<h2 id=\"45-cypher查询语言\">4.5 Cypher查询语言</h2>\n<ul>\n<li>Cypher：\n<ul>\n<li>介绍：是Neo4J的声明式图形查询语言，允许用户不必编写图形结构的遍历代码，就可以对图形数据进行高效的查询。</li>\n<li>设计目的：类似SQL，适合于开发者以及在数据库上做点对点模式（ad-hoc）查询的专业操作人员。</li>\n<li>其具备的能力包括：\n<ul>\n<li>创建、更新、删除节点和关系</li>\n<li>通过模式匹配来查询和修改节点和关系 - 管理索引和约束等</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>转载，原文链接：<a href=\"https://blog.csdn.net/weixin_44023658/article/details/112503294\">https://blog.csdn.net/weixin_44023658/article/details/112503294</a></p>\n<p>参考资料</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/guleileo/article/details/80879158\">干货 | 从零到一学习知识图谱的技术与应用</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/88745411\">手把手教你快速入门知识图谱 - Neo4J教程</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/82958776\">python操作图数据库neo4j的两种方式</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/93746655\">Neo4j之导入数据</a></li>\n<li><a href=\"https://schema.org/\">schema 介绍</a></li>\n<li><a href=\"https://ai.baidu.com/tech/kg/schema\">知识图谱Schema</a></li>\n<li><a href=\"https://tech.meituan.com/2018/11/01/meituan-ai-nlp.html\">美团大脑：知识图谱的建模方法及其应用</a></li>\n<li><a href=\"https://item.jd.com/10166718622.html\">肖仰华. 知识图谱：概念与技术．北京：电子工业出版社, 2020．2－39．</a></li>\n</ul>\n', 1, '', 0, 0, 1, '2022-05-21 17:42:38', '2022-05-21 18:05:37');
INSERT INTO `tb_article` VALUES (203, 1, 13, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7776', '知识图谱入门：知识图谱的技术流程', '<p>﻿# 知识图谱的技术流程</p>\n<blockquote>\n<p>知识图谱用于表达更加规范的<strong>高质量</strong>数据。</p>\n</blockquote>\n<ul>\n<li>一方面，知识图谱采用更加规范而标准的概念模型、本体术语和语法格式来建模和描述数据；</li>\n<li>另一方面，知识图谱通过语义链接增强数据之间的关联。这种表达规范、关联性强的数据在改进搜索、问答体验、辅助决策分析和支持推理等多个方面都能发挥重要的作用。</li>\n</ul>\n<p>知识图谱方法论涉及<strong>知识表示</strong>、<strong>知识获取</strong>、<strong>知识处理</strong>和<strong>知识利用</strong>多个方面。一般流程为：</p>\n<ul>\n<li>首先确定知识表示模型，然后根据数据来源选择不同的知识获取手段导入知识</li>\n<li>接着综合利用知识推理、知识融合、知识挖掘等技术对构建的知识图谱进行质量提升</li>\n<li>最后根据场景需求设计不同的知识访问与呈现方法，如语义搜索、问答交互、图谱可视化分析等。</li>\n</ul>\n<p>下面简要概述这些技术流程的核心技术要素。</p>\n<h2 id=\"1知识来源\">1.知识来源</h2>\n<blockquote>\n<p>可以从多种来源获取知识图谱数据，包括文本、结构化数据库、多媒体数据、传感器数据和人工众包等。</p>\n</blockquote>\n<p>每一种数据源的知识化都需要综合各种不同的技术手段。例如，对于<strong>文本数据源</strong>，需要综合实体识别、实体链接、关系抽取、事件抽取等各种自然语言处理技术，实现从文本中抽取知识。</p>\n<p><strong>结构化数据库</strong>如各种关系数据库，也是最常用的数据来源之一。已有的结构化数据库通常不能直接作为知识图谱使用，而需要将结构化数据定义到本体模型之间的语义映射。再通过编写语义翻译工具实现结构化数据到知识图谱的转化。此外，还需要综合采用<strong>实体消歧</strong>、<strong>数据融合</strong>、<strong>知识链接</strong>等技术，提升数据的规范化水平，增强数据之间的关联。</p>\n<p><strong>语义技术</strong>也被用来对传感器产生的数据进行语义化。这包括对物联设备进行抽象，定义符合语义标准的数据接口；对传感数据进行语义封装和对传感数据增加上下文语义描述等。</p>\n<p><strong>人工众包</strong>是获取高质量知识图谱的重要手段。例如，<strong>Wikidata</strong> 和 <strong>Sehema.org</strong> 都是较为典型的知识众包技术手段。此外，还可以开发针对文本、图像等多种媒体数据的语义标注工具，辅助人工进行知识获取。</p>\n<h2 id=\"2知识表示与-schema-工程\">2.知识表示与 Schema 工程</h2>\n<blockquote>\n<p><strong>知识表示</strong>是指用计算机符号描述和表示人脑中的知识，以支持机器模拟人的心智进行推理的方法与技术。</p>\n</blockquote>\n<p>知识表示决定了图谱构建的产出目标，即知识图谱的语义描述框架<br />\n(<strong>Description Framework</strong>)、<strong>Schema</strong> 与本体（<strong>Ontology</strong>)、<strong>知识交换语法（Syntax)</strong>、<strong>实体命名</strong>及 <strong>ID 体系</strong>。</p>\n<p>基本描述框架定义知识图谱的基本数据模型（<strong>Data Model</strong>）和逻辑结构（<strong>Structure</strong>)，如:</p>\n<ul>\n<li>国际万维网联盟（<strong>World Wide Web Consortium</strong>，<strong>W3C</strong>）的 RDF。</li>\n<li><strong>Schema</strong> 与本体定义知识图谱的类集、属性集、关系集和词汇集。交换语法定义知识实际存在的物理格式，如<strong>Turtle</strong>、<strong>JSON</strong> 等。实体命名及 ID 体系定义实体的命名原则及唯一标识规范等。</li>\n</ul>\n<h3 id=\"什么是-rdf\">什么是 RDF？</h3>\n<p>w3school中是这样解释的：</p>\n<blockquote>\n<p>RDF 指资源描述框架（Resource Description Framework）<br />\nRDF 是一个用于描述 Web 上的资源的框架<br />\nRDF 提供了针对数据的模型以及语法，这样独立的团体们就可以交换和使用它<br />\nRDF 被设计为可被计算机阅读和理解<br />\nRDF 被设计的目的不是为了向人们显示出来<br />\nRDF 使用 XML 编写<br />\nRDF 是 W3C 语义网络活动的组成部分<br />\nRDF 是一个 W3C 推荐标准</p>\n</blockquote>\n<p>按知识类型的不同，知识图谱包括词（<strong>Vocabulary</strong>）、实体（<strong>Entity</strong>）、关系(<strong>Relation</strong>)、事件(<strong>Event</strong>)、术语体系（<strong>Taxonomy</strong>）、规则（<strong>Rule</strong>）等。</p>\n<ul>\n<li>词一级的知识以<strong>词</strong>为中心，并定义词与词之间的关系，如 <strong>WordNet</strong>，<strong>ConceptNet</strong> 等。</li>\n<li>实体一级的知识以实体以<strong>实体</strong>为中心，并定义实体之间的关系、描述实体的术语体系等。</li>\n<li>事件是一种复合的实体:</li>\n</ul>\n<p>W3C 的 RDF 把三元组（Triple）作为基本的数据模型，其基本的逻辑结构包含主语(<strong>Subject</strong>)、谓词（<strong>Predicate</strong>）、宾语（<strong>Object</strong>）三个部分。虽然不同知识库的描述框架的表述有所不同，但本质上都包含<strong>实体</strong>、<strong>实体的属性</strong>和<strong>实体之间的关系</strong>几个要素。</p>\n<h2 id=\"3知识抽取\">3.知识抽取</h2>\n<blockquote>\n<p>知识抽取按任务可以分为概念抽取、实体识别、关系抽取、事件抽取和规则抽取等。</p>\n</blockquote>\n<p>传统专家系统时代的知识主要依靠专家手工录入，难以扩大规模。现代知识图谱的构建通常大多依靠已有的结构化数据资源进行转化，形成基础数据集，再依靠<strong>自动化知识抽取</strong>和<strong>知识图谱补全技术</strong>，从多种数据来源进一步扩展知识图谱，并通过人工众包进一步提升知识图谱的质量。</p>\n<p><em><strong>结构化和文本数据是目前最主要的知识来源。</strong></em></p>\n<h2 id=\"4知识融合\">4.知识融合</h2>\n<p>在构建知识图谱时，可以从第三方知识库产品或已有结构化数据中获取知识输入。</p>\n<p>当多个知识图谱进行融合，或者将外部关系数据库合并到本体知识库时，需要处理两个层面的问题：</p>\n<ul>\n<li>通过模式层的融合，将新得到的本体融入已有的本体库中，以及新旧本体的融合；</li>\n<li>数据层的融合，包括实体的指称、属性、关系以及所属类别等，主要的问题是如何避免实例以及关系的冲突问题，造成不必要的冗余。</li>\n</ul>\n<p><strong>数据层的融合是指实体和关系（包括属性）元组的融合，主要是实体匹配或者对齐</strong><br />\n由于知识库中有些实体含义相同但是具有不同的标识符，因此需要对这些实体进行合并处理。</p>\n<p>此外，还需要对新增实体和关系进行验证和评估，以确保知识图谱的内容一致性和准确性，通常采用的方法是在评估过程中为新加入的知识赋予可信度值，据此进行知识的过滤和融合。</p>\n<blockquote>\n<p><strong>实体对齐</strong>的任务包括<strong>实体消歧</strong>和<strong>共指消解</strong>，即判断知识库中的同名实体是否代表不同的含义以及知识库中是否存在其他命名实体表示相同的含义。</p>\n</blockquote>\n<ul>\n<li>实体消歧专门用于解决同名实体产生歧义的问题，通常采用聚类法，其关键问题是如何定义实体对象与指称项之间的相似度，一些最新的工作利用知识图谱嵌入方法进行实体对齐，并引入人机协作方式提升实体对齐的质量。</li>\n<li>本体是针对特定领域中 Schema定义、概念模型和公理定义而言的，目的是弥合<strong>词汇异构性</strong>和<strong>语义歧义</strong>的间隙，使沟通达成共识。这种共识往往通过一个反复的过程达到，每次迭代都是一次共识的修改。因此，本体对齐通常带来的是共识模式的演化和变化，本体对齐的主要问题之一也可以转化为怎样管理这种演化和变化】。</li>\n</ul>\n<h2 id=\"5知识图谱补全与推理\">5.知识图谱补全与推理</h2>\n<p>常用的知识图谱补全方法包括:</p>\n<ul>\n<li>基于<strong>本体推理</strong>的补全方法，这类推理主要针对TBox，即概念层进行推理，也可以用来对实体级的关系进行补全。</li>\n<li>基<strong>于图结构和关系路径特征</strong>的方法，如基于随机游走获取路径特征的PRA算法、基于子图结构的SFE法基于层次随机游走模型的 PRA算法。这类算法的共同特点是通过两个实体节点之间的路径，以及节点周围图的结构提取特征，并通过随机游走等算法降低特征抽取的复杂度，然后叠加线性的学习模型进行关系的预测。此类算法依赖于图结构和路径的丰富程度</li>\n<li>更为常见的补全实现是基于表示学习和知识图谱嵌入的链接预测，简单的如前面介绍最基本的翻译模型、组合模型和神经元模型等。这类简单的嵌入模型一般只能实现单步的推理。对于更为复杂的模型，如向量空间中引入随机游走模型的方法，在同一个向量空间中将路径与实体和关系一起表示出来再进行补全的模型</li>\n<li>文本信息也被用来辅助实现知识图谱的补全[。例如，Jointly(w)、ointly(z)、 DKRL、TEKE、SSP 等方法将文本中的实体和结构化图谱中的实体对齐，然后利用双方的语义信息辅助实现关系预测或抽取。这类模型一般包含三个部分:三元组解码器、文本解码器和联合解码器。三元组解码器将知识图谱中的实体和关系转化为低维向量;文本解码器则要从文本语料库中学习实体(词)的向量表示;联合解码器的目的是要保证实体、关系和词的嵌入向量位于相同的空间中，并且集成实体向量和词向量。</li>\n</ul>\n<h2 id=\"6知识检索与知识分析\">6、知识检索与知识分析</h2>\n<p>基于知识图谱的知识检索的实现形式主要包括<strong>语义检索</strong>和<strong>智能问答</strong>。</p>\n<ul>\n<li>传统搜索引擎依靠网页之间的超链接实现网页的搜索，</li>\n<li>而语义搜索直接对事物进行搜索，如人物、机构、地点等。这些事物可能来自文本、图片、视频、音频、loT设备等各种信息资源。而知识图谱和语义技术提供了关于这些事物的分类、属性和关系的描述，使得搜索引擎可以直接对事物进行索引和搜索。</li>\n</ul>\n<p>知识图谱和语义技术也被用来辅助做数据分析与决策。例如，大数据公司 Plantir基于本体融合和集成多种来源的数据，通过知识图谱和语义技术增强数据之间的关联，使得用户可以用更加直观的图谱方式对数据进行关联挖掘与分析。近年来，描述性数据分析(Declarative Data Analysis)越来越受到重视。描述性数据分析是指依赖数据本身的语义描述实现数据分析的方法。不同于计算性数据分析主要以建立各种数据分析模型，如深度神经网络，描述性数据分析突出预先抽取数据的语义，建立数据之间的逻辑，并依靠逻辑推理的方法(如<strong>Datalog</strong>)实现数据分析。</p>\n<p>参考资料：<a href=\"http://product.dangdang.com/27920286.html\">知识图谱：方法、实践与应用</a></p>\n', 1, '', 0, 0, 1, '2022-05-21 18:02:02', '2022-05-21 18:05:24');
INSERT INTO `tb_article` VALUES (204, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7670', '知识图谱与数据库技术：RDF三元组库和Neo4j图数据库', '<p>﻿# 知识图谱与数据库系统</p>\n<blockquote>\n<p>随着知识图谱规模的日益增长，知识图谱数据管理问题愈加突出。近年来，知识图谱和数据库领域均认识到大规模知识图谱数据管理任务的紧迫性。</p>\n</blockquote>\n<p>由于传统关系数据库无法有效适应知识图谱的图数据模型，知识图谱领域形成了<strong>RDF数据的三元组库(Triple Store)</strong>，数据库领域开发了管理属性图的<strong>图数据库(Graph Database)</strong>。</p>\n<p>知识图谱的主要数据模型有<strong>RDF图(RDFgraph)</strong> 和 <strong>属性图(Property Graph)</strong> 两种;知识图谱查询语言可分为 <strong>声明式(Declarative)</strong> 和 <strong>导航式(Navigational)</strong> 两类。</p>\n<h2 id=\"rdf三元组库\">RDF三元组库</h2>\n<p>主要是由 Semantic Web 领域推动开发的数据库管理系统，其数据模型<strong>RDF</strong> 图和查询语言<strong>SPARQL</strong>均遵守<strong>W3C</strong> 标准。查询语言<strong>SPARQL</strong> 从语法上借鉴了 <strong>SQL</strong>语言，属于<strong>声明式查询语言</strong>。</p>\n<p>最新的SPARQL 1.1版本为有效查询<strong>RDF</strong>三元组集合设计了</p>\n<ul>\n<li>三元组模式(<strong>Triple Pattern</strong>)</li>\n<li>基本图模式(<strong>Basic Graph Pattern</strong>)</li>\n<li>属性路径(<strong>Property Path</strong>)</li>\n</ul>\n<p>等多种查询机制。</p>\n<h2 id=\"图数据库\">图数据库</h2>\n<p><strong>图数据库是数据库领域为更好地存储和管理图模型数据而开发的数据库管理系统。</strong> 其数据模型采用属性图，其上的声明式查询语言有:<strong>Cypher</strong>、<strong>PGQL</strong>和<strong>G-Core。</strong></p>\n<ul>\n<li><strong>Cypher</strong> 是开源图数据库 <strong>Neo4j</strong> 中实现的图查询语言。</li>\n<li><strong>PGQL</strong> 是<strong>Oracle</strong>公司开发的图查询语言。</li>\n<li><strong>G-Core</strong>是由**LDBC (Linked Data Benchmarks Council)**组织设计的图查询语言。</li>\n</ul>\n<blockquote>\n<p>考虑到关系数据库采用统一的查询语言<strong>SQL</strong>，目前学术和工业界关于开发统一图数据库语言的呼声越来越高。</p>\n</blockquote>\n<h2 id=\"存储方案\">存储方案</h2>\n<p>目前，基于三元组库和图数据库能够提供的知识图谱数据存储方案可分为三类:</p>\n<h3 id=\"1基于关系的存储方案\">(1)基于关系的存储方案</h3>\n<p>基于关系的存储方案。包括三元组表、水平表、属性表、垂直划分、六重索引和 <strong>DB2RDF</strong> 等。</p>\n<ul>\n<li>\n<p><strong>三元组表</strong>是将知识图谱中的每条三元组存储为一行具有三列的记录(主语，谓语，宾语)。三元组表存储方案虽然简单明了，但三元组表的行数与知识图谱的边数一样，其问题是将知识图谱查询翻译为<strong>SQL</strong>后会产生大量三元组表的自连接操作，影响效率。</p>\n</li>\n<li>\n<p><strong>水平表</strong>存储方案的每行记录存储知识图谱中一个主语的所有谓语和宾语，相当于知识图谱的邻接表。但其缺点在于所需列数目过多，表中产生大量空值，无法存储多值宾语等。</p>\n</li>\n<li>\n<p><strong>属性表</strong>存储方案将同一类主语分配到一个表中，是对水平表存储方案的细化。属性表解决了三元组表的自连接问题和水平表的列数目过多问题。但对于真实大规模知识图谱，属性表的问题包括:所需属性表过多，复杂查询的多表连接效率，空值问题和多值宾语问题。</p>\n</li>\n<li>\n<p><strong>垂直划分</strong>存储方案为知识图谱中的每种谓语建立一张两列的表(主语，宾语)，表中存放由该谓语连接的主语和宾语，支持“主语-主语”作为连接条件的查询操作的快速执行。垂直划分有效解决了空值问题和多值宾语问题;但其仍有缺点，包括:大规模知识图谱的谓语表数目过多、复杂查询表连接过多、更新维护代价大等</p>\n</li>\n<li>\n<p><strong>六重索引</strong>存储方案是将三元组全部6种排列对应地建立为6张表。六重索引通过“空间交换时间”策略有效缓解了三元组表的自连接问题，但需要更多的存储空间开销和索引更新维护代价。</p>\n</li>\n<li>\n<p><strong>DB2RDF</strong>存储方案，是以往存储方案的一种权衡优化。三元组表的灵活性体现在“行维度”上，无论多少行三元组数据，表核式只有3列固定不变;DB2RDF了“列维度”，列名称不再和语绑定，将同一主语的所有谓语和宾语动态分配到某列。</p>\n</li>\n</ul>\n<h2 id=\"2面向rdf的三元组\">(2)面向RDF的三元组。</h2>\n<p>主要的RDF三元组包括:</p>\n<ul>\n<li>商业系统Virtuoso、</li>\n<li>AllegroGraph</li>\n<li>GraphDB</li>\n<li>BlazeGraph</li>\n<li>开源系统Jena</li>\n<li>RDF-3X</li>\n<li>gStore</li>\n</ul>\n<p><strong>RDF4J</strong>目前是Eclipse基下的开源孵化项目，其功能包括RDF数据的解析、储、推理和查询等。RDF4J本身提供内存和磁盘两种RDF存储机制，支持全部的 SPARQL11 查询和更新语言，可以使用与访问本地RDF库相同的API访问远程RD库，支持所有主流的DF格式，包括DFXML、Turtle、N-Triples、N-Quads JSON-LD、TriG和TriXRDF4J框架的主要特点是其模块化的软件架构设计。</p>\n<p><strong>gStore</strong> 是由北京大学、加拿大滑铁卢大学和香港科技大学研究项目开发的基于图的RDF三元组数据库。gStore的底层存储使用RDF图对应的标签图(Signature Graph)并建立“VS树”索引结构以加速查找。gStore 系统提出建立“VS 树”索引，其基本思想实际上是为标签图G*建立不同详细程度的摘要图(SummaryGraph);利用“VS树”索引提供的摘要图，gStore 系统提出可以大幅削减 SPARQL 查询的搜索空间，以加快查询速度。</p>\n<h3 id=\"3原生图数据库neo4j\">(3)原生图数据库Neo4j</h3>\n<p><strong>Neo4j 是用 Java实现的开源图数据库。 可以说Neo4j是目前流行程度最高的图数据库产品。</strong></p>\n<p>Neo4j的不足之处在于其社区版是<strong>单机系统</strong>，虽然Neo4j企业版支持高可用性(<strong>High availability</strong>)集群，但其与分布式图存储系统的最大区别在于每个节点上存储图数据库的完整副本(类似于关系数据库镜像的副本集群)，而不是将图数据划分为子图进行分布式存储，而并非真正意义上的分布式数据库系统。如果图数据超过一定规模，系统性能就会因为磁盘、内存等限制而大幅降低。</p>\n<p><strong>JanusGraph</strong> 是在原有Titan系统基础上继续开发的开源分布式图数据库，目前是 Linux基金会旗下的一个开源项目。JanusGraph的存储后端与查询引擎是分离的，由于其可使用分布式Bigtable 存储库Cassandra或HBase 作为存储后端，<strong>因此 JanusGraph自然就成了分布式图数据库</strong>。JanusGraph分布式查询功能仅限于基于Cassandra或 HBase提供的分布式读写实现的简单导航查询，对于很多稍复杂的查询类型，目前还不了持真正意义上的分布式查询处理，例如子图匹配查询、正则路径查询等。</p>\n<h1 id=\"总结\">总结</h1>\n<blockquote>\n<p>总体来讲，基于关系的存储系统继承了关系数据库的优势，成熟度较高，在硬件性能和存储容量满足的前提下，通常能够适应千万到十亿三元组规模的管理。</p>\n</blockquote>\n<p>官方测评显示，关系数据库Oracle 12c配上空间和图数据扩展组件(Spatial and Graph)可以管理的三元组数量高达1.08万亿条。</p>\n<p>对于一般在百万到上亿三元组的管理，使用稍高配置的单机系统和主流RDF三元组数据库(如Jena、RDF4J、Virtuoso等)完全可以胜任。</p>\n<p>如果需要管理几亿到十几亿以上大规模的RDF三元组，则可尝试部署具备分布式存储与查询能力的数据库系统(如商业版的GraphDB 和BlazeGraph、开源的JanusGraph等)。</p>\n<p><strong>近年来，以 Neo4j 为代表的图数据库系统发展迅猛，使用图数据库管理 RDF三元组也是一种很好的选择</strong>;但目前大部分图数据库还不能直接支持RDF三元组存储，对于这种情况，可采用数据转换方式，先将RDF 预处理为图数据库支持的数据格式(如属性图模型)，再进行后续管理操作。</p>\n<p><em>目前，还没有一种数据库系统被公认为是具有主导地位的知识图谱数据库。但可以预见，随着三元组库和图数据库的相互融合发展，知识图谱的存储和数据管理手段将愈加丰富和强大。</em></p>\n<p>参考资料：<a href=\"http://product.dangdang.com/27920286.html\">知识图谱：方法、实践与应用：王昊奋 漆桂林等主编</a></p>\n', 1, '', 0, 0, 1, '2022-05-22 10:31:00', '2022-05-22 10:31:00');
INSERT INTO `tb_article` VALUES (205, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=112', 'Hello Halo', '<h2 id=\"hello-halo\">Hello Halo</h2>\n<p>如果你看到了这一篇文章，那么证明你已经安装成功了，感谢使用 <a href=\"https://halo.run\">Halo</a> 进行创作，希望能够使用愉快。</p>\n<h2 id=\"相关链接\">相关链接</h2>\n<ul>\n<li>官网：<a href=\"https://halo.run\">https://halo.run</a></li>\n<li>社区：<a href=\"https://bbs.halo.run\">https://bbs.halo.run</a></li>\n<li>主题仓库：<a href=\"https://halo.run/s/themes\">https://halo.run/s/themes</a></li>\n<li>开源地址：<a href=\"https://github.com/halo-dev/halo\">https://github.com/halo-dev/halo</a></li>\n</ul>\n<p>在使用过程中，有任何问题都可以通过以上链接找寻答案，或者联系我们。</p>\n<blockquote>\n<p>这是一篇自动生成的文章，请删除这篇文章之后开始你的创作吧！</p>\n</blockquote>\n', 1, '', 0, 0, 1, '2020-04-24 18:38:38', '2022-05-21 18:21:34');
INSERT INTO `tb_article` VALUES (206, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=6657', '关于我', '<h2 id=\"%E8%87%AA%E8%AF%AD\" tabindex=\"-1\">自语</h2>\n<ul>\n<li>大家好，我是一枚刚入门的后端开发工程师👨🏻‍💻，在读研究生，目前主攻Java后端开发.</li>\n<li>我希望用代码改变世界,我也在改变世界,自豪脸😏</li>\n<li>目前正走在成为一个<s>厉害</s>(Zhuang Bi)程序猿的路上. 前途很艰辛, 但是我会坚持!</li>\n<li>生活不止有撸码和工作, 也有诗和远方. 在快乐中生活, 在快乐中工作, 爱家人, 爱自己</li>\n</ul>\n<p><strong>子曰：生而知之者，上也；学而知之者，次也；困而学之，又其次也；困而不学，民斯为下矣。<br />\n人生得意须尽欢，莫使金樽空对月。<br />\n少小须勤学，文章可立身。满朝朱紫贵，尽是读书人。</strong></p>\n<h2 id=\"%E6%8A%80%E8%83%BD\" tabindex=\"-1\">技能</h2>\n<ul>\n<li>语言：Java, JavaScript, HTML, CSS</li>\n<li>数据库：MySQL, Redis, Oracle</li>\n<li>开发框架：Spring, Spring Boot, Spring Cloud Alibaba, MyBatis, Shiro, JQuery，Bootstrap，Layui，Vue</li>\n<li>交互协议：TCP/IP，Netty，MQTT，WebSocket</li>\n<li>中间件：Kafka, Zookeeper,MyCat</li>\n<li>构建工具： Maven, Tomcat</li>\n<li>环境： Centos, Linux, Git,Eclipse, Intellij IDEA</li>\n</ul>\n<h2 id=\"%E5%AD%A6%E4%B9%A0\" tabindex=\"-1\">学习</h2>\n<ul>\n<li>有道是学无止境，Java 后端开发的路很难走，但是既然走了这条路，那就得一直走下去。</li>\n<li>Java 相关的技术栈很多，学起来很不容易，最近两年的行情也是优胜劣汰，希望自己能够快速成长起来。</li>\n<li>夯实基础，学习源码。</li>\n<li>初识<strong>知识图谱</strong>，希望在这条路上也有所成长。</li>\n</ul>\n<p><ins>问渠哪得清如许？为有源头活水来。</ins></p>\n<blockquote>\n<p>要问为什么方塘的水会如此清澈？是由于有永不枯竭的源头为它源源不断地输送活水啊。<br />\n诗句常用来比喻知识是不断更新和发展的，需要不断积累，就像水源头一样，在人生的学习中不断地学习、运用和探索，才能使自己永葆先进和活力。</p>\n</blockquote>\n<h2 id=\"%E5%8D%9A%E5%AE%A2\" tabindex=\"-1\">博客</h2>\n<ul>\n<li>期望：平时生活和工作一种记录, 希望之后回过头再来看自己的博客也会有所收获或感想</li>\n<li>技术、感想与生活</li>\n<li>对生活和学习的一个记录</li>\n<li>希望自己越来越强大，为了自己所爱的人</li>\n</ul>\n<h2 id=\"%E5%88%86%E4%BA%AB\" tabindex=\"-1\">分享</h2>\n<p>最喜欢的一首诗，与你共勉：</p>\n<blockquote>\n<p><strong>大鹏一日同风起，抟摇直上九万里。<br />\n假令风歇时下来，犹能簸却沧溟水。<br />\n世人见我恒殊调，闻余大言皆冷笑。<br />\n宣父犹能畏后生，丈夫未可轻年少。</strong></p>\n</blockquote>\n', 1, '', 0, 0, 1, '2020-10-07 12:41:27', '2022-08-02 11:19:04');
INSERT INTO `tb_article` VALUES (207, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3173', 'Springboot多模块配置详细教程+源码案例+所遇到的坑', '<h3 id=\"springboot多模块配置详细教程\">Springboot多模块配置详细教程</h3>\n<blockquote>\n<p>这两天参考了下若依大神的后台管理项目，感觉程序的健壮性是真的强大，本人佩服的五体投地，很多程序设计技巧规范非常值得我去学习，其中第一个便是Springboot的多模块化配置，也正好项目中需要，所以特地学习一下，但是实际操作中遇到了很多问题，特此记录一下。</p>\n</blockquote>\n<h6 id=\"进行多模块配置的好处maven多模块项目通常由一个父模块和若干个子模块构成每个模块都对应着一个pomxml它们之间通过继承和聚合也称作多模块相互关联多模块适用于一些比较大的项目通过合理的模块拆分实现代码的复用便于维护和管理\">进行多模块配置的好处：maven多模块项目通常由一个父模块和若干个子模块构成，每个模块都对应着一个pom.xml。它们之间通过继承和聚合（也称作多模块）相互关联。多模块适用于一些比较大的项目，通过合理的模块拆分，实现代码的复用，便于维护和管理。</h6>\n<p>在开始动手之前，我们先捋一捋每个模块的作用，清楚需求做事才有目的。之后再说如何创建：<br />\n<img src=\"https://img-blog.csdnimg.cn/20191231180812711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n首先，如上图所示，我这里分了四个子模块和一个父模块。</p>\n<p>其中ww_system模块主要放entity、service、serviceImpl、mapper等文件。<br />\nww_common主要放一些公共的工具类，<br />\nww_blog是我的前台controller控制器<br />\nww_admin 是系统的web启动入口，包括系统后台controller都在这。是整个系统启动的入口。</p>\n<p>有心的朋友可以再单独把service也单独抽出来做一个模块，不过我觉得没有必要，用了mybatisplus之后service和mapper就很少写了。</p>\n<h3 id=\"如何创建\">如何创建？</h3>\n<h4 id=\"1创建父模块\">1，创建父模块</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20191231181705863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n父模块的创建和平常我们创建Springboot项目没法不同，一步一步来就行了，不过既然是父模块，那么它显然是不需要src目录的，所以创建后直接删掉它就行。其他的东西爱删不删，<strong>留下pom文件就行。</strong></p>\n<h4 id=\"2创建子模块\">2，创建子模块。</h4>\n<p>创建子模块的时候不要直接在左上角new -&gt;project来创建。要选择我们刚创建好的父模块项目，在它上面右击创建new module。<br />\n<img src=\"https://img-blog.csdnimg.cn/20191231182055709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n然后一直下一步就行，这里还没有什么要注意的地方，按照这种方式在父模块上右键创建其余的另外三个子模块。</p>\n<h4 id=\"3重点配置依赖\">3，重点：配置依赖</h4>\n<p>都创建好之后就是重点了，要配置我们几个模块之间的关联关系，<br />\n大致思路就是：所有的子模块都继承父模块<br />\nww_admin和ww_blog两个带控制器的模块要引用ww_system和ww_common公共模块。<br />\n公共模块ww_common不依赖任何模块，只补充它所需要的jar包坐标就行</p>\n<p>然后，父模块pom中不需要配置build打包配置</p>\n<h6 id=\"父模块pom文件内容\">父模块pom文件内容：</h6>\n<p><strong>注意模块引用和modules标签！！！！</strong></p>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.macw&lt;/groupId&gt;\n    &lt;artifactId&gt;wwblog&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n\n    &lt;name&gt;wwblog&lt;/name&gt;\n    &lt;url&gt;http://www.henaumcw.top&lt;/url&gt;\n    &lt;description&gt;马超伟●个人博客系统&lt;/description&gt;\n\n    &lt;properties&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n        &lt;macw.version&gt;1.0.0&lt;/macw.version&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n        &lt;shiro.version&gt;1.4.2&lt;/shiro.version&gt;\n        &lt;thymeleaf.extras.shiro.version&gt;2.0.0&lt;/thymeleaf.extras.shiro.version&gt;\n        &lt;druid.version&gt;1.1.14&lt;/druid.version&gt;\n    &lt;/properties&gt;\n\n    &lt;modules&gt;\n        &lt;module&gt;ww_admin&lt;/module&gt;\n        &lt;module&gt;ww_blog&lt;/module&gt;\n        &lt;module&gt;ww_system&lt;/module&gt;\n        &lt;module&gt;ww_common&lt;/module&gt;\n    &lt;/modules&gt;\n    &lt;packaging&gt;pom&lt;/packaging&gt;\n\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;!-- SpringBoot的依赖配置--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;\n                &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n                &lt;type&gt;pom&lt;/type&gt;\n                &lt;scope&gt;import&lt;/scope&gt;\n            &lt;/dependency&gt;\n            &lt;!--thymeleaf依赖--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n                &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--阿里数据库连接池 --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n                &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;\n                &lt;version&gt;${druid.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!-- 阿里JSON解析器 --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n                &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n                &lt;version&gt;${fastjson.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--系统模块--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.macw&lt;/groupId&gt;\n                &lt;artifactId&gt;ww_system&lt;/artifactId&gt;\n                &lt;version&gt;${macw.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--博客前台模块--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.macw&lt;/groupId&gt;\n                &lt;artifactId&gt;ww_blog&lt;/artifactId&gt;\n                &lt;version&gt;${macw.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--系统后台入口模块--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.macw&lt;/groupId&gt;\n                &lt;artifactId&gt;ww_admin&lt;/artifactId&gt;\n                &lt;version&gt;${macw.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!--公共模块--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.macw&lt;/groupId&gt;\n                &lt;artifactId&gt;ww_common&lt;/artifactId&gt;\n                &lt;version&gt;${macw.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.1&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;source&gt;${java.version}&lt;/source&gt;\n                    &lt;target&gt;${java.version}&lt;/target&gt;\n                    &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n    &lt;!--配置阿里云国内镜像--&gt;\n    &lt;repositories&gt;\n        &lt;repository&gt;\n            &lt;id&gt;public&lt;/id&gt;\n            &lt;name&gt;aliyun nexus&lt;/name&gt;\n            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;\n            &lt;releases&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n            &lt;/releases&gt;\n        &lt;/repository&gt;\n    &lt;/repositories&gt;\n&lt;/project&gt;\n\n</code></pre>\n<h6 id=\"ww-systempom文件内容\">ww_system:pom文件内容：</h6>\n<p>注意parent标签和模块引用</p>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;wwblog&lt;/artifactId&gt;\n        &lt;groupId&gt;com.macw&lt;/groupId&gt;\n        &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;groupId&gt;com.macw&lt;/groupId&gt;\n    &lt;artifactId&gt;ww_system&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;name&gt;ww_system&lt;/name&gt;\n    &lt;description&gt;系统模块&lt;/description&gt;\n    &lt;dependencies&gt;\n        &lt;!-- Mysql驱动包 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- 通用工具--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.macw&lt;/groupId&gt;\n            &lt;artifactId&gt;ww_common&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--Mybatis plus--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;\n            &lt;version&gt;3.3.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-extension&lt;/artifactId&gt;\n            &lt;version&gt;3.3.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;\n            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;\n            &lt;version&gt;2.3.28&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n\n</code></pre>\n<h6 id=\"ww-common模块pom文件内容\">ww_common模块pom文件内容：</h6>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;wwblog&lt;/artifactId&gt;\n        &lt;groupId&gt;com.macw&lt;/groupId&gt;\n        &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;groupId&gt;com.macw&lt;/groupId&gt;\n    &lt;artifactId&gt;ww_common&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;name&gt;ww_common&lt;/name&gt;\n    &lt;description&gt;公共模块&lt;/description&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- Spring框架基本的核心工具 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- SpringWeb模块 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;${lombo.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n\n</code></pre>\n<h6 id=\"ww-admin模块pom文件内容\">ww_admin模块pom文件内容：</h6>\n<p><strong>注意这里的模块引用和build标签内容</strong></p>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;wwblog&lt;/artifactId&gt;\n        &lt;groupId&gt;com.macw&lt;/groupId&gt;\n        &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;groupId&gt;com.macw&lt;/groupId&gt;\n    &lt;artifactId&gt;ww_admin&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;name&gt;ww_admin&lt;/name&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n    &lt;description&gt;系统后台●总后台web服务入口模块&lt;/description&gt;\n  \n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- SpringBoot集成thymeleaf模板 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- spring-boot-devtools --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n            &lt;optional&gt;true&lt;/optional&gt; &lt;!-- 表示依赖不会传递 --&gt;\n        &lt;/dependency&gt;\n\n        &lt;!--公共模块--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.macw&lt;/groupId&gt;\n            &lt;artifactId&gt;ww_common&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;!--博客前台--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.macw&lt;/groupId&gt;\n            &lt;artifactId&gt;ww_blog&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;!--系统模块--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.macw&lt;/groupId&gt;\n            &lt;artifactId&gt;ww_system&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;3.3.0&lt;/version&gt;\n        &lt;/dependency&gt;\n\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;fork&gt;true&lt;/fork&gt; &lt;!-- 如果没有该配置，devtools不会生效 --&gt;\n                &lt;/configuration&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;repackage&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n        &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n\n</code></pre>\n<h4 id=\"4-启动入口配置\">4 启动入口配置</h4>\n<p>启动入口只在ww_admin下配置Application启动类就行了，其他模块下不需要。<br />\n需要注意的是启动类一定要放在模块的根目录下，<br />\n我之前就是放在了模块目录下然后就导致了bean注入失败等的许多错误，需要加上@ComponentScan等好几个来进行包扫描，及其麻烦</p>\n<p>所以最好的就是放在根目录下，如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20191231185137914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n如果遇到bean注释失败的错误，那么别问其他，就去找你的包扫描吧，肯定是路径的问题。我就在这里栽了好久好久。<br />\n添加控制器和连接池之后的目录大致是这样的<br />\n<img src=\"https://img-blog.csdnimg.cn/20191231185515837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n由于篇幅限制上面pom文件中删掉了很多与这篇文章讲解无用的依赖。如果报错或无法启动请参考本项目源码：<a href=\"https://gitee.com/macw/wwblog.git\">https://gitee.com/macw/wwblog.git</a></p>\n<p>今天先更新到这，其他有问题闲来再更新</p>\n', 1, '', 0, 0, 1, '2020-04-25 08:33:11', '2022-05-21 18:21:18');
INSERT INTO `tb_article` VALUES (208, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4103', 'centos7系统运行、停止java程序常用命令，springboot打包运行', '<p>﻿</p>\n<h4 id=\"对于spring-boot导出的jar包程序\">对于Spring Boot导出的jar包程序</h4>\n<p>当连接的远程服务器执行的时候，一旦关闭了当前终端，程序也被迫停止运行了。这显然是不行的<br />\n我想要的是让它常驻后台执行，不受启动其终端关闭与否的影响。</p>\n<h5 id=\"解决办法\">解决办法</h5>\n<p>在jar包文件所在的目录执行以下命令：</p>\n<pre><code> nohup java -jar springboot-0.0.1-SNAPSHOT.jar  &gt;nohup 2&gt;&amp;1 &amp;\n</code></pre>\n<p>nohup: 不挂断的执行命令，忽略所有的挂断信号。 运行后台命令 最后加 &amp;<br />\n在jar目录下会生成一个nohup.out文件，默认的log输出到这里了。</p>\n<h5 id=\"命令解释\">命令解释</h5>\n<p>以上命令是不输出启动日志的，运行后会只输出一个运行的进程号。<br />\n想要输出启动日志可以这样：</p>\n<pre><code>java -jar xx.jar &gt; log.file 2&gt;&amp;1 &amp;\n</code></pre>\n<p><strong>这里启动信息就输出到了日志文件上，注意的是log文件需要先创建chmod授权</strong><br />\n可以给日志一个777授权，测试阶段无所谓：</p>\n<pre><code>chmod 777 -R /home/logs\n</code></pre>\n<h5 id=\"21含义\">2&gt;&amp;1含义</h5>\n<p>&amp; 1 更准确的说是文件描述符 1,<br />\n而1 一般代表的就是STDOUT_FILENO,实际上这个操作就是一个dup2(2)调用<br />\n.他标准输出到all_result ,然后复制标准输出到文件描述符2(STDERR_FILENO)， 其后果就是文件描述符1和2指向同一个文件表项,也可以说错误的输出被合并了<br />\n.其中0表示键盘输入 1表示屏幕输出 2表示错误输出.把标准出错重定向到标准输出,然后扔到/DEV/NULL下面去。通俗的说，就是把所有标准输出和标准出错都扔到垃圾桶里面。<br />\n|值|含义  |<br />\n|--|--|<br />\n| 0 |标准输入（一般是键盘）  |<br />\n|1|标准输出（一般是显示屏，准确的说是用户终端控制台）|<br />\n|2|标准错误（出错信息输出）|</p>\n<p>最后一个&amp; ， 是让该命令在后台执行</p>\n<h4 id=\"查看进程\">查看进程</h4>\n<p><strong>查看全部进程</strong></p>\n<pre><code>ps -ef \n</code></pre>\n<p><strong>查看java进程</strong></p>\n<pre><code>ps -ef |grep java\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20200106122724191.png\" alt=\"在这里插入图片描述\" /><br />\n如图所示：<br />\n第一个进程是我jar包启动进程，第二个是java的查找进程不用管<br />\n前面的那个root是当前用户，第一个数字403是当前进程号<br />\n<strong>杀死当前进程</strong></p>\n<pre><code>kill -9 403\n</code></pre>\n<p><strong>只查询当前jar包程序的进程号：</strong></p>\n<pre><code>pgrep -f \'java -jar springboot-0.0.1-SNAPSHOT.jar\'\n</code></pre>\n<p>如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20200106123205274.png\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 15:30:30', '2022-05-21 18:21:05');
INSERT INTO `tb_article` VALUES (209, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=86', 'SpringBoot在自定义实现类中调用service层等Spring其他层报错为null的解决办法', '<p>﻿## 背景：<br />\n使用Springboot整合Netty写了一个TCP实现客户端服务端通信接收主板信息，然后需要将设备实时发送的检测数据等关键信息存储到数据库，也是为了能最快利用mybatis框架实现数据访问，然后在TCP服务器消息处理时，需要写数据库，直接调用DAO层，编译报错。改为调用Service层，编译正常，运行到调用的地方，报空指针异常，跟踪到异常位置，发现service为空，也就是按照之前controller层通过<br />\n@Autowired注入service层失效。<br />\n解决方案：</p>\n<h2 id=\"1不要用mybatis使用原生的jdbc连接数据库进行存储\">1.不要用mybatis,使用原生的jdbc连接数据库进行存储</h2>\n<p>代码如下：</p>\n<pre><code class=\"language-java\">blic class MessageHandler extends ChannelInboundHandlerAdapter {\n	private static Logger logger = LoggerFactory.getLogger(MessageHandler.class);\n	/**\n	 * 本方法用于读取客户端发送的信息\n	 * @param ctx\n	 * @param msg\n	 * @throws Exception\n	 */\n	@Override\n	public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n    System.out.println(&quot;输出接收过来的信息： &quot;+msg);\n        //将msg进行入库操作\n        //基础的jdbc连接操作，这里省去基础的连接方法\n        String str;\n        // 传递sql语句\n        Statement stt;\n        Connection conn = null;\n        String sql = &quot;insert into test_db(datas) values (\'&quot;+msg+&quot;\')&quot;;  //写SQL\n        try {\n            conn = mysqlimages.getConn();  //一个连接数据库的方法，这就不贴了，很简单的\n            //获取Statement对象\n            stt = conn.createStatement();\n            //执行sql语句\n            stt.executeUpdate(sql);\n            logger.info(&quot;&gt;&gt;&gt;插入数据库成功&quot;);\n            str = Const.SECCESS;\n        }catch (Exception e) {\n            logger.error(&quot;&lt;&lt;&lt;插入数据错误--&quot;+e.getMessage());\n            str = Const.ERROR;\n        }\n</code></pre>\n<p>这种方法可以实现，但是不推荐，本来这里数据量就大，再用jdbc没有连接池将会造成业务阻塞netty本身的worker工作线程。<br />\n所以推荐使用下一种方法：</p>\n<h2 id=\"2使用postconstruct静态初始化spring的成员变量\">2.使用@PostConstruct静态初始化spring的成员变量</h2>\n<p>代码如下：<br />\nchannelRead方法：</p>\n<pre><code class=\"language-java\">	//调用线程池处理大数据量问题\n	ExecutorService executor = Executors.newFixedThreadPool(5);\n    int num=0;\n    \n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        System.out.println();\n        log.info(&quot;加载客户端报文......&quot;);\n        log.info(&quot;【&quot; + ctx.channel().id() + &quot;】&quot; + &quot; :&quot; + msg);\n        /**\n         *  下面可以解析数据，保存数据，生成返回报文，将需要返回报文写入write函数\n         */\n        num++;\n        System.out.println(num);//输出当前已经接收过来的条数\n        //引入异步业务线程池的方式，避免长时间业务耗时业务阻塞netty本身的worker工作线程\n        executor.submit(new Callable&lt;Object&gt;() {\n            @Override\n            public Object call() throws Exception {\n                log.info(&quot;收到服务端发来的方法请求了--------------------------------------------&quot;);\n                ServerHandler handler = new ServerHandler();//这个类在下面\n                handler.test(msg.toString());\n                return null;\n            }\n        });\n        //响应客户端\n        this.channelWrite(ctx.channel().id(), msg);\n    }\n\n\n@Component \npublic class ServerHandler extends IoHandlerAdapter {\n\n    @Autowired\n    private ITest2StaticService test2StaticService;// 注入service方法\n\n    private static ServerHandler serverHandler;\n\n    @PostConstruct //通过@PostConstruct实现初始化bean之前进行的操作\n    //在初始化的时候初始化静态对象和它的静态成员变量healthDataService，原理是拿到service层bean对象，静态存储下来，防止被释放。\n    public void init() {\n        serverHandler = this;\n        serverHandler.test2StaticService = this.test2StaticService;\n        // 初使化时将已静态化的testService实例化\n    }\n\n    //测试调用\n    public void test(String msg) {\n        Test2Static test2Static = new Test2Static();\n        test2Static.setBb(Double.valueOf(msg));\n        test2Static.setCreateTime(LocalDateTime.now());\n        System.out.println(&quot;1111111111111111&quot;);\n        boolean b = serverHandler.test2StaticService.save(test2Static);\n        System.out.println(&quot;---! &quot;+b);\n    }\n\n}\n\nIoHandlerAdapter类 所用到的maven坐标：\n  &lt;!-- https://mvnrepository.com/artifact/org.apache.mina/mina-core --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.mina&lt;/groupId&gt;\n            &lt;artifactId&gt;mina-core&lt;/artifactId&gt;\n            &lt;version&gt;2.1.3&lt;/version&gt;\n        &lt;/dependency&gt;\n\n\n</code></pre>\n<p><strong>2.说明：</strong></p>\n<p>将需要调用Spring的Service层的类通过@Component注解为组件加载；<br />\n同样通过@Autowired获取Service层的Bean对象；<br />\n为类声明一个静态变量，方便下一步存储bean对象；<br />\n<strong>划重点：通过注解@PostConstruct ，在初始化的时候初始化静态对象和它的静态成员变量healthDataService，原理是拿到service层bean对象，静态存储下来，防止被释放。</strong></p>\n<p>找了好久，终于找到这个方法，本来以为很简单，却总是怎么也写不进去数据库。调用service一直为空，可困扰我好久。<br />\n特此记录。。。。。。。。。。。。。。。。。</p>\n<p><strong>那些浪费的时间，都是丢在真理路上的金子~~~~!</strong></p>\n', 1, '', 0, 0, 1, '2020-04-25 15:34:08', '2022-05-21 18:20:49');
INSERT INTO `tb_article` VALUES (210, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5289', 'java实现微信第三方登录流程源码详解，所遇到的坑', '<p>﻿&gt; 昨天在写一个手机版的web项目，要在微信客户端使用微信第三方登录，想着也没啥，看看就看看吧，但是可恶的微信官方文档给我画了很大的一个坑，特此记录</p>\n<h6 id=\"二次更新说明一下我这个是用我微信网页授权就是在微信客户端点开链接或菜单能弹出微信授权登录框的功能\">二次更新，说明一下我这个是用我微信网页授权，就是在微信客户端点开链接或菜单能弹出微信授权登录框的功能！</h6>\n<p><img src=\"https://img-blog.csdnimg.cn/20191219191009275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n前期准备工作我就不多说了，无非就是公众平台账号，填写相关资料耐心等待审核就好。</p>\n<p>这里要注意一点的是，网站应用创建好之后的<strong>授权回调域填写顶级域名就好</strong>，之前我一直写的二级域名，测试的时候回调总是过不来，后来回来看文档，微信说的就是，<strong>该域名下的所有页面都 可以回调</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20191219100843364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n创建好网站应用之后我们来看微信提供的接口文档</p>\n<p><a href=\"https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html\">微信开放平台第三方登录接口文档地址</a></p>\n<h4 id=\"第一步请求code\">第一步：请求CODE</h4>\n<p>根据官方文档，请求code这里要按照响应的参数进行拼接，参数就按照官方提供的，需要注意的是appid是你用哪个公众号登录就用哪个公众号的appid，<strong>这里不是开放平台的网站应用appid</strong></p>\n<p>然后另一个坑，redirect_uri，一定要用urlEncode对链接进行处理，这个链接是用户打开这个链接同意登录之后会跳转的地址，我们要跳转到后台对回调的信息就行处理，所以就要回调到我们域名下的controller控制器方法中，并且一定是要外网可访问。比如：<a href=\"http://www.test.com/callback\">www.test.com/callback</a><br />\n把链接进行Encode处理，<a href=\"http://www.jsons.cn/urlencode/\">这里提供一个 encode在线解码工具</a></p>\n<p>拼接好路径之后再微信客户端打开就应该会显示某某公众号的授权登录页面了，如果报错那就是路径没有拼接正确</p>\n<p>请求code的控制器如下所示：<br />\n参数是我自己的，换成你的参数就好</p>\n<pre><code class=\"language-java\">    @RequestMapping(&quot;/getCode&quot;)\n    public void getCode(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        //拼接url\n        StringBuilder url = new StringBuilder();\n        url.append(&quot;https://open.weixin.qq.com/connect/oauth2/authorize?&quot;);\n        //微信开放平台的appid\n        url.append(&quot;appid=&quot; + WeixinConfig.appId);\n        //转码\n        try {\n        	//回调地址 ,回调地址要进行Encode转码\n            String redirect_uri = URLEncoder.encode(WeixinConfig.REDIRECT_URI, &quot;utf-8&quot;);\n            System.out.println(&quot;redirect_uri==&quot; + redirect_uri);\n            url.append(&quot;&amp;redirect_uri=&quot; + redirect_uri);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        url.append(&quot;&amp;response_type=code&quot;);\n        url.append(&quot;&amp;scope=snsapi_userinfo&quot;);\n        url.append(&quot;&amp;state=&quot; + request.getSession().getId());\n        url.append(&quot;#wechat_redirect&quot;);\n        System.out.println(&quot;url===&quot; + url.toString());\n//        return &quot;redirect:&quot; + url.toString();\n        String s = url.toString();\n        response.sendRedirect(s);\n    }\n</code></pre>\n<p>返回说明</p>\n<p>用户允许授权后，将会重定向到redirect_uri的网址上，并且带上code和state参数</p>\n<p><strong>第二步：通过code换取网页授权access_token</strong></p>\n<p><strong>第三步：刷新access_token（如果需要）</strong></p>\n<p><strong>第四步：拉取用户信息(需scope为 snsapi_userinfo)</strong></p>\n<p>这三步我们应该在上面授权回调方法中调用，起初我在想每一个方法都要返回一个json，那么是不是我要三个控制器方法才行？，怎样才能在一个控制器里调用三个方法呢？</p>\n<p>感谢大神提供的发送GET请求的工具类：</p>\n<pre><code class=\"language-java\">public static JSONObject doGetJson(String url) throws Exception, IOException {\n        JSONObject jsonObject = null;\n        //初始化httpClient\n        DefaultHttpClient client = new DefaultHttpClient();\n        //用Get方式进行提交\n        HttpGet httpGet = new HttpGet(url);\n        //发送请求\n        HttpResponse response = client.execute(httpGet);\n\n        //获取数据\n        HttpEntity entity = response.getEntity();\n        //格式转换\n        if (entity != null) {\n            String result = EntityUtils.toString(entity, &quot;UTF-8&quot;);\n            jsonObject = JSONObject.fromObject(result);\n        }\n        //释放链接\n        httpGet.releaseConnection();\n        return jsonObject;\n    }\n</code></pre>\n<p>最后附上我的授权回调方法：</p>\n<pre><code class=\"language-java\">  /**\n     * 微信 授权登录回调\n     **/\n    @RequestMapping(&quot;/callback&quot;)\n    public void callback(String code, String state, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        System.out.println(&quot;====&quot; + code + &quot;===&quot; + state + &quot;====&quot;);\n        logger.debug(&quot;code===&quot; + code);\n        logger.debug(&quot;state===&quot; + state);\n        if (StringUtils.isNotEmpty(code)) {\n            logger.debug(&quot;sssssssss====&quot; + code);\n            StringBuilder url = new StringBuilder();\n            url.append(&quot;https://api.weixin.qq.com/sns/oauth2/access_token?&quot;);\n            //微信公众平台的AK和SK\n            url.append(&quot;appid=&quot; + WeixinConfig.appId);\n            url.append(&quot;&amp;secret=&quot; + WeixinConfig.appSecret);\n            //这是微信回调给你的code\n            url.append(&quot;&amp;code=&quot; + code);\n            url.append(&quot;&amp;grant_type=authorization_code&quot;);\n            System.out.println(&quot;url.toString()===&quot; + url.toString());\n            logger.debug(&quot;url.toString()===&quot; + url.toString());\n\n            JSONObject jsonObject = AuthUtil.doGetJson(url.toString());\n            logger.debug(&quot;jsonObject================&quot;+jsonObject);\n            //解析jsonStr的字符串\n            //1.获取微信用户的openid\n            String openid = jsonObject.getString(&quot;openid&quot;);\n\n            //2.获取获取access_token\n            String access_token = jsonObject.getString(&quot;access_token&quot;);\n\n            logger.debug(&quot;openid===&quot; + openid);\n            logger.debug(&quot;access_token===&quot; + access_token);\n\n            String infoUrl = &quot;https://api.weixin.qq.com/sns/userinfo?access_token=&quot; + access_token + &quot;&amp;openid=&quot; + openid\n                    + &quot;&amp;lang=zh_CN&quot;;\n            logger.debug(&quot;infoUrl===&quot; + infoUrl);\n\n            //3.获取微信用户信息\n            JSONObject userInfo = AuthUtil.doGetJson(infoUrl);\n            logger.debug(&quot;userInfo======================&quot;+userInfo);\n            //至此拿到了微信用户的所有信息,剩下的就是业务逻辑处理部分了\n            //保存openid和access_token到session\n            if (openid==null){\n                logger.debug(&quot;-------------------------微信授权回调，获取用户信息失败！=============================&quot;);\n                response.sendRedirect(&quot;http://m.huerdai.net/html/Program-error.html&quot;);\n                return;\n            }\n            request.getSession().setAttribute(&quot;openid&quot;, openid);\n            request.getSession().setAttribute(&quot;access_token&quot;, access_token);\n\n            logger.debug(&quot;openid===&quot; + openid);\n            logger.debug(&quot;access_token===&quot; + access_token);\n\n            String sessionid = getRequest().getSession().getId();\n            //去数据库查询有没有这个 openid\n            CustomerInfo customerInfoServiceOne = iCustomerInfoService.getOne(new QueryWrapper&lt;CustomerInfo&gt;().eq(&quot;openid&quot;, openid));\n            //如果没有这一个用户，则创建\n            if (customerInfoServiceOne == null) {\n                CustomerInfo customerInfo = new CustomerInfo();\n              	//省略实体set方法\n                boolean save = registerService.register(customerInfo);\n                if (save) {\n                    logger.debug(&quot;首次认证:http://m.huerdai.net&quot;);\n                    redisTemplate.opsForValue().set(sessionid, customerInfoServiceOne.getCustomerId());\n//                    response.sendRedirect(&quot;http://m.huerdai.net/index.html&quot;);\n                    response.sendRedirect(&quot;http://m.huerdai.net/html/bind-tel.html&quot;);\n                    return;\n                } else {\n                    logger.debug(&quot;认证失败！&quot;);\n                    response.sendRedirect(&quot;http://m.huerdai.net/error.html&quot;);\n                    return;\n                }\n            } else {\n                //已经授权过，没有绑定手机号，也是直接跳转到首页\n                redisTemplate.opsForValue().set(sessionid, customerInfoServiceOne.getCustomerId());\n                if (customerInfoServiceOne.getMobilePhone() == null) {\n                    logger.debug(&quot;已经授权过，没有绑定手机号，也是直接跳转到首页&quot;);\n                    //并且将用户信息存到Redis中\n//                    response.sendRedirect(&quot;http://m.huerdai.net/index.html&quot;);\n                    response.sendRedirect(&quot;http://m.huerdai.net/html/bind-tel.html&quot;);\n                    return;\n                } else {\n                    //已经授权过，并且已经绑定手机号\n                    logger.debug(&quot;有openid的跳转http://m.huerdai.net222222&quot;);\n                    response.sendRedirect(&quot;http://m.huerdai.net/index.html&quot;);\n                    return;\n                }\n\n            }\n\n        } else {\n            logger.debug(&quot;code获取失败！====&quot; + code);\n            // return new ModelAndView(&quot;redirect:http://m.huerdai.net/error.html&quot;);\n            response.sendRedirect(&quot;http://m.huerdai.net/error.html&quot;);\n        }\n    }\n</code></pre>\n<p>到这里就微信登录并且获取用户信息就算完成了，</p>\n<p>然后我遇到一个问题就是用户首次登录进来的时候会报openid找不到异常，第二次进来就好了，也没有其他报错信息，期待有大佬路过指正问题原因，感激不尽！</p>\n<p>这之间其他的一些问题异常和容易碰到的坑以后有时间再总结！</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:35:49', '2022-05-21 18:20:38');
INSERT INTO `tb_article` VALUES (211, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7152', 'Springboot自定义注解实现操作日志管理', '<p>﻿## 操作日志的记录</p>\n<p><strong>为什么要有日志？</strong><br />\n因为我们不光要记录代码的运行，如（logback log4j），而且还应该记录用户的行为，这叫做<strong>业务运行日志</strong></p>\n<blockquote>\n<p>例如：记录 zhangsan 在项目中 调用了哪个方法， 什么时间调用的 。访问的ip地址，  访问了哪些数据，做了什么操作，以此当程序出现问题的时候更利于我们进行错误的排查！</p>\n</blockquote>\n<p><strong>业务运行日志的作用</strong></p>\n<ol>\n<li>记录用户的行为 用于后续的分析</li>\n<li>记录用户的所有的操作</li>\n</ol>\n<p><strong>业务运行日志最常用的使用场景：记录管理员所有的行为操作， 可以用于业务分析，事故恢复</strong></p>\n<h3 id=\"日志实现的思路\">日志实现的思路</h3>\n<h4 id=\"1我们需要记录哪些数据--存入数据库\">1.我们需要记录哪些数据  存入数据库</h4>\n<p>这里列出一个我所用的表结构，如下所示：</p>\n<table>\n<thead>\n<tr><th>字段</th><th>含义</th></tr>\n</thead>\n<tbody>\n<tr><td>log_id</td><td>主键</td></tr>\n<tr><td>log_date</td><td>时间</td></tr>\n<tr><td>log_content</td><td>操作内容  例如：查询全部菜单信息  添加用户数据</td></tr>\n<tr><td>log_name_id</td><td>用户的id</td></tr>\n<tr><td>log_ip</td><td>用户的ip地址</td></tr>\n<tr><td>log_type</td><td>操作类型</td></tr>\n</tbody>\n</table>\n<h4 id=\"2在项目中什么位置记录\">2.在项目中什么位置记录</h4>\n<blockquote>\n<p>日志记录是一个数据库的添加操作 是一段代码</p>\n</blockquote>\n<p><strong>通常，我们在Controller方法进行后置增强</strong><br />\n如下图所示，我们在需要记录操作的controller上使用aop配置一个切入点，以此来记录用户所进行的操作<br />\n<img src=\"https://img-blog.csdnimg.cn/20191211145643492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"3如何实现记录功能\">3.如何实现记录功能</h4>\n<p>实现方式：AOP</p>\n<h4 id=\"4aop日志记录-具体代码实现\">4.Aop日志记录 具体代码实现</h4>\n<p>aop的使用流程，这里使用注解式aop来实现<br />\n具体步骤：</p>\n<ol>\n<li>\n<p>设置切入点</p>\n<ol>\n<li>可以切在方法上</li>\n<li>可以切在注解上\n<pre><code>@Transactional 事务注解 注解加在类上 aop 切在注解上\n</code></pre>\n</li>\n</ol>\n</li>\n<li>\n<p>写增强 日志记录增强</p>\n<ol>\n<li>获取日志的相关信息<br />\n用户的id  ip地址，  时间，  操作的描述，  类型等信息</li>\n<li>将日志对象 添加到数据库</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"增强方法的编写\">增强方法的编写</h4>\n<p><strong>增强方法中获取session</strong><br />\n因为我们是通过aop来获取用户的请求的，所以就需要通过当前的请求拿到session，进而去获取用户的信息。<br />\n<img src=\"https://img-blog.csdnimg.cn/20191211150342156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>但是，操作的描述如何获取呢？</strong></p>\n<pre><code>比如 执行的方法不同  描述是不一样的\nlogin             管理员登录\nselectAllMenu  查询了所有的菜单\n</code></pre>\n<p>解决方案：<strong>使用自定义注解：</strong></p>\n<ol>\n<li>\n<p>在 目标 方法上添加自定义注解 （@Log） 如下</p>\n</li>\n<li>\n<p>在增强中获取注解(@Log)的value 和 type</p>\n</li>\n</ol>\n<p><strong>代码实现</strong></p>\n<p>自定义日志注解<br />\n<img src=\"https://img-blog.csdnimg.cn/20191211151108554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<pre><code class=\"language-java\">import java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * 元注解：加在自定义注解上的注解\n * @Target 定义注解可以添加的位置 METHOD 方法上 type 类上\n * @Retention RUNTIME 运行时  不管编译 还是 运行 这个注解都可以用\n *\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface LogAnnotation {\n    /**\n     * 写法类似于接口的方法 后面可以通过default 关键字给默认值\n     * 用法类似于属性\n     * @return\n     */\n    String value() default &quot;&quot;;\n    String type() default &quot;&quot;;\n}\n</code></pre>\n<p><strong>这里要注意什么是元注解，和 注解属性的定义方式</strong></p>\n<h5 id=\"2-在目标方法上使用注解\">2. 在目标方法上使用注解</h5>\n<p><img src=\"https://img-blog.csdnimg.cn/20191211150853141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n3. 在增强方法中获取注解的value 和 type<br />\n<img src=\"https://img-blog.csdnimg.cn/20191211151652465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<pre><code class=\"language-java\">        /**\n         * 操作的描述\n         *\n         * 执行的方法不同  描述是不一样的\n         * login         管理员登录\n         * selectAllGuru 查询了所有的上师\n         *\n         * 获取注解的值\n         */\n//        1.通过连接点获取方法签名 被切入方法的所有信息\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n//        2.获取被切入方法对象\n        Method method = signature.getMethod();\n//        3.获取方法上的注解\n        LogAnnotation annotation = method.getAnnotation(LogAnnotation.class);\n//        4.获取注解的值\n        String value = annotation.value();\n</code></pre>\n<h2 id=\"完整的aop的代码实现\">完整的aop的代码实现</h2>\n<pre><code class=\"language-java\">package com.tourism.hu.config;\n\n/**\n * @author 马超伟\n * @PROJECT_NAME: fzll\n * @Description:\n * @date 15:29\n * @Copyright: All rights Reserved, Designed By Huerdai  \n * Copyright:    Copyright(C) 2019-2020\n * Company       Huerdai Henan LTD.\n */\n\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.tourism.hu.entity.CustomerInfo;\nimport com.tourism.hu.entity.CustomerLoginLog;\nimport com.tourism.hu.service.ICustomerInfoService;\nimport com.tourism.hu.service.ICustomerLoginLogService;\nimport com.tourism.hu.util.IpAddressUtil;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\n\nimport javax.annotation.Resource;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpSession;\nimport java.lang.reflect.Method;\nimport java.time.LocalDateTime;\n\n/*** @Aspect 标记当前类为功能增强类 切面类 *\n *  @Configuration 标记当前类为配置类 这个注解包含了@Component的功能\n */\n@Aspect\n@Configuration\npublic class LogAop {\n\n    private  Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Resource\n    private ICustomerInfoService iCustomerInfoService;\n\n    @Resource\n    private RedisTemplate redisTemplate;\n\n    @Resource\n    private ICustomerLoginLogService iCustomerLoginLogService;\n\n    /**\n     * JoinPoint 连接点 就是切入点 通过这个对象可以获取切入点的相关所有信息 例如：被切入的方法和注解\n     *\n     * @param joinPoint ** 切入点的设置 切注解 @annotation *\n     */\n    @After(&quot;@annotation(com.tourism.hu.config.Log)&quot;)\n    public void logAfter(JoinPoint joinPoint) {\n    	//new 一个日志的实体，用来保存日志信息\n        CustomerLoginLog loginLog = new CustomerLoginLog();\n        // 1.获取日志相关的信息  用户的id session  ip  时间  操作的描述  类型  ctrl+H\n        /**\n         * 获取用户id\n         * 为什么不能装配session？因为服务器有多个session\n         * 通过 ServletRequestAttributes 可以获取当前请求\n         * 当前请求可以获取当前会话的session\n         */\n         //获取用户的请求\n        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = requestAttributes.getRequest();\n        //得到session\n        HttpSession session = request.getSession();\n        String sessionid = session.getId();\n        //通过sessionid去获取用户信息\n        Object obj = redisTemplate.opsForValue().get(sessionid);\n        String customerId = &quot;&quot;;\n        if(obj!=null) {\n            customerId=obj.toString();\n        }\n        //拿到用户对象\n        CustomerInfo customerInfo = iCustomerInfoService.getOne(new QueryWrapper&lt;CustomerInfo&gt;().eq(&quot;id&quot;, customerId));\n        if (customerInfo!=null){\n        	//将用户的id 存入到日志实体中\n            loginLog.setCustomerId(customerInfo.getCustomerId());\n        }\n         loginLog.setLoginTime(LocalDateTime.now());\n        /**\n         * 获取用户的ip\n         * 通过工具类 ip\n         */\n        loginLog.setLoginIp(IpAddressUtil.getIp());\n\n        /**\n         * 操作的描述\n         * 执行的方法不同  描述是不一样的\n         * login         管理员登录\n         * 获取注解的值\n         */\n//        1.通过连接点获取方法签名 被切入方法的所有信息\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n//        2.获取被切入方法对象\n        Method method = signature.getMethod();\n//        3.获取方法上的注解\n        Log annotation = method.getAnnotation(Log.class);\n//        4.获取注解的值\n        String value = annotation.value();\n        loginLog.setLogContent(value);\n        // 获取注解的类型\n        String type = annotation.type();\n        if (type!=null){\n            loginLog.setLoginType(type);\n        }\n//        2.将日志对象 添加到数据库\n        System.out.println(loginLog);\n        logger.debug(&quot;loginLog====&quot;+loginLog);\n        boolean save = iCustomerLoginLogService.save(loginLog);\n        logger.debug(&quot;保存日志------&quot;+save);\n    }\n}\n\n</code></pre>\n<h4 id=\"所用到的工具类\">所用到的工具类</h4>\n<p>获取ip地址的工具类IpAddressUtil</p>\n<pre><code class=\"language-java\">  public static String getIp() {\n        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();\n        String ip = &quot;null&quot;;\n        try {\n            ip = request.getHeader(&quot;x-forwarded-for&quot;);\n            if (StringUtils.isEmpty(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getHeader(&quot;Proxy-Client-IP&quot;);\n            }\n            if (StringUtils.isEmpty(ip) || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);\n            }\n            if (StringUtils.isEmpty(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getHeader(&quot;HTTP_CLIENT_IP&quot;);\n            }\n            if (StringUtils.isEmpty(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);\n            }\n            if (StringUtils.isEmpty(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                ip = request.getRemoteAddr();\n            }\n        } catch (Exception e) {\n            logger.error(&quot;IPUtils ERROR &quot;, e);\n        }\n        //使用代理，则获取第一个IP地址\n        if(StringUtils.isNotEmpty(ip) &amp;&amp; ip.length() &gt; 15) {\n          if(ip.indexOf(&quot;,&quot;) &gt; 0) {\n              ip = ip.substring(0, ip.indexOf(&quot;,&quot;));\n          }\n      }\n        return ip;\n    }\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:36:30', '2022-05-21 18:20:19');
INSERT INTO `tb_article` VALUES (212, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8853', 'Linux-Centos7,开放相应端口命令', '<p>﻿今天在配置阿里云服务器的时候，发现我明明已经开放了云服务器防火墙的8080端口，然而Tomcat还是无法访问，然后意思到可能是Linux系统的防火墙的8080端口可能还没有打开，于是查询总结了以下命令：</p>\n<h2 id=\"现在linux防火墙有两种服务\">现在Linux防火墙有两种服务</h2>\n<h2 id=\"--1service-firewalld\">- 1.service firewalld</h2>\n<h2 id=\"--2service-iptables\">- 2.service iptables</h2>\n<h4 id=\"一就firewalld来说\">一.就firewalld来说</h4>\n<ul>\n<li>查看开放的端口命令：</li>\n</ul>\n<pre><code>netstat -anp\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20191117124820976.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>查询防火墙状态</li>\n</ul>\n<pre><code>systemctl status firewalld\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20191117124948744.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>如果防火墙关闭了，就开启</li>\n</ul>\n<pre><code> systemctl start firewalld\n</code></pre>\n<ul>\n<li>查询对应端口号</li>\n</ul>\n<pre><code>firewall-cmd --query-port=8080/tcp\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2019111712524287.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>如果显示no，则开启</li>\n</ul>\n<pre><code>firewall-cmd --add-port=8080/tcp --permanent\n</code></pre>\n<p>注意这条命令是 --add,加入端口号，上面那个是query查询端口号<br />\n<img src=\"https://img-blog.csdnimg.cn/20191117125331279.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>然后重启防火墙</li>\n</ul>\n<pre><code>firewall-cmd --reload\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20191117125437520.png\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"二service-iptables\">二.service iptables</h2>\n<ol>\n<li>开放端口命令： /sbin/iptables -I INPUT -p tcp --dport 8085 -j ACCEPT<br />\n2.保存：/etc/rc.d/init.d/iptables save<br />\n3.重启服务：/etc/init.d/iptables restart<br />\n4.查看端口是否开放：/sbin/iptables -L -n</li>\n</ol>\n<h5 id=\"最后附上云服务器打开端口号的配置\">最后附上云服务器打开端口号的配置</h5>\n<p><img src=\"https://img-blog.csdnimg.cn/20191117125617767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 15:37:01', '2022-05-21 18:20:08');
INSERT INTO `tb_article` VALUES (213, 1, 8, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8334', '省市区管理sql数据表设计、以及全国省市区全部最新数据', '<p>﻿使用Mysql数据库，主要字段有：<br />\n区域主键、区域名称、区域上级标识、地名简称、区域等级、区域编码、邮政编码、组合名称、经度、维度、拼音，<br />\n其页面展示效果图如下：<br />\n<img src=\"https://img-blog.csdnimg.cn/2019101611124889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n建表sql为：</p>\n<pre><code class=\"language-sql\">CREATE TABLE `region`  (\n  `id` int(11) NOT NULL COMMENT \'区域主键\',\n  `name` varchar(40) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'区域名称\',\n  `pid` int(11) NULL DEFAULT NULL COMMENT \'区域上级标识\',\n  `sname` varchar(40) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'地名简称\',\n  `level` int(11) NULL DEFAULT NULL COMMENT \'区域等级\',\n  `citycode` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'区域编码\',\n  `yzcode` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'邮政编码\',\n  `mername` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'组合名称\',\n  `Lng` float NULL DEFAULT NULL COMMENT \'经度\',\n  `Lat` float NULL DEFAULT NULL COMMENT \'维度\',\n  `pinyin` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'拼音\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n\n</code></pre>\n<h3 id=\"插入全国最新数据地址库\">插入全国最新数据地址库：</h3>\n<p>由于CSDN篇幅限制，数据一篇放不下，<br />\nsql文件下载地址为：<a href=\"https://download.csdn.net/download/macwx/11869084\">https://download.csdn.net/download/macwx/11869084</a><br />\n下面只是部分数据，全部数据请下载文件，是CSDN篇幅限制不让我全部复制下来啊~~~~</p>\n<pre><code class=\"language-sql\">\nINSERT INTO `fz_region` VALUES (100000, \'中国\', 0, \'中国\', 0, \'\', \'\', \'中国\', 116.368, 39.9151, \'China\');\nINSERT INTO `fz_region` VALUES (110000, \'北京\', 100000, \'北京\', 1, \'\', \'\', \'中国,北京\', 116.405, 39.905, \'Beijing\');\nINSERT INTO `fz_region` VALUES (110100, \'北京市\', 110000, \'北京\', 2, \'010\', \'100000\', \'中国,北京,北京市\', 116.405, 39.905, \'Beijing\');\nINSERT INTO `fz_region` VALUES (110101, \'东城区\', 110100, \'东城\', 3, \'010\', \'100010\', \'中国,北京,北京市,东城区\', 116.41, 39.9316, \'Dongcheng\');\nINSERT INTO `fz_region` VALUES (110102, \'西城区\', 110100, \'西城\', 3, \'010\', \'100032\', \'中国,北京,北京市,西城区\', 116.36, 39.9305, \'Xicheng\');\nINSERT INTO `fz_region` VALUES (110105, \'朝阳区\', 110100, \'朝阳\', 3, \'010\', \'100020\', \'中国,北京,北京市,朝阳区\', 116.485, 39.9484, \'Chaoyang\');\nINSERT INTO `fz_region` VALUES (110106, \'丰台区\', 110100, \'丰台\', 3, \'010\', \'100071\', \'中国,北京,北京市,丰台区\', 116.286, 39.8585, \'Fengtai\');\nINSERT INTO `fz_region` VALUES (110107, \'石景山区\', 110100, \'石景山\', 3, \'010\', \'100043\', \'中国,北京,北京市,石景山区\', 116.223, 39.9056, \'Shijingshan\');\nINSERT INTO `fz_region` VALUES (110108, \'海淀区\', 110100, \'海淀\', 3, \'010\', \'100089\', \'中国,北京,北京市,海淀区\', 116.298, 39.9593, \'Haidian\');\nINSERT INTO `fz_region` VALUES (110109, \'门头沟区\', 110100, \'门头沟\', 3, \'010\', \'102300\', \'中国,北京,北京市,门头沟区\', 116.101, 39.9404, \'Mentougou\');\nINSERT INTO `fz_region` VALUES (110111, \'房山区\', 110100, \'房山\', 3, \'010\', \'102488\', \'中国,北京,北京市,房山区\', 116.143, 39.7479, \'Fangshan\');\nINSERT INTO `fz_region` VALUES (110112, \'通州区\', 110100, \'通州\', 3, \'010\', \'101149\', \'中国,北京,北京市,通州区\', 116.657, 39.9097, \'Tongzhou\');\nINSERT INTO `fz_region` VALUES (110113, \'顺义区\', 110100, \'顺义\', 3, \'010\', \'101300\', \'中国,北京,北京市,顺义区\', 116.654, 40.1302, \'Shunyi\');\nINSERT INTO `fz_region` VALUES (110114, \'昌平区\', 110100, \'昌平\', 3, \'010\', \'102200\', \'中国,北京,北京市,昌平区\', 116.231, 40.2207, \'Changping\');\nINSERT INTO `fz_region` VALUES (110115, \'大兴区\', 110100, \'大兴\', 3, \'010\', \'102600\', \'中国,北京,北京市,大兴区\', 116.341, 39.7267, \'Daxing\');\nINSERT INTO `fz_region` VALUES (110116, \'怀柔区\', 110100, \'怀柔\', 3, \'010\', \'101400\', \'中国,北京,北京市,怀柔区\', 116.632, 40.316, \'Huairou\');\nINSERT INTO `fz_region` VALUES (110117, \'平谷区\', 110100, \'平谷\', 3, \'010\', \'101200\', \'中国,北京,北京市,平谷区\', 117.121, 40.1406, \'Pinggu\');\nINSERT INTO `fz_region` VALUES (110228, \'密云县\', 110100, \'密云\', 3, \'010\', \'101500\', \'中国,北京,北京市,密云县\', 116.843, 40.3762, \'Miyun\');\nINSERT INTO `fz_region` VALUES (110229, \'延庆县\', 110100, \'延庆\', 3, \'010\', \'102100\', \'中国,北京,北京市,延庆县\', 115.975, 40.4567, \'Yanqing\');\nINSERT INTO `fz_region` VALUES (120000, \'天津\', 100000, \'天津\', 1, \'\', \'\', \'中国,天津\', 117.19, 39.1256, \'Tianjin\');\nINSERT INTO `fz_region` VALUES (120100, \'天津市\', 120000, \'天津\', 2, \'022\', \'300000\', \'中国,天津,天津市\', 117.19, 39.1256, \'Tianjin\');\nINSERT INTO `fz_region` VALUES (120101, \'和平区\', 120100, \'和平\', 3, \'022\', \'300041\', \'中国,天津,天津市,和平区\', 117.215, 39.1172, \'Heping\');\nINSERT INTO `fz_region` VALUES (120102, \'河东区\', 120100, \'河东\', 3, \'022\', \'300171\', \'中国,天津,天津市,河东区\', 117.226, 39.1232, \'Hedong\');\nINSERT INTO `fz_region` VALUES (120103, \'河西区\', 120100, \'河西\', 3, \'022\', \'300202\', \'中国,天津,天津市,河西区\', 117.223, 39.1096, \'Hexi\');\nINSERT INTO `fz_region` VALUES (120104, \'南开区\', 120100, \'南开\', 3, \'022\', \'300110\', \'中国,天津,天津市,南开区\', 117.151, 39.1382, \'Nankai\');\nINSERT INTO `fz_region` VALUES (120105, \'河北区\', 120100, \'河北\', 3, \'022\', \'300143\', \'中国,天津,天津市,河北区\', 117.197, 39.1482, \'Hebei\');\nINSERT INTO `fz_region` VALUES (120106, \'红桥区\', 120100, \'红桥\', 3, \'022\', \'300131\', \'中国,天津,天津市,红桥区\', 117.151, 39.1671, \'Hongqiao\');\nINSERT INTO `fz_region` VALUES (120110, \'东丽区\', 120100, \'东丽\', 3, \'022\', \'300300\', \'中国,天津,天津市,东丽区\', 117.314, 39.0863, \'Dongli\');\nINSERT INTO `fz_region` VALUES (120111, \'西青区\', 120100, \'西青\', 3, \'022\', \'300380\', \'中国,天津,天津市,西青区\', 117.009, 39.1412, \'Xiqing\');\nINSERT INTO `fz_region` VALUES (120112, \'津南区\', 120100, \'津南\', 3, \'022\', \'300350\', \'中国,天津,天津市,津南区\', 117.385, 38.9914, \'Jinnan\');\nINSERT INTO `fz_region` VALUES (120113, \'北辰区\', 120100, \'北辰\', 3, \'022\', \'300400\', \'中国,天津,天津市,北辰区\', 117.132, 39.2213, \'Beichen\');\nINSERT INTO `fz_region` VALUES (120114, \'武清区\', 120100, \'武清\', 3, \'022\', \'301700\', \'中国,天津,天津市,武清区\', 117.044, 39.3842, \'Wuqing\');\nINSERT INTO `fz_region` VALUES (120115, \'宝坻区\', 120100, \'宝坻\', 3, \'022\', \'301800\', \'中国,天津,天津市,宝坻区\', 117.31, 39.7176, \'Baodi\');\nINSERT INTO `fz_region` VALUES (120116, \'滨海新区\', 120100, \'滨海新区\', 3, \'022\', \'300451\', \'中国,天津,天津市,滨海新区\', 117.702, 39.0267, \'Binhaixinqu\');\nINSERT INTO `fz_region` VALUES (120221, \'宁河县\', 120100, \'宁河\', 3, \'022\', \'301500\', \'中国,天津,天津市,宁河县\', 117.826, 39.3305, \'Ninghe\');\nINSERT INTO `fz_region` VALUES (120223, \'静海县\', 120100, \'静海\', 3, \'022\', \'301600\', \'中国,天津,天津市,静海县\', 116.974, 38.9458, \'Jinghai\');\nINSERT INTO `fz_region` VALUES (120225, \'蓟县\', 120100, \'蓟县\', 3, \'022\', \'301900\', \'中国,天津,天津市,蓟县\', 117.408, 40.0457, \'Jixian\');\n\n\n\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:37:24', '2022-05-21 18:19:51');
INSERT INTO `tb_article` VALUES (214, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=6720', 'Spring Boot 封装文件上传工具类', '<p>﻿springboot 实现文件的上传这里我用的是commins-io依赖：<br />\n坐标如下：</p>\n<pre><code class=\"language-java\"> &lt;dependency&gt;\n      &lt;groupId&gt;commons-io&lt;/groupId&gt;\n      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;\n      &lt;version&gt;2.4&lt;/version&gt;\n    &lt;/dependency&gt;\n</code></pre>\n<p>引入这个依赖之后就可以使用下面这个工具类进行文件上传的操作了：<br />\n如下：</p>\n<pre><code class=\"language-java\">package com.tourism.fzll.util;\n\nimport java.io.File;\nimport java.util.UUID;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\nimport org.springframework.web.multipart.MultipartFile;\n\npublic class FileUploadUtil {\n	\n	public static String upload(MultipartFile file) {\n		try {\n			String extName = file.getOriginalFilename();\n			// 获取文件后缀\n			if (extName.lastIndexOf(&quot;.&quot;) &lt;= 0) {\n				throw new RuntimeException(&quot;不支持该文件类型&quot;);\n			}\n			extName = extName.substring(extName.lastIndexOf(&quot;.&quot;));\n			String webUrl = getWebUrl();\n			String fileName = getFileName();\n			String sysPath = System.getProperty(&quot;catalina.home&quot;) + &quot;/webapps&quot;;\n			// 获取文件名字\n			fileName = getFileName() + extName;\n			// 获取文件地址\n			String filePath = &quot;/content/&quot; + fileName;\n			String Url = sysPath +&quot;/content/&quot;;\n			File file2 = new File(Url);\n			if (!file2.exists()) {\n				file2.mkdirs();\n			}\n			file.transferTo(new File(sysPath + filePath));\n			return webUrl + filePath;\n		} catch (Exception e) {\n			throw new RuntimeException(e);\n		}\n	}\n	/**\n	 * \n	 * @Title: upload \n	 * @Description: (将文件保存到指定的路径下) \n	 * @param file\n\n	 * @return  \n	 * @date 2019年9月30日 上午10:22:31\n	 * @author 马超伟\n	 */\n	public static String upload(MultipartFile file,String specifiedPath) {\n		try {\n			String extName = file.getOriginalFilename();\n			// 获取文件后缀\n			if (extName.lastIndexOf(&quot;.&quot;) &lt;= 0) {\n				throw new RuntimeException(&quot;不支持该文件类型&quot;);\n			}\n			extName = extName.substring(extName.lastIndexOf(&quot;.&quot;));\n			String fileName = getFileName();\n			// 获取文件名字\n			fileName = getFileName() + extName;\n			File file2 = new File(specifiedPath);\n			if (!file2.exists()) {\n				file2.mkdirs();\n			}\n			file.transferTo(new File(specifiedPath + File.separator+ fileName));\n			return fileName;\n		} catch (Exception e) {\n			throw new RuntimeException(e);\n		}\n	}\n\n	/**\n	 * 获取文件名\n	 * @return\n	 */\n	public static String getFileName() {\n		String uuid = UUID.randomUUID().toString();\n		uuid = uuid.replace(&quot;-&quot;, &quot;&quot;);\n		return uuid.toLowerCase();\n	}\n\n	public static String getWebUrl() {\n		HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();\n		return  request.getServletContext().getRealPath(&quot;/img&quot;);\n	}\n	\n	public static String getWebProUrl() {\n		HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();\n		return request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() +request.getContextPath();\n	}\n	\n}\n\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:37:53', '2021-08-30 10:00:30');
INSERT INTO `tb_article` VALUES (215, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4522', 'layui 树形表格 treeTable使用详细指南，不能折叠解决办法', '<p>﻿最近在写一个商品分类管理的功能，本来想用layui的树形组件来写，但发现layui原生的tree只能展示title，而分类的其他字段无法展示，这就有点不适用了，无意中看到一位大神自定义写的一个树形表格组件，正好满足我的要求，特此将使用方法以及其中遇到的一些坑记录下来。。。</p>\n<h3 id=\"首先看下treetable的\">首先看下treeTable的</h3>\n<p><a href=\"https://whvse.gitee.io/treetable-lay/\">演示地址</a></p>\n<p><a href=\"https://gitee.com/whvse/treetable-lay\">项目地址</a></p>\n<p>好了，如果看完演示到这里你觉得正好符合你的功能要求，就可以继续往下看了，</p>\n<p>虽然项目地址中已经把使用介绍的很详细了，但是我在这里要补充一下我遇到的坑：</p>\n<h2 id=\"使用方法\">使用方法</h2>\n<h4 id=\"1引入模块\">1，引入模块</h4>\n<p>打开项目地址，将整个项目下载下来，项目中其他文件可以参考，我们主要用的就是treetable-lay这个文件夹的内容。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190925170811464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n下载好项目后把treetable-lay放在我们自己项目的任意位置，但是尽量和layui文件夹放一块，好找！<br />\n下面是我放的位置，如图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190925171552808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"2初始化模块配置\">2，初始化模块配置</h4>\n<p>要扩展layui的模块使用我们引入的js模块，注意base路径是treetable-lay文件夹所在的父路径，这里出错会报404，extend内容最好不要改。<br />\n下面我先每个重点注意事项单独列出来，最后放完整代码。</p>\n<pre><code class=\"language-java\">   layui.config({\n        base: \'${pageContext.request.contextPath}/layuiadmin/modules/\' //   资源所在路径\n    }).extend({\n        treetable: \'treetable-lay/treetable\'\n    }).use([\'treetable\', \'table\', \'layer\'], function () {\n        var treetable = layui.treetable;\n        var layer = layui.layer;\n        var table = layui.table;\n        var $ = layui.jquery;\n});\n</code></pre>\n<p>如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/201909251720347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"3动态渲染表格\">3，动态渲染表格</h4>\n<p>数据是从后台查询出来，数据格式不需要做处理，只需要查询所有就行了，官方文档给了json格式，我自己也做了一个简单的封装，一会儿再说json格式。</p>\n<p>这里要注意的是treeIdName和treePidName这两个属性，要对应自己查询出来的id和pid。支持自定义这点非常好</p>\n<pre><code class=\"language-java\"> &lt;%--树形表格--%&gt;\n &lt;table class=&quot;layui-table&quot; id=&quot;Lay_category_treeTable&quot; lay-filter=&quot;Lay_category_treeTable&quot;&gt;&lt;/table&gt;\n    \n    //js如下：\n    layui.use([\'treetable\', \'table\', \'layer\'], function () {\n        var treetable = layui.treetable;\n        var layer = layui.layer;\n        var table = layui.table;\n        var $ = layui.jquery;\n\n        var re;\n        // 渲染表格\n        var renderTable = function () {\n            layer.load(3);    //这里好像是要加载几层 ，我的是3层，就写了个3，\n            re = treetable.render({\n                elem: \'#Lay_category_treeTable\',\n                url: \'${basepath}/goodscategory/selectTreeTable\',\n                treeColIndex: 1,          // 树形图标显示在第几列\n                treeSpid: 0,             // 最上级的父级id\n                treeIdName: \'classId\',       // 	id字段的名称\n                treePidName: \'parentId\',    // 	pid字段的名称\n                treeDefaultClose: true,     //是否默认折叠\n                page: false,\n                //treeLinkage: true,      //父级展开时是否自动展开所有子级\n                cols: [[\n                    {type: \'numbers\'},\n                    {title: &quot;分类名称&quot;, field: &quot;className&quot;,align:&quot;left&quot;},\n                    {title: &quot;分类编码&quot;, field: &quot;classCode&quot;},\n                    //  {title: &quot;分类层级&quot;, field: &quot;classIdLevel&quot;},\n                    {title: &quot;分类状态&quot;, field: &quot;classIdStatus&quot;,templet: \'#classIdStatusTpl\'},\n                    {title: &quot;创建人&quot;, field: &quot;createUser&quot;},\n                    {\n                        title: &quot;创建时间&quot;,\n                        field: &quot;createTime&quot;,\n                        templet: \'&lt;div&gt;{{# if(d.createTime!=null){ }} {{ layui.util.toDateString(d.createTime,\\\'yyyy-MM-dd HH:mm:ss\\\')  }} {{# } }}&lt;/div&gt;\'\n                    },\n                    {title: &quot;更新人员&quot;, field: &quot;updateUser&quot;},\n                    {\n                        title: &quot;更新时间&quot;,\n                        field: &quot;updateTime&quot;,\n                        templet: \'&lt;div&gt;{{# if(d.updateTime!=null){ }} {{ layui.util.toDateString(d.updateTime,\\\'yyyy-MM-dd HH:mm:ss\\\')  }} {{# } }}&lt;/div&gt;\'\n                    },\n                    {title: &quot;操作&quot;, templet: &quot;#updateAndDelete&quot;}\n                ]],\n                done: function () {\n                    layer.closeAll(\'loading\');\n                }\n            })\n        };\n</code></pre>\n<p>可以使用url传递数据，也可以使用data传递数据，如果使用url传递数据，参数是where字段，<br />\n跟layui数据表格的使用方式一致。</p>\n<h4 id=\"4参数说明这里直接复制官方的\">4，参数说明，（这里直接复制官方的）</h4>\n<p>layui数据表格的所有参数都可以用，除此之外treetable新增的参数有：</p>\n<table>\n<thead>\n<tr><th>参数</th><th>类型</th><th>是否必填</th><th>描述</th><th> </th></tr>\n</thead>\n<tbody>\n<tr><td>treeColIndex</td><td>int</td><td>是</td><td>树形图标显示在第几列</td><td> </td></tr>\n<tr><td>treeSpid</td><td>object</td><td>是</td><td>最上级的父级id</td><td> </td></tr>\n<tr><td>treeIdName</td><td>string</td><td>否</td><td>id字段的名称</td><td> </td></tr>\n<tr><td>treePidName</td><td>string</td><td>否</td><td>pid字段的名称</td><td> </td></tr>\n<tr><td>treeDefaultClose</td><td>boolean</td><td>否</td><td>是否默认折叠</td><td> </td></tr>\n<tr><td>treeLinkage</td><td>boolean</td><td>否</td><td>父级展开时是否自动展开所有子级</td><td> </td></tr>\n</tbody>\n</table>\n<p> <strong>treeColIndex</strong></p>\n<p> 树形图标（箭头和文件夹、文件的图标）显示在第几列， 索引值是cols数组的下标。</p>\n<p> <strong>treeSpid</strong></p>\n<p> 最上级的父级id，比如你可以规定pid为0或-1的是最顶级的目录。</p>\n<p> <strong>treeIdName</strong></p>\n<p> treetable是以id和pid字段来渲染树形结构的，如果你的数据没有id和pid字段，你可以指定id和pid字段的名称。</p>\n<p> <strong>treePidName</strong></p>\n<p> pid在你的数据字段中的名称。</p>\n<p> <strong>treeDefaultClose</strong></p>\n<p> 默认是全部展开的，如果需要默认全部关闭，加上treeDefaultClose:true即可。</p>\n<p> <strong>treeLinkage</strong></p>\n<p> 父级展开时是否自动展开所有子级</p>\n<h4 id=\"注意事项\">注意事项</h4>\n<ul>\n<li>不能使用分页功能，即使写了page:true，也会忽略该参数。</li>\n<li>不能使用排序功能，不要开启排序功能。</li>\n<li>table.reload()不能实现刷新，请参考demo的刷新。</li>\n<li>除了文档上写的treetable.xxx的方法之外，其他数据表格的方法都使用table.xxx。</li>\n<li>建议删除和修改请求完后台之后请刷新（重新渲染）表格，最好不要使用obj.delete方式删除。</li>\n</ul>\n<h4 id=\"5其他方法\">5，其他方法</h4>\n<p>这里除了layui的方法新增的方法有展开所有，折叠所有，刷新表格 ，三种方法，使用方法如下：</p>\n<pre><code class=\"language-java\"> &lt;div class=&quot;layui-btn-group&quot;&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-expand&quot;&gt;全部展开&lt;/button&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-fold&quot;&gt;全部折叠&lt;/button&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-refresh&quot;&gt;刷新表格&lt;/button&gt;\n &lt;/div&gt;\n\n	 renderTable();   //这个就是上面的渲染表格 var renderTable = function () {...}\n        //展开所有\n        $(\'#btn-expand\').click(function () {\n            //alert(0)\n            treetable.expandAll(\'#Lay_category_treeTable\');\n        });\n        //折叠所有\n        $(\'#btn-fold\').click(function () {\n           // alert(1)\n            treetable.foldAll(\'#Lay_category_treeTable\');\n        });\n        //刷新表格\n        $(\'#btn-refresh\').click(function () {\n            renderTable();\n        });\n\n</code></pre>\n<h4 id=\"6content图标\">6，content图标。</h4>\n<p>图标这个从gitee码云的源码上看吧，不再详细说，也没啥可说的。</p>\n<h2 id=\"7我遇到的坑\">7，我遇到的坑</h2>\n<p>我照着他给的教程一步步弄下来页面也显示出来了，但就是不能折叠，不管是我用折叠方法还是点那个三角图片还是设置为默认折叠，就是不管用，<br />\n不能折叠，可把我给气坏了。<br />\n苦思冥想找不到问题，最后我去研究treetable.js这个文件</p>\n<p>发现其中有一段代码他给注释掉了，如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190925174505180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n然后我把注释的这一段代码打开，哎，好了，展开折叠正常了，不知道什么原因，不知道有没有其他人遇到过。。。</p>\n<h5 id=\"最后分享一下我写的不成熟的这个页面的功能汇总做个记录\">最后，分享一下我写的不成熟的这个页面的功能汇总，做个记录：</h5>\n<p>主要功能有，树形表格展示，添加，修改，删除，批量删除，搜索，layui时间日期自定义格式列，表格全部展开、折叠、刷新表格等功能，有兴趣的看下吧~~<br />\n效果图如下所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190925175823787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>全部代码在这~：</strong></p>\n<pre><code class=\"language-java\">&lt;%--\n  Created by IntelliJ IDEA.\n  User: Administrator\n  Date: 2019/9/23\n  Time: 13:25\n  To change this template use File | Settings | File Templates.\n--%&gt;\n\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;\n&lt;%@ include file=&quot;../meta.jsp&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;商品分类管理&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;${basepath}layuiadmin/layui/css/layui.css&quot; media=&quot;all&quot;&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;${basepath}layuiadmin/modules/treetable-lay/treetable.css&quot;&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;${basepath}js/jquery-1.12.0.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;${basepath}js/cookies.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;${basepath}layuiadmin/layui/layui.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;${basepath}layuiadmin/modules/treetable-lay/treetable.js&quot;&gt;&lt;/script&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n        .layui-table-cell {\n            height: auto;\n            line-height: 30px;\n        }\n\n    &lt;/style&gt;\n\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=&quot;layui-card-body&quot;&gt;\n    &lt;div style=&quot;padding-bottom: 10px;&quot; id=&quot;LAY_lay_add&quot;&gt;\n        &lt;button type=&quot;button&quot; class=&quot;layui-btn layui-btn-danger&quot; onclick=&quot;doMultiDelete()&quot;&gt;\n            &lt;i class=&quot;layui-icon layui-icon-delete&quot;&gt;&lt;/i&gt; 批量删除\n        &lt;/button&gt;\n        &lt;button class=&quot;layui-btn layuiadmin-btn-role &quot; data-type=&quot;add&quot; onclick=&quot;toOpenAddLayer()&quot;&gt;\n            &lt;i class=&quot;layui-icon layui-icon-add-circle-fine&quot;&gt;&lt;/i&gt; 添加\n        &lt;/button&gt;\n        &amp;nbsp;\n        &lt;div class=&quot;layui-input-inline&quot; style=&quot;width: 200px;&quot;&gt;\n            &lt;input type=&quot;text&quot; name=&quot;search&quot; id=&quot;Lay_toSearch_input&quot; placeholder=&quot;请输入分类名称&quot; autocomplete=&quot;off&quot;\n                   class=&quot;layui-input&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;layui-input-inline&quot; style=&quot;width: 100px;&quot;&gt;\n            &lt;button type=&quot;button&quot; class=&quot;layui-btn layui-btn-normal&quot; id=&quot;btn-search&quot;&lt;%-- onclick=&quot;doSearch()&quot;--%&gt;&gt;\n                &lt;i class=&quot;layui-icon layui-icon-search&quot;&gt;&lt;/i&gt; 搜索\n            &lt;/button&gt;\n        &lt;/div&gt;\n        &amp;nbsp;\n        &lt;div class=&quot;layui-btn-group&quot;&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-expand&quot;&gt;全部展开&lt;/button&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-fold&quot;&gt;全部折叠&lt;/button&gt;\n            &lt;button class=&quot;layui-btn&quot; id=&quot;btn-refresh&quot;&gt;刷新表格&lt;/button&gt;\n        &lt;/div&gt;\n        &lt;%--\n                &lt;button type=&quot;button&quot; class=&quot;layui-btn layui-btn-normal  change-icon&quot;&gt;随机更换小图标&lt;/button&gt;\n        --%&gt;\n    &lt;/div&gt;\n\n    &lt;%--树形表格--%&gt;\n    &lt;table class=&quot;layui-table&quot; id=&quot;Lay_category_treeTable&quot; lay-filter=&quot;Lay_category_treeTable&quot;&gt;&lt;/table&gt;\n\n    &lt;%--树形菜单--%&gt;\n    &lt;div id=&quot;Lay_category_tree&quot; lay-filter=&quot;Lay_category_tree&quot;&gt;&lt;/div&gt;\n\n    &lt;%--Table表格--%&gt;\n    &lt;%-- &lt;table id=&quot;Lay_back_table&quot; lay-filter=&quot;Lay_back_table&quot;&gt;&lt;/table&gt;--%&gt;\n\n\n&lt;/div&gt;\n\n&lt;script type=&quot;text/html&quot; id=&quot;updateAndDelete&quot;&gt;\n    &lt;button type=&quot;button&quot; class=&quot;layui-btn  layui-btn-normal&quot; onclick=&quot;toOpenUpdateLayer(\'{{d.classId}}\')&quot;&gt;\n        &lt;i class=&quot;layui-icon layui-icon-edit&quot;&gt;&lt;/i&gt;修改\n    &lt;/button&gt;\n    &lt;button type=&quot;button&quot; class=&quot;layui-btn layui-btn-danger&quot; onclick=&quot;doDelete(\'{{d.classId}}\')&quot;&gt;\n        &lt;i class=&quot;layui-icon layui-icon-delete&quot;&gt;&lt;/i&gt; 删除\n    &lt;/button&gt;\n&lt;/script&gt;\n\n&lt;%--弹出层--%&gt;\n\n&lt;form id=&quot;addForm&quot; class=&quot;layui-form&quot;&gt;\n    &lt;div class=&quot;layui-form&quot; lay-filter=&quot;layuiconfig-form-role&quot; id=&quot;layuiconfig-form-role&quot;\n         style=&quot;padding: 20px 30px 0 0;display: none&quot;&gt;\n        &lt;div class=&quot;layui-form-item&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;分类名称&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;input name=&quot;className&quot; id=&quot;className&quot; class=&quot;layui-input&quot;&gt;\n                &lt;input name=&quot;classId&quot; id=&quot;classId&quot; lay-type=&quot;hide&quot; type=&quot;hidden&quot; class=&quot;layui-input&quot;&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;layui-form-item&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;分类编码&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;input name=&quot;classCode&quot; id=&quot;classCode&quot; class=&quot;layui-input&quot;&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;layui-form-item&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;分类状态&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;input type=&quot;checkbox&quot; lay-skin=&quot;switch&quot; lay-text=&quot;启用|禁用&quot; value=&quot;1&quot; checked name=&quot;classIdStatus&quot;\n                       id=&quot;classIdStatus&quot; class=&quot;layui-input&quot;&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=&quot;layui-form-item&quot; id=&quot;Lay_select_Level&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;请选择分类级别&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;select name=&quot;classIdLevel&quot; lay-verify=&quot;required&quot; lay-filter=&quot;classIdLevel&quot;&gt;\n                    &lt;option value=&quot;&quot;&gt;&lt;/option&gt;\n                    &lt;option value=&quot;1&quot; selected&gt;一级分类&lt;/option&gt;\n                    &lt;option value=&quot;2&quot;&gt;二级分类&lt;/option&gt;\n                    &lt;option value=&quot;3&quot;&gt;三级分类&lt;/option&gt;\n                &lt;/select&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n\n        &lt;div class=&quot;layui-form-item&quot; style=&quot;display: none&quot; id=&quot;Lay_One_Level&quot;&gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;请选择所属的一级分类&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;select name=&quot;parentId&quot; id=&quot;parentId&quot;  lay-filter=&quot;parent_classIdLevel_One&quot;&gt;\n                    &lt;option value=&quot;&quot;&gt;&lt;/option&gt;\n                &lt;/select&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=&quot;layui-form-item&quot; style=&quot;display: none&quot; id=&quot;Lay_Two_Level&quot; &gt;\n            &lt;label class=&quot;layui-form-label&quot;&gt;请选择所属的二级分类&lt;/label&gt;\n            &lt;div class=&quot;layui-input-block&quot;&gt;\n                &lt;select name=&quot;parentId2&quot; id=&quot;Two_parentId&quot;  lay-filter=&quot;parent_classIdLevel_Two&quot;&gt;\n                    &lt;option value=&quot;&quot;&gt;&lt;/option&gt;\n                &lt;/select&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n\n        &lt;div class=&quot;layui-form-item&quot; style=&quot;text-align: right&quot;&gt;\n            &lt;button class=&quot;layui-btn &quot; lay-submit lay-filter=&quot;LAY-sysconfig-submit&quot; id=&quot;LAY-sysconfig-submit&quot;&gt;确认添加\n            &lt;/button&gt;\n            &lt;button lay-submit lay-filter=&quot;updateSubmitBtn&quot; class=&quot;layui-btn&quot; id=&quot;updateSubmitBtn&quot;&gt;确认修改&lt;/button&gt;\n\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/form&gt;\n\n&lt;script type=&quot;text/html&quot; id=&quot;classIdStatusTpl&quot;&gt;\n    {{#  if(d.classIdStatus==1){ }}\n    启用\n    {{#  } else { }}\n    &lt;i style=&quot;color: red;&quot;&gt;禁用&lt;/i&gt;\n    {{#  } }}\n&lt;/script&gt;\n\n&lt;script type=&quot;text/javascript&quot;&gt;\n\n    layui.config({\n        base: \'${pageContext.request.contextPath}/layuiadmin/modules/\' //   资源所在路径\n    }).extend({\n        treetable: \'treetable-lay/treetable\'\n    }).use([\'treetable\', \'table\', \'layer\'], function () {\n        var treetable = layui.treetable;\n        var layer = layui.layer;\n        var table = layui.table;\n        var $ = layui.jquery;\n\n        var re;\n\n        // 渲染表格\n        var renderTable = function () {\n            layer.load(3);\n            re = treetable.render({\n                elem: \'#Lay_category_treeTable\',\n                url: \'${basepath}/goodscategory/selectTreeTable\',\n                treeColIndex: 1,          // 树形图标显示在第几列\n                treeSpid: 0,             // 最上级的父级id\n                treeIdName: \'classId\',       // 	id字段的名称\n                treePidName: \'parentId\',    // 	pid字段的名称\n                treeDefaultClose: true,     //是否默认折叠\n                page: false,\n                //treeLinkage: true,      //父级展开时是否自动展开所有子级\n                cols: [[\n                    {type: \'numbers\'},\n                    {title: &quot;分类名称&quot;, field: &quot;className&quot;,align:&quot;left&quot;},\n                    {title: &quot;分类编码&quot;, field: &quot;classCode&quot;},\n                    //  {title: &quot;分类层级&quot;, field: &quot;classIdLevel&quot;},\n                    {title: &quot;分类状态&quot;, field: &quot;classIdStatus&quot;,templet: \'#classIdStatusTpl\'},\n                    {title: &quot;创建人&quot;, field: &quot;createUser&quot;},\n                    {\n                        title: &quot;创建时间&quot;,\n                        field: &quot;createTime&quot;,\n                        templet: \'&lt;div&gt;{{# if(d.createTime!=null){ }} {{ layui.util.toDateString(d.createTime,\\\'yyyy-MM-dd HH:mm:ss\\\')  }} {{# } }}&lt;/div&gt;\'\n                    },\n                    {title: &quot;更新人员&quot;, field: &quot;updateUser&quot;},\n                    {\n                        title: &quot;更新时间&quot;,\n                        field: &quot;updateTime&quot;,\n                        templet: \'&lt;div&gt;{{# if(d.updateTime!=null){ }} {{ layui.util.toDateString(d.updateTime,\\\'yyyy-MM-dd HH:mm:ss\\\')  }} {{# } }}&lt;/div&gt;\'\n                    },\n                    {title: &quot;操作&quot;, templet: &quot;#updateAndDelete&quot;}\n                ]],\n                done: function () {\n                    layer.closeAll(\'loading\');\n                }\n\n            })\n        };\n\n        renderTable();\n        //展开所有\n        $(\'#btn-expand\').click(function () {\n            //alert(0)\n            treetable.expandAll(\'#Lay_category_treeTable\');\n        });\n        //折叠所有\n        $(\'#btn-fold\').click(function () {\n           // alert(1)\n            treetable.foldAll(\'#Lay_category_treeTable\');\n        });\n        //刷新表格\n        $(\'#btn-refresh\').click(function () {\n            renderTable();\n        });\n\n        $(\'#btn-search\').click(function () {\n            var keyword = $(\'#Lay_toSearch_input\').val();\n            //alert(keyword);\n           // var searchName = $(\'#Lay_toSearch_input\').val();\n            var searchCount = 0;\n            $(\'#Lay_category_treeTable\').next(\'.treeTable\').find(\'.layui-table-body tbody tr td\').each(function () {\n                $(this).css(\'background-color\', \'transparent\');\n                var text = $(this).text();\n                if (keyword != \'\' &amp;&amp; text.indexOf(keyword) &gt;= 0) {\n                    $(this).css(\'background-color\', \'rgba(250,230,160,0.5)\');\n                    if (searchCount == 0) {\n                        treetable.expandAll(\'#Lay_category_treeTable\');\n                        $(\'html,body\').stop(true);\n                        $(\'html,body\').animate({scrollTop: $(this).offset().top - 150}, 500);\n                    }\n                    searchCount++;\n                }\n            });\n            if (keyword == \'\') {\n                layer.msg(&quot;请输入搜索内容&quot;, {icon: 5});\n            } else if (searchCount == 0) {\n                layer.msg(&quot;没有匹配结果&quot;, {icon: 5});\n            }\n        });\n    });\n\n\n    //这是一棵树，\n    layui.use([\'table\', \'tree\', &quot;layer&quot;, \'jquery\', \'form\'], function () {\n        var table = layui.table;\n        var layer = layui.layer;\n        var form = layui.form;\n        var tree = layui.tree;\n        var $ = layui.jquery;\n\n        $.ajax({\n            url: &quot;${pageContext.request.contextPath}/goodscategory/selectTree&quot;,\n            success: function (data) {\n                //console.log(data);\n                //渲染\n                var inst1 = tree.render({\n                    elem: \'#Lay_category_tree\',  //绑定元素\n                    data: data.data,\n                    showCheckbox: true\n                    // accordion:true\n                });\n            }\n        });\n    });\n\n\n    //搜索操作\n    function doSearch() {\n        //1.获取到输入框中输入的内容\n        var searchName = $(\'#Lay_toSearch_input\').val();\n        //发送请求，并且接收数据\n        layui.use(\'table\', function () {\n            var table = layui.table;\n            table.reload(\'Lay_back_table\', {\n                where: {&quot;platform&quot;: searchName}\n            });\n        });\n    }\n\n    //执行编辑修改\n    function toOpenUpdateLayer(classId) {\n        //alert(classId);\n        //1.获取当前行数据===》发送ajax请求，获取当前行数据\n        $.ajax({\n            url: &quot;${pageContext.request.contextPath}/goodscategory/selectOne&quot;,\n            data: &quot;aid=&quot; + classId,\n            success: function (data) {\n                $(&quot;#className&quot;).val(data.className);\n                $(&quot;#classId&quot;).val(data.classId);\n                $(&quot;#classCode&quot;).val(data.classCode);\n                // $(&quot;#classIdStatus&quot;).val(data.classIdStatus);\n                $(&quot;#classIdStatus&quot;).selected(data.classIdStatus);\n\n            }\n        });\n\n        //2.把数据填充到修改弹出层中==&gt;弹出层显示\n        layui.use([\'layer\', \'form\', \'table\'], function () {\n            var form = layui.form;\n            var layer = layui.layer;\n            var table = layui.table;\n            var $ = layui.jquery;\n\n            $(&quot;#Lay_select_Level&quot;).hide();\n            layer.open({\n                title: &quot;修改配置&quot;,\n                content: $(&quot;#layuiconfig-form-role&quot;),\n                type: 1,\n                maxmin: true,\n                area: [\'500px\', \'480px\'],\n                end:function(){\n                    window.location.reload();\n                }\n            });\n\n            $(&quot;#LAY-sysconfig-submit&quot;).hide();\n            $(&quot;#updateSubmitBtn&quot;).show();\n\n            //3.提交表单\n            form.on(&quot;submit(updateSubmitBtn)&quot;, function (data) {\n                // console.log(data);\n                $.ajax({\n                    url: &quot;${pageContext.request.contextPath}/goodscategory/updateGoods&quot;,\n                    data: data.field,\n                    type: &quot;post&quot;,\n                    //4.接收后台修改响应回来的数据；关闭弹出层、提示修改信息、刷新table\n                    success: function (data) {\n                        //1.关闭掉添加弹出层\n                        layer.closeAll(\'page\');\n                        //2.提示修改成功\n                        layer.alert(&quot;修改&quot; + data.msg+&quot;，请点击右上角刷新表格后生效！&quot;, {time: 3000});\n                        //刷新table\n                      //  table.reload(&quot;Lay_category_treeTable&quot;);\n                    }\n                });\n                return false;//阻止跳转；\n            })\n        });\n\n    }\n\n    //执行添加\n    function toOpenAddLayer() {\n        layui.use([&quot;form&quot;, &quot;layer&quot;, &quot;table&quot;], function () {\n            var form = layui.form;\n            var layer = layui.layer;\n            var table = layui.table;\n\n            layer.open({\n                title: &quot;添加配置&quot;,\n                content: $(&quot;#layuiconfig-form-role&quot;),\n                type: 1,\n                maxmin: true,\n                area: [\'500px\', \'480px\'],\n                end: function () {\n                    window.location.reload();\n                }\n            });\n\n            $(&quot;#updateSubmitBtn&quot;).hide();\n            $(&quot;#LAY-sysconfig-submit&quot;).show();\n\n            form.on(\'select(classIdLevel)\', function (data) {\n                //console.log(data.elem); //得到select原始DOM对象\n                console.log(&quot;data.value = &quot;+data.value); //得到被选中的值\n                //console.log(data.othis); //得到美化后的DOM对象\n                if(data.value == 1){\n                    // alert(1);\n                    $(&quot;#Lay_One_Level&quot;).hide();\n                    $(&quot;#Lay_Two_Level&quot;).hide();\n                }\n                if (data.value == 2) {\n                    // alert(2);\n                    $(&quot;#Lay_One_Level&quot;).show();\n                    $(&quot;#Lay_Two_Level&quot;).hide();\n                    $.ajax({\n                        url: \'${basepath}goodscategory/selectOneLevel\',\n                        dataType: \'json\',\n                        type: \'post\',\n                        success: function (data) {\n                            $.each(data, function (index, item) {\n                                //console.log(&quot;000 &quot; + index);\n                                //console.log(&quot;111 &quot; + item);\n                                $(\'#parentId\').append(new Option(item.className, item.classId));//往下拉菜单里添加元素\n                            });\n                            form.render();//菜单渲染 把内容加载进去\n                        }\n                    })\n                }\n                if (data.value == 3) {\n                    // alert(3);\n                    $(&quot;#Lay_One_Level&quot;).hide();\n                   // form.on(\'select(parent_classIdLevel_One)\', function (data2){\n                        $(&quot;#Lay_Two_Level&quot;).show();\n                        $.ajax({\n                            url: \'${basepath}goodscategory/selectTwoLevel\',\n                            dataType: \'json\',\n                            type: \'post\',\n                            success: function (data) {\n                                $.each(data, function (index, item) {\n                                    //console.log(&quot;000 &quot; + index);\n                                    //console.log(&quot;111 &quot; + item);\n                                    $(\'#Two_parentId\').append(new Option(item.className, item.classId));//往下拉菜单里添加元素\n                                });\n                                form.render();//菜单渲染 把内容加载进去\n                            }\n                        })\n                   // })\n                }\n            });\n\n            //当点击提交按钮的时候，会进入到这个函数\n            form.on(&quot;submit(LAY-sysconfig-submit)&quot;, function (data) {\n                 console.log(data.field);\n                $.ajax({\n                    url: &quot;${pageContext.request.contextPath}/goodscategory/addGoodsCategory&quot;,\n                    data: data.field,\n                    type: &quot;post&quot;,\n                    success: function (data) {\n                        //1.关闭掉添加弹出层\n                        layer.closeAll(\'page\');\n                        //2.提示添加成功\n                        layer.alert(&quot;添加&quot; + data.msg, {time: 3000});\n                        //3.刷新table\n                        table.reload(&quot;Lay_back_table&quot;);\n\n                    }\n                });\n                return false;//阻止跳转；\n            })\n        })\n    }\n\n    function doDelete(classId) {\n       // alert(classId);\n        //确认；如果点击确认删除；否则不删除\n        layui.use([\'layer\', \'table\'], function () {\n            var table = layui.table;\n            var layer = layui.layer;\n\n            layer.confirm(\'确定要删除吗？\', {icon: 3, title: \'确认删除\'}, function (index) {\n                $.ajax({\n                    url: &quot;${pageContext.request.contextPath}/goodscategory/deletecl&quot;,\n                    data: &quot;aid=&quot; + classId,\n                    success: function (data) {\n                        layer.alert(&quot;删除&quot; + data.msg, {time: 2000});\n                        // table.reload(&quot;Lay_back_table&quot;);\n                        layer.close(index);\n                    }\n                })\n            });\n        });\n    }\n\n    function doMultiDelete() {\n        //获取到选中的内容的id===》table模块中找方法\n        layui.use([\'layer\', \'table\'], function () {\n            var table = layui.table;\n            var layer = layui.layer;\n            //获取到选中的数据\n            var checkStatus = table.checkStatus(\'Lay_back_table\'); //idTest 即为基础参数 id 对应的值\n            // console.log(checkStatus.data);//获取选中行的数据\n            var data = checkStatus.data;\n\n            if (data.length == 0) {\n                layer.alert(&quot;请选中要删除的数据&quot;);\n            } else {\n                layer.confirm(&quot;确定要删除选中的所有数据&quot;, function (index) {\n                    //把所有选中的数据的id封装到一个数组中\n                    var ids = new Array(data.length);\n                    for (var i = 0; i &lt; ids.length; i++) {\n                        ids[i] = data[i].id;\n                    }\n                    console.log(&quot;ids===&quot; + ids);\n                    //执行删除操作\n                    $.ajax({\n                        url: &quot;${pageContext.request.contextPath}/prefixThird/deleteMany&quot;,\n                        data: &quot;ids=&quot; + ids,\n                        success: function (data) {\n                            //删除确认框关闭掉\n                            layer.close(index);\n                            //删除提示\n                            layer.alert(&quot;删除&quot; + data.msg+&quot;，请点击右上角刷新表格后生效！&quot;, {time: 2000});\n                            //刷新table\n                            // table.reload(&quot;Lay_back_table&quot;);\n                            // renderTable();\n                        }\n                    })\n                });\n            }\n        });\n    }\n\n\n&lt;/script&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:38:19', '2022-05-21 18:19:34');
INSERT INTO `tb_article` VALUES (216, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8926', 'CSDN-markdown编辑器 使用大全（备份记录快捷键使用方法）', '<p>﻿@<a href=\"这里写自定义目录标题\">TOC</a></p>\n<h1 id=\"欢迎使用markdown编辑器\">欢迎使用Markdown编辑器</h1>\n<p>你好！ 这是你第一次使用 <strong>Markdown编辑器</strong> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</p>\n<h2 id=\"新的改变\">新的改变</h2>\n<p>我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：</p>\n<ol>\n<li><strong>全新的界面设计</strong> ，将会带来全新的写作体验；</li>\n<li>在创作中心设置你喜爱的代码高亮样式，Markdown <strong>将代码片显示选择的高亮样式</strong> 进行展示；</li>\n<li>增加了 <strong>图片拖拽</strong> 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；</li>\n<li>全新的 <strong>KaTeX数学公式</strong> 语法；</li>\n<li>增加了支持<strong>甘特图的mermaid语法[^1]</strong> 功能；</li>\n<li>增加了 <strong>多屏幕编辑</strong> Markdown文章功能；</li>\n<li>增加了 <strong>焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置</strong> 等功能，功能按钮位于编辑区域与预览区域中间；</li>\n<li>增加了 <strong>检查列表</strong> 功能。<br />\n[^1]: <a href=\"https://mermaidjs.github.io/\">mermaid语法说明</a></li>\n</ol>\n<h2 id=\"功能快捷键\">功能快捷键</h2>\n<p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br />\n重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br />\n加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br />\n斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br />\n标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br />\n无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br />\n有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br />\n检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br />\n插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br />\n插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br />\n插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd><br />\n查找：<kbd>Ctrl/Command</kbd> + <kbd>F</kbd><br />\n替换：<kbd>Ctrl/Command</kbd> + <kbd>G</kbd></p>\n<h2 id=\"合理的创建标题有助于目录的生成\">合理的创建标题，有助于目录的生成</h2>\n<p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br />\n输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br />\n以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p>\n<h2 id=\"如何改变文本的样式\">如何改变文本的样式</h2>\n<p><em>强调文本</em> <em>强调文本</em></p>\n<p><strong>加粗文本</strong> <strong>加粗文本</strong></p>\n<p>==标记文本==</p>\n<p><del>删除文本</del></p>\n<blockquote>\n<p>引用文本</p>\n</blockquote>\n<p>H~2~O is是液体。</p>\n<p>2<sup>10</sup> 运算结果是 1024.</p>\n<h2 id=\"插入链接与图片\">插入链接与图片</h2>\n<p>链接: <a href=\"https://mp.csdn.net\">link</a>.</p>\n<p>图片: <img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw\" alt=\"Alt\" /></p>\n<p>带尺寸的图片: ![Alt](<a href=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw\">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw</a> =30x30)</p>\n<p>居中的图片: <img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center\" alt=\"Alt\" /></p>\n<p>居中并且带尺寸的图片: ![Alt](<a href=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center\">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center</a> =30x30)</p>\n<p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p>\n<h2 id=\"如何插入一段漂亮的代码片\">如何插入一段漂亮的代码片</h2>\n<p>去<a href=\"https://mp.csdn.net/configure\">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.</p>\n<pre><code class=\"language-javascript\">// An highlighted block\nvar foo = \'bar\';\n</code></pre>\n<h2 id=\"生成一个适合你的列表\">生成一个适合你的列表</h2>\n<ul>\n<li>项目\n<ul>\n<li>项目\n<ul>\n<li>项目</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>项目1</li>\n<li>项目2</li>\n<li>项目3</li>\n</ol>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;计划任务</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;完成任务</li>\n</ul>\n<h2 id=\"创建一个表格\">创建一个表格</h2>\n<p>一个简单的表格是这么创建的：<br />\n项目     | Value<br />\n-------- | -----<br />\n电脑  | $1600<br />\n手机  | $12<br />\n导管  | $1</p>\n<h3 id=\"设定内容居中居左居右\">设定内容居中、居左、居右</h3>\n<p>使用<code>:---------:</code>居中<br />\n使用<code>:----------</code>居左<br />\n使用<code>----------:</code>居右<br />\n| 第一列       | 第二列         | 第三列        |<br />\n|:-----------:| -------------:|:-------------|<br />\n| 第一列文本居中 | 第二列文本居右  | 第三列文本居左 |</p>\n<h3 id=\"smartypants\">SmartyPants</h3>\n<p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：<br />\n|    TYPE   |ASCII                          |HTML<br />\n|----------------|-------------------------------|-----------------------------|<br />\n|Single backticks|<code>\'Isn\'t this fun?\'</code>            |\'Isn\'t this fun?\'            |<br />\n|Quotes          |<code>&quot;Isn\'t this fun?&quot;</code>            |&quot;Isn\'t this fun?&quot;            |<br />\n|Dashes          |<code>-- is en-dash, --- is em-dash</code>|-- is en-dash, --- is em-dash|</p>\n<h2 id=\"创建一个自定义列表\">创建一个自定义列表</h2>\n<p>Markdown<br />\n:  Text-to-HTML conversion tool</p>\n<p>Authors<br />\n:  John<br />\n:  Luke</p>\n<h2 id=\"如何创建一个注脚\">如何创建一个注脚</h2>\n<p>一个具有注脚的文本。<a href=\"注脚的解释\">^2</a></p>\n<h2 id=\"注释也是必不可少的\">注释也是必不可少的</h2>\n<p>Markdown将文本转换为 HTML。</p>\n<p>*[HTML]:   超文本标记语言</p>\n<h2 id=\"katex数学公式\">KaTeX数学公式</h2>\n<p>您可以使用渲染LaTeX数学表达式 <a href=\"https://khan.github.io/KaTeX/\">KaTeX</a>:</p>\n<p>Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\forall<br />\nn\\in\\mathbb N$ 是通过欧拉积分</p>\n<p>$$<br />\n\\Gamma(z) = \\int_0<sup z-1=\"\">\\infty t</sup>e^{-t}dt,.<br />\n$$</p>\n<blockquote>\n<p>你可以找到更多关于的信息 <strong>LaTeX</strong> 数学表达式<a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\">here</a>.</p>\n</blockquote>\n<h2 id=\"新的甘特图功能丰富你的文章\">新的甘特图功能，丰富你的文章</h2>\n<div class=\"mermaid\">\ngantt\n        dateFormat  YYYY-MM-DD\n        title Adding GANTT diagram functionality to mermaid\n        section 现有任务\n        已完成               :done,    des1, 2014-01-06,2014-01-08\n        进行中               :active,  des2, 2014-01-09, 3d\n        计划一               :         des3, after des2, 5d\n        计划二               :         des4, after des3, 5d\n</div>\n<ul>\n<li>关于 <strong>甘特图</strong> 语法，参考 <a href=\"https://mermaidjs.github.io/\">这儿</a>,</li>\n</ul>\n<h2 id=\"uml-图表\">UML 图表</h2>\n<p>可以使用UML图表进行渲染。 <a href=\"https://mermaidjs.github.io/\">Mermaid</a>. 例如下面产生的一个序列图：</p>\n<div class=\"mermaid\">\nsequenceDiagram\n张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?\n李四--&gt;&gt;王五: 你最近怎么样，王五？\n李四--x 张三: 我很好，谢谢!\n李四-x 王五: 我很好，谢谢!\nNote right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.\n\n李四--&gt;&gt;张三: 打量着王五...\n张三-&gt;&gt;王五: 很好... 王五, 你怎么样?\n</div>\n<p>这将产生一个流程图。:</p>\n<div class=\"mermaid\">\ngraph LR\nA[长方形] -- 链接 --&gt; B((圆))\nA --&gt; C(圆角长方形)\nB --&gt; D{菱形}\nC --&gt; D\n</div>\n<ul>\n<li>关于 <strong>Mermaid</strong> 语法，参考 <a href=\"https://mermaidjs.github.io/\">这儿</a>,</li>\n</ul>\n<h2 id=\"flowchart流程图\">FLowchart流程图</h2>\n<p>我们依旧会支持flowchart的流程图：</p>\n<div class=\"mermaid\">\nflowchat\nst=&gt;start: 开始\ne=&gt;end: 结束\nop=&gt;operation: 我的操作\ncond=&gt;condition: 确认？\n\nst-&gt;op-&gt;cond\ncond(yes)-&gt;e\ncond(no)-&gt;op\n</div>\n<ul>\n<li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href=\"http://adrai.github.io/flowchart.js/\">这儿</a>.</li>\n</ul>\n<h2 id=\"导出与导入\">导出与导入</h2>\n<h3 id=\"导出\">导出</h3>\n<p>如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <strong>文章导出</strong> ，生成一个.md文件或者.html文件进行本地保存。</p>\n<h3 id=\"导入\">导入</h3>\n<p>如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，<br />\n继续你的创作。</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:38:37', '2020-04-25 15:38:37');
INSERT INTO `tb_article` VALUES (217, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4383', 'git从入门配置到常用基本命令，傻瓜式操作一步步命令总结', '<p>﻿### 1，git的下载安装<br />\n下载地址：<a href=\"https://git-scm.com/download/win\">git官方下载地址https://git-scm.com/download/win</a></p>\n<p>安装，双击安装包，一直不停的下一步就安装好了。</p>\n<p>检验是否安装成功：在电脑的任何位置 右键 Git Bash Here （打开Git命令窗口）</p>\n<h3 id=\"2配置本地git\">2，配置本地git</h3>\n<p>name是你自己的名字<br />\n邮箱要是你在github或者码云上注册的邮箱</p>\n<pre><code class=\"language-git\">git config --global user.name &quot;Your Name&quot;  \ngit config --global user.email &quot;email@example.com&quot;\n</code></pre>\n<h3 id=\"3基本命令\">3，基本命令</h3>\n<p>1，在自己电脑上创建一个文件夹，就是版本库<br />\n创建一个本地版本库  写一个文档  交给git管理（添加到本地版本库）</p>\n<p>2，进入文件夹内部， 右键 Git Bash Here （打开Git命令窗口）输入</p>\n<pre><code>git init \n</code></pre>\n<p>命令。初始化本地版本库。如果你的电脑不显示这个文件夹，请打开显示隐藏的项目，</p>\n<p>3，随便创建一个txt文件，添加test.tx文件到本地版本库</p>\n<p>添加当前文件夹 所有的文件 到暂存区</p>\n<pre><code>git add .\n</code></pre>\n<p>添加指定的文件</p>\n<pre><code>git add test.txt\n</code></pre>\n<p>将暂存区文件提交到本地版本库</p>\n<pre><code class=\"language-git\">git commit -m &quot;v1.0 写版本描述信息 必须写&quot;\n</code></pre>\n<p>查看所有的版本信息</p>\n<pre><code>git log   #查看日志 所有的版本信息\ngit reflog   #查看日志 所有的版本信息\n</code></pre>\n<p>区别</p>\n<ol>\n<li>git log 只显示当前版本 和 之前的所有的版本</li>\n<li>git reflog 显示所有版本 和 所有的操作信息</li>\n</ol>\n<p>更新文件，添加第二个版本</p>\n<pre><code>git add . \ngit commit -m &quot;v2.0 写版本信息 必须写&quot; \n</code></pre>\n<p>回到第一个版本</p>\n<pre><code>   git reset --hard HEAD^   ^回退一个版本 ^^回退100个版本\n   git reset --hard HEAD~100 回退100个版本\n</code></pre>\n<p>再从版本1 回到 版本2</p>\n<pre><code>git reset --hard 版本的编号（不需要写全 5 6位数字就可以）\n</code></pre>\n<p>如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826204103589.png\" alt=\"在这里插入图片描述\" /></p>\n<h3 id=\"版本库的结构\">版本库的结构</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20190826204236680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>查看当前版本库和工作区的文件状态</strong></p>\n<p>git status</p>\n<ol>\n<li>文件 显示红色 文件中有修改  没有做添加 也没有提交<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826204404213.png\" alt=\"在这里插入图片描述\" /></li>\n<li>文件 显示绿色 文件添加了 位于暂存区 没有提交<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826204445349.png\" alt=\"在这里插入图片描述\" /></li>\n<li>没有文件需要提交<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826204509671.png\" alt=\"在这里插入图片描述\" /></li>\n</ol>\n<p><strong>版本撤销</strong></p>\n<p>git checkout  版本撤销</p>\n<ol>\n<li>文件没有添加到暂存区 红色状态  会删除所有新增的内容</li>\n<li>文件添加到暂存区之后 新增的内容是撤销不了的</li>\n</ol>\n<h2 id=\"本地git-集成码云\">本地git 集成码云</h2>\n<ol>\n<li>注册码云</li>\n<li>在本地电脑执行命令生成SSH公钥 输入命令一直回车<br />\n获取公钥命令，然后一直回车就好</li>\n</ol>\n<pre><code>       ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot; \n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190826205114559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\nid_rea是秘钥，不要轻易给别人<br />\nid_rea.pub 公钥，给谁无所谓</p>\n<p>3，在码云配置公钥<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826205234866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>仓库相关的操作</strong></p>\n<ol>\n<li>创建一个仓库<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826205324719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n将整个仓库 克隆（下载） 到本地<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826205347200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></li>\n</ol>\n<p>复制 SSH 连接<br />\n在本地执行克隆的命令</p>\n<pre><code>git clone 粘贴你负责的ssh连接\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190826205439777.png\" alt=\"在这里插入图片描述\" /><br />\n<strong>将之前测试的本地文件推送到远程仓库：</strong></p>\n<pre><code>git add .\ngit commit -m &quot;v2.0 test&quot;\ngit push\n</code></pre>\n<p>在远程写一个文件  更新到本地</p>\n<pre><code>git pull\n</code></pre>\n<h2 id=\"分支的使用\">分支的使用</h2>\n<h5 id=\"常用分支命令\">常用分支命令</h5>\n<pre><code>查看分支,查看当前拥有多少个分支\n	git branch  \n\n创建分支 \n	git branch 要创建的分支的名称  \n\n切换分支 \n	git checkout 要去往的分支名称\n</code></pre>\n<p><strong>删除分支</strong>,慎用，不要轻易删除分支<br />\ngit branch -d 分支名<br />\n<img src=\"https://img-blog.csdnimg.cn/20190826210311773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" />	<br />\n<strong>开发的时候用到的dev分支</strong></p>\n<pre><code>git checkout -b dev // 创建并切换到dev分支\n\ngit push --set-upstream origin dev // 将dev分支推送到远程仓库\n</code></pre>\n<p><strong>合并dev分支至master</strong></p>\n<pre><code>git checkout master // 切换到master分支\n\ngit merge dev // 合并dev分支到当前分支（master）\n</code></pre>\n<h5 id=\"在idea中使用git遇到的一个问题\">在idea中使用Git遇到的一个问题</h5>\n<p>报错：</p>\n<blockquote>\n<p>Push rejected: Push to origin/master was rejected</p>\n</blockquote>\n<p>意思是git拒绝合并两个不相干的东西<br />\n此时你需要在打开Git Bash，然后进入相应的目录，然后敲git命令</p>\n<pre><code>$ git pull origin master --allow-unrelated-histories\n</code></pre>\n<p>出现类似于这种信息就说明pull成功了：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190827191650505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n然后再执行push命令。就可以成功了！</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:39:22', '2022-05-21 18:19:23');
INSERT INTO `tb_article` VALUES (218, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8632', 'SpringBoot集成shiro认证，实现Shiro认证的登录操作', '<p>﻿### 什么是Shiro权限管理？</p>\n<blockquote>\n<p>Apache Shiro 是 Java 的一个安全框架。目前，使用 Apache Shiro 的人越来越多，因为它相 当简单，对比<br />\nSpring Security，可能没有 Spring Security 做的功能强大，但是在实际工作时<br />\n可能并不需要那么复杂的东西，所以使用小而简单的 Shiro 就足够了。对于它俩到底哪个 好，这个不必纠结，能更简单的解决项目问题就好了。</p>\n</blockquote>\n<p>权限管理分为认证和授权</p>\n<h1 id=\"认证\">认证</h1>\n<h4 id=\"认证的基本概念\">认证的基本概念</h4>\n<p>身份认证：校验用户是不是系统合法用户的过程（比如登录操作）</p>\n<blockquote>\n<p><strong>身份认证，就是判断一个用户是否为合法用户的处理过程</strong>。</p>\n<p><strong>最常用的简单身份认证方式是系统通过核对用户输入的用户名和密码，看其是否与系统中存储的该用户的用户名和密码是否一致，来判断用户身份是否正确。</strong></p>\n<p>对于采用指纹等系统，则出示指纹；对于硬件Key等刷卡系统，则需要刷卡。通过二维码等等都是认证的过程</p>\n</blockquote>\n<h4 id=\"认证基本的对象\">认证基本的对象</h4>\n<h5 id=\"subject-主体\">Subject 主体</h5>\n<p>官方给出的解释是这样的：</p>\n<blockquote>\n<p>Without question, the most important concept in Apache Shiro is the Subject. ‘Subject’ is just a security term that means a security-specific ‘view’ of an application user. A Shiro Subject instance represents both security state and operations for a single application user.<br />\n翻译过来就是：<br />\n毫无疑问，<strong>shiro中最重要的概念就是subject（主体）</strong>。subject是一个虚拟的用户对象（就是相当于我们之前的User Admin对象等）。</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20190825173535988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>使用Subject的之后的流程变化</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190825173552565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>其实，<br />\n<strong>Subject可以认为就是Admin  User这些类</strong><br />\n另外subject中还有两个重要概念：</p>\n<blockquote>\n<p><strong>Credential 凭证信息  就是密码的意思</strong></p>\n<p><strong>Principal 身份信息 就是账号的意思</strong></p>\n</blockquote>\n<p>扩展阅读：（看一下官方的解释为什么叫Subject而不叫User）</p>\n<blockquote>\n<p>We originally wanted to call it ‘User’ since that “just makes sense”, but we decided against it: too many applications have existing APIs that already have their own User classes/frameworks, and we didn’t want to conflict with those. Also, in the security world, the term ‘Subject’ is actually the recognized nomenclature.<br />\n翻译如下：<br />\n我们最初是想把它叫做User的，这样很容易理解，但是大部分的应用程序都已经有了User类，为了不和这些原有的api发生冲突，我们最后决定不这么做。</p>\n</blockquote>\n<h4 id=\"认证的登录操作案例springboot集成shiro\">认证的登录操作案例：SpringBoot集成shiro</h4>\n<p>下面开始使用Shiro实现带认证的登录操作</p>\n<h6 id=\"导入依赖\">导入依赖</h6>\n<pre><code class=\"language-xml\">&lt;!--shiro相关依赖--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;\n    &lt;version&gt;1.3.2&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;\n    &lt;version&gt;1.3.2&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;\n    &lt;version&gt;1.3.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h5 id=\"第一个demo\">第一个demo</h5>\n<p>基本思路</p>\n<blockquote>\n<p>用户输入的账号密码  和 数据库中存储的账号密码 比对</p>\n<p>注意：shiro 默认不支持连接数据库  默认通过配置文件获取数据<br />\n所以我们要重写Realm中的方法，实现对数据库的连接</p>\n</blockquote>\n<ol>\n<li>接收用户输入的账号密码,</li>\n<li>要重写Realm中的方法，实现对数据库的连接和数据获取</li>\n<li>写Springboot的配置类，创建并将重写的Realm设置放进去安全管理器， 将安全管理器 和Subject建立联系</li>\n<li>将用户输入的账号密码给Subject</li>\n<li>调用Subject的login方法完成登录</li>\n</ol>\n<p><strong>代码实现流程</strong></p>\n<h6 id=\"重写realm的代码\">重写Realm的代码</h6>\n<pre><code class=\"language-java\">package com.macw.realm;\n\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.macw.entity.Admin;\nimport com.macw.mapper.AdminMapper;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.*;\nimport org.apache.shiro.realm.AuthenticatingRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Resource;\n\n/**\n * @author maCw\n * @version 1.0\n * @date 2019/8/22 16:13\n */\n\npublic class MyRealm extends AuthenticatingRealm {\n\n    @Resource\n    private AdminMapper adminMapper;\n    /**\n     * 记录日志\n     */\n    Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        //1，获取令牌中的数据，账号\n        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;\n        String username = token.getUsername();\n        //2，通过账号查询获取数据库中对应的账号信息\n        Admin admin = adminMapper.selectOne(new QueryWrapper&lt;Admin&gt;().eq(&quot;username&quot;, username));\n        logger.info(&quot;---&quot;+admin);\n        Subject subject = SecurityUtils.getSubject();\n        //将查询的对象放进去subject自带的session中去\n        subject.getSession().setAttribute(&quot;admins&quot;, admin);\n        //如果有数据，对象为非null，说明查询到了数据，封装account返回\n        if (admin != null){\n            SimpleAccount simpleAccount = new SimpleAccount(admin.getUsername(), admin.getPassword(), this.getName());\n            return simpleAccount;\n        }else {\n            //如果对象为空，return null就会抛出账户不存在异常\n            return null;\n        }\n    }\n}\n\n</code></pre>\n<h5 id=\"在springboot中配置shiro\">在SpringBoot中配置shiro</h5>\n<pre><code class=\"language-java\">package com.macw.config;\n\nimport com.macw.realm.MyRealm;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.spring.web.ShiroFilterFactoryBean;\nimport org.apache.shiro.web.config.WebIniSecurityManagerFactory;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.Map;\n\n\n/**\n * @Configuration 标记当前类为配置类  相当于spring.xml\n */\n@Configuration\npublic class ShiroConfig {\n\n    /**\n     * @Bean 声明创建对象  并把对象放在工厂中  相当于bean标签\n     * 如果形参类型对应的对象在工厂中有  会自动装配上\n     * @return\n     */\n    @Bean\n    public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultSecurityManager defaultSecurityManager){\n        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\n        /**\n         * 过滤器链 过滤拦截规则 哪些页面拦截  哪些页面不拦截\n         */\n        Map map = new HashMap();\n        /**\n         * anon 代表匿名可访问 就是不用登录就可以访问  登录页面  登录的url\n         * authc 认证可访问 代表登录后才能访问\n         *\n         * 支持通配符*\n         * 注意拦截规则 一个一个配置\n         */\n        map.put(&quot;/login.jsp&quot;,&quot;anon&quot;);\n        map.put(&quot;/login/*&quot;,&quot;anon&quot;);\n\n        map.put(&quot;/main/*&quot;, &quot;authc&quot;);\n        map.put(&quot;/guru/*&quot;, &quot;authc&quot;);\n        map.put(&quot;/menu/*&quot;, &quot;authc&quot;);\n\n        shiroFilterFactoryBean.setFilterChainDefinitionMap(map);\n\n        /**\n         * 设置安全管理器，将创建的安全管理器放进shiroFilterFactoryBean过滤工厂里面\n         */\n        shiroFilterFactoryBean.setSecurityManager(defaultSecurityManager);\n        return shiroFilterFactoryBean;\n    }\n\n    /**\n     * 创建安全管理器,并将自定义的Realm放进去管理器\n     * @return\n     */\n    @Bean\n    public DefaultSecurityManager getDefaultSecurityManager(MyRealm myRealm){\n        DefaultSecurityManager defaultSecurityManager = new DefaultWebSecurityManager();\n//        需要赋值一个Realm\n        defaultSecurityManager.setRealm(myRealm);\n        return defaultSecurityManager;\n    }\n\n    /**\n     * 创建自定义的Realm\n     */\n    @Bean\n    public MyRealm getMyRealm(){\n        return new MyRealm();\n    }\n}\n</code></pre>\n<p>如果引用到其他项目的话这里需要修改的是 拦截规则  和  自定义的Realm</p>\n<h5 id=\"修改原来的登录方法\">修改原来的登录方法</h5>\n<p>在控制器里的登录方法中修改：</p>\n<pre><code class=\"language-java\">    /**\n     * 使用shiro登录\n     * @param username\n     * @param password\n     * @return\n     */\n    @RequestMapping(&quot;adminLogin&quot;)\n    public String adminLogin(String username,String password){\n//        1.将用户输入的账号密码 封装在token中\n        UsernamePasswordToken token = new UsernamePasswordToken(username, password);\n\n//        2.获取Subject\n        Subject subject = SecurityUtils.getSubject();\n\n//        3.通过Subject 的login方法 完成登录\n        try {\n            subject.login(token);\n            //到这里如果没有异常说明登录成功，\n            return &quot;redirect:/main/main.jsp&quot;;\n        }catch (Exception e){\n            //有异常说明登录失败，重定向到登录页面\n            return &quot;redirect:/login.jsp&quot;;\n        }\n    }\n</code></pre>\n<h5 id=\"shiro中session的使用\">shiro中Session的使用</h5>\n<p><strong>方案1：HttpSession</strong></p>\n<p><strong>方案2：shiro中的session</strong></p>\n<pre><code>Session session1 = SecurityUtils.getSubject().getSession();\n</code></pre>\n<p>注意：方案1  和 方案2 都可以 使用  但是只能使用一种方案  不要混合使用</p>\n<h4 id=\"登录认证总结\">登录认证总结</h4>\n<p><strong>认证：登录，身份认证，校验用户是不是系统合法用户的过程</strong></p>\n<p><strong>主体Subject：就是Admin，User这些类，但是和之前自己定义的User Admin稍以后区别，Subject不仅封装用户和认证相关的数据（账号密码），还封装了和认证相关的方法（login方法）</strong></p>\n<p><strong>Credential 凭证信息  就是密码的意思</strong></p>\n<p><strong>Principal 身份信息 就是账号的意思</strong></p>\n<p><strong>重写Realm中的方法</strong></p>\n<ol>\n<li>\n<p><strong>为什么要重写Realm中的方法</strong></p>\n<p><strong>默认不支持连接数据库  默认的实现是查询配置文件</strong></p>\n</li>\n<li>\n<p><strong>解决方案</strong></p>\n<p><strong>shiro默认的doGetAuthenticationInfo方法是查询配置文件，由于这个方法是父类的一个抽象方法，通过继承和多态，可以继承父类，覆盖这个方法（在方法中写入我们新的方法实现 连接数据库 查询数据库中的账号信息）</strong></p>\n</li>\n</ol>\n<p><strong>集成项目的基本流程</strong></p>\n<ol>\n<li>\n<p>写shiro的配置类（创建对象）</p>\n<p><strong>注意：拦截规则 和 自定义的Realm 需要根据自己项目的情况调整</strong></p>\n</li>\n<li>\n<p>修改原来的登录方法</p>\n</li>\n</ol>\n', 1, '', 0, 0, 1, '2020-04-25 15:39:42', '2022-05-21 18:18:00');
INSERT INTO `tb_article` VALUES (219, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=286', '详解Redis，Redis缓存，Redis分布式锁', '<p>﻿</p>\n<h3 id=\"1redis基本知识\">1、Redis基本知识</h3>\n<h4 id=\"简介\">简介</h4>\n<p>Redis是一个支持网络、基于内存、可选持久性的NoSql数据库，目前在很多的系统中都使用了Redis，尤其是在实现缓存功能的时候应用的尤其广泛（缓存功能也是很多人对Redis的认识），那么Redis到底有哪些优点和缺点，为什么会被广泛应用呢？</p>\n<h4 id=\"redis的优点\">Redis的优点</h4>\n<p>Redis的第一个优点就是<strong>速度快</strong>，Redis使用C语言实现，基于内存，数据的读写效率非常的高，这也是为什么很多系统的缓存功能使用Redis来实现，<em><strong>但是需要明确的是Redis是一个数据库，缓存只是它的一项应用而已。</strong></em></p>\n<p>Redis的第二个优点是<strong>单线程模型</strong>，所谓单线程模型就是每一个请求都会有一个全新的线程来进行处理，这一点类似于Struts2，每一个请求都会有一个新的线程来进行处理。这样做的好处就是避免了线程频繁切换带来的系统开销，同时也避免了让人头疼的多线程问题。</p>\n<p>Redis的第三个优点就是使用了<strong>非阻塞I/O</strong> （NIO），不在网络上浪费时间，进一步提高了效率。</p>\n<p>Redis的第四个优点就是支持多种的<strong>数据类型</strong>，并且每一种数据类型都提供了丰富的操作命令，适用于很多特殊的场景，并且支持自定义命令创建个性化的操作命令。</p>\n<h2 id=\"2redis持久化机制\">2、redis持久化机制</h2>\n<p>redis服务器宕机，内存数据是会丢失了，为了保证数据不丢失需要对数据做备份，所备份就是持久化，Redis的持久化即将内存中的数据同步到硬盘，主要包括两种方式RDB、AOF。</p>\n<p><strong>RDB持久化机制，(默认使用)</strong>：做当前内存数据的全本快照，<br />\n将内存中的数据以快照的方式写入到二进制文件dump.rdb,<br />\n在redis.conf中可以设置发起快照保存的条件。在指定的时间内如果有超过指定数量的key被修改，则会发起快照保存。</p>\n<p>这种方式在数据的实时性上不高，在突然断电的情况下，可能会出现部分数据的丢失，即最后一次快照之后在内存中发生修改的数据。</p>\n<p>简单来说：RDB就是将redis上的所有数据做个备份，存储的是二进制的数据。</p>\n<p><strong>AOF持久化机制，(默认是关闭)</strong>：</p>\n<p>AOF是将Redis内存数据库中更改的数据都记录到指定的文件appendonly.aof。在redis.conf中可以进行写磁盘的相关设置。</p>\n<p>在突然断电的情况下，由于在appendonly.aof中保存了最后一次写磁盘之后redis内存发生数据修改的指令，所以在这个Redis重启后，基本不会发生数据丢失，比RDB具有更好的数据安全性。</p>\n<p>appendfsync always   接收到更改数据的命令，立即将其记录到appendonly.aof中，能保证数据持久化，数据完全不丢失，但效率相对最低。</p>\n<p>appendfsync everysec   每秒钟将redis内存数据修改的命令记录到appendonly.aof中，在性能和持久化上做了折中。因频繁执行磁盘操作，在仅存在单个Master执行写操作时，效率可能存在问题。但在多个Master执行写操作的Redis集群中，效率会提升。</p>\n<p>appendfsync no  依赖于操作系统，因不会频繁执行磁盘操作而性能最好，但redis内存数据修改持久化没有保证，无法保证数据可靠性</p>\n<p><strong>如何开启AOF持久化：</strong><br />\n将redis.conf文件中 appendonly 改成 yes ，自动创建appendonly.aof，该文件存储的客户端执行过<strong>增删改操作的命令</strong></p>\n<br/>\n<h3 id=\"3-redis的数据结构\">3、 Redis的数据结构</h3>\n<p>redis数据库存储数据使用的key-value，键值对方式存储<br />\nkey是string类型 value的数据结构支持5个string、set、sorted_set、list、hash<br />\n<img src=\"https://img-blog.csdnimg.cn/20190820092223845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"4redis-的常用命令\">4、Redis 的常用命令</h4>\n<h5 id=\"string可以存数字\">String(可以存数字)</h5>\n<p>可以实现原子性的自增（数据安全）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820092339194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>这是最基本的类型了，没啥可说的，就是普通的set和get，做简单的k-v缓存</p>\n<h5 id=\"hash\">hash</h5>\n<p>这个是类似map的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在redis里，然后每次读写缓存的时候，可以就操作hash里的某个字段。</p>\n<pre><code>key=150\n\n\n\nvalue={\n\n “id”: 150,\n\n “name”: “zhangsan”,\n\n “age”: 20\n\n}\n\n</code></pre>\n<p>hash类的数据结构，主要是用来存放一些对象，把一些简单的对象给缓存起来，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值</p>\n<pre><code>value={\n\n “id”: 150,\n\n “name”: “zhangsan”,\n\n “age”: 21\n\n}\n\n</code></pre>\n<h5 id=\"list\">list</h5>\n<p>有序列表，这个是可以玩儿出很多花样的</p>\n<p>微博，某个大v的粉丝，就可以以list的格式放在redis里去缓存</p>\n<pre><code>key=某大v\n\nvalue=[zhangsan, lisi, wangwu]\n\nkey=书名\n\nvalue=[评论1, 评论2, 评论3]\n</code></pre>\n<p>比如可以通过list存储一些列表型的数据结构，类似粉丝列表了、文章的评论列表了之类的东西</p>\n<p>比如可以通过<strong>lrange命令</strong>，就是从某个元素开始读取多少个元素，可以基于list实现分页查询，这个很棒的一个功能，基于redis实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走</p>\n<p>比如可以搞个简单的消息队列，从list头怼进去，从list尾巴那里弄出来</p>\n<h5 id=\"set\">set</h5>\n<p>无序集合，自动去重</p>\n<p>直接基于set将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于jvm内存里的HashSet进行去重，但是如果你的某个系统部署在多台机器上呢？</p>\n<p>得基于redis进行全局的set去重</p>\n<p>可以基于set玩儿交集、并集、差集的操作，比如交集吧，可以把两个人的粉丝列表整一个交集，看看俩人的共同好友是谁？对吧</p>\n<p>把两个大v的粉丝都放在两个set中，对两个set做交集</p>\n<h5 id=\"sorted-set-跳表\">sorted set 跳表</h5>\n<p>排序的set，去重但是可以排序，写进去的时候给一个分数，自动根据分数排序，这个可以玩儿很多的花样，最大的特点是有个分数可以自定义排序规则</p>\n<p>比如说你要是想根据时间对数据排序，那么可以写入进去的时候用某个时间作为分数，人家自动给你按照时间排序</p>\n<p>排行榜：将每个用户以及其对应的什么分数写入进去，zadd board score username，接着zrevrange board 0 99，就可以获取排名前100的用户；zrank board username，可以看到用户在排行榜里的排名</p>\n<p><strong>总结：优先掌握 String 即可</strong><br />\n<br/></p>\n<h4 id=\"5数据失效时间\">5、数据失效时间</h4>\n<p>场景：</p>\n<p>手机验证码登录  手机验证码注册</p>\n<p>验证码后台生成  Redis</p>\n<ol>\n<li>集中存储</li>\n<li>可以设置过期时间</li>\n</ol>\n<pre><code>验证码  \n\nkey = 手机号 \nvalue = 验证码  \n\n设置3分钟过期\n</code></pre>\n<p>Redis中可以设置数据的存活时间</p>\n<p>命令</p>\n<pre><code>expire key 存活时间的秒\nttl key 查看key对应的数据的存活时间.\npexipre key 存活时间的毫秒\npttl key 查看key对应的数据的存活时间,毫秒单位\n</code></pre>\n<p><strong>expire key 存活时间的秒</strong></p>\n<p>失效的原理</p>\n<ol>\n<li>\n<p><strong>定期随机删除+惰性删除</strong></p>\n<pre><code>key  \n1    1分钟\n2    1分钟  \n3    1分钟\n4    1分钟\n5\n6\n\nredis 每过100ms 随机抽取一定数量的设置了失效时间的key 将过期的删除\n\n有些key过期了 每次都没有随机到  就一直删不掉  怎么办？\n\n惰性删除 get key 的时候 先判断 key是否过期 如果过期 返回数据为空\n\n</code></pre>\n<p>定期随机删除  例如100ms</p>\n<p>查询的时候 先检查key</p>\n</li>\n<li>\n<p><strong>内存淘汰机制</strong></p>\n<p>如果redis的内存占用过多的时候，此时会进行内存淘汰，有如下一些策略：</p>\n<p>redis 10个key，现在已经满了，redis需要删除掉5个key</p>\n<p>1个key，最近1分钟被查询了100次</p>\n<p>1个key，最近10分钟被查询了50次</p>\n<p>1个key，最近1个小时被查询了1次</p>\n<ol>\n<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了</li>\n<li><strong>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</strong></li>\n<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊</li>\n<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）</li>\n<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key</li>\n<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除</li>\n</ol>\n<p>LRU算法  扩展视野</p>\n</li>\n</ol>\n<br/>\n<h4 id=\"6redis的基本应用\">6、Redis的基本应用！！！</h4>\n<h5 id=\"二级缓存\">二级缓存</h5>\n<ol>\n<li>\n<p>为什么要做缓存</p>\n</li>\n<li>\n<p>缓存的选择（二级缓存）</p>\n</li>\n<li>\n<p>二级缓存的基本概念</p>\n<ol>\n<li>是什么</li>\n<li>如何开启</li>\n</ol>\n</li>\n<li>\n<p>二级缓存的缺点</p>\n</li>\n<li>\n<p>使用Redis集成二级缓存的步骤</p>\n<ol>\n<li>实现cache接口</li>\n</ol>\n</li>\n</ol>\n<p><strong>缓存的作用</strong></p>\n<ol>\n<li>数据从内存获取,提升数据获取速度.</li>\n<li>减轻了数据库读操作的访问压力(数据基本不变)</li>\n</ol>\n<p><strong>MyBatis二级缓存机制(开启)</strong></p>\n<p>机制：</p>\n<ol>\n<li>\n<p>Java本地缓存空间.(jar)</p>\n</li>\n<li>\n<p>mybaits事务提交后操作缓存</p>\n</li>\n<li>\n<p>Mybatis根据Mapper文件的namespace划分多个缓存空间.</p>\n</li>\n<li>\n<p>mybatis会将查询语句执行结果,缓存在 sql所在mapper文件对应的namespace对应的缓存空间中.</p>\n<p>会将执行的查询sql(对sql处理后产生的对象)作为key.</p>\n</li>\n<li>\n<p>MyBatis执行DML,在事务提交之后,默认清空当前sql所在的mapper文件对应的namespace对应的缓存空间中</p>\n<p>A Mapper   User表  脏读</p>\n<p>B Mapper   User表  删除  缓存清空</p>\n<p>缓存空间融合</p>\n<ol>\n<li><strong>所有关于User表的操作都写在一个Mapper中</strong></li>\n<li>Mapper配置 融合缓存空间（基本没有人使用）</li>\n<li>第三方的缓存空间\n<ol>\n<li>ehcache</li>\n<li><strong>Redis</strong></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093046989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>MyBatis缓存实现原理(源码)</strong></p>\n<p><code>org.apache.ibatis.cache.impl.PerpetualCache.class</code></p>\n<ol>\n<li>\n<p>根据namepace划分缓存空间(id)</p>\n</li>\n<li>\n<p>MyBatis二级缓存本质是一个Map结构</p>\n<p>key :和执行的sql先关</p>\n<p>value:查询结果相关</p>\n</li>\n<li>\n<p>存放数据的功能: select语句(key)----查询结果(value)</p>\n</li>\n<li>\n<p>获得数据的功能: 根据key</p>\n</li>\n<li>\n<p>清空缓存的功能: clear</p>\n</li>\n<li>\n<p>MyBatis管理每个缓存,使用Map管理 key:id(namespace)  value:PerpetualCache</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093242240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>MyBatis缓存的问题?(缓存数据量不能太多)</strong></p>\n<ol>\n<li>mybatis缓存在tomcat的jvm内部分配的缓存空间.</li>\n<li>缓存数据过多,挤占java运行期间需要的内存.</li>\n</ol>\n<p>解决办法:</p>\n<p>将Mybatis的二级缓存空间转移到Redis数据库中</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093258936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>Mybatis二级缓存空间划分</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093309465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>Redis缓存空间的划分设计</strong></p>\n<p>核心:</p>\n<ol>\n<li>每个缓存空间是一个map</li>\n<li>每个缓存空间对应一个namespace.(管理多个cache空间)</li>\n</ol>\n<p>方案:</p>\n<ol>\n<li>将mybatis的namespace作为redis的key</li>\n<li>将key对应的value作为hash数据结构使用.(替换PerpetualCache)</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093323489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>自定义Redis缓存实现</strong></p>\n<p><strong>自定义缓存实现类</strong></p>\n<ol>\n<li>\n<p>自定义MyBatis二级缓存</p>\n<ol>\n<li>自定缓存类实现Cache接口</li>\n<li>导入redis操作相关的工具(jar,JedisUtil,jedis.properties)</li>\n<li>必须具备如下功能:</li>\n</ol>\n</li>\n<li>\n<p>根据namepace划分缓存空间(id)</p>\n</li>\n<li>\n<p>MyBatis二级缓存本质是一个Map结构</p>\n<p>key :和执行的sql先关</p>\n<p>value:查询结果相关</p>\n</li>\n<li>\n<p>存放数据的功能: select语句(key)----查询结果(value)</p>\n</li>\n<li>\n<p>获得数据的功能: 根据key</p>\n</li>\n<li>\n<p>清空缓存的功能: clear</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093345829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>使用自定义的缓存</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093414993.png\" alt=\"在这里插入图片描述\" /></p>\n<h5 id=\"session共享\">Session共享</h5>\n<p><strong>为何要实现session共享？</strong></p>\n<p>nginx负载均衡,希望兼顾权重的按照硬件性能分配访问压力的优势,又想保证多个tomcat使用同一个session应该怎么解决？<br />\n<img src=\"https://img-blog.csdnimg.cn/20190820093754832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>ip_hash</li>\n<li>session复制</li>\n<li>Redis</li>\n</ol>\n<p><strong>解决方案</strong></p>\n<p>使用redis管理负载均衡中多个tomcat的session.(Redis共享session)</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093811946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>如何实现Redis管理Session</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820093611617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>配置步骤</strong></p>\n<ol>\n<li>tomcat使用redis管理session的jar</li>\n</ol>\n<p>将jar拷贝tomcat中lib</p>\n<ol start=\"2\">\n<li>配置tomcat的session管理方式为RedisSessionManager</li>\n</ol>\n<pre><code class=\"language-xml\">1. tomcat 配置文件context.xml\n\n&lt;!--注册session管理工具--&gt;\n&lt;Manager className=&quot;session管理工具全类名&quot;\n         host=&quot;redis的ip地址&quot;\n         port=&quot;端口&quot;\n         maxInactiveInterval=&quot;session存活时间 秒 1800&quot; 秒\n         /&gt;\n\n&lt;!--将session管理工具使用在tomcat操作过程中--&gt;\n&lt;Valve className=&quot;RedisSessionHandlerValve在tomcat中使用session管理工具&quot;/&gt;\n</code></pre>\n<p><strong>重启两个tomcat</strong></p>\n<h4 id=\"缓存问题\">缓存问题</h4>\n<ol>\n<li>\n<p>缓存穿透</p>\n</li>\n<li>\n<p>缓存雪崩</p>\n<pre><code>User\n\n根据主键查询 \n\nkey\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n1W  -id  缓存中都没有 \n\n2000个查询  每秒 可以认为是安全的\n</code></pre>\n</li>\n</ol>\n<h5 id=\"缓存穿透\">缓存穿透</h5>\n<p>缓存击穿  大量不存在的key攻击</p>\n<p>只需要极少的空间就可以判断一个元素是不是在一个集合之内，这正好是我们所需要的场景啊：判断key是否存在<br />\n<img src=\"https://img-blog.csdnimg.cn/2019082009405750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n解决方案</p>\n<ol>\n<li>\n<p>空值缓存 （非恶意攻击）</p>\n<pre><code>key  value\n-1   null\n</code></pre>\n</li>\n<li>\n<p>布隆过滤器</p>\n<p>可以判断key是否在数据库中存在</p>\n<p>缺点：可能会判断出错 概率不高 但是会</p>\n</li>\n</ol>\n<h5 id=\"缓存雪崩\">缓存雪崩</h5>\n<p>微博</p>\n<pre><code>key = 鹿晗微博1  value = 相关信息 评论  追评 点赞 等\nkey = 鹿晗微博2  value = 相关信息 评论  追评 点赞 等\nkey = 鹿晗微博3  value = 相关信息 评论  追评 点赞 等\nkey = 鹿晗微博4  value = 相关信息 评论  追评 点赞 等\nkey = 鹿晗微博5  value = 相关信息 评论  追评 点赞 等\nkey = 吃瓜群众1 \nkey = 吃瓜群众2 \nkey = 吃瓜群众3 \nkey = 吃瓜群众4 \nkey = 吃瓜群众5\n\n上千万key 这些key一定会设置失效 失效时间设置的不合理  同一时间大量key过期了（500W）  如果发生在平时 无所谓\n不巧的是  上热搜了 突然间 大量的用户来访问 相关的信息\n</code></pre>\n<p>大量key同一时间失效 将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820094117131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>大量流量  且数据失效  导致不存在的数据每次请求都要到存储层去查询  一模一样的SQL   数据库崩溃</p>\n<ol>\n<li>合理的设置过期时间  单体架构</li>\n<li>分布式锁</li>\n<li>多级缓存</li>\n</ol>\n<p>分布式的锁，谁获得了这把锁，谁就可以访问数据库</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820094139437.png\" alt=\"在这里插入图片描述\" /></p>\n<p>大型项目中</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820094222330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>如果说用户查不到数据  降级服务</p>\n<ol>\n<li>先等着  两三秒</li>\n<li>能直接  返回固定数据</li>\n<li>等等</li>\n</ol>\n<h3 id=\"7redis-分布式锁\">7、Redis 分布式锁</h3>\n<h4 id=\"什么是分布式锁\">什么是分布式锁</h4>\n<p>一种逻辑处理</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190820094239766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"redis-分布式锁\">Redis 分布式锁</h4>\n<p>分布式锁本质上要实现的目标就是在 Redis 里面占一个“茅坑”，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。</p>\n<p>占坑一般是使用 <strong>setnx(set if not exists) 指令</strong>，只允许被一个客户端占坑。先来先占， 用完了，再调用 del 指令释放茅坑。</p>\n<pre><code>// 这里的冒号:就是一个普通的字符，没特别含义，它可以是任意其它字符，不要误解\n&gt; setnx lock:codehole true\nOK\n... do something critical ...\n&gt; del lock:codehole\n(integer) 1\n</code></pre>\n<p>但是有个问题，如果逻辑执行到中间出现异常了，可能会导致 del 指令没有被调用，这样就会陷入死锁，锁永远得不到释放。</p>\n<p>于是我们在拿到锁之后，再给<strong>锁加上一个过期时间</strong>，比如 5s，这样即使中间出现异常也可以保证 5 秒之后锁会自动释放。</p>\n<pre><code>&gt; setnx lock:codehole true\nOK\n&gt; expire lock:codehole 5\n... do something critical ...\n&gt; del lock:codehole\n(integer) 1\n</code></pre>\n<p>但是以上逻辑还有问题。如果在 setnx 和 expire 之间服务器进程突然挂掉了，可能是因为机器掉电或者是被人为杀掉的，就会导致 expire 得不到执行，也会造成死锁。</p>\n<p>这种问题的根源就在于 setnx 和 expire 是两条指令而不是原子指令。如果这两条指令可以一起执行就不会出现问题。也许你会想到用 Redis 事务来解决。但是这里不行，因为 expire 是依赖于 setnx 的执行结果的，如果 setnx 没抢到锁，expire 是不应该执行的。事务里没有 if-else 分支逻辑，事务的特点是一口气执行，要么全部执行要么一个都不执行。</p>\n<p>为了解决这个疑难，Redis 开源社区涌现了一堆分布式锁的 library，专门用来解决这个问题。实现方法极为复杂，小白用户一般要费很大的精力才可以搞懂。如果你需要使用分布式锁，意味着你不能仅仅使用 Jedis 或者 redis-py 就行了，还得引入分布式锁的 library。</p>\n<p><strong>为了治理这个乱象，Redis 2.8 版本中作者加入了 set 指令的扩展参数，使得 setnx 和 expire 指令可以一起执行，彻底解决了分布式锁的乱象。从此以后所有的第三方分布式锁 library 可以休息了。</strong></p>\n<pre><code>&gt; set lock:codehole true ex 5 nx\nOK\n... do something critical ...\n&gt; del lock:codehole\n</code></pre>\n<p>上面这个指令就是 setnx 和 expire 组合在一起的原子指令，它就是分布式锁的奥义所在。</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:40:11', '2022-05-21 18:17:42');
INSERT INTO `tb_article` VALUES (220, 1, 4, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8860', 'Java随机生成【用户对象】：中文姓名、全国随机省市居住地、随机邮箱、手机号、注册时间工具类', '<p>﻿### 话不多说，先上工具类，下面再解释：<br />\nJava随机生成【用户对象】：<br />\n中文姓名、全国随机省市居住地、随机邮箱、手机号、注册时间<br />\nGenerateUserUtil.java工具类</p>\n<pre><code class=\"language-java\">package com.macw.util;\n\nimport com.macw.entity.User;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Random;\n\n/**\n * @author 超伟\n */\npublic class GenerateUserUtil {\n\n    private static final String place[][] = {\n            {&quot;北京&quot;, &quot;市辖区&quot;, &quot;市辖县&quot;},\n            {&quot;天津&quot;, &quot;市辖区&quot;, &quot;市辖县&quot;},\n            {&quot;安徽&quot;, &quot;安庆市&quot;, &quot;蚌埠市&quot;, &quot;亳州市&quot;, &quot;巢湖市&quot;, &quot;池州市&quot;, &quot;滁州市&quot;, &quot;阜阳市&quot;, &quot;合肥市&quot;, &quot;淮北市&quot;, &quot;淮南市&quot;, &quot;黄山市&quot;, &quot;六安市&quot;, &quot;马鞍山市&quot;, &quot;宿州市&quot;, &quot;铜陵市&quot;, &quot;芜湖市&quot;, &quot;宣城市&quot;},\n            {&quot;澳门&quot;, &quot;澳门&quot;},\n            {&quot;香港&quot;, &quot;香港&quot;},\n            {&quot;福建&quot;, &quot;福州市&quot;, &quot;龙岩市&quot;, &quot;南平市&quot;, &quot;宁德市&quot;, &quot;莆田市&quot;, &quot;泉州市&quot;, &quot;厦门市&quot;, &quot;漳州市&quot;},\n            {&quot;甘肃&quot;, &quot;白银市&quot;, &quot;定西市&quot;, &quot;甘南藏族自治州&quot;, &quot;嘉峪关市&quot;, &quot;金昌市&quot;, &quot;酒泉市&quot;, &quot;兰州市&quot;, &quot;临夏回族自治州&quot;, &quot;陇南市&quot;, &quot;平凉市&quot;, &quot;庆阳市&quot;, &quot;天水市&quot;, &quot;武威市&quot;, &quot;张掖市&quot;},\n            {&quot;广东&quot;, &quot;潮州市&quot;, &quot;东莞市&quot;, &quot;佛山市&quot;, &quot;广州市&quot;, &quot;河源市&quot;, &quot;惠州市&quot;, &quot;江门市&quot;, &quot;揭阳市&quot;, &quot;茂名市&quot;, &quot;梅州市&quot;, &quot;清远市&quot;, &quot;汕头市&quot;, &quot;汕尾市&quot;, &quot;韶关市&quot;, &quot;深圳市&quot;, &quot;阳江市&quot;, &quot;云浮市&quot;, &quot;湛江市&quot;, &quot;肇庆市&quot;, &quot;中山市&quot;, &quot;珠海市&quot;},\n            {&quot;广西&quot;, &quot;百色市&quot;, &quot;北海市&quot;, &quot;崇左市&quot;, &quot;防城港市&quot;, &quot;贵港市&quot;, &quot;桂林市&quot;, &quot;河池市&quot;, &quot;贺州市&quot;, &quot;来宾市&quot;, &quot;柳州市&quot;, &quot;南宁市&quot;, &quot;钦州市&quot;, &quot;梧州市&quot;, &quot;玉林市&quot;},\n            {&quot;贵州&quot;, &quot;安顺市&quot;, &quot;毕节地区&quot;, &quot;贵阳市&quot;, &quot;六盘水市&quot;, &quot;黔东南苗族侗族自治州&quot;, &quot;黔南布依族苗族自治州&quot;, &quot;黔西南布依族苗族自治州&quot;, &quot;铜仁地区&quot;, &quot;遵义市&quot;},\n            {&quot;海南&quot;, &quot;海口市&quot;, &quot;三亚市&quot;, &quot;省直辖县级行政区划&quot;},\n            {&quot;河北&quot;, &quot;保定市&quot;, &quot;沧州市&quot;, &quot;承德市&quot;, &quot;邯郸市&quot;, &quot;衡水市&quot;, &quot;廊坊市&quot;, &quot;秦皇岛市&quot;, &quot;石家庄市&quot;, &quot;唐山市&quot;, &quot;邢台市&quot;, &quot;张家口市&quot;},\n            {&quot;河南&quot;, &quot;安阳市&quot;, &quot;鹤壁市&quot;, &quot;焦作市&quot;, &quot;开封市&quot;, &quot;洛阳市&quot;, &quot;漯河市&quot;, &quot;南阳市&quot;, &quot;平顶山市&quot;, &quot;濮阳市&quot;, &quot;三门峡市&quot;, &quot;商丘市&quot;, &quot;新乡市&quot;, &quot;信阳市&quot;, &quot;许昌市&quot;, &quot;郑州市&quot;, &quot;周口市&quot;, &quot;驻马店市&quot;},\n            {&quot;黑龙江&quot;, &quot;大庆市&quot;, &quot;大兴安岭地区&quot;, &quot;哈尔滨市&quot;, &quot;鹤岗市&quot;, &quot;黑河市&quot;, &quot;鸡西市&quot;, &quot;佳木斯市&quot;, &quot;牡丹江市&quot;, &quot;七台河市&quot;, &quot;齐齐哈尔市&quot;, &quot;双鸭山市&quot;, &quot;绥化市&quot;, &quot;伊春市&quot;},\n            {&quot;湖北&quot;, &quot;鄂州市&quot;, &quot;恩施土家族苗族自治州&quot;, &quot;黄冈市&quot;, &quot;黄石市&quot;, &quot;荆门市&quot;, &quot;荆州市&quot;, &quot;十堰市&quot;, &quot;随州市&quot;, &quot;武汉市&quot;, &quot;咸宁市&quot;, &quot;襄樊市&quot;, &quot;孝感市&quot;, &quot;宜昌市&quot;},\n            {&quot;湖南&quot;, &quot;长沙市&quot;, &quot;常德市&quot;, &quot;郴州市&quot;, &quot;衡阳市&quot;, &quot;怀化市&quot;, &quot;娄底市&quot;, &quot;邵阳市&quot;, &quot;湘潭市&quot;, &quot;湘西土家族苗族自治州&quot;, &quot;益阳市&quot;, &quot;永州市&quot;, &quot;岳阳市&quot;, &quot;张家界市&quot;, &quot;株洲市&quot;},\n            {&quot;吉林&quot;, &quot;白城市&quot;, &quot;白山市&quot;, &quot;长春市&quot;, &quot;吉林市&quot;, &quot;辽源市&quot;, &quot;四平市&quot;, &quot;松原市&quot;, &quot;通化市&quot;, &quot;延边朝鲜族自治州&quot;},\n            {&quot;江苏&quot;, &quot;常州市&quot;, &quot;淮安市&quot;, &quot;连云港市&quot;, &quot;南京市&quot;, &quot;南通市&quot;, &quot;苏州市&quot;, &quot;宿迁市&quot;, &quot;泰州市&quot;, &quot;无锡市&quot;, &quot;徐州市&quot;, &quot;盐城市&quot;, &quot;扬州市&quot;, &quot;镇江市&quot;},\n            {&quot;江西&quot;, &quot;抚州市&quot;, &quot;赣州市&quot;, &quot;吉安市&quot;, &quot;景德镇市&quot;, &quot;九江市&quot;, &quot;南昌市&quot;, &quot;萍乡市&quot;, &quot;上饶市&quot;, &quot;新余市&quot;, &quot;宜春市&quot;, &quot;鹰潭市&quot;},\n            {&quot;辽宁&quot;, &quot;鞍山市&quot;, &quot;本溪市&quot;, &quot;朝阳市&quot;, &quot;大连市&quot;, &quot;丹东市&quot;, &quot;抚顺市&quot;, &quot;阜新市&quot;, &quot;葫芦岛市&quot;, &quot;锦州市&quot;, &quot;辽阳市&quot;, &quot;盘锦市&quot;, &quot;沈阳市&quot;, &quot;铁岭市&quot;, &quot;营口市&quot;},\n            {&quot;内蒙古&quot;, &quot;阿拉善盟&quot;, &quot;巴彦淖尔市&quot;, &quot;包头市&quot;, &quot;赤峰市&quot;, &quot;鄂尔多斯市&quot;, &quot;呼和浩特市&quot;, &quot;呼伦贝尔市&quot;, &quot;通辽市&quot;, &quot;乌海市&quot;, &quot;乌兰察布市&quot;, &quot;锡林郭勒盟&quot;, &quot;兴安盟&quot;},\n            {&quot;宁夏&quot;, &quot;固原市&quot;, &quot;石嘴山市&quot;, &quot;吴忠市&quot;, &quot;银川市&quot;, &quot;中卫市&quot;},\n            {&quot;青海&quot;, &quot;果洛藏族自治州&quot;, &quot;海北藏族自治州&quot;, &quot;海东地区&quot;, &quot;海南藏族自治州&quot;, &quot;海西蒙古族藏族自治州&quot;, &quot;黄南藏族自治州&quot;, &quot;西宁市&quot;, &quot;玉树藏族自治州&quot;},\n            {&quot;山东&quot;, &quot;滨州市&quot;, &quot;德州市&quot;, &quot;东营市&quot;, &quot;菏泽市&quot;, &quot;济南市&quot;, &quot;济宁市&quot;, &quot;莱芜市&quot;, &quot;聊城市&quot;, &quot;临沂市&quot;, &quot;青岛市&quot;, &quot;日照市&quot;, &quot;泰安市&quot;, &quot;威海市&quot;, &quot;潍坊市&quot;, &quot;烟台市&quot;, &quot;枣庄市&quot;, &quot;淄博市&quot;},\n            {&quot;山西&quot;, &quot;长治市&quot;, &quot;大同市&quot;, &quot;晋城市&quot;, &quot;晋中市&quot;, &quot;临汾市&quot;, &quot;吕梁市&quot;, &quot;朔州市&quot;, &quot;太原市&quot;, &quot;忻州市&quot;, &quot;阳泉市&quot;, &quot;运城市&quot;},\n            {&quot;陕西&quot;, &quot;安康市&quot;, &quot;宝鸡市&quot;, &quot;汉中市&quot;, &quot;商洛市&quot;, &quot;铜川市&quot;, &quot;渭南市&quot;, &quot;西安市&quot;, &quot;咸阳市&quot;, &quot;延安市&quot;, &quot;榆林市&quot;},\n            {&quot;四川&quot;, &quot;阿坝藏族羌族自治州&quot;, &quot;巴中市&quot;, &quot;成都市&quot;, &quot;达州市&quot;, &quot;德阳市&quot;, &quot;甘孜藏族自治州&quot;, &quot;广安市&quot;, &quot;广元市&quot;, &quot;乐山市&quot;, &quot;凉山彝族自治州&quot;, &quot;泸州市&quot;, &quot;眉山市&quot;, &quot;绵阳市&quot;, &quot;内江市&quot;, &quot;南充市&quot;, &quot;攀枝花市&quot;, &quot;遂宁市&quot;, &quot;雅安市&quot;, &quot;宜宾市&quot;, &quot;资阳市&quot;, &quot;自贡市&quot;},\n            {&quot;西藏&quot;, &quot;阿里地区&quot;, &quot;昌都地区&quot;, &quot;拉萨市&quot;, &quot;林芝地区&quot;, &quot;那曲地区&quot;, &quot;日喀则地区&quot;, &quot;山南地区&quot;},\n            {&quot;新疆&quot;, &quot;阿克苏地区&quot;, &quot;阿勒泰地区&quot;, &quot;巴音郭楞蒙古自治州&quot;, &quot;博尔塔拉蒙古自治州&quot;, &quot;昌吉回族自治州&quot;, &quot;哈密地区&quot;, &quot;和田地区&quot;, &quot;喀什地区&quot;, &quot;克拉玛依市&quot;, &quot;克孜勒苏柯尔克孜自治州&quot;, &quot;塔城地区&quot;, &quot;吐鲁番地区&quot;, &quot;乌鲁木齐市&quot;, &quot;伊犁哈萨克自治州&quot;, &quot;自治区直辖县级行政区划&quot;},\n            {&quot;云南&quot;, &quot;保山市&quot;, &quot;楚雄彝族自治州&quot;, &quot;大理白族自治州&quot;, &quot;德宏傣族景颇族自治州&quot;, &quot;迪庆藏族自治州&quot;, &quot;红河哈尼族彝族自治州&quot;, &quot;昆明市&quot;, &quot;丽江市&quot;, &quot;临沧市&quot;, &quot;怒江僳僳族自治州&quot;, &quot;普洱市&quot;, &quot;曲靖市&quot;, &quot;文山壮族苗族自治州&quot;, &quot;西双版纳傣族自治州&quot;, &quot;玉溪市&quot;, &quot;昭通市&quot;},\n            {&quot;浙江&quot;, &quot;杭州市&quot;, &quot;湖州市&quot;, &quot;嘉兴市&quot;, &quot;金华市&quot;, &quot;丽水市&quot;, &quot;宁波市&quot;, &quot;衢州市&quot;, &quot;绍兴市&quot;, &quot;台州市&quot;, &quot;温州市&quot;, &quot;舟山市&quot;},\n            {&quot;重庆&quot;, &quot;市辖区&quot;, &quot;市辖县&quot;, &quot;县级市&quot;},\n            {&quot;台湾&quot;, &quot;台北市&quot;, &quot;高雄市&quot;, &quot;基隆市&quot;, &quot;台中市&quot;, &quot;台南市&quot;, &quot;新竹市&quot;, &quot;嘉义市&quot;},\n    };\n\n    private static String base = &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;;\n    private static String firstName = &quot;赵钱孙李周吴郑王冯陈褚卫蒋沈韩杨朱秦尤许何吕施张孔曹严华金魏陶姜戚谢邹喻柏水窦章云苏潘葛奚范彭郎鲁韦昌马苗凤花方俞任袁柳酆鲍史唐费廉岑薛雷贺倪汤滕殷罗毕郝邬安常乐于时傅皮卞齐康伍余元卜顾孟平黄和穆萧尹姚邵湛汪祁毛禹狄米贝明臧计伏成戴谈宋茅庞熊纪舒屈项祝董梁杜阮蓝闵席季麻强贾路娄危江童颜郭梅盛林刁钟徐邱骆高夏蔡田樊胡凌霍虞万支柯咎管卢莫经房裘缪干解应宗宣丁贲邓郁单杭洪包诸左石崔吉钮龚程嵇邢滑裴陆荣翁荀羊於惠甄魏加封芮羿储靳汲邴糜松井段富巫乌焦巴弓牧隗山谷车侯宓蓬全郗班仰秋仲伊宫宁仇栾暴甘钭厉戎祖武符刘姜詹束龙叶幸司韶郜黎蓟薄印宿白怀蒲台从鄂索咸籍赖卓蔺屠蒙池乔阴郁胥能苍双闻莘党翟谭贡劳逄姬申扶堵冉宰郦雍却璩桑桂濮牛寿通边扈燕冀郏浦尚农温别庄晏柴瞿阎充慕连茹习宦艾鱼容向古易慎戈廖庚终暨居衡步都耿满弘匡国文寇广禄阙东殴殳沃利蔚越夔隆师巩厍聂晁勾敖融冷訾辛阚那简饶空曾毋沙乜养鞠须丰巢关蒯相查后江红游竺权逯盖益桓公万俟司马上官欧阳夏侯诸葛闻人东方赫连皇甫尉迟公羊澹台公冶宗政濮阳淳于仲孙太叔申屠公孙乐正轩辕令狐钟离闾丘长孙慕容鲜于宇文司徒司空亓官司寇仉督子车颛孙端木巫马公西漆雕乐正壤驷公良拓拔夹谷宰父谷粱晋楚阎法汝鄢涂钦段干百里东郭南门呼延归海羊舌微生岳帅缑亢况后有琴梁丘左丘东门西门商牟佘佴伯赏南宫墨哈谯笪年爱阳佟第五言福百家姓续&quot;;\n    private static String girl = &quot;秀娟英华慧巧美娜静淑惠珠翠雅芝玉萍红娥玲芬芳燕彩春菊兰凤洁梅琳素云莲真环雪荣爱妹霞香月莺媛艳瑞凡佳嘉琼勤珍贞莉桂娣叶璧璐娅琦晶妍茜秋珊莎锦黛青倩婷姣婉娴瑾颖露瑶怡婵雁蓓纨仪荷丹蓉眉君琴蕊薇菁梦岚苑婕馨瑗琰韵融园艺咏卿聪澜纯毓悦昭冰爽琬茗羽希宁欣飘育滢馥筠柔竹霭凝晓欢霄枫芸菲寒伊亚宜可姬舒影荔枝思丽 &quot;;\n    private static String boy = &quot;伟刚勇毅俊峰强军平保东文辉力明永健世广志义兴良海山仁波宁贵福生龙元全国胜学祥才发武新利清飞彬富顺信子杰涛昌成康星光天达安岩中茂进林有坚和彪博诚先敬震振壮会思群豪心邦承乐绍功松善厚庆磊民友裕河哲江超浩亮政谦亨奇固之轮翰朗伯宏言若鸣朋斌梁栋维启克伦翔旭鹏泽晨辰士以建家致树炎德行时泰盛雄琛钧冠策腾楠榕风航弘&quot;;\n    private static final String[] email_suffix = &quot;@gmail.com,@yahoo.com,@msn.com,@hotmail.com,@aol.com,@ask.com,@live.com,@qq.com,@0355.net,@163.com,@163.net,@263.net,@3721.net,@yeah.net,@googlemail.com,@126.com,@sina.com,@sohu.com,@yahoo.com.cn&quot;.split(&quot;,&quot;);\n    private static String[] sexs = {&quot;男&quot;, &quot;女&quot;};\n\n    private static int getNum(int start, int end) {\n        return (int) (Math.random() * (end - start + 1) + start);\n    }\n//    获得随机数的方法\n\n    private static int getRandom(int length) {\n        Random random = new Random();\n        return random.nextInt(length);\n    }\n\n\n    /**\n     * 返回Email\n     *\n     * @param lMin 最小长度\n     * @param lMax 最大长度\n     * @return\n     */\n    private static String getEmail(int lMin, int lMax) {\n        int length = getNum(lMin, lMax);\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i &lt; length; i++) {\n            int number = (int) (Math.random() * base.length());\n            sb.append(base.charAt(number));\n        }\n        sb.append(email_suffix[(int) (Math.random() * email_suffix.length)]);\n        return sb.toString();\n    }\n\n    /**\n     * 返回手机号码\n     */\n    private static String[] telFirst = &quot;134,135,136,137,138,139,150,151,152,157,158,159,130,131,132,155,156,133,153&quot;.split(&quot;,&quot;);\n\n    private static String getTel() {\n        int index = getNum(0, telFirst.length - 1);\n        String first = telFirst[index];\n        String second = String.valueOf(getNum(1, 888) + 10000).substring(1);\n        String third = String.valueOf(getNum(1, 9100) + 10000).substring(1);\n        return first + second + third;\n    }\n\n    /**\n     * 返回中文姓名\n     */\n    private static String name_sex = &quot;&quot;;\n\n    private static String getChineseName() {\n        int index = getNum(0, firstName.length() - 1);\n        String first = firstName.substring(index, index + 1);\n        int sex = getNum(0, 1);\n        String str = boy;\n        int length = boy.length();\n        if (sex == 0) {\n            str = girl;\n            length = girl.length();\n            name_sex = &quot;女&quot;;\n        } else {\n            name_sex = &quot;男&quot;;\n        }\n        index = getNum(0, length - 1);\n        String second = str.substring(index, index + 1);\n        int hasThird = getNum(0, 1);\n        String third = &quot;&quot;;\n        if (hasThird == 1) {\n            index = getNum(0, length - 1);\n            third = str.substring(index, index + 1);\n        }\n        return first + second + third;\n    }\n\n\n    /**\n     * 生成随机时间\n     *\n     * @param beginDate\n     * @param endDate\n     * @return\n     */\n    private static Date randomDate(String beginDate, String endDate) {\n\n        try {\n\n            SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);\n//构造开始日期 \n            Date start = format.parse(beginDate);\n//构造结束日期 \n            Date end = format.parse(endDate);\n\n//getTime()表示返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 \n\n            if (start.getTime() &gt;= end.getTime()) {\n\n                return null;\n\n            }\n\n            long date = random(start.getTime(), end.getTime());\n\n            return new Date(date);\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n\n        }\n\n        return null;\n\n    }\n\n    private static long random(long begin, long end) {\n\n        long rtn = begin + (long) (Math.random() * (end - begin));\n\n        //如果返回的是开始时间和结束时间，则递归调用本函数查找随机值 \n\n        if (rtn == begin || rtn == end) {\n\n            return random(begin, end);\n\n        }\n\n        return rtn;\n\n    }\n\n    /**\n     * 生成用户对象\n     *\n     * @return\n     */\n    public static User getUser() {\n        User cmfzUser = new User();\n        cmfzUser.setUserName(getChineseName());\n        cmfzUser.setUserNickname(&quot;大圣&quot;);\n        cmfzUser.setUserTelphone(getTel());\n        cmfzUser.setUserPassword(&quot;123456&quot;);\n        cmfzUser.setUserStatus(0);\n        cmfzUser.setGuruId(1);\n        cmfzUser.setUserSex(sexs[getRandom(sexs.length)]);\n        String[] strings = place[getRandom(place.length)];\n        cmfzUser.setUserProvince(strings[0]);\n        cmfzUser.setUserCity(strings[getRandom(strings.length)]);\n        cmfzUser.setUserAutograph(&quot;岁月静好&quot;);\n        cmfzUser.setUserImage(&quot;hhh.jpg&quot;);\n        cmfzUser.setUserCreateDate(randomDate(&quot;2019-03-01&quot;, &quot;2019-8-15&quot;));\n        return cmfzUser;\n    }\n\n}\n\n</code></pre>\n<p>这里我所创建的用户对象是：</p>\n<pre><code class=\"language-java\">\n/**\n * @author macw\n * @since 2019-08-13\n */\n@Data\n@EqualsAndHashCode(callSuper = false)\n@Accessors(chain = true)\n@TableName(&quot;cmfz_user&quot;)\npublic class User implements Serializable {\n\n    @TableId(value = &quot;user_id&quot;, type = IdType.AUTO)\n    @Excel(name = &quot;用户编号&quot;)\n    private Integer userId;\n    @Excel(name = &quot;手机号&quot;)\n    private String userTelphone;\n    @Excel(name = &quot;密码&quot;)\n    private String userPassword;\n    @Excel(name = &quot;头像&quot;)\n    private String userImage;\n    @Excel(name = &quot;用户昵称&quot;)\n    private String userNickname;\n    @Excel(name = &quot;用户名&quot;)\n    private String userName;\n    @Excel(name = &quot;性别&quot;)\n    private String userSex;\n    @Excel(name = &quot;个性签名&quot;)\n    private String userAutograph;\n    @Excel(name = &quot;省份&quot;)\n    private String userProvince;\n    @Excel(name = &quot;城市&quot;)\n    private String userCity;\n    @Excel(name = &quot;所属小组&quot;)\n    private Integer guruId;\n    @Excel(name = &quot;用户状态&quot;,replace = {&quot;男_1&quot;,&quot;女_0&quot;})\n    private Integer userStatus;\n    @TableField(&quot;user_create_date&quot;)\n    @Excel(name = &quot;注册时间&quot;)\n    private Date userCreateDate;\n    @TableField(exist = false)\n    private Integer count;\n\n}\n\n</code></pre>\n<p>然后就可以直接调用生成十万条用户数据了！<br />\n调用测试类如下：</p>\n<pre><code class=\"language-java\">  @Test\n    public void test1(){\n        SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n        long start = System.currentTimeMillis();\n        System.out.println(&quot;-----&quot;+date);\n        int insert = 0;\n        for (int i = 0; i &lt; 10000; i++) {\n            User user = GenerateUserUtil.getUser();\n            insert += userMapper.insert(user);\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;成功添加： &quot;+insert+&quot; 条数据，所用时间：&quot;+(end-start)+&quot;ms&quot;);\n    }\n</code></pre>\n<p>如此，就可轻轻松松向数据库添加十万条数据了，</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:40:35', '2022-05-21 18:17:29');
INSERT INTO `tb_article` VALUES (221, 1, 8, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3449', 'MySQL数据库4种常用优化方式，sql语句书写优化规范', '<p>﻿<strong>MySQL数据库优化</strong></p>\n<p><a href=\"#引言\">1. 引言</a></p>\n<p><a href=\"#数据库优化手段\">2. 数据库优化手段</a></p>\n<p><a href=\"#优化储备知识\">3. 优化储备知识</a></p>\n<p><a href=\"#慢查询\">3.1 慢查询</a></p>\n<p><a href=\"#执行计划\">3.2 执行计划</a></p>\n<p><a href=\"#索引优化\">4. 索引优化</a></p>\n<p><a href=\"#索引语法\">4.1 索引语法</a></p>\n<p><a href=\"#索引应用场景\">4.2 索引应用场景</a></p>\n<p><a href=\"#查询缓存\">5. 查询缓存</a></p>\n<p><a href=\"#sql优化\">6. SQL优化</a></p>\n<p><a href=\"#读写分离\">7. 读写分离</a></p>\n<p><a href=\"#centos中linux的安装\">7.1 CentOS中linux的安装</a></p>\n<p><a href=\"#mysql主从复制\">7.2 MySQL主从复制</a></p>\n<p><a href=\"#读写分离基于mycat实现\">7.3 读写分离(基于MyCat实现)</a></p>\n<h1 id=\"引言\">引言</h1>\n<p>实际项目中，我们的数据往往存储在数据库中，但是由于数据库本身是持久化存储，数据的查询速度受到磁盘IO瓶颈的限制，同时，随着数据量的增长，数据的查询也会因为单表数据量的巨大，影响查询速度。所以我们需要对数据库进行优化，提高系统的响应效率。</p>\n<h1 id=\"数据库优化手段\">数据库优化手段</h1>\n<ol>\n<li>\n<p>索引优化。</p>\n</li>\n<li>\n<p>添加查询缓存。</p>\n</li>\n<li>\n<p>优化数据库SQL语句。</p>\n</li>\n<li>\n<p>数据库Cluster(搭建数据库集群环境)。</p>\n</li>\n</ol>\n<h1 id=\"优化储备知识\">优化储备知识</h1>\n<h2 id=\"31-慢查询\">3.1 慢查询</h2>\n<blockquote>\n<p>慢查询就是查看我们每条sql语句查询所用的时间，<br />\n开启慢查询的目的是将我们每次查询所用的时间记录在日志里进行观察检测，如果检测到查询的时间到达超过一定的预定时间（比如查询时间超过1秒的语句），将被记录下来进行优化！</p>\n</blockquote>\n<ol>\n<li>查看慢查询的信息状态</li>\n</ol>\n<blockquote>\n<p>show variables like \'%quer%\';</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818165456174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>开启慢查询</li>\n</ol>\n<blockquote>\n<p>set global slow_query_log=on;</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818170417988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>修改慢查询最短时间为1s</li>\n</ol>\n<blockquote>\n<p>set GLOBAL long_query_time = 1;</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818170539243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>查看MySQL执行过的慢查询SQL语句。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818170706476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"32-执行计划\">3.2 执行计划</h2>\n<p>补充： 数据库查询优化中需要了解MySQL执行计划命令，查看sql的执行效率</p>\n<p>进行一条查询语句，点下左上角的解释看语句解释：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190818170730136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"索引优化\">索引优化</h1>\n<h2 id=\"41-索引语法\">4.1 索引语法</h2>\n<ol>\n<li>索引的作用</li>\n</ol>\n<blockquote>\n<p>加快以索引字段为条件的查询效率。</p>\n</blockquote>\n<ol>\n<li>创建索引</li>\n</ol>\n<blockquote>\n<p>create index  索引名字 on 表(字段)</p>\n</blockquote>\n<ol>\n<li>删除索引</li>\n</ol>\n<blockquote>\n<p>drop index  索引名字</p>\n</blockquote>\n<ol>\n<li>查询某张表创建了哪些索引</li>\n</ol>\n<blockquote>\n<p>Show index from 表名;</p>\n</blockquote>\n<ol>\n<li>索引的特点</li>\n</ol>\n<blockquote>\n<p>①索引会占用存储空间，虽然比较少，但是也占用了。</p>\n</blockquote>\n<blockquote>\n<p>②MySQL会自动为primary 主键列和unique 唯一列自动增加索引。</p>\n</blockquote>\n<blockquote>\n<p>③MySQL数据库对数据做DML操作时，需要同时做维护索引的操作。</p>\n</blockquote>\n<blockquote>\n<p><strong>隐含之意，就是索引会降低数据库增删改的效率。</strong></p>\n</blockquote>\n<ol>\n<li>使用原则：</li>\n</ol>\n<blockquote>\n<p>一般会对sql中的where条件字段或者order by字段建立索引。</p>\n</blockquote>\n<h2 id=\"42-索引应用场景\">4.2 索引应用场景</h2>\n<p>实际项目中，如果从业务角度出发，发现经常会用到某个字段，对表数据进行查询，或者根据经常用到某个字段的排序，则该数据是需要增加索引的。</p>\n<h1 id=\"在这里插入图片描述查询缓存\"><img src=\"https://img-blog.csdnimg.cn/20190818171131437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n查询缓存</h1>\n<ol>\n<li>在数据库操作对象DAO处增加查询缓存。</li>\n</ol>\n<blockquote>\n<p><em>参考Ehcache缓存，或者MyBatis+Ehcache整合方案、Hibernate二级缓存Ehcache。</em></p>\n</blockquote>\n<ol start=\"2\">\n<li>需要注意的问题是，要注意数据的一致性，所以缓存思路如下：</li>\n</ol>\n<blockquote>\n<p>① 只对查询结果进行缓存</p>\n</blockquote>\n<blockquote>\n<p>②<br />\n缓存结果存放要以业务逻辑相关为划分单位。比如，如果是单表，则可以创建一个缓存区域，与该表对应，如果业务中涉及到表连接操作，要将查询结果缓存在这多张表的查询结果都要缓存在对应的一个缓存区域中。</p>\n</blockquote>\n<ol start=\"3\">\n<li>\n<p>当执行增删改的时候，为了避免出现脏数据。</p>\n</li>\n<li>\n<p>基于以上的特点，缓存原则是对那些查询需求远大于增删改需求的数据，进行缓存。</p>\n</li>\n</ol>\n<blockquote>\n<p>例如：新闻网站的首页数据、电商的类别数据等。</p>\n</blockquote>\n<h1 id=\"sql优化\">SQL优化</h1>\n<ol>\n<li>\n<p>尽量不要在要给在SQL语句的where子句中使用函数，这样会使索引失效。</p>\n</li>\n<li>\n<p>如果已经确定查询结果只有一条数据（当表中数据的该字段是唯一的），在查询SQL末尾增加<br />\nlimit    1，这样MySQL的查询执行引擎在找到1条数据之后就会停止搜索，提高效率。（mysql5.6之后有效）<br />\n例如：</p>\n</li>\n</ol>\n<blockquote>\n<p>select * from t_department where department_name = \'研发部\' limit 1;</p>\n</blockquote>\n<ol start=\"3\">\n<li>\n<p>模糊查询尽量使用右模糊：‘xx%’，这样可以利用上索引，而使用‘%xx’这种模糊查询会导致该查询字段上的索引失效。</p>\n</li>\n<li>\n<p>如果非要使用表连接，最好要保证连接的两个字段都是创建了索引的。</p>\n</li>\n<li>\n<p>查询的时候最好用什么数据查询什么数据，避免使用select<br />\n*,原因是数据库访问往往是远程通过网络来访问，这也就意味着，查询结果也是通过网络来传输的，如果查询了额外的无用的数据，他们会额外占用网络带宽，数据传输效率也会降低。</p>\n</li>\n<li>\n<p>尽量使用非空 not<br />\nnull，可以使用‘’空串代替null。因为‘’不占用空间，null会占用空间的。</p>\n</li>\n<li>\n<p>使用!= 或者&lt;&gt; 数据库会放弃索引。</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/2019081817164678.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"6\">\n<li>在SQL语句中不要有运算，否则MySQL会放弃索引。（mysql在执行查询时，会自动过滤当前语句，当效率大于使用索引时，则默认不使用索引）</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190818171706234.png\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>\n<p>对于百万级以上的表数据，如果要做表连接查询，一定要对表先分页，然后对分页结果再做表连接。</p>\n</li>\n<li>\n<p>尽量避免大事务操作，这样会降低系统的并发能力。在满足实际业务的前提下，尽量缩短事务的边界。</p>\n</li>\n<li>\n<p>Where子句多条件and连接的情况，要把精确条件放在最先执行的位置，提高效率。Oracle中是从右至左。MySQL中是从左至右。<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081817175944.jpg\" alt=\"在这里插入图片描述\" /></p>\n</li>\n</ol>\n<h1 id=\"mysql集群环境之------读写分离主从复制\">MySql集群环境之------读写分离、主从复制</h1>\n<p>搭建MySQL的集群环境来优化查询<br />\n详细的使用搭建步骤可参考我之前文章：</p>\n<p><a href=\"https://blog.csdn.net/MacWx/article/details/98778719\"> Centos 7使用MyCat搭建 MySQL-读写分离</a></p>\n<a href=\"https://blog.csdn.net/MacWx/article/details/98777361\">\nCentos 7搭建MySQL-主从复制</a>\n', 1, '', 0, 0, 1, '2020-04-25 15:40:58', '2022-05-21 18:17:14');
INSERT INTO `tb_article` VALUES (222, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8899', 'POI简介，以及使用POI技术实现Excel文件的导入导出案例', '<p>﻿### 1、什么是POI？<br />\nApache POI 是 Apache 软件基金会的开放源码函式库，POI 提供 API 给 Java 程序对<br />\nMicrosoft Office 格式档案读和写的功能。</p>\n<p><strong>常用的两种java操作Excel技术POi和JXL的对比：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190814211200494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>POI 和 JXL 对 Excel 抽象出来的对象对比</strong><br />\n|                  |       POI        |   JXL    |<br />\n| :--------------: | :--------------: | :------: |<br />\n|    Excel 文档    |   HSSFWorkbook   | Workbook |<br />\n|  Excel 的工作表  |    HSSFSheet     |  Sheet   |<br />\n|    Excel 的行    |     HSSFRow      |    无    |<br />\n| Excel 中的单元格 |     HSSFCell     |   Cell   |<br />\n|    Excel 字体    |     HSSFFont     |          |<br />\n| Excel 单元格样式 |  HSSFCellStyle   |          |<br />\n|    Excel 颜色    |    HSSFColor     |          |<br />\n|    合并单元格    | CellRangeAddress |          |</p>\n<h3 id=\"2使用poi实现excel的导入导出\">2、使用POI实现Excel的导入导出</h3>\n<p>先来回忆一下window使用Excel和POi对Excel抽象出来的对象</p>\n<ol>\n<li>创建一个Excel文件 HSSFWorkbook</li>\n<li>创建一张工作表 HSSFSheet</li>\n<li>选中一行  HSSFRow</li>\n<li>选中一个单元格  HSSFCell</li>\n<li>在单元格中写入数据</li>\n<li>保存</li>\n</ol>\n<h4 id=\"第一个demo-excel导出\">第一个demo Excel导出</h4>\n<p><strong>1，导入POI依赖</strong></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;\n    &lt;artifactId&gt;poi&lt;/artifactId&gt;\n    &lt;version&gt;3.11&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p><strong>2，POI工具类实现导出</strong><br />\n案例1：</p>\n<pre><code class=\"language-java\">package com.macw;\n\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\nimport org.junit.Test;\n\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class PoiTest {\n\n    @Test\n    public void test1() throws IOException {\n//        1.创建一个文件对象\n        HSSFWorkbook hssfWorkbook = new HSSFWorkbook();\n\n//        2.创建一个表对象 通过文件对象创建表对象\n        HSSFSheet sheet = hssfWorkbook.createSheet(&quot;表名：excel数据表&quot;);\n\n//        3.获取行对象 下标从0开始\n        HSSFRow row = sheet.createRow(0);\n\n//        4.获取第1个单元格  下标从0开始\n        HSSFCell cell = row.createCell(0);\n\n//        5.在单元格中写入数据\n        cell.setCellValue(&quot;Hello Wolld&quot;);\n\n//        6.保存在磁盘中 流  文件名的后缀必须有.xls\n        hssfWorkbook.write(new FileOutputStream(&quot;E://demo.xls&quot;));\n    }\n}\n```java\n案例2：\n模拟从数据库查到的所有用户及用户信息导出到excel文件中\n</code></pre>\n<pre><code>@RequestMapping(&quot;/exportAll&quot;)\npublic void exportAll(HttpServletResponse resp){\n    //模拟从数据库查到的所有用户及用户信息\n    List&lt;User&gt; users = new ArrayList&lt;User&gt;();\n    User user = new User(&quot;1&quot;,&quot;张三 1&quot;,&quot;2019-8-10&quot;);\n    User user1 = new User(&quot;2&quot;,&quot;张三 2&quot;,&quot;2019-8-10&quot;);\n    User user2 = new User(&quot;3&quot;,&quot;张三 3&quot;,&quot;2019-8-10&quot;);\n    User user3 = new User(&quot;4&quot;,&quot;张三 4&quot;,&quot;2019-8-10&quot;);\n    User user4 = new User(&quot;5&quot;,&quot;张三 5&quot;,&quot;2019-8-10&quot;);\n    User user5 = new User(&quot;6&quot;,&quot;张三 6&quot;,&quot;2019-8-10&quot;);\n    User user6 = new User(&quot;7&quot;,&quot;张三 7&quot;,&quot;2019-8-10&quot;);\n    User user7 = new User(&quot;8&quot;,&quot;张三 8&quot;,&quot;2019-8-10&quot;);\n    users.add(user);\n    users.add(user1);\n    users.add(user2);\n    users.add(user3);\n    users.add(user4);\n    users.add(user5);\n    users.add(user6);\n    users.add(user7);\n    //创建工作薄\n    HSSFWorkbook workbook = new HSSFWorkbook();\n    //创建工作表\n    HSSFSheet sheet = workbook.createSheet(&quot;用户信息&quot;);\n    //设置列宽 第一个参数：列索引 第二个参数：列宽\n    sheet.setColumnWidth(2, 4500);\n    //创建导出样式\n    HSSFCellStyle cellStyle = workbook.createCellStyle();\n    //创建字体\n    HSSFFont font = workbook.createFont();\n    //设置字体颜色\n    font.setColor(HSSFFont.COLOR_RED);\n    //设置加粗\n    font.setBold(true);\n   \n    //设置字体\n    font.setFontName(&quot;宋体&quot;);\n    //设置居中\n    cellStyle.setAlignment(CellStyle.ALIGN_CENTER);\n    //管理字体样式\n    cellStyle.setFont(font);\n    //创建标题栏\n    HSSFRow row = sheet.createRow(0);\n    HSSFCell cell = null;\n    String[] titles = {&quot;编号&quot;,&quot;真实姓名&quot;,&quot;出生年月&quot;};\n    for (int i = 0; i &lt; titles.length; i++) {\n        cell = row.createCell(i);\n        cell.setCellValue(titles[i]);\n    //标题行使用样式\n        cell.setCellStyle(cellStyle);\n    }\n    for (int i = 1; i &lt;= users.size(); i++) {\n         //创建数据行对象\n        row = sheet.createRow(i);\n        //数据行第一列设值\n        cell = row.createCell(0);\n        cell.setCellValue(users.get(i-1).getUserId());\n        //数据行第二列设值\n        cell = row.createCell(1);\n        cell.setCellValue(users.get(i-1).getRealname());\n        //数据行第三列设值\n        cell = row.createCell(2);\n        cell.setCellValue(users.get(i-1).getDharmaName());\n    }\n    String fileName = &quot;用户报表(&quot;+new\n            SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date())+&quot;).xls&quot;;\n    //处理中文下载名乱码\n    try {\n        fileName = new  String(fileName.getBytes(&quot;utf-8&quot;),&quot;utf-8&quot;);\n        //设置 response\n        resp.setContentType(&quot;application/vnd.ms-excel&quot;);\n        resp.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename=&quot;+fileN\n                ame);\n       \n        workbook.write(resp.getOutputStream());\n        workbook.close();\n    } catch (Exception e) {\n    // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n}\n</code></pre>\n<h3 id=\"3poi导入\">3、POI导入</h3>\n<pre><code class=\"language-java\"> @RequestMapping(&quot;/uploadIn&quot;)\n    @ResponseBody\n    public Map uploadIn(MultipartFile multipartFile) throws IOException {\n        //输出文件名\n        logger.info(&quot;----------文件名为： &quot;+multipartFile.getOriginalFilename());\n        //1，获取流对象\n        InputStream inputStream = multipartFile.getInputStream();\n\n//        2.通过poi解析流 得到 Excel文件对象\n        HSSFWorkbook workbook = new HSSFWorkbook(inputStream);\n\n//        3.通过对象获取数据 得到表\n        HSSFSheet sheet = workbook.getSheetAt(0);\n\n//        4.通过表 得到行\n        int lastRowNum = sheet.getLastRowNum();\n        //定义计数器，计算批量导入多少条数据\n        int sum = 0;\n        for (int i = 1; i &lt;= lastRowNum; i++) {\n            Guru guru = new Guru();\n            HSSFRow row = sheet.getRow(i);\n//            获取单元格\n            double guruId = row.getCell(0).getNumericCellValue();\n            guru.setGuruId((int) guruId);\n\n            guru.setGuruName(row.getCell(1).getStringCellValue());\n            guru.setGuruImage(row.getCell(2).getStringCellValue());\n            guru.setGuruNickname(row.getCell(3).getStringCellValue());\n            guru.setGuruStatus((int) row.getCell(4).getNumericCellValue());\n            System.out.println(guru);\n			//执行添加的SQL\n            int insert = guruMapper.insert(guru);\n            //统计添加成功的条数\n            sum+=insert;\n        }\n        Map map = new HashMap();\n        map.put(&quot;flag&quot;, sum+&quot;&quot;);\n        return map;\n    }\n</code></pre>\n<p>页面代码：</p>\n<pre><code class=\"language-html\">&lt;div id=&quot;insertFile&quot; class=&quot;easyui-dialog&quot; data-options=&quot;closed:true&quot;&gt;\n    &lt;form id=&quot;insertFileForm&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;\n        上传Excel文件：&lt;input class=&quot;easyui-filebox&quot; name=&quot;multipartFile&quot;\n                         data-options=&quot;required:true,missingMessage:\'请选择文件\'&quot;/&gt;&lt;br/&gt;&lt;br/&gt;\n        &lt;a href=&quot;javascript:void(0)&quot; class=&quot;easyui-linkbutton&quot; iconCls=&quot;icon-save&quot; onClick=&quot;insertFileConfirm()&quot;&gt;上传&lt;/a&gt;\n    &lt;/form&gt;\n&lt;/div&gt;\n\n\njs代码：\n\n //批量上传的文件提交\n    function insertFileConfirm() {\n        $(&quot;#insertFileForm&quot;).form(&quot;submit&quot;, {\n            url: &quot;${pageContext.request.contextPath}/guru/uploadIn&quot;,\n            success: function (data) {\n               console.log(data);\n                alert(&quot;成功添加：&quot;+data.flag+&quot; 条数据&quot;);\n                $(&quot;#insertFile&quot;).dialog(&quot;close&quot;);\n                $(&quot;#guruManager&quot;).datagrid(&quot;reload&quot;);\n            }\n        })\n    }\n</code></pre>\n', 1, '', 0, 0, 1, '2020-04-25 15:41:41', '2022-05-21 18:16:54');
INSERT INTO `tb_article` VALUES (223, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=2482', 'Maven仓库 一键自动删除失效jar包，没事儿点点_', '<p>﻿因为网路等各种原因，使用maven仓库下载jar包可能会下载失败，或者下载一半停止，</p>\n<p>下载失效的jar包会严重影响我们程序的运行，<br />\n看着明明没问题，但是一运行就报错，而且还很难找到错误问题原因，</p>\n<p><strong>所以及时得清理失效的jar包会使我们从程序减少出错的可能；</strong></p>\n<p>如何清理失效的jar包呢，<br />\n失效的jar在我们的maven仓库 都有一个.lastUpdated结尾的后缀，、</p>\n<p>只要是有这个后缀的文件夹里面的jar包就都是失效的，</p>\n<p>下面说一个使用windows的批处理清理带.lastUpdated结尾的失效jar包的解决办法：</p>\n<p>新建一个记事本，输入一下命名：</p>\n<pre><code>@echo  off\nrem create by sunhao(sunhao.java@gmail.com)\nrem crazy coder\nset REPOSITORY_PATH=D:\\Maven\\repository\nrem 正在搜索...\nfor /f &quot;delims=&quot; %%i in (\'dir /b /s &quot;%REPOSITORY_PATH%\\*lastUpdated*&quot;\') do (\n    del /s /q %%i\n)\nrem 搜索完毕\npause\n</code></pre>\n<p>其中的：<br />\n<strong>set REPOSITORY_PATH=D:\\Maven\\repository</strong><br />\n改为你的本地仓库路径地址</p>\n<p><strong>然后将这个txt文件另存为：删除失效jar包工具没事儿点点.bat<br />\n一定要是.bat结尾的批处理文件才行啊，</strong></p>\n<p>然后就可以把 这个东西发送到桌面快捷方式，闲着没事就点点清理jar包</p>\n<p>如果双击不运行的话就右键以管理员身份打开~</p>\n', 1, '', 0, 0, 1, '2020-04-25 15:41:44', '2022-05-21 18:16:24');
INSERT INTO `tb_article` VALUES (224, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=2523', 'Redis持久化机制RDB 和AOF', '<p>﻿## redis持久化机制</p>\n<p>redis服务器宕机，内存数据是会丢失了，为了保证数据不丢失需要对数据做备份，所备份就是持久化，Redis的持久化即将内存中的数据同步到硬盘，主要包括两种方式RDB、AOF。</p>\n<p><strong>RDB持久化机制，(默认使用)</strong>：做当前内存数据的全本快照，<br />\n将内存中的数据以快照的方式写入到二进制文件dump.rdb,<br />\n在redis.conf中可以设置发起快照保存的条件。在指定的时间内如果有超过指定数量的key被修改，则会发起快照保存。</p>\n<p>这种方式在数据的实时性上不高，在突然断电的情况下，可能会出现部分数据的丢失，即最后一次快照之后在内存中发生修改的数据。</p>\n<p>简单来说：RDB就是将redis上的所有数据做个备份，存储的是二进制的数据。</p>\n<p><strong>AOF持久化机制，(默认是关闭)</strong>：</p>\n<p>AOF是将Redis内存数据库中更改的数据都记录到指定的文件appendonly.aof。在redis.conf中可以进行写磁盘的相关设置。</p>\n<p>在突然断电的情况下，由于在appendonly.aof中保存了最后一次写磁盘之后redis内存发生数据修改的指令，所以在这个Redis重启后，基本不会发生数据丢失，比RDB具有更好的数据安全性。</p>\n<p>appendfsync always   接收到更改数据的命令，立即将其记录到appendonly.aof中，能保证数据持久化，数据完全不丢失，但效率相对最低。</p>\n<p>appendfsync everysec   每秒钟将redis内存数据修改的命令记录到appendonly.aof中，在性能和持久化上做了折中。因频繁执行磁盘操作，在仅存在单个Master执行写操作时，效率可能存在问题。但在多个Master执行写操作的Redis集群中，效率会提升。</p>\n<p>appendfsync no  依赖于操作系统，因不会频繁执行磁盘操作而性能最好，但redis内存数据修改持久化没有保证，无法保证数据可靠性</p>\n<p><strong>如何开启AOF持久化：</strong><br />\n将redis.conf文件中 appendonly 改成 yes ，自动创建appendonly.aof，该文件存储的客户端执行过<strong>增删改操作的命令</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190811162518765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"什么是aof重写\">什么是AOF重写？</h2>\n<p>当命令存储了一定程度的时候，有一些命令可能是已经无效的了<br />\n例如set usernname xx  del usename,添加一条数据，后又删除，所以这两条命令备份的备份的时候就都是无效的<br />\n所有redis会对AOF文件进行优化，把一些没有对于数据恢复没有意义的命令优化掉<br />\n默认AOF是关闭的，需要在redis.conf中进行开启<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081116254741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 15:41:47', '2022-05-21 18:16:11');
INSERT INTO `tb_article` VALUES (225, 1, 5, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3970', 'Mybatis中$ {} 和 # {}的区别，动态SQL之if、where、set、trim、foreach标签的使用', '<p>﻿## 一．Mapper文件的补充细节</p>\n<p><strong>a)	Xml的特殊字符</strong><br />\n在mapper文件中，小于号用&amp; lt;代替， 大于号用 &amp; gt;代替</p>\n<pre><code>i.	&lt;   &amp;lt;  \nii.	&gt;  &amp;gt; \n</code></pre>\n<p><strong>b)	$ {} 和 # {}的区别</strong><br />\ni.	使用上，$ {}要获取的参数值，对应的参数必须使用Param注解<br />\nii.	底层上，<br />\n${}使用字符串拼接<br />\n#{}使用?占位符</p>\n<ol>\n<li>字符串拼接，可以拼接表名 列名 sql关键字</li>\n<li>?占位符，只能绑定数据，但可以避免sql注入攻击</li>\n</ol>\n<h2 id=\"二动态sql\">二．动态SQL</h2>\n<p>什么是动态SQL？就是能够根据不同的条件，产生不同 的SQL语句。</p>\n<blockquote>\n<p>比如我们常见的多条件搜索框，可以根据姓名、性别、年龄、工资范围等按照一定的条件进行搜素，<br />\n但如果我只输入姓名搜素呢，或者按照姓名+年龄进行搜素呢，这样排列组合情况就太多了，我们不可能一个条件去写一个SQL的，<br />\n所以就需要我们根据用户输入的条件来动态的生成一条SQL语句。</p>\n</blockquote>\n<p><strong>Mapper文件中动态SQL常用的几个标签</strong><br />\n&lt; if&gt; 作用：<br />\n满足条件时执行sql，不满足则不执行</p>\n<p>&lt; where&gt; 作用：</p>\n<ol>\n<li>会自动删除if动态sql产生的多余的and or前缀</li>\n<li>会在if动态sql语句前添加where关键字</li>\n</ol>\n<p>如下SQL语句所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728141308831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>&lt; set&gt;作用：<br />\n1.会自动if动态sql产生的多余的逗号后缀<br />\n2.会在if动态sql语句前添加set关键字</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190728141444363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>&lt; trim&gt;作用：<br />\n可以自定义前缀和后缀：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019072814165010.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>&lt; foreach&gt; 循环遍历，<br />\n常用来做批量删除的时候用</strong><br />\n如下图所示：<br />\ncollection:相当于集合名，<br />\nitem表示集合中的一个元素，<br />\nopen是循环之前要加的东西，<br />\nclose是循环结束的时候要加的东西，<br />\nseparator:元素间使用什么分隔。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728141835696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:17', '2022-05-21 18:15:56');
INSERT INTO `tb_article` VALUES (226, 1, 5, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5747', '简单理解什么是Spring中的IOC控制反转和DI依赖注入，Spring对象的三种创建方式', '<p>﻿IOC ：Inversion of Control     控制反转<br />\nDI  :  dependency Injection   依赖注入</p>\n<p>咋一听，控制反转、依赖注入，似乎很高大上的名字，概念比较抽象，但其实慢慢分析，转换成自己的话也不难理解：</p>\n<p><strong>IOC的理解：</strong></p>\n<p><em>在原始社会的时候，我们需要自己生火、自己挖井。这个时候主动权在自己手里。随着时代的发展我们现在有燃气公司和水利公司。我们现在想喝水直接扭水龙头水就流出来了，但是水这个来源的控制权交给自来水公司了，这个过程称之为控制反转</em></p>\n<p>对于Spring来说，以前自己创建的对象UserService service = new UserServiceImpl(),<br />\nservice.xxx()<br />\n而现在，对象的创建交给Spring工厂，用的时候去工厂中获取，<br />\nClassPathXmlApplicationContext ac = new ...;</p>\n<p>从之前自己创建对象，到现在交给Spring工厂创建对象，包括给属性赋值也交给Spring工厂来完成，这个由我们自己完成一些事情转移到Spring框架完成这些事情的过程，Spring称之为控制反转（IOC）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190728145347156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>DI (依赖注入):</strong></p>\n<p>如果我们站在spring工厂的角度，工厂创建需要的对象，并且还可以给程序员中的类的属性赋值，对象由工厂创建，最终由程序员使用，这就是spring的依赖注入<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728145414207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<blockquote>\n<p>IOC和DI实际上是等同的概念，如果要进行区分的话，IOC和DI可以理解为同一个东西的不同角度看法，IOC<br />\n站在程序员的角度，以前创建对象是我们自己new出来的，现在让容器自己创建，控制权交给了容器，对于<br />\n我们来说控制权反转了。<br />\nDI是站在容器的角度，从Spring角度来看，用到的所有的对象都是自己创建的，并且对象在创建的时候需要<br />\n依赖的参数也是容器注入的，而这种维持对象之间依赖关系的方式就是依赖注入。</p>\n</blockquote>\n<blockquote>\n<p>所以IOC和DI实际上都是指容器负责创建对象和维护对象之间依赖关系的这种行为。</p>\n</blockquote>\n<h3 id=\"说到这里再来分析一下spring创建对象的三种方式\">说到这里，再来分析一下Spring创建对象的三种方式：</h3>\n<p><strong>1，通过构造方法创建，采用默认的构造函数，</strong><br />\n也就是通过xml+bean标签，bean标签要写class的类的全限定名，其原理是通过java类的反射机制创建对象。<br />\nindex : 参数的索引,从0 开始<br />\nname: 参数名<br />\ntype:类型(区分开关键字和封装类int 和Integer)</p>\n<pre><code>&lt;bean id=&quot;peo&quot; class=&quot;com.macw.pojo.People&quot;&gt;\n&lt;!-- ref 引用另一个bean value 基本数据类型或String 等--&gt;\n    &lt;constructor-arg index=&quot;0&quot; name=&quot;id&quot; type=&quot;int&quot;  value=&quot;123&quot;&gt;&lt;/constructor-arg&gt;\n    &lt;constructor-arg index=&quot;1&quot; name=&quot;name&quot; type=&quot;java.lang.String&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>在早期Spring1.0版本，还没有注解的时候，Spring能够帮我们创建对象和管理对象，<br />\n但是没有注解每创建一个对象就要配置一个xml，其实还没有我们直接new一个对象来得快呢，</p>\n<p>但是为什么spring框架仍然有他的极大优势呢，因为他最重要的一个特性是能够帮我们管理对象，<br />\n自己new对象在类中多处调用会造成程序模块之间耦合性太强，不利于维护更新。而spring帮我们管理对象通过依赖注入声明的是管理对象的关系。</p>\n<p><strong>2、通过实例工厂创建对象<br />\n也就是 工厂设计模式：帮助创建类对象，一个工厂可以生产多个对象</strong></p>\n<pre><code>// 工厂，创建对象\npublic class StudentFactory {\n    // 实例方法创建对象\n    public Student getInstance() {\n        return new User(001,&quot;学生工厂：调用实例方法&quot;);\n    }\n\n    // 静态方法创建对象\n    public static Student getStaticInstance() {\n        return new Student(002,&quot; 学生工厂：调用静态方法&quot;);\n    }\n}\n\n配置文件：\n\n&lt;!-- # 3.1 工厂类，实例方法 --&gt;\n    &lt;!-- 先创建工厂 --&gt;\n    &lt;bean id=&quot;factory&quot; class=&quot;com.macw.StudentFactory&quot;&gt;&lt;/bean&gt;\n    &lt;!-- 在创建student对象，用factory方的实例方法 --&gt;\n    &lt;bean id=&quot;student2&quot; factory-bean=&quot;factory&quot; factory-method=&quot;getInstance&quot;&gt;&lt;/bean&gt;\n</code></pre>\n<p>其中： factory-bean=”factory”指定工厂。factory-method=”getInstance”指定工厂的哪个方法。</p>\n<p><strong>3.静态工厂创建对象，不需要创建工厂，快速创建对象</strong></p>\n<p>实现步骤：编写一个静态工厂（在方法上添加static）</p>\n<pre><code>public class StudentFactory{\n    public static Student newInstance(){\n        return new Student(001,&quot;studentTest&quot;);\n    }\n}\n\n在applicationContext.xml中\n&lt;bean  id = &quot;student2&quot;  class = &quot;com.macw.pojo.StudentFactory&quot;  factory-method = &quot;newInstance&quot;&gt;&lt;/bean&gt;\n\n</code></pre>\n<p>在spring2.0之后采用注解的形式开发，减少了大量 的xml配置文件，开发的形式变为xml+bean配置数据源，大量使用第三方框架，通过组件注解配置自己的类。</p>\n<p>spring3.0之后采用配置类+bean注解来创建对象，目的想取代xml配置文件，也就是springboot自动装配的底层原理</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:22', '2022-05-21 18:15:42');
INSERT INTO `tb_article` VALUES (227, 1, 6, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=885', '面试题：BeanFactory和FactoryBean有啥关系_', '<p>﻿没啥太大关系!</p>\n<p>BeanFactory(对象工厂)，他是spring框架中的工厂类，spring的工厂设计的比较复杂，BeanFactory被抽象成了一个接口，我们经常写代码叫做ClassPathXmlApplicationContext是BeanFactory的实现类</p>\n<p>FactoryBean也是一个接口，主要用于特殊对象的创建，例如Connectoin和SqlSession对象，由于他们是一个接口，这些对象的创建需要使用代码完成，所以需要一个类实现FactoryBean接口间接创建这些类的对象</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:26', '2022-05-21 18:15:29');
INSERT INTO `tb_article` VALUES (228, 1, 6, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1790', '使用代理模式实现Spring AOP的面向切面编程，动态代理的四种增强处理', '<p>﻿<strong>什么是代理类？</strong><br />\n代理就是代替我们去执行一些额外的工作。</p>\n<p><strong>目标类:只有核心功能的类</strong></p>\n<p>比如我们在写service的时候，<strong>调用dao方法是我们的核心业务</strong>，<strong>而service类中的日志记录，事务处理，异常处理等都属于额外的功能</strong>，每个service方法中都要写一次这些额外功能也会造成大量代码的冗余，</p>\n<p><strong>而面向切面编程的意思就是说把这些公共的、额外的代码功能抽取出来，每个service里面只写我们的核心业务</strong>，这样就提高了我们的开发效率。</p>\n<p><strong>为什么代理类和目标类要实现相同的接口？</strong><br />\n1.从代码的角度来说,代理类对象能够赋值给接口类型的变量<br />\n2.要保证代理类和目标类有相同的功能</p>\n<p>有了代理类:<br />\n程序员可以只关心核心功能</p>\n<p><strong>额外功能+目标类 =代理类</strong></p>\n<p>以上这种说法就是叫做静态代理，<br />\n静态代理就是在代码编译时,代理类已经存在<br />\n好处:程序员可以只关心核心功能<br />\n不好:多个代理类 ，    没有解决代码冗余的问题</p>\n<h2 id=\"什么是动态代理\">什么是动态代理？</h2>\n<p>运行时,动态创建出来代理对象<br />\nSpringAOP通过动态代理,让程序猿只关心核心代码,同时代码不再冗余</p>\n<p><strong>springAOP的开发步骤:</strong><br />\n1.写核心功能(目标类)<br />\n核心功能就是调用dao方法：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728174629656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2.配置目标类<br />\n要在SpringApplication.xml文件中配置目标类所在路径</p>\n<pre><code> &lt;!--配置目标类--&gt;\n    &lt;bean id=&quot;bookService&quot; class=&quot;com.macw.serviceImpl.bookServiceImpl&quot;&gt;\n        &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p><strong>3.写额外功能(增强处理)</strong><br />\n(公共功能:日志处理/事务处理/异常处理/性能分析....) 等</p>\n<p>前置增强(MethodBeforeAdvice):在核心功能之前执行的额外功能<br />\n后置增强:在核心功能之后执行的额外功能</p>\n<p>环绕增强:在核心功能之前以及之后执行的额外功能<br />\n异常增强:在核心功能发生异常时执行的额外功能</p>\n<p><strong>前置增强的配置使用：</strong><br />\n1，声明一个类，需要实现	MethodBeforeAdvice接口：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728175452663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2，spring配置文件中,配置声明的增强功能类</p>\n<pre><code>	&lt;!--额外功能--&gt;\n   &lt;bean id=&quot;myBeforeAdvice&quot; class=&quot;com.macw.advice.myBeforeAdvice&quot;&gt;&lt;/bean&gt;\n</code></pre>\n<p>3，在spring配置文件中,通过aop标签做配置(需要添加aop命名空间以及schema验证文档):<br />\n.在哪些方法上面做增强处理<br />\n.在需要增强处理的方法上面,加哪个增强处理<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728180128311.png\" alt=\"在这里插入图片描述\" /><br />\n4.让spring在运行的时候,帮我们创建代理对象()<br />\n<img src=\"https://img-blog.csdnimg.cn/2019072817590249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>详解advice<br />\nMethodBeforeAdvice前置增强的before方法</strong><br />\n实现MethodBeforeAdvice接口必须要要实现before方法，这个方法有三个参数，<br />\narg0：目标方法，<br />\narg1:目标方法参数，<br />\narg2:目标类，<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728180359181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2.AfterReturningAdvice:后置增强<br />\n<img src=\"https://img-blog.csdnimg.cn/2019072818044361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n3.ThrowsAdvice:异常增强<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728180513201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>4.MethodInterceptor:环绕增强,目标方法执行之前以及之后做的增强处理</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190728180541273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n总结：<br />\n<strong>Spring AOP:Aspect Oriented Program 面向切面编程</strong><br />\n几个重要概念：</p>\n<p>1.切入点:需要把增强处理加在的位置;service层的方法上面;需要在配置文件中配置<br />\n2.增强处理:额外功能(公共功能) ,通知/建议(advice)<br />\n3.目标类:核心功能所在的类(原始类)<br />\n4.切面:把增强处理,放在切入点的位置,形成的一个概念<br />\n5.编织/织入:把增强处理放置在切入点的过程</p>\n<p><strong>AOP使用场景:</strong><br />\n1.把功能内容抽取出来,形成advice;在配置文件中中做配置====&gt;程序猿只关心核心功能;解决冗余<br />\n2.在原有功能基础之上,做功能扩展===&gt;在不改变原有代码的基础上做功能扩展</p>\n<p>AOP实现:代理模式的使用</p>\n<p>代理类的产生原理<br />\n类加载ClassLoader<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728181445489.png\" alt=\"在这里插入图片描述\" /></p>\n<p>代理类的生成:由jdk动态代理生成<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728181529670.png\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"springaop实现原理\">SpringAOP实现原理:</h2>\n<p>1.底层通过字节码技术,把目标对象以及额外功能动态封装,生成代理对象  ==&gt;动态代理<br />\n使用了JDK动态代理以及cglib动态代理<br />\n2.为什么通过id得到的是代理对象<br />\nspring工厂创建对象之后,由BeanPostProcessor进行处理<br />\n<img src=\"https://img-blog.csdnimg.cn/20190728181629605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:28', '2020-10-07 13:09:55');
INSERT INTO `tb_article` VALUES (229, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7338', 'idea新手好用的几个插件、让你快速掌握IDEA', '<p>﻿从Myeclipse突然转到idea，最让我们感到不顺手的就是快捷键的使用变了，</p>\n<p>习惯了一个东西再去接受另一个新事物是很难接受的，虽然我们可以让idea切换成eclipse的快捷键，</p>\n<p>但是仍然有很多功能的快捷键的我们所不知道的，</p>\n<p>所以我要推荐的第一个插件就是：</p>\n<h2 id=\"1key-promoter-x\">1、Key promoter X</h2>\n<blockquote>\n<p>显示点击某个功能选项的快捷键（如果有的话）<br />\n前期新手使用确实对idea的快捷键感到头疼，有了这个的话就能帮助我们很快的掌握各种快捷键<br />\n等到使用熟练之后再把这个关掉就好了</p>\n</blockquote>\n<p>Key Promoter (X)其实这里是指2个插件，分别为Key Promoter X 和Key Promoter ，主要功能差不多的，都是一个提示插件，当你在IDEA里面使用鼠标的时候，如果这个鼠标操作是能够用快捷键替代的，那么Key Promoter X会在右下角弹出一个提示框，Key Promoter 会在左上角弹出一个提示框告，<strong>并且当你想看看一个功能的快捷键的时候你只需要把鼠标放上去不动他就会提示你这个功能的快捷键是啥</strong>、<strong>或者告知你这个鼠标操作可以用什么快捷键替代</strong>。当然，对于Key Promoter X还有一个官方功能解释那就是用来统计你鼠标操作的次数，然后在一个窗口中展示出来。对于想完全使用快捷键在IDEA的，这个插件就很有用。</p>\n<p><strong>安装：</strong><br />\n安装这个插件很简单，只需要打开Settings,然后找到Plugins那一栏目,然后输入key promoter,点击install就行，安装好会让你重启生效，<br />\n<img src=\"https://img-blog.csdnimg.cn/20190730090501863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"idea安装插件\" /><br />\n这是我已经安装过了。<br />\n如果找不到，就直接到仓库里找即可。</p>\n<h2 id=\"2jrebel-for-intellij\">2，JRebel for IntelliJ</h2>\n<blockquote>\n<p>一款热部署插件，只要不是修改了项目的配置文件，用它都可以实现热部署。<br />\n在没有这个之前频繁的重启和reply搞得我烦不胜烦。而这个简直没有太方便，节省了大量的重启程序的等待时间<br />\n只不过是收费的，但是目前已经有好多破解方法了，不过功能确实很强大。算是开发必备神器了。</p>\n</blockquote>\n<p><strong>安装：</strong><br />\n安装和上面安装步骤一样，打开Settings,然后找到Plugins那一栏目,然后输入Jrebel,一般第一个就是,点击install安装重启就能用，安装好如下图所示会在setting下面出现JRebel的配置信息：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190730091920369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n我这个是已经激活过了，<br />\n激活流程可以参考这篇大神写的文章：<a href=\"https://blog.csdn.net/songfei_dream/article/details/90921505\">https://blog.csdn.net/songfei_dream/article/details/90921505</a></p>\n<p><strong>使用：</strong><br />\n这个安装完之后会在右上角启动哪里多两个启动项，如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/2019073010052628.png\" alt=\"在这里插入图片描述\" /><br />\n再次启动程序的时候我们就可以通过jrebel启动tomcat了，实现真正 的热部署。快捷键是crtl+F10</p>\n<h2 id=\"3mybatis-plugin\">3,Mybatis plugin</h2>\n<blockquote>\n<p>可以在mapper接口中和mapper的xml文件中来回跳转，就想接口跳到实现类那样简单。<br />\n这个是免费版的，有收费要破解的，不过功能都差不多</p>\n</blockquote>\n<p><strong>安装：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190730101011297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>效果：</strong><br />\n点击箭头就可以实现dao和mapper文件之间的跳转<br />\n<img src=\"https://img-blog.csdnimg.cn/2019073011004642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"4alibaba-java-coding--guidelines\">4、Alibaba java Coding  Guidelines</h2>\n<blockquote>\n<p>阿里巴巴java开发规范手册<br />\n规范代码，从小开始<br />\n这个插件会智能时时的提醒你哪里写的不规范，并且命名哪里不好，建议你怎样怎样改，等等。<br />\n开发必备，很重要，习惯一旦养成很难再修改的，从开始就要规范代码书写风格<br />\n<img src=\"https://img-blog.csdnimg.cn/20190731104714623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<h2 id=\"5装饰插件activate-power-mode\">5，装饰插件：activate-power-mode</h2>\n<blockquote>\n<p>这是一款让你在编码的时候，整个屏幕都为之颤抖的插件。<br />\n敲的越快，抖动越厉害，并且会统计你在不停歇的情况下一口气敲了多少次键盘<br />\n不过这个插件晃的我头晕，</p>\n</blockquote>\n<p><strong>效果</strong></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNzcyNzQzLzIwMTgwNC83NzI3NDMtMjAxODA0MTEyMzIxMzAzNzQtMjA4NzI3MTU1MC5naWY\" alt=\"在这里插入图片描述\" /><br />\n重点还是前4个好用哈，最后一个就是玩玩~</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:31', '2021-08-30 09:58:46');
INSERT INTO `tb_article` VALUES (230, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=9179', 'Nginx搭建负载均衡详细操作', '<p>﻿</p>\n<p><strong>什么是负载均衡?</strong></p>\n<p>互联网早期，业务流量比较小并且业务逻辑比较简单，<strong>单台服务器</strong>便可以满足基本的需求；但随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台机器的性能问题以及单点问题凸显了出来，因此需要<strong>多台机器</strong>来进行性能的水平扩展以及避免单点故障。但是要如何将不同的用户的流量分发到不同的服务器上面呢？</p>\n<p>那么通过使用nginx搭建的负载均衡器即可解决该问题</p>\n<p>客户端的流量首先会到达负载均衡服务器，由负载均衡服务器通过一定的调度算法将流量分发到不同的应用服务器上面，同时负载均衡服务器也会对应用服务器做周期性的健康检查，当发现故障节点时便动态的将节点从应用服务器集群中剔除，以此来保证应用的高可用。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190801211348483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>搭建步骤以及准备条件：</strong></p>\n<ol>\n<li>搭建三台Linux服务器</li>\n<li>一台安装Nginx,另外两台各安装Tomcat</li>\n<li>对Nginx的/etc/nginx/conf.d/default.conf进行配置</li>\n<li>测试负载均衡</li>\n</ol>\n<p>这里我用的是使用Vmware创建三台Linux服务器，其中一台安装Nginx，为其使用dhclient分配ip为：192.168.248.128<br />\n另外两台安装jdk+Tomcat.，分别为其分配IP为：192.168.129和129.168.248.130.</p>\n<p>结果如下图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019080121244254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"详细操作\">详细操作：</h2>\n<h4 id=\"1克隆三台linux服务器\">1.克隆三台Linux服务器</h4>\n<p>​     1.1 以上图为例 dhclient 分配 ip地址</p>\n<p>​            安装tomcat的两台服务器ip分别为192.168.30.128、192.168.30.130</p>\n<p>​            安装的nginx的服务器ip为192.168.30.131</p>\n<h4 id=\"2安装jdk和tomcat\">2.安装JDK和Tomcat</h4>\n<p>在192.168.30.128、192.168.30.130上先安装JDK，在安装tomcat</p>\n<p>安装tomcat需要依赖JDK</p>\n<p>安装步骤参考之前的文章</p>\n<h4 id=\"3安装nginx\">3.安装Nginx</h4>\n<p>​    在192.168.30.131安装Nginx</p>\n<h4 id=\"4配置负载均衡\">4.配置负载均衡</h4>\n<p>在192.168.30.131安装Nginx的服务器上， 打开/etc/nginx/conf.d/default.conf文件</p>\n<pre><code>#新增\nupstream aa{\n    server 192.168.30.128:8080;\n    server 192.168.30.130:8080;\n}\n\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n        #新增一行\n        proxy_pass  http://aa;\n    }\n}\n\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190801212805182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"5关闭nginx上的安全组\">5.关闭Nginx上的安全组</h4>\n<p>使用  vi  /etc/selinux/config<br />\n编辑config文件，修改SELNUX=disabled<br />\n如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190801213601273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>注意：修改过安全组要把系统重启reboot下生效！<br />\n重启之后如果不能访问就要禁用掉防火墙：systemctl stop firewalld<br />\n并且开启Nginx：stystemctl start nginx</p>\n<h4 id=\"6测试\">6.测试</h4>\n<p>通过  <a href=\"http://192.168.30.131:80\">http://192.168.30.131:80</a> 访问Nginx,即可看到实际访问了tomcat</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190801212929871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"负载均衡的策略\">负载均衡的策略</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190801213815648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<ol>\n<li>\n<p>轮询 （默认）</p>\n<p>特点：一个一个挨着访问，tomcat服务器会被依次访问</p>\n</li>\n<li>\n<p>权重</p>\n<p>weight=数字越大权重越大，被访问的几率越高</p>\n<p>下边的配置上边的机器访问2次，下边的访问1次</p>\n</li>\n</ol>\n<p>​    <img src=\"https://img-blog.csdnimg.cn/20190801213027809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n​</p>\n<ol start=\"3\">\n<li>\n<p>ip黏着</p>\n<p>根据用户的ip,绑定到一台tomcat服务器<br />\n根据客户端用户的ip地址计算出一个可以被访问的tomcat服务器<br />\n如果客户端用户的ip地址不变，那么访问的tomcat就固定了</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20190801213058161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>原理:把用户的ip进行hash处理(取用户ip的hash值),对tomcat总数量取模,然后根据得到的值,对应找到要访问的Tomcat</p>\n<h2 id=\"反向代理和正向代理的区别\">反向代理和正向代理的区别</h2>\n<p>代理如果在服务器端就是反向代理，如果放在客户端就是正向代理<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080121444414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"反向代理-和-负载均衡-的关系\">反向代理 和 负载均衡 的关系？</h2>\n<p>什么是负载均衡？ 搭建多个tomcat服务器，在用户访问量大的时候，可以访问不同的tomcat，减少某个tomcat的访问压力</p>\n<p>在nginx中如果想实现负载均衡，需要借助反向代理机制</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:11:36', '2021-08-30 09:58:33');
INSERT INTO `tb_article` VALUES (231, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7448', 'Centos7安装JDK和Tomcat详细步骤', '<p>﻿</p>\n<p><strong>安装步骤</strong></p>\n<ol>\n<li>将JDK安装包上传到/opt下</li>\n<li>解压</li>\n<li>配置JDK的环境变量</li>\n<li>使配置生效</li>\n<li>测试JDK是否安装成功</li>\n</ol>\n<h4 id=\"1上传jdk安装包到centos系统中的opt目录下\">1.上传JDK安装包到Centos系统中的/opt目录下</h4>\n<p>1.1 使用xftp软件和服务器建立传输</p>\n<p><img src=\"https://img-blog.csdnimg.cn/201908020841059.png\" alt=\"[外链图片转存失败(img-CtHs62Ir-1564705402590)(assets\\1563577470477.png)]\" /></p>\n<p>1.2 建立会话</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084124185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-aak5tZci-1564705402592)(assets\\1563577590105.png)]\" /></p>\n<p>1.3 填写连接会话的参数</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084201723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-CTZFFQe9-1564705402594)(assets\\1563578003459.png)]\" /><br />\n<img src=\"https://img-blog.csdnimg.cn/20190802084218687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-QoTSsKd0-1564705402598)(assets\\1563578266172.png)]\" /></p>\n<p>1.4 上传JDK的安装包到Linux系统中的/opt目录下</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084249307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-XJtwQDjf-1564705402601)(assets\\1563578083307.png)]\" /></p>\n<h4 id=\"2对上传后的jdk进行解压操作\">2.对上传后的JDK进行解压操作</h4>\n<p>2.1 进入/opt目录，查看上传后的JDK安装包</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084321703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-n0qkNEmT-1564705402603)(assets\\1563578357662.png)]\" /></p>\n<p>2.2 使用tar命令对安装包进行解压安装操作</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084348488.png\" alt=\"[外链图片转存失败(img-sWXS2ocl-1564705402604)(assets\\1563578725269.png)]\" /></p>\n<p>2.3 解压后查看结果</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084400475.png\" alt=\"​	[外链图片转存失败(img-0JMcmAyB-1564705402604)(assets\\1563578770033.png)]\" /></p>\n<p>2.4 对解压包进行重命名，此步骤不是必须的，主要是为了方便后边配置环境变量</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084415519.png\" alt=\"[外链图片转存失败(img-WRGm8lhb-1564705402605)(assets\\1563578859303.png)]\" /></p>\n<h4 id=\"3配置环境变量\">3.配置环境变量</h4>\n<p>3.1 编辑/etc/profile文件</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084429531.png\" alt=\"[外链图片转存失败(img-B4O5MFI5-1564705402605)(assets\\1563579105923.png)]\" /></p>\n<p>3.2 来到profile文件末尾，按i进入编辑模式</p>\n<p>3.3 增加JAVA_HOME和PATH两个环境变量</p>\n<pre><code># JAVA_HOME\nexport JAVA_HOME=/opt/jdk1.8\n# PATH\nexport PATH=$PATH:$JAVA_HOME/bin\n解释： $PATH是获取本身已经配置的path环境变量   \n      :(冒号)是分隔符的作用，相当于windows系统中配置的逗号\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084914896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-ZNrtSdAZ-1564705402606)(assets\\1563579389001.png)]\" /></p>\n<p>编辑完成保存退出</p>\n<p>3.4 使用source命令配置文件生效</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802084942990.png\" alt=\"[外链图片转存失败(img-q9UO9DAk-1564705402607)(assets\\1563579423623.png)]\" /></p>\n<p>3.5 测试javac和java命令是否可用</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802085045546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-K7rZKudz-1564705402607)(assets\\1563579582383.png)]\" /></p>\n<p>使用java -version命令查看当前安装的jdk版本</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802085108870.png\" alt=\"[外链图片转存失败(img-VzAF0eDj-1564705402608)(assets\\1563579655693.png)]\" /></p>\n<p>到此，jdk1.8就算安装完成了，接下来安装tomcat</p>\n<h2 id=\"tomcat安装步骤\">Tomcat安装步骤：</h2>\n<ul>\n<li>上传tomcat到/opt下</li>\n<li>解压</li>\n<li>启动tomcat</li>\n<li>使用windows系统的浏览器访问Linux服务器的tomcat</li>\n</ul>\n<p><strong>1.上传tomcat到Linux系统的/opt目录下</strong><br />\n1.1 打开xftp连接到Linux系统上，将tomcat上传至/opt目录下<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085521524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>2.对于上传后的tomcat，进行解压安装</strong><br />\n2.1 查看上传后的tomcat，并且使用tar命令解压<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080208554144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2.2 查看解压后的tomcat<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085552895.png\" alt=\"在这里插入图片描述\" /><br />\n<strong>3.启动tomcat</strong><br />\n3.1 进入解压后的tomcat中bin子目录<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085615441.png\" alt=\"在这里插入图片描述\" /><br />\n3.2 执行./startup.sh命令启动tomcat<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085812211.png\" alt=\"在这里插入图片描述\" /><br />\n4.访问tomcat<br />\n4.1 在windows系统中打开浏览器输入 <a href=\"http://ip:8080\">http://ip:8080</a> 访问已经启动的tomcat<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085914846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>注意事项：如果不能访问就关闭linux系统的防火墙</strong><br />\nsystemctl stop firewalld<br />\n<img src=\"https://img-blog.csdnimg.cn/20190802085941311.png\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:12:15', '2020-10-07 13:06:41');
INSERT INTO `tb_article` VALUES (232, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3710', 'Centos7安装Nginx详细安装步骤', '<p>﻿</p>\n<h2 id=\"centos7安装nginx步骤\">Centos7安装Nginx步骤</h2>\n<ol>\n<li>手动配置nginx的yum仓库</li>\n<li>使用yum命令安装nginx</li>\n<li>启动nginx</li>\n<li>访问nginx</li>\n</ol>\n<h4 id=\"1指定nginx的yum仓库\">1.指定nginx的yum仓库</h4>\n<p>说明：centos系统中默认的yum仓库中没有nginx的安装包，<br />\n<strong>所以要想安装nginx需要单独指定它的仓库地址</strong></p>\n<p>1.1 将nginx.repo上传到Linux服务器下的/etc/yum.repos.d/下</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095154684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-Le4aM6gZ-1564710569597)(assets\\1563680660832.png)]\" /></p>\n<p>nginx.repo文件内容说明（了解）：</p>\n<p>name=     #一个描述，随意。<br />\nbaseurl=   #设置资源库的地址<br />\ngpkcheck=0 表示对从这个源下载的rpm包不进行校验  ， 1是校验；<br />\nenable=1 表示启用这个源 ， 0是禁用。</p>\n<pre><code class=\"language-xml\">[nginx]\nname=nginx repo\nbaseurl=http://nginx.org/packages/centos/7/x86_64/\ngpgcheck=0\nenabled=1\n</code></pre>\n<h4 id=\"2安装nginx\">2.安装nginx</h4>\n<p>2.1 使用yum install nginx 安装nginx</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095217158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-XwWjM2JW-1564710569604)(assets\\1563681894366.png)]\" /></p>\n<p>输入y</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095227875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-tPhk5gH7-1564710569604)(assets\\1563681901148.png)]\" /></p>\n<p>安装完成</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095238959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-xfGPm3C9-1564710569605)(assets\\1563681914220.png)]\" /></p>\n<p>可以查看whereis nginx查看安装位置</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095250383.png\" alt=\"[外链图片转存失败(img-sL0CGaE1-1564710569606)(assets\\1563681972621.png)]\" /></p>\n<p>nginx安装配置文件位置(重要):</p>\n<p>配置文件位置: /etc/nginx/nginx.conf</p>\n<p>配置文件路径: /etc/nginx/conf.d/default.conf (默认加载)</p>\n<h3 id=\"3启动nginx\">3.启动nginx</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095304135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-nrRDw8Jq-1564710569606)(assets\\1563682067852.png)]\" /></p>\n<p>启动Nginx<br />\nsystemctl start nginx<br />\n停止Nginx<br />\nsystemctl stop nginx<br />\n查看Nginx启动状态<br />\nsystemctl status nginx</p>\n<h4 id=\"4访问nginx\">4.访问nginx</h4>\n<p>在windows中打开浏览器输入<a href=\"http://ip:80\">http://ip:80</a></p>\n<p>说明：80是http协议的默认端口号，当端口号为80时可以省略不写</p>\n<p>[外链图片转存失败(img-vgBkRSr7-1564710569607)(assets\\1563711413922.png)]</p>\n<p><a href=\"p://ip:80\">p://ip:80</a></p>\n<p>说明：80是http协议的默认端口号，当端口号为80时可以省略不写</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095346272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存中...(img-vgBkRSr7-1564710569607)]\" /><br />\n到此，Centos7安装Nginx就完成啦</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:12:18', '2020-10-07 13:06:06');
INSERT INTO `tb_article` VALUES (233, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=2777', 'Yum命令使用，使用yum安装vim案例演示yum的使用', '<p>﻿</p>\n<h4 id=\"何为yum-\">何为Yum ?</h4>\n<p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。</p>\n<p>基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>\n<p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>\n<blockquote>\n<p>简单说：从指定服务器自动下载并安装，使用简单方便</p>\n</blockquote>\n<p>1.安装指定的软件命令：yum install &lt;package_name&gt;</p>\n<p>2.更新指定的软件命令：yum update &lt;package_name&gt;</p>\n<p>3.删除软件包命令：yum remove &lt;package_name&gt;</p>\n<p>4.查找软件包 命令：yum search <keyword></p>\n<p>5.列出所有可安裝的软件清单命令：yum list</p>\n<h4 id=\"下边以vim的安装为例演示yum的使用\">下边以Vim的安装为例，演示Yum的使用</h4>\n<p>Vim是一个类似于Vi的著名的功能强大、高度可定制的文本编辑器，在Vi的基础上改进和增加了很多特性。</p>\n<p>1.1 使用Yum命令安装Vim</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095654938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-PZSCRNhs-1564710956716)(assets\\1563677444298.png)]\" /></p>\n<p>1.2 输入y，确定安装</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095716576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-cEviKAHX-1564710956718)(assets\\1563677490574.png)]\" /></p>\n<p>再输入一个y</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095725494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-IhB43gIF-1564710956718)(assets\\1563677545056.png)]\" /></p>\n<p>出现这个提示说明vim ，以及vim需要的依赖都安装完成</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095738125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-DdonWFH8-1564710956721)(assets\\1563677584819.png)]\" /></p>\n<p>1.3 通过vim命令修改某个文件，可以发现内容有颜色，说明vim已经正常安装并且可以使用了</p>\n<p>​      此处主要是为了介绍yum安装，vim的使用不再介绍，vim的基本使用和vi是一样</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095750451.png\" alt=\"[外链图片转存失败(img-Zc1KZtCS-1564710956723)(assets\\1563677748821.png)]\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/201908020958026.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-oXMPAesr-1564710956726)(assets\\1563677754841.png)]\" /></p>\n<h4 id=\"yum安装的原理介绍\">yum安装的原理介绍</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190802095812908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-wqcOkbSo-1564710956727)(assets\\1563679844231.png)]\" /></p>\n', 1, '', 0, 0, 1, '2020-09-29 17:24:57', '2020-12-19 17:11:42');
INSERT INTO `tb_article` VALUES (234, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=656', 'Spring boot 整合mybatis报错ClassNotFoundException_ org.mybatis.logging.LoggerFactory', '<p>﻿<strong>使用spring boot整合mybatis需要加入依赖：</strong></p>\n<pre><code>&lt;dependency&gt;\n      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n      &lt;version&gt;1.3.2&lt;/version&gt;\n    &lt;/dependency&gt;\n</code></pre>\n<p>这时候项目是没有任何问题的，正常运行！</p>\n<h2 id=\"但是\">但是</h2>\n<p>但是后来我使用<strong>Lombok</strong>和<strong>MyBatis-Plus</strong>进行开发，然后就引入了一个叫做<strong>mybatis-plus-boot-starter</strong>的依赖，再次运行测试的时候就一直报错：</p>\n<p>java.lang.IllegalStateException: Failed to load ApplicationContext</p>\n<p><strong>Caused by: java.lang.ClassNotFoundException: org.mybatis.logging.LoggerFactory</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190806202954276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n百度了一下其他人说是少了commons-logging 的jar包，我加上后依旧报错</p>\n<p>有人说是少了slf4j-api的jar包，我加上后也是依旧报错。</p>\n<p><strong>还有人说是少了mybatis-plus-boot-starter</strong>，到这里我似乎发现了什么，<br />\n<strong>使用mybatis-plus是让spring boot集成了mybatis，那么我在上面配置的mybatis-spring-boot-starter这个jar同样是集成mybatis的，这两个会不会有冲突？或者是因为这个jar导致了下面的mybatis-plus报错？</strong></p>\n<p>抱着试试的态度，我把mybatis-spring-boot-starter这个jar注释掉然后再运行，</p>\n<h2 id=\"然后就\">然后就，</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190806203918945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"大功告成\">大功告成！</h2>\n<p>后来我又测试，如果没有mybatis-plus提供的</p>\n<pre><code>   &lt;dependency&gt;\n        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n        &lt;version&gt;3.1.2&lt;/version&gt;\n    &lt;/dependency&gt;\n</code></pre>\n<p>这个依赖的话，同样会报ClassNotFoundException: org.mybatis.logging.LoggerFactory这个错！</p>\n<p>所以就能确定我的错误原因了！</p>\n<p>最后附一个lombok常用注解：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190806204243388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:12:32', '2020-10-07 13:05:32');
INSERT INTO `tb_article` VALUES (235, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=453', 'Centos 7搭建MySQL-主从复制', '<p>﻿## 什么是主从复制?</p>\n<p>如果数据库服务器一旦宕机，我们的项目将无法运行，如果数据库服务器硬盘损坏还将面临数据丢失的问题!!!</p>\n<p><strong>将MySQL数据库主机的数据复制到MySQL从机上(备份)</strong></p>\n<p>原理：将MySQL主机的SQL语句以日志的方式记录下来，通过网络将日志文件复制到从机上，执行日志中的SQL语句同步主机的操作和数据</p>\n<p>搭建步骤</p>\n<ol>\n<li>创建三台Linux服务器</li>\n<li>分别安装MySQL数据库</li>\n<li>配置主节点（Mysql主机操作）</li>\n<li>配置从节点（Mysql从机操作）</li>\n</ol>\n<h4 id=\"1搭建三台linux服务器\">1.搭建三台Linux服务器</h4>\n<p>一台作为mysql数据库的主节点(master)</p>\n<p>另外两台作为mysql数据库的从节点(slave)</p>\n<h4 id=\"2分别安装mysql数据库\">2.分别安装mysql数据库</h4>\n<p>说明：可以先安装一台，然后在克隆两台</p>\n<p>2.1 上传mysql的yum源</p>\n<p>2.2 使用yum install 命令安装</p>\n<p>2.3 启动mysql数据库，修改密码，设置允许远程访问</p>\n<p>2.4 关闭防火墙</p>\n<p>或者上传rpm安装包离线安装</p>\n<p>可参考之前文章Linux上安装mysql教程：<br />\n<a href=\"https://blog.csdn.net/MacWx/article/details/98171109\">https://blog.csdn.net/MacWx/article/details/98171109</a></p>\n<h4 id=\"3配置主从\">3.配置主从</h4>\n<p>3.1 在主节点（也就是Mysql主机）</p>\n<p>vi /etc/my.cnf</p>\n<p>增加</p>\n<pre><code>server-id=132\nlog_bin\n\n#需要同步的数据库\nbinlog-do-db=baizhi\n#忽略(不需要)同步的数据库\nbinlog-ignore-db=mysql\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807193853293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-EzkAqLnM-1565177567068)(assets\\1563789758573.png)]\" /></p>\n<p>重启主节点的mysql数据库</p>\n<p>登录，查看主机状态</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194339252.png\" alt=\"[外链图片转存失败(img-KKS7eoUF-1565177567069)(assets\\1563789882250.png)]\" /></p>\n<p>3.2 从节点</p>\n<p>说明：如果是克隆的需要先删除从机上的/var/lib/mysql/auto.cnf文件</p>\n<pre><code>rm -f  /var/lib/mysql/auto.cnf\n</code></pre>\n<p>vi /etc/my.cnf</p>\n<p>增加</p>\n<pre><code>server-id=133\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2019080719440416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-R1q40Q0I-1565177567069)(assets\\1563789981959.png)]\" /></p>\n<p>重启mysql数据库       systemctl restart mysqld</p>\n<p>登录mysql数据库       mysql -uroot -p</p>\n<p>关闭从机状态              stop slave</p>\n<p>设置和主机建立连接</p>\n<p>语法</p>\n<pre><code>change master to master_host=\'主机ip地址\',master_user=主机用户名,master_password=主机密码,master_log_file=\'主机日志文件名\',master_log_pos=日志文件的位置\n</code></pre>\n<p>示例</p>\n<pre><code>change master to master_host=’192.168.152.133’,master_user=’root’,master_password=’123456’,master_log_file=’mysqld-bin.000001’,master_log_pos=241\n</code></pre>\n<p>查看从机状态              show slave status \\G;</p>\n<h4 id=\"4测试\">4.测试</h4>\n<p>在主节点创建一个叫做baizhi的数据库，然后在该数据库中创建一张表，添加一条测试数据</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194430611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-GOAwJ4fR-1565177567070)(assets\\1563868813155.png)]\" /></p>\n<p>在从节点查看</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194442918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-UwygxUPF-1565177567071)(assets\\1563868782868.png)]\" /></p>\n<p>看到我们在Mysql主机添加一条记录，从机也有了相应的记录，这就实现了mysql的主从复制！</p>\n', 1, '', 0, 0, 1, '2020-10-07 13:03:14', '2020-12-21 14:50:26');
INSERT INTO `tb_article` VALUES (236, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3599', 'Centos 7使用MyCat搭建 MySQL-读写分离', '<p>﻿</p>\n<h2 id=\"什么是读写分离\">什么是读写分离?</h2>\n<p>只有mysql的主机接收增删改SQL语句，从机接收查询语句，分担主机的查询压力</p>\n<p><strong>搭建步骤</strong></p>\n<ol>\n<li>新建一台Linux服务器、关闭防火墙</li>\n<li>上传mycat的安装包到服务器、解压安装</li>\n<li>配置mycat的环境变量</li>\n<li>修改mycat的server.xml和schema.xml配置文件</li>\n<li>启动mycat</li>\n<li>测试</li>\n</ol>\n<h4 id=\"1上传mycat安装包到-usr目录下\">1.上传mycat安装包到 /usr目录下</h4>\n<p>使用Shell上传文件<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807194804651.png\" alt=\"[外链图片转存失败(img-RxcePQqK-1565178387515)(assets\\1563939118812.png)]\" /></p>\n<h4 id=\"2解压安装\">2.解压安装</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194829867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-azuw4Fis-1565178387516)(assets\\1563939127063.png)]\" /></p>\n<h4 id=\"3配置环境变量\">3.配置环境变量</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194842945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-M3lz6kTq-1565178387517)(assets\\1563939234079.png)]\" /></p>\n<p>在profile文件中添加以下内容：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807194853939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-0SxjIG8z-1565178387518)(assets\\1563939258590.png)]\" /></p>\n<p>使用source使profile生效</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019080719491061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-KlZcok9I-1565178387524)(assets\\1563939334854.png)]\" /><br />\n测试mycat命令已经可以正常使用！！！<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807195045279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"4修改mycat的配置文件\">4.修改mycat的配置文件</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195058987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-Y5sHEbse-1565178387525)(assets\\1563939427059.png)]\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195118274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-ggyxZ0dJ-1565178387525)(assets\\1563939587312.png)]\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195134837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-ukQkcW8t-1565178387526)(assets\\1563939932919.png)]\" /></p>\n<p>关闭防火墙</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195145851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-ZtqO2hDx-1565178387526)(assets\\1563939991140.png)]\" /></p>\n<p>测试<br />\n在windows主机上使用navicat连接mysql进行测试<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807195203899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败(img-QsAmFHId-1565178387527)(assets\\1563940150731.png)]\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807195304645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>连接成功后我们之后再进行增删改查操作就可以只连接mycat主机进行操作</strong>，mycat会自动的进行对mysql的主机接收增删改SQL语句，从机接收查询语句，分担主机的查询压力。</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:09', '2020-10-07 13:02:54');
INSERT INTO `tb_article` VALUES (237, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1587', 'Linux 常用基本命令总结', '<p>﻿## Linux 常用基本命令总结</p>\n<p>1.1  <strong>ls</strong><br />\n作用：查看目录下的所有文件</p>\n<p>ls -a    -后边的参数   命令可以跟参数<br />\n作用：可以查询被隐藏的文件<br />\n<strong>ls -l</strong><br />\n作用：查看文件的详细信息</p>\n<p>通常我们结合起来使用：<br />\n查询文件夹下的全部文件信息：<strong>ls -la</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203216430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\nr:可读权限<br />\nw：可写权限<br />\nx：可执行权限</p>\n<p>三个为一组，其中前三个为当前用户对该文件的权限<br />\n中间三个为root管理员用户的权限<br />\n最后三个是其他用户的权限</p>\n<p>例如，如果设置为只可读：r--<br />\n只可读写：rw-<br />\n等<br />\n1.2 <strong>cd  切换目录</strong></p>\n<p>绝对路径   以 /  开头<br />\n相对路径   从当前所在的目录开始</p>\n<p>cd .   一个.代表当前目录<br />\ncd ..   两个..代表上一级目录<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080720354164.png\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>1.3 mkdir</strong><br />\n作用：创建文件夹<br />\n用法： mkdir  文件夹名称(可以是相对或者绝对路径)<br />\nmkdir  a1  在当前文件夹中创建a1文件夹<br />\nmkdir -p a1/b1  创建b1文件夹，如果父文件夹不存在可以一并创建</p>\n<p><strong>1.4 touch</strong>   (了解)<br />\n作用：创建空白文件<br />\ntouch 1.txt  创建一个空白的1.txt文件</p>\n<p><strong>1.5 echo</strong><br />\n作用：打印<br />\necho hello   向控制台打印hello字符串</p>\n<p><strong>1.6  &gt;  &gt;&gt;</strong><br />\n作用：指定输出的文件<br />\necho hello &gt; 1.txt  向1.txt文件中输出hello<br />\n区别 &gt; 是覆盖原有文件的内容  &gt;&gt; 在原有文件中追加新的内容</p>\n<p><strong>1.7 cat</strong><br />\n作用：查看文件内容<br />\ncat  1.txt  在控制台打印1.txt文件中的内容</p>\n<p><strong>1.8 cp</strong><br />\n作用：复制<br />\n在tmp目录下创建一个文件1.txt<br />\n[root@localhost  tmp] cp  1.txt  /1.txt  将当前目录下的1.txt 复制到根目录下</p>\n<p><strong>1.9 mv</strong><br />\n作用：移动和重命名<br />\n[root@localhost  tmp] mv  1.txt  2.txt  将当前目录下的1.txt 重命名为2.txt<br />\n[root@localhost  tmp] mv  2.txt  /     将当前目录下的2.txt 移动到 跟目录下</p>\n<p><strong>2.0 rm</strong><br />\n作用：删除<br />\n有询问的删除!!<br />\nrm 文件名<br />\nrm -r 文件夹      -r 是递归<br />\n不带询问的删除 -f<br />\nrm -f 文件名    直接删除文件，不询问<br />\nrm -rf 文件夹    直接删除文件夹，不询问</p>\n<p><strong>2.2 pwd</strong><br />\n作用：打印当前所在的目录路径<br />\n可以获取当前路径进行复制使用<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080720355591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2.3 cat、more、less、head、tail</strong><br />\n作用：查看文件的内容<br />\ncat特点：展示文件中所有内容</p>\n<p>more和less 特点：分页展示文件中内容<br />\n回车往下一行 ，空格往下翻一页</p>\n<pre><code> more只能往下翻， less还可以通过键盘上的上下键 上下翻\n 使用less查看，使用q键退出查看\n</code></pre>\n<p>head特点：查看文件的前n行<br />\nhead  -n  5  /etc/profile  查看文件的前5行</p>\n<p>tail特点：查看文件的最后几行<br />\ntail的特殊作用：查看日志文件 tail -f xxx.txt  可以监听文件，打印出新生产的日志信息</p>\n<p><strong>2.3 tab键</strong>  （键盘上的一个快捷键）<br />\n作用：自动补全命令 文件路径等<br />\n<img src=\"https://img-blog.csdnimg.cn/2019080720361717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2.4 grep</strong><br />\n作用：根据关键字查找<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203652730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>2.5 find</strong><br />\n作用：从系统中进行查找<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203702947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>2.6 systemctl  (system control)</strong><br />\n作用：开启、关闭、查看、重启系统的服务<br />\n语法：systemctl  start     服务名<br />\nsystemctl  restart   服务名<br />\nsystemctl  stop     服务名<br />\nsystemctl  status    服务名</p>\n<p>例如：以防火墙为例，进行服务器的开启，关闭等操作</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807203715174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>在centos6  services iptables stop  (了解)<br />\n重启虚拟机防火墙会自动开启</p>\n<p>在实际的阿里云服务器中可以不关闭防火墙，只开启指定端口(通过图形界面完成)</p>\n<p><strong>2.7 ps -ef</strong><br />\n作用：查看虚拟机正在运行的进程<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203737801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2.8 kill -9 进程id</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807203800657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n如果当前虚拟机ip丢失，dhclient命令又无法使用<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203811609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>3.0 tar 命令</strong><br />\n作用：对文件进行压缩和解压缩操作<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807203821896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"2vi编辑器\">2.VI编辑器</h2>\n<p>作用：linux操作的一款编辑器，只能用键盘操作，无法使用鼠标</p>\n<p>使用 vi 文件名     进入vi编辑器<br />\n输入i、A、a、O、o都可进入编辑模式，进入编辑模式左下角会变成insert<br />\n按下Esc键盘左上角的退出键退出编辑模式<br />\n：冒号进入末行模式<br />\nq，不保存退出vi<br />\nq! ,不保存强制退出<br />\nwq保存退出vi<br />\nwq！，保存并强制退出</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019080720390785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"命令补充\">命令补充</h2>\n<p>权限相关：groupadd  组名<br />\nuseradd -g 组名 用户名<br />\npasswd 用户名<br />\nsu 用户名<br />\nchmod u=rwx,g=rwx,o=rwx 文件</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:13', '2020-10-07 13:01:43');
INSERT INTO `tb_article` VALUES (238, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5287', 'Redis数据库的介绍、安装、数据结构、常用命令', '<p>﻿## 1、 redis是什么呢？</p>\n<p>redis是非关系型数据库(nosql)，基于内存读写的数据库,采用key-value的方式存储数据<br />\n<strong>nosql：  not noly sql</strong> ，没有表的SQL</p>\n<p>在目前的企业开发中会用关系型数据库（Oracale+MySQL）+非关系型数据库(Redis 、MongoDB、Memcache)共同开发项目</p>\n<p><strong>为什么使用NoSQL</strong></p>\n<p>现在存在数据格式非常多样，不适合应用表格进行存储。<br />\n表格数据称之为 结构化数据<br />\n非表格数据称之为 半结构化 （kv json)  非结构化数据 音频 视频</p>\n<p>Redis是基于内存读写的数据库，<br />\n硬盘读取速度 大约几百M<br />\n内存读取速度 大约 上千M<br />\n所以Redis相对来说是要比关系型数据库要快很多</p>\n<p>Redis的应用场景：查询读取操作非常频繁的业务<br />\n例如：缓存</p>\n<h2 id=\"2redis的下载安装\">2、Redis的下载安装</h2>\n<p>Redis可从<br />\n<a href=\"https://redis.io/download\">https://redis.io/download</a><br />\n官网进行下载，有windows版和linux版，<br />\n都是下载直接解压就可使用<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807210547190.png\" alt=\"在这里插入图片描述\" /><br />\n解压后的目录如下：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807211247767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n不过需要注意的是：<br />\n在windows系统上，我们要修改redis.windows.conf这个文件，将appendonly no改为appendonly yes<br />\n因为redis是忘往内存上面存储数据的，改完这个可以使数据直接同步到硬盘上。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807211152164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n而启动的时候也不要双击redis-server.exe进行启动，因为这样启动是不能加载到redis.windows.conf这个配置文件的，<br />\n所以启动的时候我们要在redis解压的目录下进入cmd，<br />\n输入：redis-server  redis.windows.conf  启动redis服务<br />\n如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807211617774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n这样就启动了Redis服务，再双击redis-cli.exe就启动了Redis的客户端</p>\n<p>Linux系统下启动Redis服务要进到解压目录的src下，<br />\n输入./redis-server  ../redis.conf<br />\n进行启动，如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190807212204837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"3redis的数据结构常用命令\">3、Redis的数据结构、常用命令</h2>\n<p><strong>redis数据库存储数据使用的key-value</strong><br />\n<strong>key是string类型  value的数据结构支持5个string、set、sorted_set、list、hash</strong></p>\n<p>value最大占用空间 1GB<br />\nredis支持的数据结构比较丰富、对不同的数据结构，还拥有不同的操作命令</p>\n<p>set、get、del<br />\nkeys *  打印所有的key</p>\n<p>基础命令 （key value）</p>\n<p>keys *</p>\n<p>命令的作用：显示redis中 所有的key<br />\nkeys  name*  name后面可以有0---多个任意字符<br />\nkeys  name?  name后面必须只存在一个字符</p>\n<p><strong>exists key</strong><br />\n判断 key是否存在 若返回 1 则存在 0 不存在</p>\n<p><strong>del key</strong><br />\n作用：删除 某一个key</p>\n<p><strong>help 命令</strong><br />\n帮助命令</p>\n<p><strong>flushall</strong> 清空所有数据库中的内容</p>\n<p>退出 <strong>exit|quit</strong> 退出redis的服务器</p>\n<h2 id=\"redis中值是字符串类型-string-数字\">Redis中值是字符串类型 （String 数字）</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213239589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>set</strong><br />\n用于设置 一个字符串类型的  key value</p>\n<p><strong>get</strong><br />\n根据key获取值</p>\n<p><strong>mset</strong><br />\n一次性设置多个 key value</p>\n<p>mget<br />\nstrlen<br />\nappend<br />\ngetrange 截取子串<br />\ngetrange name 0 3<br />\nsetex 设置一个key的存活有效期 (秒) psetex 作用与 setex 一致 但是毫秒<br />\nsetnx<br />\n如果当前没有这个key的话 那么 setnx等价于 set命令<br />\n如果当前存在这个key的话 那么 setnx不起作用<br />\ndecr 针对数字类型 做 -1操作 另外 desr key 数字 根据数字做减法操作<br />\nincr incrby incrbyfloat</p>\n<blockquote>\n<p>应用场景：缓存查询结果(json或者序列化) 用户访问记录 例如：通过记录ip-访问次数来显示ip的访问<br />\n统计粉丝数、点击次数、点赞</p>\n</blockquote>\n<h2 id=\"redis中值是set类型在这里插入图片描述\">Redis中值是set类型<img src=\"https://img-blog.csdnimg.cn/20190807213452727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></h2>\n<h2 id=\"c-list类型的数据操作的命令\">c) List类型的数据操作的命令</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213545465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\ni.	lpush 栈式结构<br />\nlpush name suns[2]<br />\nlpush name xiaohei[1]<br />\nlpush name xiaowb[0]<br />\nii.	lpushx 如果操作的key不存在 则不起作用<br />\n如果操作的key存在 则等同于lpush<br />\niii.	rpush 操作的内容 等效 java List<br />\n第一个操作的元素 就放置在第一个位置<br />\n依次类推<br />\n应用场景：关注列表、消息队列</p>\n<h2 id=\"hash类型的数据操作的命令\">hash类型的数据操作的命令</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213752596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"zset-sorted-set类型的数据操作的命令\">zset (sorted_set)类型的数据操作的命令</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213813240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"7-redis命令的补充部分\">7. Redis命令的补充部分</h2>\n<p>a)	只有set命令 可以操作 任意类型的数据</p>\n<p>b)	注意Redis中会有数据库概念 默认存在16数据库 0 ---- 15</p>\n<p>默认所使用的数据库 0 如果要选择使用别的数据库 select 编号</p>\n<p>注意：不同数据库所创建的key 相互隔离 互补干扰的。通过flushall 清空的是所有数据库中的key. 清空当前的数据库 flushdb这个命令<br />\n如何该表Redis中对于数据库的支持呢？编辑 redis.conf</p>\n<p>**	expire相关命令  （促销 秒杀  手机验证码倒计时 排行榜  Cache）**<br />\ni.	在Redis创建key value 默认都是持久化的 永久保存。<br />\nii.	可以通过expire 命令 指定 key 存活时间<br />\nexpire key seconds</p>\n<p><strong>查看某一个key的存活时常</strong><br />\npersist 作用 可以把 一个应用了expire命令key 再次转换持久化的key<br />\nexpireat key  unix 时间戳 毫秒数iii.</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190807213646467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:20', '2021-08-30 09:57:06');
INSERT INTO `tb_article` VALUES (239, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3289', '面试题：说一下HashMap和HashSet的实现原理？', '<p>﻿## HashMap 的实现原理：</p>\n<p><strong>HashMap是基于Hash算法实现的，</strong><br />\n我们通过put（key，value）存储数据，通过get（key）来获取数据</p>\n<p>当传入key时，HashMap会根据Key.hashCode()计算出Hash值，根据Hash值将value保存在bucket里	，。</p>\n<p><strong>当计算出相同的Hash值时，我们称之为Hash冲突</strong>，HashMap 的做法是用链表和红黑树存储相同Hash值的value，<br />\n当hash冲突的个数比较少时，使用链表存储，<br />\n否则使用红黑树。</p>\n<h2 id=\"hashset-的实现原理\">HashSet 的实现原理：</h2>\n<p>HashSet是基于HashMap实现的，HashSet 底层使用HashMap来保存所有元素，<br />\n因此HashSet 的实现比较简单，相关HashSet 的操作，基本上都是直接调用底层HashMap的相关方法来完成，HashSet不允许有重复的值，并且元素是无序的。</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:25', '2021-08-30 09:53:48');
INSERT INTO `tb_article` VALUES (240, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=2731', '多线程相关面试题_并行和并发的区别、线程和进程、线程的创建方式、运行状态', '<p>﻿<strong>1，并行和并发有什么区别</strong></p>\n<p>并行：多个处理器或多核处理器同时处理多个任务。<br />\n并发：多个任务在同一个CPU核上，按细分的时间片轮流（交替）执行，从逻辑上来看并发的任务是同时执行；</p>\n<p>简而言之：<br />\n并发=两个队列和一台处理器<br />\n并发=两个队列和两个处理器</p>\n<p><strong>2、线程和进程的区别</strong></p>\n<p>一个程序下至少有一个进程，<br />\n一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p>\n<p><strong>3.守护线程是什么?</strong></p>\n<p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在Java中垃圾回收线程就是特殊的守护线程。</p>\n<p><strong>4.创建线程有哪几种方式?</strong></p>\n<p>创建线程有三种方式:</p>\n<pre><code>  ●继承Thread重写run方法;\n\n  ●实现Runnable接口;\n\n  ●实现Callable接口。\n</code></pre>\n<p><strong>5.线程有哪些状态?线程的状态:</strong></p>\n<pre><code>   NEW尚未启动\n\n   RUNNABLE正在执行中\n\n   BLOCKED阻塞的(被同步锁或者I0锁阻塞)\n\n   WAITING永久等待状态\n\n  TIMED_ WAITING 等待指定的时间重新被唤醒的状态\n</code></pre>\n<p><strong>6，sleep（）和 wait（）的区别</strong></p>\n<p>类的不同，sleep（）来自Thred ，wait（）来着Object，<br />\n释放锁，sleep（）不释放锁，而wait（）释放锁<br />\n用法不同，sleep（）到时间会自动醒来，自动回复线程，而wait（）需要用notify（）/  notifyAll()来唤醒线程。</p>\n<p><strong>7，线程的run（）和start（）方法有什么区别</strong></p>\n<p>start（）方法用于启动线程，<br />\nrun（）方法用于执行线程的运行时代码，<br />\nrun（）可以重复使用，而start（）只能调用一次。</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:52', '2021-08-30 09:53:36');
INSERT INTO `tb_article` VALUES (241, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4016', 'tomcat集群环境下如何保证session一致性', '<p>﻿## 为什么集群环境下，会出现session不一致问题？</p>\n<p>答：使用nginx的负载均衡之后，不确定访问哪个tomcat，导致客户端存储的jsessionid携带到集群环境下的其他tomcat是无效的。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811142904838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>关于集群环境下，解决session不一致问题?</strong></p>\n<p>方式1：负载均衡的策略ip黏着：在nginx的default.conf配置<strong>ip_hash</strong>,这样客户端会固定的访问某一台服务器</p>\n<p>方式2：使用redis管理集群环境的session，session对象不在存储在tomcat服务器，而是redis数据库中,如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811143147501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n<strong>实现原理描述:</strong><br />\n客户端访问nginx，分配到tomcat-1服务器，创建session对象，jsessionid,将jsessionid作为key，session对象作为value存到redis数据库中，随着响应将jsessionid返回给客户端浏览器，该客户端浏览器向nginx在次发出请求，写cookie(包含jsessionid),到nginx后被分配到tomcat-2服务器，tomcat-2获取cookie中的jsessionid，去redis数据库查找对应的session对象并且返回使用</p>\n<h2 id=\"实现步骤\">实现步骤：</h2>\n<p>1.将下边三个jar上传到tomcat服务器中的lib目录下<br />\n要重写tomcat的session实现方法，将session管理到redis服务器中<br />\n如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811143509147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n2. 修改tomcat中conf目录下的context.xml<br />\n原因1：我们上传的jar中的类，替换了tomcat中的代码，需要让tomcat知道我们的类叫什么名字<br />\n原因2：配置redis数据库所在服务器的ip地址和redis数据库的端口号</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190811143631510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n3. 重启tomcat服务<br />\n进入bin目录 ,先执行./shutdown.sh 再执行./startup.sh</p>\n<p>注意：以上操作集群中的tomcat(有几个就操作几个)都是相同的操作</p>\n<p>4，测试<br />\n做一个登陆页面，测试一下上面的操作有没有成功</p>\n', 1, '', 0, 0, 1, '2020-04-25 17:13:58', '2020-12-21 14:52:10');
INSERT INTO `tb_article` VALUES (242, 1, 5, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8390', 'mybatis的二级缓存，以及如何利用redis优化mybatis缓存？', '<p>﻿学习redis，缓存是很重要的一块</p>\n<p><strong>1.1 为什么要使用缓存？</strong></p>\n<p>为mybatis增加缓存功能，可有利用减少数据库访问</p>\n<p>系统运行的瓶颈很重要的一个因素就是数据库，<br />\n减少数据库的访问压力，可以提高整个系统的吞吐量。</p>\n<p><strong>什么是缓存？</strong></p>\n<p>将SQL语句，以及对应的查询结果存在服务器内存中，这一块内存存储区域，被我们称之为缓存。</p>\n<p>如果之后再执行该同样的SQL语句，则直接从缓存中去取，不再去查询数据库，可减小数据库的访问压力。</p>\n<p><strong>缓存的核心使用思路</strong></p>\n<ol>\n<li>开启缓存</li>\n<li>缓存的作用范围 缓存中的数据可以使用的范围</li>\n<li>脏数据的处理<br />\n脏数据：缓存是数据库中热点数据的备份，当数据库中的热点数据发生变化时，缓存也要和数据库保持一致，否则相应的数据成为脏数据。</li>\n</ol>\n<h2 id=\"12-mybatis现有的缓存\">1.2 mybatis现有的缓存</h2>\n<p><strong>mybatis的缓存分成一级缓存和二级缓存</strong></p>\n<p>一级缓存也称之为SqlSession级别的缓存，默认开启，只一次查询有效，作用范围太小，意义不大。<br />\n脏数据的处理 ：执行增删改有可能造成脏数据，一旦执行增删改立刻清空缓存。</p>\n<p>二级缓存称之为SqlSessionFactory级别的缓存,<br />\n通常我们所说的缓存默认指的就是二级缓存。</p>\n<p>二级缓存使用步骤</p>\n<ol>\n<li>开启二级缓存 (如果和spring整合，默认已经开启)<br />\n若没有，要在mybatis-config.xml中配置一下信息：</li>\n</ol>\n<pre><code>&lt;settings&gt;\n	&lt;setting name = &quot;cacheEnabled&quot;  value=&quot;true&quot; /&gt; \n&lt;/settings&gt;\n</code></pre>\n<ol start=\"2\">\n<li>在mapper文件增加 &lt; cache/&gt;</li>\n</ol>\n<p>*Mapper.xml中配置：</p>\n<pre><code>&lt;cache /&gt;\n</code></pre>\n<p>只有添加了cache标签的mapper文件中的查询结果才会放置到对应的二级缓存中</p>\n<ol start=\"3\">\n<li>\n<p>将需要存储到缓存中的对象实现序列化接口</p>\n</li>\n<li>\n<p>二级缓存作用范围<br />\n同1个namespace下</p>\n</li>\n<li>\n<p>脏数据的处理<br />\n执行同1个namespace下的增删改，自动清空该namespace下的缓存</p>\n</li>\n</ol>\n<p>内置的二级缓存通常也不用。<br />\n内置的二级缓存本身有namespace的问题，并且不支持持久化。<br />\n所以平时主要用：Ehcache 独立的缓存组件，使用纯Java编写。<br />\n准备工作：引入相关jar包 ehcache-core.jar   mybatis-ehcache.jar</p>\n<p>使用步骤：</p>\n<ol>\n<li>开启 缓存，Config.xml中配置和上面一样</li>\n<li>mapper.xml中配置，cache标签要加一个type属性指向我们自定义的cache<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081115082521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></li>\n<li>src下添加ehcache.xml<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811150937127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\nEncache作用于整个项目中 。<br />\n对脏数据的处理：执行增删改，立刻清空缓存中的数据。</li>\n</ol>\n<p>注意：低版本的mybatis配合ehcache有问题，需要升级mybatis到3.2以上<br />\n另外ehcache.xml 需要添加updateCheck=”false” 禁用检查更新<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811151048191.png\" alt=\"在这里插入图片描述\" /></p>\n<p>说了这么多，</p>\n<h2 id=\"如何使用redis优化mybatis缓存\">如何使用redis优化mybatis缓存</h2>\n<p>mybatis已经实现了二级缓存，为什么使用redis对其优化？？？</p>\n<p>mybatis本身二级缓存的查询结果要存储在当前服务器的JVM虚拟机中，如果缓存的数据量过大会造成jvm服务器臃肿缓慢，大量占用内存空间。</p>\n<p>所以我们最好将缓存的数据从tomcat服务器上转移到redis服务器上，redis存取速度快，并且是一个独立进程和jvm没有关系。</p>\n<p><strong>实现步骤</strong></p>\n<ol>\n<li>添加jar包<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081115272444.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在mapper文件中，增加自定义二级缓存的实现类配置<br />\n<img src=\"https://img-blog.csdnimg.cn/2019081115302038.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></li>\n<li>在src下，增加一个redis.properties配置文件，指明要连接redis数据库的ip和端口号<br />\n默认是连接本地的redis<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811153210940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n总结：为了减少mysql数据库的查询压力，借助mybatis二级缓存，让多用户共享查询结果<br />\n前提执行的SQL语句是相同的。但是项目运行过程中，发现二级缓存存储的数据量越来越大，大量占用了当前JVM的空间，为了解决这个问题，使用redis数据库存储缓存的数据</li>\n</ol>\n', 1, '', 0, 0, 1, '2020-10-07 12:56:29', '2022-05-21 18:13:56');
INSERT INTO `tb_article` VALUES (243, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=451', 'spring boot 实现文件的上传下载', '<p>﻿## spring boot实现文件的上传，</p>\n<p>我是使用maven搭建的spring boot项目，页面集成的jsp。<br />\n页面结构如下：<br />\n<img src=\"https://img-blog.csdnimg.cn/20190811160646759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n准备工作：在webapp下新建一个目录叫upload</p>\n<p><strong>1，页面，upload.jsp</strong></p>\n<pre><code>&lt;body&gt;\n&lt;form method=&quot;post&quot; action=&quot;${pageContext.request.contextPath}/file/upload&quot; enctype=&quot;multipart/form-data&quot;&gt;\n    &lt;input type=&quot;file&quot; name=&quot;files&quot;&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n</code></pre>\n<p><strong>2) 控制器 ,FileController.java</strong></p>\n<pre><code>@Controller\n@RequestMapping(&quot;/file&quot;)\npublic class FileController {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RequestMapping(&quot;/upload&quot;)\n    public String upLoad(MultipartFile files, HttpSession session) throws IOException {\n        logger.info(&quot;upload 方法执行了&quot;);\n        //获取上传文件的路径\n        String realPath = session.getServletContext().getRealPath(&quot;upload&quot;);\n        System.out.println(&quot;--------&quot;+realPath);\n        //获取上传的文件名，\n        File file1 = new File(realPath, files.getOriginalFilename());\n        //执行文件上传复制\n        files.transferTo(file1);\n        //跳到下载页面\n        return &quot;/download.jsp&quot;;\n\n    }\n}\n</code></pre>\n<p><strong>3) 修改上传文件大小的限制，application.properties</strong></p>\n<pre><code>//配置tomcat端口号\nserver.port=8080\n//项目访问路径\nserver.servlet.context-path=/maven_springboot\n//jsp页面热部署\nserver.servlet.jsp.init-parameters.development=true\n//修改上传文件大小限制为10Mb\nspring.servlet.multipart.max-file-size=10485760\n\n</code></pre>\n<h2 id=\"2下载\">2，下载</h2>\n<p><strong>1) 页面 download.jsp</strong><br />\n这里的fileName应该是要从数据库读取出来，包括上传也是应该把上传的文件信息存到数据库，这里我就不写了。<br />\n就直接把文件写死了，</p>\n<pre><code>&lt;body&gt;\n&lt;a href=&quot;${pageContext.request.contextPath}/file/download?fileName=aaa.png&quot;&gt;下载&lt;/a&gt;\n&lt;/body&gt;\n</code></pre>\n<p><strong>2）控制器, FileController</strong></p>\n<pre><code> @RequestMapping(&quot;/download&quot;)\n    public void Download(String fileName, HttpServletResponse response,HttpSession session) throws Exception {\n   //设置下载响应头\n        response.setHeader(&quot;content-disposition&quot;,&quot;attachment;fileName&quot;+ URLEncoder.encode(fileName,&quot;UTF-8&quot;));\n    //获取文件路径\n        String uploadPath = session.getServletContext().getRealPath(&quot;upload&quot;);\n\n        File file = new File(uploadPath,fileName);\n        ServletOutputStream outputStream = response.getOutputStream();\n        FileUtils.copyFile(file,response.getOutputStream());\n\n    }\n</code></pre>\n<p>这里要用到一个jar包，commons-io包的FileUtils工具类，<br />\npom引入该依赖如下：</p>\n<pre><code> &lt;dependency&gt;\n      &lt;groupId&gt;commons-io&lt;/groupId&gt;\n      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;\n      &lt;version&gt;2.4&lt;/version&gt;\n    &lt;/dependency&gt;\n\n</code></pre>\n<p>如此，一个简单的上传下载demo就算完成了</p>\n', 1, '', 0, 0, 1, '2020-09-29 17:25:27', '2020-12-21 14:53:59');
INSERT INTO `tb_article` VALUES (244, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5731', 'Centos Linux系统使用vsftpd搭建ftp服务', '<p>﻿## Linux，Centos系统使用vsftpd搭建ftp服务</p>\n<h3 id=\"一安装vsftpd\">一、安装vsftpd</h3>\n<ol>\n<li>运行以下命令安装vsftpd。</li>\n</ol>\n<pre><code class=\"language-powershell\">yum install -y vsftpd\n</code></pre>\n<p>返回如下图所示界面时，表示安装成功。<br />\n<img src=\"https://img-blog.csdnimg.cn/20201011163459305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"2\">\n<li>运行以下命令设置FTP服务开机自启动。</li>\n</ol>\n<pre><code class=\"language-powershell\">systemctl enable vsftpd.service\n</code></pre>\n<ol start=\"3\">\n<li>启动FTP服务。</li>\n</ol>\n<pre><code class=\"language-powershell\">systemctl start vsftpd.service\n</code></pre>\n<ol start=\"4\">\n<li>运行以下命令查看FTP服务监听的端口。</li>\n</ol>\n<pre><code class=\"language-powershell\">netstat -antup | grep ftp\n</code></pre>\n<p>出现如下图所示界面，表示FTP服务已启动，监听的端口号为 21。此时，vsftpd默认已开启匿名访问功能，您无需输入用户名密码即可登录FTP服务器，但没有修改或上传文件的权限。<br />\n<img src=\"https://img-blog.csdnimg.cn/20201011163555146.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h3 id=\"二配置vsftpd\">二、配置vsftpd</h3>\n<blockquote>\n<p>vsftpd（very secure FTP<br />\ndaemon）是一款在Linux发行版中最受推崇的FTP服务器。vsftpd支持匿名访问和本地用户模式两种访问方式。匿名访问方式任何用户都可以访问搭建的FTP服务；本地用户模式只支持添加的本地用户访问搭建的FTP服务。</p>\n</blockquote>\n<ul>\n<li>说明: 匿名用户模式和本地用户模式只可同时配置一种。</li>\n</ul>\n<h4 id=\"21-匿名用户模式\">2.1 匿名用户模式</h4>\n<ol>\n<li>修改配置文件vsftpd.conf。</li>\n</ol>\n<pre><code class=\"language-powershell\">vim /etc/vsftpd/vsftpd.conf\n</code></pre>\n<p>按 i 键进入编辑模式，将匿名上传权限 anon_upload_enable=YES 的注释解开。<br />\n<img src=\"https://img-blog.csdnimg.cn/20201011163821978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"2\">\n<li>\n<p>按ESC键退出编辑模式，输入:wq 保存并退出vim。</p>\n</li>\n<li>\n<p>更改/var/ftp/pub目录的权限，为FTP用户添加写权限。</p>\n</li>\n</ol>\n<pre><code class=\"language-powershell\">chmod o+w /var/ftp/pub/\n</code></pre>\n<ol start=\"4\">\n<li>重启FTP服务。</li>\n</ol>\n<pre><code class=\"language-powershell\">systemctl restart vsftpd.service\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20201011163953415.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"22-本地用户模式\">2.2 本地用户模式</h4>\n<ol>\n<li>为FTP服务创建一个Linux用户。</li>\n</ol>\n<pre><code class=\"language-powershell\">adduser ftptest\n</code></pre>\n<p>为用户设置密码。</p>\n<pre><code class=\"language-powershell\">passwd ftptest\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20201011164202186.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"2\">\n<li>创建一个供FTP服务使用的文件目录。</li>\n</ol>\n<pre><code class=\"language-powershell\">mkdir /var/ftp/test\n</code></pre>\n<ol start=\"3\">\n<li>更改/var/ftp/test目录的拥有者为ftptest。</li>\n</ol>\n<pre><code class=\"language-powershell\">chown -R ftptest:ftptest /var/ftp/test\n</code></pre>\n<ol start=\"4\">\n<li>修改vsftpd.conf配置文件。</li>\n</ol>\n<p>配置FTP为主动模式请执行如下命令:</p>\n<pre><code class=\"language-powershell\">sed -i \'s/anonymous_enable=YES/anonymous_enable=NO/\' /etc/vsftpd/vsftpd.conf #禁止匿名登录FTP服务器 \nsed -i \'s/listen=NO/listen=YES/\' /etc/vsftpd/vsftpd.conf #监听IPv4 sockets \nsed -i \'s/listen_ipv6=YES/#listen_ipv6=YES/\' /etc/vsftpd/vsftpd.conf #关闭监听IPv6 sockets \nsed -i \'s/#chroot_local_user=YES/chroot_local_user=YES/\' /etc/vsftpd/vsftpd.conf #全部用户被限制在主目录 \nsed -i \'s/#chroot_list_enable=YES/chroot_list_enable=YES/\' /etc/vsftpd/vsftpd.conf #启用例外用户名单 \nsed -i \'s/#chroot_list_file=/chroot_list_file=/\' /etc/vsftpd/vsftpd.conf #指定例外用户列表文件，列表中的用户不被锁定在主目录 \necho &quot;allow_writeable_chroot=YES&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf \necho &quot;local_root=/var/ftp/test&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置本地用户登录后所在的目录\n</code></pre>\n<p>配置FTP为被动模式请执行如下命令：</p>\n<pre><code class=\"language-powershell\">sed -i \'s/anonymous_enable=YES/anonymous_enable=NO/\' /etc/vsftpd/vsftpd.conf #禁止匿名登录FTP服务器 \nsed -i \'s/listen=NO/listen=YES/\' /etc/vsftpd/vsftpd.conf #监听IPv4 sockets \nsed -i \'s/listen_ipv6=YES/#listen_ipv6=YES/\' /etc/vsftpd/vsftpd.conf #关闭监听IPv6 sockets \nsed -i \'s/#chroot_local_user=YES/chroot_local_user=YES/\' /etc/vsftpd/vsftpd.conf #全部用户被限制在主目录 \nsed -i \'s/#chroot_list_enable=YES/chroot_list_enable=YES/\' /etc/vsftpd/vsftpd.conf #启用例外用户名单 \nsed -i \'s/#chroot_list_file=/chroot_list_file=/\' /etc/vsftpd/vsftpd.conf #指定例外用户列表文件，列表中的用户不被锁定在主目录 \necho &quot;allow_writeable_chroot=YES&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf \necho &quot;local_root=/var/ftp/test&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置本地用户登录后所在的目录 \n\necho &quot;pasv_enable=YES&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #开启被动模式 \necho &quot;pasv_address=&lt;FTP服务器公网IP地址&gt;&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #本教程中为ECS服务器弹性IP \necho &quot;pasv_min_port=20&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置被动模式下，建立数据传输可使用的端口范围的最小值 \necho &quot;pasv_max_port=21&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf #设置被动模式下，建立数据传输可使用的端口范围的最大值\n</code></pre>\n<ol start=\"5\">\n<li>在/etc/vsftpd目录下创建chroot_list文件，并在文件中写入例外用户名单。</li>\n</ol>\n<pre><code class=\"language-powershell\">#使用vim命令编辑chroot_list文件，添加例外用户名单。此名单中的用户不会被锁定在主目录，可以访问其他目录。\nvim /etc/vsftpd/chroot_list\n</code></pre>\n<p>说明: 没有例外用户时，也必须创建chroot_list文件，内容可为空。</p>\n<ol start=\"6\">\n<li>重启FTP服务。</li>\n</ol>\n<pre><code class=\"language-powershell\">systemctl restart vsftpd.service\n</code></pre>\n<h2 id=\"三客户端测试\">三、客户端测试</h2>\n<p>FTP客户端、Windows命令行工具或浏览器均可用来测试FTP服务器。（此步骤仅适用于本地用户，匿名模式无需进行测试操作）</p>\n<p>说明：使用浏览器访问FTP服务器出错时，建议您清除浏览器缓存后再尝试。</p>\n<ol>\n<li>\n<p>打开Chrom浏览器，在地址栏中输入<a href=\"ftp://&lt;\">ftp://&lt;</a>FTP服务器公网IP地址&gt;:FTP端口，FTP服务器公网IP地址为ECS服务器的弹性IP地址。例如：ftp://139.0.0.1:21。</p>\n</li>\n<li>\n<p>在弹出的对话框中，输入用户名和密码。</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20201011164412400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"3\">\n<li>登录成功界面如下，此时可对FTP文件进行相应权限的操作。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20201011164418652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-10-14 15:43:49', '2022-05-21 18:14:31');
INSERT INTO `tb_article` VALUES (245, 1, 10, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8963', '在VUE中使用RSA加密解密加签解签', '</font>\n<p>@<a href=\"目录\">TOC</a></p>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h1 id=\"前言\">前言</h1>\n<font >\n项目中部分隐私参数要前后端对接交互时，出于安全性考虑，我们会对重要的参数进行加密后再进行传输，一般采用的加密方式是非对称性加密RSA算法。\n</font>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<p><font color=#999AAA >提示：以下是本篇文章正文内容，下面案例可供参考</p>\n<h1 id=\"一什么是rsa加密\">一、什么是RSA加密？</h1>\n<p><font color=#999AAA >RSA加密是一种非对称加密。<br />\n可以在不直接传递密钥的情况下，完成解密。<br />\n这能够确保信息的安全性，避免了直接传递密钥所造成的被破解的风险。<br />\nRSA是由一对密钥来进行加解密的过程，分别称为公钥和私钥。<br />\n两者之间有数学相关，该加密算法的原理就是对一极大整数做因数分解的困难性来保证安全性。<br />\n通常个人保存私钥，公钥是公开的（可能同时多人持有）。</p>\n<h1 id=\"二加密过程\">二、加密过程</h1>\n<ul>\n<li>（1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。</li>\n<li>（2）A传递自己的公钥给B，B用A的公钥对消息进行加密。</li>\n<li>（3）A接收到B加密的消息，利用A自己的私钥对消息进行解密。<br />\n　<br />\n在这个过程中，只有2次传递过程，第一次是A传递公钥给B，第二次是B传递加密消息给A，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行解密，防止了消息内容的泄露。</li>\n</ul>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h1 id=\"三在vue中使用步骤\">三、在Vue中使用步骤</h1>\n<p>一般是客户端初始化时访问服务端时，服务端会生成一对RSA对，及公钥和密钥。</p>\n<ul>\n<li>如果前端只需要将要传给后端的数据进行<strong>加密</strong>后传输，那么前端可以只要公钥，通过公钥对要传输的参数进行加密后把加密的字符串发给后端即可，后端自有办法解密。</li>\n<li>如果前端要获取后端传过来的已经加密后的字符串，并且<strong>解密</strong>使用，那么前端就需要拿到RSA对立面的私钥进行解密后使用了。</li>\n</ul>\n<h3 id=\"使用步骤\">使用步骤：</h3>\n<h4 id=\"1安装依赖\">1、安装依赖</h4>\n<p>首先引入jsencrypt</p>\n<pre><code class=\"language-powershell\">npm install jsencrypt --save\n</code></pre>\n<h4 id=\"2在mainjs中引入\">2、在main.js中引入</h4>\n<pre><code class=\"language-powershell\">import JsEncrypt from \'jsencrypt\'\nVue.prototype.$jsEncrypt = JsEncrypt\n</code></pre>\n<h4 id=\"3将加密解密方法封装到通用的js内\">3、将加密解密方法封装到通用的js内</h4>\n<pre><code class=\"language-javascript\">let publicKey = \'这里是封装的公钥\'\nlet privateKey = \'这里是封装的私钥\'\n//加密方法\n  RSAencrypt(pas){\n    //实例化jsEncrypt对象\n    let jse = new JSEncrypt();\n    //设置公钥\n    jse.setPublicKey(publicKey);\n     console.log(\'加密：\'+jse.encrypt(pas))\n    return jse.encrypt(pas);\n  },\n  \n//解密方法\n  RSAdecrypt(pas){\n    let jse = new JSEncrypt();\n    // 私钥\n    jse.setPrivateKey(privateKey)\n     console.log(\'解密：\'+jse.decrypt(pas))\n    return jse.decrypt(pas);\n  },\n\n</code></pre>\n<p>我在项目中的使用如下图：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201216153329749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在VUE中使用RSA加密解密加签解签\" /></p>\n<h4 id=\"运行结果\">运行结果</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20201216153523787.png\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"总结\">总结</h1>\n<p>后端的使用Springboot对RSA进行加解密的过程可以看我的另一篇博客</p>\n', 1, '', 0, 0, 1, '2020-12-17 15:32:34', '2020-12-17 15:32:34');
INSERT INTO `tb_article` VALUES (246, 1, 2, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=6175', 'SpringBoot集成WebSocket，实现后台向前端推送信息', '<p>@<a href=\"目录\">TOC</a></p>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h1 id=\"前言\">前言</h1>\n<p><font color=#999AAA >在一次项目开发中，使用到了Netty网络应用框架，以及MQTT进行消息数据的收发，这其中需要后台来将获取到的消息主动推送给前端，于是就使用到了MQTT，特此记录一下。</p>\n<h1 id=\"一什么是websocket\">一、什么是websocket？</h1>\n<p><font color=#999AAA >WebSocket协议是基于TCP的一种新的网络协议。它实现了客户端与服务器全双工通信，学过计算机网络都知道，既然是全双工，就说明了<strong>服务器可以主动发送信息给客户端</strong>。这与我们的推送技术或者是多人在线聊天的功能不谋而合。<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217170824701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>为什么不使用HTTP 协议呢？这是因为HTTP是单工通信，通信只能由客户端发起，客户端请求一下，服务器处理一下，这就太麻烦了。于是websocket应运而生。<br />\n<img src=\"https://img-blog.csdnimg.cn/2020121717094782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>下面我们就直接开始使用Springboot开始整合。以下案例都在我自己的电脑上测试成功，你可以根据自己的功能进行修改即可。<br />\n我的项目结构如下：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217173226396.png\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"二使用步骤\">二、使用步骤</h1>\n<h2 id=\"1添加依赖\">1.添加依赖</h2>\n<p><font color=#999AAA >Maven依赖：</p>\n<pre><code class=\"language-xml\">	&lt;dependency&gt;  \n           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  \n           &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;  \n    &lt;/dependency&gt; \n</code></pre>\n<h2 id=\"2启用springboot对websocket的支持\">2.启用Springboot对WebSocket的支持</h2>\n<p><font color=#999AAA >启用WebSocket的支持也是很简单，几句代码搞定：</p>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.socket.server.standard.ServerEndpointExporter;\n/**\n * @ Auther: 马超伟\n * @ Date: 2020/06/16/14:35\n * @ Description: 开启WebSocket支持\n */\n@Configuration\npublic class WebSocketConfig {\n    @Bean\n    public ServerEndpointExporter serverEndpointExporter() {\n        return new ServerEndpointExporter();\n    }\n}\n</code></pre>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h2 id=\"3核心配置websocketserver\">3.核心配置：WebSocketServer</h2>\n<p><font color=#999AAA >因为WebSocket是类似客户端服务端的形式(采用ws协议)，那么这里的WebSocketServer其实就相当于一个ws协议的Controller</p>\n<ul>\n<li>@ ServerEndpoint 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端, 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端</li>\n<li>新建一个ConcurrentHashMap webSocketMap 用于接收当前userId的WebSocket，方便传递之间对userId进行推送消息。</li>\n</ul>\n<p>下面是具体业务代码：</p>\n<pre><code class=\"language-java\">package cc.mrbird.febs.external.webScoket;\n\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Service;\n\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.time.LocalDateTime;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n/**\n * Created with IntelliJ IDEA.\n * @ Auther: 马超伟\n * @ Date: 2020/06/16/14:35\n * @ Description:\n * @ ServerEndpoint 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端,\n * 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端\n */\n@Component\n@Slf4j\n@Service\n@ServerEndpoint(&quot;/api/websocket/{sid}&quot;)\npublic class WebSocketServer {\n    //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。\n    private static int onlineCount = 0;\n    //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。\n    private static CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketSet = new CopyOnWriteArraySet&lt;WebSocketServer&gt;();\n\n    //与某个客户端的连接会话，需要通过它来给客户端发送数据\n    private Session session;\n\n    //接收sid\n    private String sid = &quot;&quot;;\n\n    /**\n     * 连接建立成功调用的方法\n     */\n    @OnOpen\n    public void onOpen(Session session, @PathParam(&quot;sid&quot;) String sid) {\n        this.session = session;\n        webSocketSet.add(this);     //加入set中\n        this.sid = sid;\n        addOnlineCount();           //在线数加1\n        try {\n            sendMessage(&quot;conn_success&quot;);\n            log.info(&quot;有新窗口开始监听:&quot; + sid + &quot;,当前在线人数为:&quot; + getOnlineCount());\n        } catch (IOException e) {\n            log.error(&quot;websocket IO Exception&quot;);\n        }\n    }\n\n    /**\n     * 连接关闭调用的方法\n     */\n    @OnClose\n    public void onClose() {\n        webSocketSet.remove(this);  //从set中删除\n        subOnlineCount();           //在线数减1\n        //断开连接情况下，更新主板占用情况为释放\n        log.info(&quot;释放的sid为：&quot;+sid);\n        //这里写你 释放的时候，要处理的业务\n        log.info(&quot;有一连接关闭！当前在线人数为&quot; + getOnlineCount());\n\n    }\n\n    /**\n     * 收到客户端消息后调用的方法\n     * @ Param message 客户端发送过来的消息\n     */\n    @OnMessage\n    public void onMessage(String message, Session session) {\n        log.info(&quot;收到来自窗口&quot; + sid + &quot;的信息:&quot; + message);\n        //群发消息\n        for (WebSocketServer item : webSocketSet) {\n            try {\n                item.sendMessage(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    /**\n     * @ Param session\n     * @ Param error\n     */\n    @OnError\n    public void onError(Session session, Throwable error) {\n        log.error(&quot;发生错误&quot;);\n        error.printStackTrace();\n    }\n\n    /**\n     * 实现服务器主动推送\n     */\n    public void sendMessage(String message) throws IOException {\n        this.session.getBasicRemote().sendText(message);\n    }\n\n    /**\n     * 群发自定义消息\n     */\n    public static void sendInfo(String message, @PathParam(&quot;sid&quot;) String sid) throws IOException {\n        log.info(&quot;推送消息到窗口&quot; + sid + &quot;，推送内容:&quot; + message);\n\n        for (WebSocketServer item : webSocketSet) {\n            try {\n                //这里可以设定只推送给这个sid的，为null则全部推送\n                if (sid == null) {\n//                    item.sendMessage(message);\n                } else if (item.sid.equals(sid)) {\n                    item.sendMessage(message);\n                }\n            } catch (IOException e) {\n                continue;\n            }\n        }\n    }\n\n    public static synchronized int getOnlineCount() {\n        return onlineCount;\n    }\n\n    public static synchronized void addOnlineCount() {\n        WebSocketServer.onlineCount++;\n    }\n\n    public static synchronized void subOnlineCount() {\n        WebSocketServer.onlineCount--;\n    }\n\n    public static CopyOnWriteArraySet&lt;WebSocketServer&gt; getWebSocketSet() {\n        return webSocketSet;\n    }\n}\n</code></pre>\n<h2 id=\"4测试controller\">4.测试Controller</h2>\n<pre><code class=\"language-java\">\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Created with IntelliJ IDEA.\n *\n * @ Auther: 马超伟\n * @ Date: 2020/06/16/14:38\n * @ Description:\n */\n@Controller(&quot;web_Scoket_system&quot;)\n@RequestMapping(&quot;/api/socket&quot;)\npublic class SystemController {\n    //页面请求\n    @GetMapping(&quot;/index/{userId}&quot;)\n    public ModelAndView socket(@PathVariable String userId) {\n        ModelAndView mav = new ModelAndView(&quot;/socket1&quot;);\n        mav.addObject(&quot;userId&quot;, userId);\n        return mav;\n    }\n\n    //推送数据接口\n    @ResponseBody\n    @RequestMapping(&quot;/socket/push/{cid}&quot;)\n    public Map pushToWeb(@PathVariable String cid, String message) {\n        Map&lt;String,Object&gt; result = new HashMap&lt;&gt;();\n        try {\n            WebSocketServer.sendInfo(message, cid);\n            result.put(&quot;code&quot;, cid);\n            result.put(&quot;msg&quot;, message);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n}\n\n</code></pre>\n<h2 id=\"5测试页面indexhtml\">5.测试页面index.html</h2>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n	&lt;head&gt;\n		&lt;meta charset=&quot;utf-8&quot;&gt;\n		&lt;title&gt;Java后端WebSocket的Tomcat实现&lt;/title&gt;\n		&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;\n	&lt;/head&gt;\n\n	&lt;body&gt;\n		&lt;div id=&quot;main&quot; style=&quot;width: 1200px;height:800px;&quot;&gt;&lt;/div&gt;\n		Welcome&lt;br/&gt;&lt;input id=&quot;text&quot; type=&quot;text&quot; /&gt;\n		&lt;button onclick=&quot;send()&quot;&gt;发送消息&lt;/button&gt;\n		&lt;hr/&gt;\n		&lt;button onclick=&quot;closeWebSocket()&quot;&gt;关闭WebSocket连接&lt;/button&gt;\n		&lt;hr/&gt;\n		&lt;div id=&quot;message&quot;&gt;&lt;/div&gt;\n	&lt;/body&gt;\n	&lt;script type=&quot;text/javascript&quot;&gt;\n		var websocket = null;\n		//判断当前浏览器是否支持WebSocket\n		if(\'WebSocket\' in window) {\n			//改成你的地址\n			websocket = new WebSocket(&quot;ws://192.168.100.196:8082/api/websocket/100&quot;);\n		} else {\n			alert(\'当前浏览器 Not support websocket\')\n		}\n\n		//连接发生错误的回调方法\n		websocket.onerror = function() {\n			setMessageInnerHTML(&quot;WebSocket连接发生错误&quot;);\n		};\n\n		//连接成功建立的回调方法\n		websocket.onopen = function() {\n			setMessageInnerHTML(&quot;WebSocket连接成功&quot;);\n		}\n		var U01data, Uidata, Usdata\n		//接收到消息的回调方法\n		websocket.onmessage = function(event) {\n			console.log(event);\n			setMessageInnerHTML(event);\n			setechart()\n		}\n\n		//连接关闭的回调方法\n		websocket.onclose = function() {\n			setMessageInnerHTML(&quot;WebSocket连接关闭&quot;);\n		}\n\n		//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。\n		window.onbeforeunload = function() {\n			closeWebSocket();\n		}\n\n		//将消息显示在网页上\n		function setMessageInnerHTML(innerHTML) {\n			document.getElementById(\'message\').innerHTML += innerHTML + \'&lt;br/&gt;\';\n		}\n\n		//关闭WebSocket连接\n		function closeWebSocket() {\n			websocket.close();\n		}\n\n		//发送消息\n		function send() {\n			var message = document.getElementById(\'text\').value;\n			websocket.send(\'{&quot;msg&quot;:&quot;\' + message + \'&quot;}\');\n			setMessageInnerHTML(message + &quot;&amp;#13;&quot;);\n		}\n	&lt;/script&gt;\n\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"6结果展示\">6.结果展示</h2>\n<p>后台：<br />\n如果有连接请求<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217181325920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>前台显示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217181300879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"总结\">总结</h1>\n<p><font color=#999AAA >这中间我遇到一个问题，就是说WebSocket启动的时候优先于spring容器，从而导致在WebSocketServer中调用业务Service会报空指针异常</p>\n<p>所以需要在WebSocketServer中将所需要用到的service给静态初始化一下：<br />\n如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217181723382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n还需要做如下配置：<br />\n<img src=\"https://img-blog.csdnimg.cn/20201217181921591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2020-12-18 11:40:54', '2022-05-21 18:06:14');
INSERT INTO `tb_article` VALUES (247, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7958', '留言', '<h3 id=\"留言板说明\">留言板说明</h3>\n<p>有什么话要对我说吗？这里是你畅所欲言的地方，可以咨询，可以交流，可以感叹，可以发飙，但不可以订外卖。</p>\n<p><img src=\"http://file.henaumcw.top/blog/image_1608350101016.png\" alt=\"image.png\" /></p>\n', 1, '', 0, 0, 1, '2020-12-19 10:30:42', '2020-12-19 11:55:06');
INSERT INTO `tb_article` VALUES (248, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4652', '新浪随机图片壁纸API接口 刷新网页换背景接口', '<p>新浪随机图片壁纸API接口 刷新网页换背景接口<br />\n在这里插入图片描述</p>\n<p>刷新一次页面换一次图片，可以调用到你的网站背景里面去，多炫酷啊，刷新一下本页看下效果哦。</p>\n<p>说明：随机图片壁纸api，调用的是新浪api，速度不用担心，图片资源也很多</p>\n<p>电脑动漫图片：<a href=\"http://api.btstu.cn/sjbz/?lx=dongman\">http://api.btstu.cn/sjbz/?lx=dongman</a></p>\n<p>电脑美女图片：<a href=\"http://api.btstu.cn/sjbz/?lx=meizi\">http://api.btstu.cn/sjbz/?lx=meizi</a></p>\n<p>电脑随机动漫妹子：<a href=\"http://api.btstu.cn/sjbz/?lx=suiji\">http://api.btstu.cn/sjbz/?lx=suiji</a></p>\n<p>手机动漫图片：<a href=\"http://api.btstu.cn/sjbz/?lx=m_dongman\">http://api.btstu.cn/sjbz/?lx=m_dongman</a></p>\n<p>手机美女图片：<a href=\"http://api.btstu.cn/sjbz/?lx=m_meizi\">http://api.btstu.cn/sjbz/?lx=m_meizi</a></p>\n<p>手机随机动漫妹子：<a href=\"http://api.btstu.cn/sjbz/?m_lx=suiji\">http://api.btstu.cn/sjbz/?m_lx=suiji</a></p>\n<p>手机电脑自动判断，电脑显示适合电脑的壁纸，手机显示适合手机的壁纸 <a href=\"http://api.btstu.cn/sjbz/zsy.php\">http://api.btstu.cn/sjbz/zsy.php</a></p>\n', 1, '', 0, 0, 1, '2020-12-19 16:31:05', '2021-08-30 09:53:11');
INSERT INTO `tb_article` VALUES (249, 1, 3, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1344', '超详细的 Vagrant 上手指南，搭建Linux虚拟机别再用VMware Workstation了！', '<p>﻿<br />\n@<a href=\"文章目录\">TOC</a></p>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<h1 id=\"前言\">前言</h1>\n<p><font color=#999AAA >也许你已经习惯了 docker，习惯了在 XX 云上快速创建云主机，但是如果你想在个人电脑上安装虚拟机来搭建开发/测试环境，Vagrant 仍然不失高效之选。</font></p>\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n<p><font color=#999AAA >下面说下搭建的主要步骤：</p>\n<h1 id=\"一安装virtualbox\">一、安装VirtualBox</h1>\n<p><font color=#999AAA >VirtualBox 是一个跨平台的虚拟化工具，支持多个操作系统，根据自己的情况选择对应的版本下载即可。</p>\n<p>进入 VirtualBox 的主页<a href=\"https://www.virtualbox.org/\">https://www.virtualbox.org/</a>，点下载按钮，即可进入下载页面。</p>\n<p>进行安装需要<strong>cpu开启虚拟化</strong>，在开机启动的时候设置主板，CPU configuration，然后点击Intel Vitualization Technology。重启电脑</p>\n<h1 id=\"二vagrant\">二、Vagrant</h1>\n<h2 id=\"1安装vagrant\">1.安装Vagrant</h2>\n<p>在 Vagant 网站<a href=\"https://www.vagrantup.com/\">https://www.vagrantup.com/</a>下载最新的版本，根据自己的操作系统选择对应的版本下载即可。</p>\n<p>注意，Vagrant 是没有图形界面的，所以安装完成后也没有桌面快捷方式。具体使用方法，接下来会详细说明。</p>\n<p><font color=#99AA >Vagrant 的安装程序会自动把安装路径加入到 PATH 环境变量，所以，这时候可以通过命令行执行 <strong>vagrant version</strong> 检查是否安装成功：</p>\n<pre><code class=\"language-c\">C:\\Users\\ma&gt;vagrant version\n==&gt; vagrant: A new version of Vagrant is available: 2.2.14 (installed version: 2.2.5)!\n==&gt; vagrant: To upgrade visit: https://www.vagrantup.com/downloads.html\n\nInstalled Version: 2.2.5\nLatest Version: 2.2.14\n</code></pre>\n<h2 id=\"配置虚机存放位置\">配置虚机存放位置</h2>\n<p>创建虚拟机会占用较多的磁盘空间，在 Windows 系统下默认的虚机创建位置是在 C 盘，所以最好配置到其它地方。</p>\n<h2 id=\"2配置-virtualbox\">2.配置 VirtualBox</h2>\n<p>启动 VirtualBox 后，通过菜单 <code>管理 -&gt; 全局设定</code>，或者按下快捷键 <code>Ctrl + g</code>，在全局设定对话框中，修改 <code>默认虚拟电脑位置</code>，指定一个容量较大的磁盘。<br />\n<img src=\"https://img-blog.csdnimg.cn/20210308113209588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"3配置-vagrant\">3.配置 Vagrant</h2>\n<p>通过 Vagrant 创建虚机需要先导入镜像文件，也就是 box，它们默认存储的位置在用户目录下的 <code>.vagrant.d</code> 目录下，对于 Windows 系统来说，就是 <code>C:\\Users\\用户名\\.vagrant.d</code>。</p>\n<p>如果后续可能会用到较多镜像，或者你的 C 盘空间比较紧缺，可以通过设置环境变量 <code>VAGRANT_HOME</code> 来设置该目录。</p>\n<p>在 Windows 系统中，可以这样操作：新建系统环境变量，环境变量名为 <code>VAGRANT_HOME</code>，变量值为 <code>你的其他盘的路径</code>。</p>\n<h2 id=\"4下载虚机镜像\">4.下载虚机镜像</h2>\n<p>使用 Vagrant 创建虚机时，需要指定一个镜像，也就是 box。开始这个 box 不存在，所以 Vagrant 会先从网上下载，然后缓存在本地目录中。</p>\n<p>Vagrant 有一个镜像网站<a href=\"https://app.vagrantup.com/boxes/search\">https://app.vagrantup.com/boxes/search</a>，里面列出了都有哪些镜像可以用，并且提供了操作文档。<br />\n<img src=\"https://img-blog.csdnimg.cn/20210308115510105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n输入<code>vagrant init centos/7</code>（<strong>仓库镜像名</strong>），即可初始化一个centos7系统。（注意这个命令在哪个目录下执行的，他的Vagrantfile就生成在哪里）这个命令是一键下载并初始化。<strong>后面会详细介绍</strong></p>\n<blockquote>\n<p>但是这里默认下载往往会比较慢，所以下面我会介绍如何在其它地方下载到基础镜像，然后按照自己的需要重置。如果网速较好，下载顺利的朋友可以选择性地跳过部分内容。</p>\n<p>下面我给出最常用的两个 Linux 操作系统镜像的下载地址：</p>\n<p><strong>CentOS</strong></p>\n<p>CentOS 的镜像下载网站是： <a href=\"http://cloud.centos.org/centos/\">http://cloud.centos.org/centos/</a></p>\n<p><strong>Ubuntu</strong></p>\n<p>Ubuntu 的镜像下载网站是： <a href=\"http://cloud-images.ubuntu.com\">http://cloud-images.ubuntu.com</a></p>\n</blockquote>\n<p>在其中选择自己想要下载的版本，列表中有一个 vagrant 目录，里面是专门为 vagrant 构建的镜像。选择其中的 .box 后缀的文件下载即可。这里可以使用下载工具，以较快的速度下载下来。</p>\n<h2 id=\"5添加-box\">5.添加 box</h2>\n<p><font color=#999AAA >以 CentOS 7 为例，使用其它版本操作系统的也可以参考。</p>\n<p>接下来我们需要将下载后的 <code>.box</code> 文件添加到 vagrant 中。</p>\n<p>Vagrant 没有 GUI，只能从命令行访问，先启动一个命令行，然后执行:</p>\n<pre><code class=\"language-java\">$ vagrant box list\nThere are no installed boxes! Use `vagrant box add` to add some.\n</code></pre>\n<p>提示现在还没有 box。如果这是第一次运行，此时 <code>VAGRANT_HOME</code> 目录下会自动生成若干的文件和文件夹，其中有一个 boxes 文件夹，这就是要存放 box 文件的地方。</p>\n<p>执行 <code>vagrant box add</code> 命令添加 box:</p>\n<pre><code class=\"language-java\">$ vagrant box add e:\\Downloads\\CentOS-7.box --name centos-7\n==&gt; box: Box file was not detected as metadata. Adding it directly...\n==&gt; box: Adding box \'centos-7\' (v0) for provider:\n    box: Unpacking necessary files from: file:///e:/Downloads/CentOS-7.box\n    box:\n==&gt; box: Successfully added box \'centos-7\' (v0) for \'virtualbox\'!\n</code></pre>\n<p>命令后面跟着的是下载的文件路径，并且通过 --name centos-7 为这个 box 指定一个名字。</p>\n<p>后面创建虚机都需要指定这个名字，所以尽量把名字取得简短一点，同时也要能标识出这个镜像的信息（我们后面会定制自己的基础镜像，所以这里可以简单点）。</p>\n<p>再次查询，可以看到有了一个 box：</p>\n<pre><code class=\"language-java\">$ vagrant box list\ncentos-7 (virtualbox, 0)\n</code></pre>\n<h2 id=\"6vagrant-基本操作\">6.Vagrant 基本操作</h2>\n<h3 id=\"61-新建虚机\">6.1 新建虚机</h3>\n<p>创建一个目录，先执行 <code>vagrant init</code>：</p>\n<pre><code class=\"language-java\">$ mkdir demo\n$ cd demo\n$ vagrant init centos-7\nA `Vagrantfile` has been placed in this directory. You are now\nready to `vagrant up` your first virtual environment! Please read\nthe comments in the Vagrantfile as well as documentation on\n`vagrantup.com` for more information on using Vagrant.\n</code></pre>\n<p>其中的 <code>centos-7</code> 就是我们要使用的 <code>box</code> 名字。</p>\n<p>这个命令只是为我们生成一个 <code>Vagrantfile</code>，所以，这里的名字没指定或者写错了都没关系，后面会介绍如何编辑这个 <code>Vagrantfile</code> 来修改。</p>\n<h3 id=\"62-启动虚机\">6.2 启动虚机</h3>\n<p>我们等会再来细看这个文件，现在直接按照提示执行 <code>vagrant up</code>：</p>\n<pre><code class=\"language-java\">$ vagrant up\nBringing machine \'default\' up with \'virtualbox\' provider...\n==&gt; default: Importing base box \'centos-7\'...\n==&gt; default: Matching MAC address for NAT networking...\n==&gt; default: Setting the name of the VM: demo_default_1588406874156_65036\n==&gt; default: Clearing any previously set network interfaces...\n==&gt; default: Preparing network interfaces based on configuration...\n    default: Adapter 1: nat\n==&gt; default: Forwarding ports...\n    default: 22 (guest) =&gt; 2222 (host) (adapter 1)\n==&gt; default: Booting VM...\n==&gt; default: Waiting for machine to boot. This may take a few minutes...\n    default: SSH address: 127.0.0.1:2222\n    default: SSH username: vagrant\n    default: SSH auth method: private key\n</code></pre>\n<p>正常的情况下，不到一分钟应该就能启动成功了。</p>\n<h3 id=\"63-查看虚机状态\">6.3 查看虚机状态</h3>\n<p>执行下面的命令可以查看虚机的状态：</p>\n<pre><code class=\"language-java\">vagrant status\n\nCurrent machine states:\n\ndefault                   running (virtualbox)\n\nThe VM is running. To stop this VM, you can run `vagrant halt` to\nshut it down forcefully, or you can run `vagrant suspend` to simply\nsuspend the virtual machine. In either case, to restart it again,\nsimply run `vagrant up`.\n</code></pre>\n<p>该命令还提示了如何操作虚机，我们继续一一介绍</p>\n<h3 id=\"64-连接虚机\">6.4 连接虚机</h3>\n<p>如果启动没问题，接下来执行 <code>vagrant ssh</code> 就能以 <code>vagrant</code> 用户直接登入虚机中。</p>\n<p>root 用户没有默认密码，也不能直接登录。需要 root 权限的命令可以通过在命令前添加 <code>sudo</code> 来执行，也可以执行 <code>sudo -i</code> 直接切换到 root 用户。</p>\n<p>这时候打开 <code>VirtualBox</code> 程序，可以看到自动创建的虚机：<br />\n<img src=\"https://img-blog.csdnimg.cn/20210308120126381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>我们也可以在 VirtualBox 的终端上登录系统，默认的登录用户名和密码<strong>都是</strong> <code>vagrant</code>。</p>\n<p>当然还可以使用其它的 SSH 连接工具例如 XShell，SecureCRT 连接，但是这里默认网卡使用的是 NAT 模式，没有指定 IP，实际应用并不方便，我们在后面介绍网络配置时再详细介绍如何连接虚机。</p>\n<p><strong>停止虚机</strong><br />\n执行下面的命令可以关闭虚机：</p>\n<pre><code class=\"language-java\">vagrant halt\n</code></pre>\n<p>直接在 VirtualBox 上关闭虚机，或者直接在虚机内部执行 poweroff 命令也都是可以的。</p>\n<p><strong>暂停虚机</strong><br />\n执行下面的命令可以暂停虚机：</p>\n<pre><code class=\"language-java\">vagrant suspend\n</code></pre>\n<p><strong>恢复虚机</strong><br />\n执行下面的命令把暂停状态的虚机恢复运行：</p>\n<pre><code class=\"language-java\">vagrant resume\n</code></pre>\n<p>注意： 不管虚机是关闭还是暂停状态，甚至是 error 状态，都可以执行 vagrant up 来让虚机恢复运行。</p>\n<p><strong>重载虚机</strong><br />\n执行下面的命令会重启虚机，并且重新加载 Vagrantfile 中的配置信息：</p>\n<pre><code class=\"language-java\">vagrant reload\n</code></pre>\n<p><strong>删除虚机</strong><br />\n最后，执行下面的命令可以彻底删除虚机，包括整个虚机文件：</p>\n<pre><code class=\"language-java\">vagrant destroy\n</code></pre>\n<p>注意： 在当前这个小例子中，上面所有的 vagrant 命令都需要在 Vagrantfile 所在的目录下执行。</p>\n<h2 id=\"7自定义配置-vagrantfile\">7.自定义配置 Vagrantfile</h2>\n<p>端口转发（Port forward）又叫端口映射，就是把虚机的某个端口，映射到宿主机的端口上。这样就能在宿主机上访问到虚拟机中的服务。</p>\n<p>例如启动虚机时，默认的 <code>22 (guest) =&gt; 2222 (host) (adapter 1)</code> 就是把虚机的 SSH 服务端口（22）映射到宿主机的 2222 端口，这样直接在宿主机通过 ssh 客户端访问 <code>127.0.0.1:2222</code> 端口就等价于访问虚拟机的 22 端口。</p>\n<p>默认的网络连接方式是网络地址转换NAT（端口转发），如果其他主机要访问虚拟机，必须由windows端口如3333断发给虚拟机端口如3306。这样每在linux里安一个软件都要进行端口映射，不方便，（也可以在virualBox里挨个设置）。我们想要给虚拟机一个固定的ip地址，windows和虚拟机可以互相ping通。</p>\n<p><strong>方式1是在虚拟机中配置静态ip。</strong></p>\n<p>也可以更改<code>Vagrantfile</code>更改虚拟机ip，修改其中的<code>config.vm.network``&quot;private_network&quot;,ip:&quot;192.168.56.10&quot;，</code>这个ip需要在windows的<code>ipconfig</code>中查到<code>vitualbox</code>的虚拟网卡ip，然后更改下最后一个数字就行（不能是1，1是我们的主机）。配置完后<code>vagrant reload</code>重启虚拟机。在虚拟机中<code>ip addr</code>就可以查看到地址了。互相ping也能ping通。</p>\n<p>关掉防火墙，<code>VirualBox</code>中第一个网卡设置<code>NAT</code>，第二个网卡设置仅主机</p>\n<p>如果ping不了baidu</p>\n<ul>\n<li><code>cd /etc/sysconfig/network-scripts</code></li>\n<li>ls 一般有<code>ifcfg-eth0 1</code></li>\n<li><code>ip addr</code> 看哪个网格是<code>192.168.56</code>网段，然后vim他</li>\n<li><code>vim ifcfg-eth1</code> 加入</li>\n</ul>\n<pre><code>GATEWAY=192.168.56.1\nDNS1=114.114.114.114\nDNS2=8.8.8.8\n</code></pre>\n<ul>\n<li><code>service network restart</code></li>\n</ul>\n<p>默认只允许ssh登录方式，为了后来操作方便，文件上传等，我们可以配置允许账号密码登录</p>\n<pre><code class=\"language-java\">vim /etc/ssh/sshd_config\n修改\nPasswordAuthentication yes\n重启\nservice sshd restart\n账号root\n密码vagrant\n</code></pre>\n<p>配置源</p>\n<pre><code class=\"language-java\"># 备份原yum源\n\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n# 使用新yum源\ncurl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.163.com/.help/CentOS7-Base-163.repo\n# 生成缓存\nyum makecache\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p>费了莫大的力气，终于可以比较愉快地玩耍了。虽然也只是刚把基础镜像搞定了，后面可能还要针对不同用途的环境编写更加复杂的 Vagrantfile。</p>\n<p>现在很多人刚认识到 Vagrant 之后都会问，<strong>Vagrant 和 Docker 的区别是什么？</strong></p>\n<p>在容器流行之前，Vagrant 就是用来编排虚机和自动部署开发环境的，有了 Docker/Kubernetes 之后，直接用容器来编排应用确实更香。但是还有一些工作，例如容器平台自身的安装，多节点集群的部署测试等，更方便用虚机解决。</p>\n<p>此外，现在 Windows 中还可以通过 WSL 使用 Linux 系统，但是使用场景上还是有所不同。Vagrant 更多地用于快速搭建可重用的开发环境，从这个角度看，Vagrant 其实好比 IaaS 云平台，只不过规模局限在个人电脑上。</p>\n', 1, '', 0, 0, 1, '2021-03-10 18:17:11', '2022-05-21 18:06:00');
INSERT INTO `tb_article` VALUES (250, 1, 7, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8500', '918农业信息化考研资料', '<h2 id=\"%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A\" tabindex=\"-1\">名词解释</h2>\n<p><strong>信息：</strong> 事物之间相互联系、相互作用的状态的描述。</p>\n<p><strong>信息技术：</strong> 是指计算机硬件技术、计算机软件和通信技术的总称。</p>\n<p><strong>信息系统：</strong> 是由计算机硬件、网络和通讯设备、计算机软件、信息资源、信息用户和规章制度组成的以处理信息流为目的的人机一体化系统。</p>\n<p><strong>农业信息：</strong> 是指人们利用农业生产资源进行农产品生产、加工和营销等活动的一切消息、情报、数据等的总称。</p>\n<p><strong>农业信息技术：</strong> 包括农业信息的获取技术（如遥感技术）、处理技术（如数据的并行处理技术）、模拟技术（如作物生长模拟）、自动识别技术、人工智能技术等等。</p>\n<p><strong>农业信息系统：</strong> 一般由农业生物信息、农业环境信息、农业技术知识信息和农业经济信息等四个信息子系统构成。</p>\n<p><strong>农业信息学：</strong> 农业科学与信息科学相互交叉融合形成的一门学科。可以定义为：以农业科学为基本理论基础，以农业信息为对象，以信息技术支撑，研究农业信息的采集、处理、分析、存储、传输及其运动变化规律，为农业生产服务的科学和技术。</p>\n<p><strong>信息再生：</strong> 指运用信息技术和科学方法对本原信息进行加工处理而产生出新的信息的工作过程。</p>\n<p><strong>数据库：</strong> 存放数据的仓库（顾名思义/不准确的含义）尽管数据库技术已发展成熟，但还没有一个普遍接受的、严格的定义。</p>\n<p><strong>数据库系统：</strong> 基于数据库的计算机应用系统。</p>\n<p><strong>数据模型：</strong> 是数据特征的抽象，在数据库系统中，数据模型是它的核心与基础。数据模型描述数据的结构，定义在其上的操作以及约束条件。它从概念层面上描述了系统的静态特征、动态特征和约束条件，为数据库系统的信息表示与操作提供一个抽象框架。</p>\n<p><strong>关系模型：</strong> 用关系表示（不需用指针）实体和实体之间联系的模型称为关系模型。<br />\n<strong>农业专家系统：</strong> 也叫农业智能系统，是一个拥有大量权威农业专家的知识、经验、资料、数据与成果构成的知识库，并能利用其中的知识模拟农业专家解决问题的思维方法尽心判断、推理，求得解决农业生产问题答案的智能程序系统。</p>\n<p><strong>农业模拟模型：</strong> 利用系统分析方法和计算机模拟技术，对农业系统中的生物与非生物过程及其与环境和农业技术措施之间的动态关系进行定量描述和预测。</p>\n<p><strong>系统分析法：</strong> 是把将要研究的目标当做一个统一的整体，并把这个整体分解为若干个子系统，揭示影响子系统的各项因素及相互关系，并进行数量化描述，以此为基础，对获取的信息进行综合整理、分析、判断和加工，选择出最优的因素组合，优化系统或设计新系统。</p>\n<p><strong>精确农业：</strong> 是由信息技术支持的、根据空间变异定位、定时、定量的实施一整套现代化农事</p>\n<p><strong>农业物流：</strong> 是指以农业生产为核心而发生的一系列物品从供应地向接受地的实体流动和与之有关的技术、组织、管理活动。</p>\n<p><strong>电子商务：</strong> 广义上讲，电子商务是电子工具再商务活动中的应用。<br />\n狭义上讲：电子商务是在技术、经济高度发达的现代社会里掌握信息技术和商务规则的人、系统化应用电子工具高效率、低成本地从事以商品交换为中心的葛洪活动的总称。</p>\n<p><strong>物联网：</strong> 物联网被视为互联网的应用扩展，应用创新是物联网的发展的核心，以用户体验为核心的创新是物联网发展的灵魂。</p>\n<p><strong>农业信息化：</strong> 其内涵应包括农业资源环境信息化、农业生产管理信息化、农业市场流通信息化、农业科技与教育信息化、农业产业经营信息化。</p>\n<h2 id=\"%E7%AE%80%E7%AD%94\" tabindex=\"-1\">简答</h2>\n<p><strong>1、	信息有哪些主要性质特征</strong><br />\n真实性、时效性、不完全性、等级性、层次性、对性习惯、价值性、共享性、寄载性</p>\n<p><strong>2、	什么是信息量？如何度量信息量？</strong><br />\n信息量是指从N个相等可能事件中选出一个事件所需要的信息度量或含量，也就是在辨识N个事件中特定的一个事件的过程中所需要提问&quot;是或否&quot;的最少次数.<br />\n信息的度量是利用概率来度量信息。</p>\n<p><strong>3、	农业信息有哪些主要特征？</strong><br />\n1,农业生物的自身特性：农业生产的种子、种苗、种禽等原材料．都是由农业自身提供的．这些农业生物有机体有其自身的生长、发育特性和自然再生产的规律．从事农业生产经营活动，必须掌握农业生物信息，符合农业生物自然再生产的规律．<br />\n2,农业依赖环境的特性：农业生物依赖农业环境而生长、发育、繁衍后代．光、热、水、气、风、霜、雨、雪、土壤质地以及地形地貌等环境信息，对农业生产经营起着促进或制约作用．<br />\n3,农业生产的季节性：春种、夏管、秋收、冬藏，农业生产具有强烈的季节性．按农时组织农业生产经营，要求掌握农时信息，提供农时信息．<br />\n4,农业生产的地域性：农人们按照农业生物适地适生的信息．做到因地制宜的组织农业生产经营活动．<br />\n5,农业生产的周期性：农业生物有其自身的生命周期．农业生产是遵循生物体生命周期规律的有目的的生产活动．为此，人类应掌捏农业生物的生命信息，生命周期的连续信息，以获取农业经济效益和生态效益。<br />\n6,农业生产的系统性：农业生产是生物、环境、经济、技术和人类共同参与活动的系统工程，各方面的信息同时存在，相互渗透，共同作用，推动或制约整个系统的运行.<br />\n7,农业生产的分散性：我国农付地域宽广，由几亿农民从事农业，产生信息的信源分散；将信息传输至信宿．也同样分散．要在广大农村建立信息网络，收集和传输信息，其难度较大．</p>\n<p><strong>4、	农业信息收集有哪些主要途径？</strong><br />\n主要有两类途径：<br />\n（1）	关系途径：沿着各种与信源相关的事物进行收集，如人际关系。<br />\n（2）	技术途径：利用各种技术直接或间接收集信息，如网络技术等。</p>\n<p><strong>5、	农业信息收集有哪些主要方法？</strong><br />\n收集信息的方法主要可分为人工收集法和技术收集方法，</p>\n<ol>\n<li>人工收集法：信息收集者人工地进行收集，如实验、考察、手工查阅文献等。</li>\n<li>技术收集法：通过各种技术手段自动收集，包括计算机技术、微电子技术（传感器）、感、卫星技术等等。</li>\n</ol>\n<p><strong>6、	简述农信息整理加工的基本要求和基本内容。</strong><br />\n基本要求：应符合真实、标准、及时、合适、有效等要求。<br />\n基本内容：<br />\n（1）原始信息的汇集、筛选、分析、鉴别<br />\n（2）信息变换、载体结合、信道选配<br />\n（3）信息分类、排序、编码、录制、储存<br />\n（4）信息再生、转化、进入终端显示、利用等</p>\n<p><strong>7、	简述数据额模型的三要素。</strong><br />\n（1）数据结构——描述数据额的静态特征，包括对数据结构和数据间联系的描述、<br />\n通常按照数据结构的类型来命名数据模型：<br />\n层次结构——层次模型    网状结构——网状模型    关系结构——关系模型<br />\n（2）数据操作——描述数据的动态特征和，一组定义在数据上的操作（包括操作的含义、操作符、运算规则及其语言等），主要操作：检索和更新（插入、删除、修改）<br />\n（3）数据的约束条件——完整性规则的集合，数据库中的数据必须满足这组规则。约束条件的主要目的是使数据库与它所描述的现实系统相符合。</p>\n<p><strong>8、	简述E-R数据模型。</strong><br />\nE-R模型是一种重要的数据模型，它结构简单，语义表现力丰富，描述力强，同时又能方便的转换为其他经常使用的网状、层次或关系模型，所以，再数据库设计中得到广泛应用。</p>\n<p><strong>9、	简述数据库系统的开发流程。</strong><br />\n目前信息系统开发经常采用周期法，该方法将整个信息系统的开发过程分为若干阶段，预先规定每个阶段的目标和任务，按一定准则顺次完成。AMIS的开发可采用生命周期法，其开发过程分为下图所示的六个阶段，即可行性研究、系统分析、系统总体方案设计、系统技术方案分析、系统实施、系统评价与维护。同时，再每个阶段都进行及时讨论和信息反馈。</p>\n<p><strong>10、简述农业专家系统的开发流程。</strong><br />\n包括知识获取，即从农业领域专家收集整理归纳有关的专业知识和经验、数据，并经农业专家系统开发人员消化、整理、归纳写成一条符号表示的形式；确定知识表示和推理方法；建立知识库；编写推理程序，然后调试、运行和修改等步骤。</p>\n<p><strong>11、写出SAS统计分析软件进行多重比较的程序。</strong><br />\nDATA A;<br />\nDO I=1 TO 5;<br />\nDO J=1 TO 10;<br />\nINPUT X @@;<br />\nOUTPUT;<br />\nEND;<br />\nEND;<br />\nDROP J;<br />\nCARDS;<br />\n…<br />\nPROC ANOVA;<br />\nCLASS I;<br />\nMODEL X=I;<br />\nMEANS VLSD;<br />\nRUN.</p>\n<p><strong>12、简述3S技术及其基本原理。</strong></p>\n<p><strong>3S技术是指</strong>遥感技术、地理信息技术、和全球定位系统。是空间技术、传感器技术、卫星定位与导航技术和计算机技术、通讯技术相结合，多学科高度集成的对空间信息进行采集、处理、管理、分析、表达、传播和应用的现在信息技术。</p>\n<p><strong>遥感技术原理：</strong> 直接接触目标物，在距地物几公里到几百公里、甚至上千公里的飞机、飞船、卫星上，使用光学或者电子光学仪器接受地面物体反射或者辐射的电磁波信号，并以图像胶片或数据磁带形式记录下来，形成数字影像。该影像传输到地面，经过各种校正后，进行影像分类、翻译，最后获取所需要的信息。</p>\n<p><strong>地理信息技术原理：</strong> 是在计算机硬件、软件及网络等支持下，对有关空间数据进行获取、存贮、查询检索、处理、分析、显示、更新和提供应用的技术系统。</p>\n<p><strong>全球定位系统原理：</strong> 共24颗卫星，其中3颗备用，分布在6个轨道面上。轨道面对地球赤道面的倾角为55°，各轨道平面升交点赤经相差60°，相邻轨道上卫星的升交距相差30°，轨道平均高度约20200km，均为近圆形轨道，运行周期11h58m。</p>\n<p><strong>13、地物空间数据矢量化的方法有哪些？</strong><br />\n矢量结构是通过记录坐标的方式来表达点线面等地理实体。获取方法：（1）手工数字化法；（2）手扶跟踪数字化法；（3）数据结构转换法。<br />\n（栅格数据结构：栅格结构是以规则的阵列来表示空间地物或现象分布的数据组织，组织中的符复合数据表示地理要素的非几合属性特征。获取方法：1手工网格法2扫描数字化法3分类影像输入法47数据结构转换法。）</p>\n<p><strong>14、简述农业模拟模型的研制步骤。</strong><br />\n（1）	模型选择与系统定义。弄清研究目的、研究水平和研究对象。<br />\n（2）	资料来源。①自己积累或文献资料②从同行专家处获取③补充试验或支持研究<br />\n（3）	模块设计与模型设计。编程语言的选择、算法编程、界面编程、输入输出内容和形式。<br />\n（4）	模型检验与改进。①敏感性分析  分析模型对主要参数和变量反应的灵敏度②校正  调整模型的参数和关系，使得模型符合特定的环境和资料参数③核实  将模拟结果与实际结果进行相关回归分析；将实际结果与模拟结果按同一时间坐标绘1:1图进行比较；检查模拟结果与实际结果的平均误差。</p>\n<p><strong>15、简述农业信息服务的基本原理和基本内容。</strong><br />\n基本内容：1.农业资源信息服务2.农业教育服务3.农业咨询服务4.农业物流服务</p>\n<p><strong>16、实现精确农业的关键技术有哪些？</strong><br />\n精确农业的支持技术除地理信息系统（GIS）、遥感技术（RS）、全球定位系统（GPS）外，还包括决策支持系统（DSS）和变量投入技术（VRT），以上几个关键技术互相补充，共同构建精确农业的技术体系。</p>\n<h1 id=\"%E7%BB%BC%E5%90%88%E9%A2%98\" tabindex=\"-1\">综合题</h1>\n<p><strong>1、	结合专业，谈谈学习农业信息学的意义（不能少于300字）<br />\n2、	结合专业，谈谈在我国如何实现农业的信息化。</strong></p>\n', 1, '', 0, 0, 1, '2021-08-30 10:24:09', '2022-05-21 17:44:21');
INSERT INTO `tb_article` VALUES (251, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=2685', '《计算机网络》复习要点', '<p>《计算机网络》复习要点<br />\n一、概述（远看、近看互联网）<br />\n计算机网络的定义、功能<br />\n组成、分类、拓扑结构<br />\n互联网（因特网）的多级结构、接入方式<br />\n二、物理层<br />\n模拟数据与数字数据、模拟信号与数字信号、模拟信道与数字信道<br />\n不归零码、归零码、曼彻斯特编码、差分曼彻斯特编码<br />\n数据传输率、带宽、信道容量、误码率、时延<br />\n多路复用技术：频分、时分、波分<br />\n交换技术：电路、分组（原理、区别）<br />\n介质：双绞线、同轴电缆、光纤<br />\n三、网络体系结构<br />\n分层原理（为何分层、层间关系、数据在层间传递、封转的过程）<br />\n网络协议的概念、组成元素<br />\nOSI体系结构（每层功能）<br />\nTCP/IP体系结构（每层功能、每层主要协议）<br />\nOSI与 TCP/IP体系结构的比较、综合的五层体系结构<br />\n四、数据链路层（以太网）<br />\n以太网特点、拓扑结构、要解决的问题<br />\nIEEE802标准<br />\nMAC层功能、MAC地址、MAC帧格式<br />\nCSMA/CD工作原理<br />\n交换机（网桥）的工作原理、特点、转发表的建立方法<br />\n交换机与集线器的区别<br />\nVLAN的概念、特点、好处、划分方法<br />\n局域网的搭建、VLAN的划分（实践环节）<br />\n五、网络层（网络互联）<br />\n网络互联的思路、工作原理<br />\n路由器的作用、工作原理<br />\n路由表的基本内容和查表方法<br />\nIP分组的格式、router处理IP分组基本过程<br />\nIP地址（分类地址、子网划分地址）<br />\n单播地址、广播地址、组播地址、特殊IP地址<br />\n子网掩码的作用、使用方法<br />\nIP地址与硬件地址的区别与关系<br />\nARP的功能、原理、有效范围<br />\nICMP功能、特点<br />\nPing、tracert的原理<br />\nRIP的功能、工作原理、优缺点<br />\nOSPF、BGP的功能、特点<br />\n组建互联网、配置地址、路由的基本方法（实践环节）<br />\n六、端到端传输<br />\n传输层的作用、服务类型（可靠传输、不可靠传输）<br />\n端口、端口号的作用、特点、知名端口<br />\nTCP的服务特点、报文格式<br />\nTCP可靠传输的措施（滑动窗口、流量控制、慢开始、拥塞避免算法等）<br />\nUDP的特点、报文格式、应用场景<br />\n七、网络应用<br />\n客户/服务器工作模式的特点<br />\nDNS（域名结构、域名服务器的层次结构、解析过程）</p>\n', 1, '', 0, 0, 1, '2021-08-30 10:42:30', '2021-08-30 10:42:30');
INSERT INTO `tb_article` VALUES (252, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3758', '下载库不库', '<table>\n<thead>\n<tr>\n<th>安装包列表清单👉👉👉</th>\n<th>👇</th>\n<th>👇</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F05%2F07%2FFroit5NB_mysql-installer-community-5.7.28.0.msi?Expires=1652584202\" target=\"_blank\">MySQL</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F08%2F18%2FVFSexUgC_CentOS-7-x86_64-DVD-2003.iso?Expires=1652584306\" target=\"_blank\">Centos7</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F09%2F28%2FMkIuEzVA_%E8%A1%A8%E6%83%85%E5%8C%85.rar?Expires=1652584333\" target=\"_blank\">表情包</a></td>\n</tr>\n<tr>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F05%2F07%2FkSuZFcV0_Redis-x64-3.2.100.zip?Expires=1652584447\" target=\"_blank\">Redis</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F05%2F07%2FhuKw8WI7_jdk-8u201-windows-x64.exe?Expires=1652584467\" target=\"_blank\">JDK8-win64</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F05%2F07%2Fy9YB1Fox_jdk-8u181-linux-x64.tar.gz?Expires=1652584495\" target=\"_blank\">JDK8-Linux</a></td>\n</tr>\n<tr>\n<td><a href=\"http://cloud.henaumcw.top/#/s/ZbCP\" target=\"_blank\">截图工具</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2022%2F06%2F01%2Ff9wuuLPb_wiztree_3_29_setup.exe?Expires=1654090488\" target=\"_blank\">磁盘树分析</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2022%2F06%2F01%2F9FCoSfiA_attahcmentName_findDuplicateClass.exe?Expires=1654090530\" target=\"_blank\">jar包冲突分析工具</a></td>\n</tr>\n<tr>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2022%2F06%2F01%2FrLd8HhNt_mqttfx-1.7.1-windows-x64%20%281%29.exe?Expires=1654090571\" target=\"_blank\">MQTT.FX 1.7.1</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2022%2F06%2F01%2FUPpiUJjH_Listary.exe?Expires=1654090607\" target=\"_blank\">Lisary</a></td>\n<td><a href=\"https://macwoss.oss-cn-beijing.aliyuncs.com/cloud_uploads%2F2020%2F07%2F21%2FYs5dI2fb_WinMTR-v092%20%281%29.rar?Expires=1654090780\" target=\"_blank\">WinMTR路由追踪</a></td>\n</tr>\n</tbody>\n</table>\n', 1, '', 0, 0, 1, '2022-05-15 09:16:51', '2022-06-01 21:45:57');
INSERT INTO `tb_article` VALUES (253, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4520', '测试外链', '<p><a href=\"http://photo.henaumcw.top/\" target=\"_blank\">http://photo.henaumcw.top/</a></p>\n', 1, '', 0, 0, 1, '2022-05-15 18:28:16', '2022-08-09 17:43:55');
INSERT INTO `tb_article` VALUES (254, 1, 13, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=205', '知识图谱入门一：知识图谱介绍', '<p>﻿@<a href=\"知识图谱入门一：\">TOC</a></p>\n<h1 id=\"一知识图谱简介\">一、知识图谱简介</h1>\n<h2 id=\"11-引言\">1.1 引言</h2>\n<p>从一开始的Google搜索，到现在的聊天机器人、大数据风控、证券投资、智能医疗、自适应教育、推荐系统，无一不跟知识图谱相关。它在技术领域的热度也在逐年上升。</p>\n<p>早在 2010 年微软就开始构建知识图谱，包括 Satori 和 Probase；2012 年，Google 正式发布了 Google Knowledge Graph，现在规模已超 700 亿。目前微软和 Google 拥有全世界最大的通用知识图谱，Facebook 拥有全世界最大的社交知识图谱，而阿里巴巴和亚马逊则分别构建了商品知识图谱。<br />\n<img src=\"https://img-blog.csdnimg.cn/9054a66bfd6440faabeb18351edaf203.png\" alt=\"图 1 业内布局\" /><strong><center>图 1 业内布局</center></strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/2f2467ec95e44cb9bd60b9dc1bc68109.png\" alt=\"在这里插入图片描述\" /><br />\n<strong><center>图 2 业内应用</center></strong><br />\n本章以通俗易懂的方式来讲解知识图谱相关的知识、介绍从零开始搭建知识图谱过程当中需要经历的步骤以及每个阶段。本次组队学习还将动手实践一个关于kg在智能问答中的应用。</p>\n<h2 id=\"12-什么是知识图谱呢\">1.2 什么是知识图谱呢？</h2>\n<p>知识图谱是由 Google 公司在 2012 年提出来的一个新的概念。从学术的角度，我们可以对知识图谱给一个这样的定义：“知识图谱本质上是语义网络（Semantic Network）的知识库”。但这有点抽象，所以换个角度，从实际应用的角度出发其实可以简单地把知识图谱理解成多关系图（Multi-relational Graph）。</p>\n<h3 id=\"121-什么是图graph呢\">1.2.1 什么是图（Graph）呢？</h3>\n<ul>\n<li>图（Graph）是由节点（Vertex）和边（Edge）来构成，多关系图一般包含多种类型的节点和多种类型的边。</li>\n<li>实体（节点）指的是现实世界中的事物比如人、地名、概念、药物、公司等，</li>\n<li>关系（边）则用来表达不同实体之间的某种联系，比如人-“居住在”-北京、张三和李四是“朋友”、逻辑回归是深度学习的“先导知识”等等。<br />\n<img src=\"https://img-blog.csdnimg.cn/8620986eba194701a0dca830efb53f23.png\" alt=\"————————————————\n版权声明：本文为CSDN博主「越前浩波」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/weixin_44023658/article/details/112503294\" /><br />\n<strong><center>图 3 图（Graph）介绍</center></strong></li>\n</ul>\n<h3 id=\"122-什么是-schema-呢\">1.2.2 什么是 Schema 呢？</h3>\n<p>知识图谱另外一个很重要的概念是 Schema:</p>\n<ul>\n<li>\n<p>介绍：<strong>Schema（模式）</strong> 限定待加入知识图谱数据的格式；相当于某个领域内的数据模型，包含了该领域内有意义的概念类型以及这些类型的属性</p>\n</li>\n<li>\n<p>作用：规范结构化数据的表达，一条数据必须满足Schema预先定义好的实体对象及其类型，才被允许更新到知识图谱中， <strong>一图胜千言</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/49997f4c7e0a480397bc67c09a68a2b1.png\" alt=\"图 4 Schema定义\" /><br />\n<strong><center>图 4 Schema定义</center></strong></p>\n</li>\n<li>\n<p>图中的<strong>DataType</strong>限定了知识图谱节点值的类型为文本、日期、数字（浮点型与整型）</p>\n</li>\n<li>\n<p>图中的<strong>Thing</strong>限定了节点的类型及其属性（即图1-1中的边）</p>\n</li>\n<li>\n<p>举例说明：基于上图<strong>Schema</strong>构建的知识图谱中仅可含作品、地方组织、人物；其中作品的属性为电影与音乐、地方组织的属性为当地的商业（eg：饭店、俱乐部等）、人物的属性为歌手</p>\n</li>\n</ul>\n<h2 id=\"13-知识图谱的价值在哪呢\">1.3 知识图谱的价值在哪呢？</h2>\n<ul>\n<li>从图5中可以看出，知识图谱是人工智能很重要的一个分支, 人工智能的目标为了让机器具备像人一样理性思考及做事的能力 -&gt;</li>\n<li>在符号主义的引领下，知识工程（核心内容即建设专家系统）取得了突破性的进展 -&gt;</li>\n<li>在整个知识工程的分支下，知识表示是一个非常重要的任务 -&gt;<br />\n而知识图谱又恰恰是知识表示的重要一环<br />\n<img src=\"https://img-blog.csdnimg.cn/2ee44f5e78844320a8ea77f692aada7e.png\" alt=\"在这里插入图片描述\" /></li>\n</ul>\n<p><strong><center>图 5 学科概念</center></strong></p>\n<h1 id=\"二怎么构建知识图谱呢\">二、怎么构建知识图谱呢？</h1>\n<h2 id=\"21-知识图谱的数据来源于哪里\">2.1 知识图谱的数据来源于哪里？</h2>\n<p>知识图谱的构建是后续应用的基础，而且构建的前提是需要把数据从不同的数据源中抽取出来。对于垂直领域的知识图谱来说，它们的数据源主要来自两种渠道：</p>\n<p>第一种：业务本身的数据。这部分数据通常包含在公司内的数据库表并以结构化的方式存储，一般只需要简单预处理即可以作为后续AI系统的输入；<br />\n第二种：网络上公开、抓取的数据。这些数据通常是以网页的形式存在所以是非结构化的数据，一般需要借助于自然语言处理等技术来提取出结构化信息。<br />\n<img src=\"https://img-blog.csdnimg.cn/222b103a13694d7f83daa282f6a2e4b5.png\" alt=\"在这里插入图片描述\" /><strong><center>图 6 数据来源</center></strong><br />\n比如在下面的搜索例子里，Bill Gates和Malinda Gate的关系就可以从非结构化数据中提炼出来，比如维基百科等数据源。<br />\n<img src=\"https://img-blog.csdnimg.cn/4311a97f97674cbfaa267bf023351379.png\" alt=\"在这里插入图片描述\" /><strong><center>图 7 举例说明</center></strong></p>\n<h2 id=\"22-信息抽取的难点在哪里\">2.2 信息抽取的难点在哪里？</h2>\n<p>信息抽取的难点在于处理非结构化数据。在下面的图中，我们给出了一个实例。左边是一段非结构化的英文文本，右边是从这些文本中抽取出来的实体和关系。<br />\n<img src=\"https://img-blog.csdnimg.cn/1d4ed81dab8244239c0ae9c0b976966e.png\" alt=\"在这里插入图片描述\" /><strong><center>图 8 信息抽取的难点举例</center></strong></p>\n<h2 id=\"23-构建知识图谱所涉及的技术\">2.3 构建知识图谱所涉及的技术？</h2>\n<p>在构建类似的图谱过程当中，主要涉及以下几个方面的自然语言处理技术：</p>\n<ul>\n<li>实体命名识别（Name Entity Recognition）</li>\n<li>关系抽取（Relation Extraction）</li>\n<li>实体统一（Entity Resolution）</li>\n<li>指代消解（Coreference Resolution）</li>\n<li>…</li>\n</ul>\n<h2 id=\"24知识图谱的具体构建技术是什么\">2.4、知识图谱的具体构建技术是什么？</h2>\n<p>下面针对每一项技术解决的问题做简单的描述，至于这些是具体怎么实现的，不在这里一一展开。<br />\n<img src=\"https://img-blog.csdnimg.cn/f6cddfc32ebc41d6b606d1c7c29e38ae.png\" alt=\"在这里插入图片描述\" /></p>\n<h3 id=\"241-实体命名识别named-entity-recognition\">2.4.1 实体命名识别（Named Entity Recognition）</h3>\n<ul>\n<li>实体命名识别（英语：Named Entity Recognition），简称NER</li>\n<li>目标：就是从文本里提取出实体并对每个实体做分类/打标签；</li>\n<li>\n<ul>\n<li>举例说明：比如从上述文本里，我们可以提取出实体-“NYC”，并标记实体类型为 “Location”；我们也可以从中提取出“Virgil\'s BBQ”，并标记实体类型为“Restarant”。</li>\n</ul>\n</li>\n<li>这种过程称之为实体命名识别，这是一项相对比较成熟的技术，有一些现成的工具可以用来做这件事情。</li>\n</ul>\n<h3 id=\"242-关系抽取relation-extraction\">2.4.2 关系抽取（Relation Extraction）</h3>\n<ul>\n<li>关系抽取（英语：Relation Extraction），简称 RE</li>\n<li>介绍：通过关系抽取技术，把实体间的关系从文本中提取出来；</li>\n<li>举例说明：比如实体“hotel”和“Hilton property”之间的关系为“in”；“hotel”和“Time Square”的关系为“near”等等。<br />\n<img src=\"https://img-blog.csdnimg.cn/d65109814ab84828bcd9eda2b7ea5056.png\" alt=\"图 9 NER 和 RE 示例\" /><strong><center>图 9 NER 和 RE 示例</center></strong></li>\n</ul>\n<h3 id=\"243-实体统一entity-resolution\">2.4.3 实体统一（Entity Resolution）</h3>\n<ul>\n<li>实体统一（英语：Entity Resolution），简称 ER</li>\n<li>介绍：对于有些实体写法上不一样，但其实是指向同一个实体；</li>\n<li>举例说明：比如“NYC”和“New York”表面上是不同的字符串，但其实指的都是纽约这个城市，需要合并。</li>\n<li>价值：实体统一不仅可以减少实体的种类，也可以降低图谱的稀疏性（Sparsity）；</li>\n</ul>\n<h3 id=\"244-指代消解disambiguation\">2.4.4 指代消解（Disambiguation）</h3>\n<ul>\n<li>指代消解（英语：Disambiguation）</li>\n<li>介绍：文本中出现的“it”, “he”, “she”这些词到底指向哪个实体，比如在本文里两个被标记出来的“it”都指向“hotel”这个实体。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/02c96bbafcba40c0b061dd7f7207774d.png\" alt=\"图 10 ER 和 Disambiguation 示例\" /><strong><center>图 10 ER 和 Disambiguation 示例</center></strong></p>\n<h1 id=\"三知识图谱的存储\">三、知识图谱的存储</h1>\n<ul>\n<li>知识图谱主要有两种存储方式：\n<ul>\n<li>一种是基于RDF的存储；</li>\n<li>另一种是基于图数据库的存储。</li>\n</ul>\n</li>\n</ul>\n<p>它们之间的区别如下图所示。RDF一个重要的设计原则是数据的易发布以及共享，图数据库则把重点放在了高效的图查询和搜索上。其次，RDF以三元组的方式来存储数据而且不包含属性信息，但图数据库一般以属性图为基本的表示形式，所以实体和关系可以包含属性，这就意味着更容易表达现实的业务场景。其中Neo4j系统目前仍是使用率最高的图数据库，它拥有活跃的社区，而且系统本身的查询效率高，但唯一的不足就是不支持准分布式。相反，OrientDB和JanusGraph（原Titan）支持分布式，但这些系统相对较新，社区不如Neo4j活跃，这也就意味着使用过程当中不可避免地会遇到一些刺手的问题。如果选择使用RDF的存储系统，Jena或许一个比较不错的选择。<br />\n<img src=\"https://img-blog.csdnimg.cn/e2baaca77d3b4786910948451ab377f7.png\" alt=\"图 11 RDF的存储 和 基于图数据库的存储 的区别\" /><strong><center>图 11 RDF的存储 和 基于图数据库的存储 的区别</center></strong></p>\n<h1 id=\"四neo4j-介绍与安装\">四、Neo4J 介绍与安装</h1>\n<h2 id=\"41-引言\">4.1 引言</h2>\n<p>“工欲善其事，必先利其器”，知识图谱作为一种特殊的图结构，自然需要专门的图数据库进行存储。</p>\n<p>知识图谱由于其数据包含实体、属性、关系等，常见的关系型数据库诸如MySQL之类不能很好的体现数据的这些特点，因此知识图谱数据的存储一般是采用图数据库（Graph Databases）。而Neo4j是其中最为常见的图数据库。</p>\n<h2 id=\"42-neo4j-下载\">4.2 Neo4J 下载</h2>\n<p>首先在 <a href=\"https://neo4j.com/download/\">Neo4J官网</a> 下载 Neo4J。</p>\n<p>Neo4J分为社区版和企业版：</p>\n<ul>\n<li>企业版：收费，在横向扩展、权限控制、运行性能、HA等方面都比社区版好，适合正式的生产环境；</li>\n<li>社区版：免费，普通的学习和开发采用免费社区版就好。</li>\n</ul>\n<h2 id=\"43-neo4j-安装\">4.3 Neo4J 安装</h2>\n<ul>\n<li>在Mac或者Linux中，安装好jdk后，直接解压下载好的Neo4J包，运行命令</li>\n</ul>\n<pre><code> bin/neo4j start\n</code></pre>\n<ul>\n<li>windows系统下载好neo4j和jdk 1.8.0后，输入以下命令启动后neo4j</li>\n</ul>\n<pre><code> neo4j.bat console\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/a424e4e3acea4eb699a13a903e5481ff.png\" alt=\"图 12 Neo4j 运行结果\" /><strong><center>图 12 Neo4j 运行结果</center></strong></p>\n<h2 id=\"44-neo4j-web-界面-介绍\">4.4 Neo4J Web 界面 介绍</h2>\n<p>Neo4J提供了一个用户友好的 Web 界面，可以进行各项配置、写入、查询等操作，并且提供了可视化功能。类似<strong>ElasticSearch</strong>一样，我个人非常喜欢这种开箱即用的设计。</p>\n<p>打开浏览器，输入<a href=\"http://127.0.0.1:7474/browser/，如下图\">http://127.0.0.1:7474/browser/，如下图</a> 13 所示，界面最上方就是交互的输入框。<br />\n<img src=\"https://img-blog.csdnimg.cn/1f8dfddc7d4f4e5cb3cb45083294006c.png\" alt=\"图 13 Neo4J Web界面\" /><br />\n<strong><center>图 13 Neo4J Web界面</center></strong></p>\n<h2 id=\"45-cypher查询语言\">4.5 Cypher查询语言</h2>\n<ul>\n<li>Cypher：\n<ul>\n<li>介绍：是Neo4J的声明式图形查询语言，允许用户不必编写图形结构的遍历代码，就可以对图形数据进行高效的查询。</li>\n<li>设计目的：类似SQL，适合于开发者以及在数据库上做点对点模式（ad-hoc）查询的专业操作人员。</li>\n<li>其具备的能力包括：\n<ul>\n<li>创建、更新、删除节点和关系</li>\n<li>通过模式匹配来查询和修改节点和关系 - 管理索引和约束等</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>转载，原文链接：<a href=\"https://blog.csdn.net/weixin_44023658/article/details/112503294\">https://blog.csdn.net/weixin_44023658/article/details/112503294</a></p>\n<p>参考资料</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/guleileo/article/details/80879158\">干货 | 从零到一学习知识图谱的技术与应用</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/88745411\">手把手教你快速入门知识图谱 - Neo4J教程</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/82958776\">python操作图数据库neo4j的两种方式</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/93746655\">Neo4j之导入数据</a></li>\n<li><a href=\"https://schema.org/\">schema 介绍</a></li>\n<li><a href=\"https://ai.baidu.com/tech/kg/schema\">知识图谱Schema</a></li>\n<li><a href=\"https://tech.meituan.com/2018/11/01/meituan-ai-nlp.html\">美团大脑：知识图谱的建模方法及其应用</a></li>\n<li><a href=\"https://item.jd.com/10166718622.html\">肖仰华. 知识图谱：概念与技术．北京：电子工业出版社, 2020．2－39．</a></li>\n</ul>\n', 1, '', 0, 0, 1, '2022-05-21 17:42:38', '2022-05-21 18:05:37');
INSERT INTO `tb_article` VALUES (255, 1, 13, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5306', '知识图谱入门：知识图谱的技术流程', '<p>﻿# 知识图谱的技术流程</p>\n<blockquote>\n<p>知识图谱用于表达更加规范的<strong>高质量</strong>数据。</p>\n</blockquote>\n<ul>\n<li>一方面，知识图谱采用更加规范而标准的概念模型、本体术语和语法格式来建模和描述数据；</li>\n<li>另一方面，知识图谱通过语义链接增强数据之间的关联。这种表达规范、关联性强的数据在改进搜索、问答体验、辅助决策分析和支持推理等多个方面都能发挥重要的作用。</li>\n</ul>\n<p>知识图谱方法论涉及<strong>知识表示</strong>、<strong>知识获取</strong>、<strong>知识处理</strong>和<strong>知识利用</strong>多个方面。一般流程为：</p>\n<ul>\n<li>首先确定知识表示模型，然后根据数据来源选择不同的知识获取手段导入知识</li>\n<li>接着综合利用知识推理、知识融合、知识挖掘等技术对构建的知识图谱进行质量提升</li>\n<li>最后根据场景需求设计不同的知识访问与呈现方法，如语义搜索、问答交互、图谱可视化分析等。</li>\n</ul>\n<p>下面简要概述这些技术流程的核心技术要素。</p>\n<h2 id=\"1知识来源\">1.知识来源</h2>\n<blockquote>\n<p>可以从多种来源获取知识图谱数据，包括文本、结构化数据库、多媒体数据、传感器数据和人工众包等。</p>\n</blockquote>\n<p>每一种数据源的知识化都需要综合各种不同的技术手段。例如，对于<strong>文本数据源</strong>，需要综合实体识别、实体链接、关系抽取、事件抽取等各种自然语言处理技术，实现从文本中抽取知识。</p>\n<p><strong>结构化数据库</strong>如各种关系数据库，也是最常用的数据来源之一。已有的结构化数据库通常不能直接作为知识图谱使用，而需要将结构化数据定义到本体模型之间的语义映射。再通过编写语义翻译工具实现结构化数据到知识图谱的转化。此外，还需要综合采用<strong>实体消歧</strong>、<strong>数据融合</strong>、<strong>知识链接</strong>等技术，提升数据的规范化水平，增强数据之间的关联。</p>\n<p><strong>语义技术</strong>也被用来对传感器产生的数据进行语义化。这包括对物联设备进行抽象，定义符合语义标准的数据接口；对传感数据进行语义封装和对传感数据增加上下文语义描述等。</p>\n<p><strong>人工众包</strong>是获取高质量知识图谱的重要手段。例如，<strong>Wikidata</strong> 和 <strong>Sehema.org</strong> 都是较为典型的知识众包技术手段。此外，还可以开发针对文本、图像等多种媒体数据的语义标注工具，辅助人工进行知识获取。</p>\n<h2 id=\"2知识表示与-schema-工程\">2.知识表示与 Schema 工程</h2>\n<blockquote>\n<p><strong>知识表示</strong>是指用计算机符号描述和表示人脑中的知识，以支持机器模拟人的心智进行推理的方法与技术。</p>\n</blockquote>\n<p>知识表示决定了图谱构建的产出目标，即知识图谱的语义描述框架<br />\n(<strong>Description Framework</strong>)、<strong>Schema</strong> 与本体（<strong>Ontology</strong>)、<strong>知识交换语法（Syntax)</strong>、<strong>实体命名</strong>及 <strong>ID 体系</strong>。</p>\n<p>基本描述框架定义知识图谱的基本数据模型（<strong>Data Model</strong>）和逻辑结构（<strong>Structure</strong>)，如:</p>\n<ul>\n<li>国际万维网联盟（<strong>World Wide Web Consortium</strong>，<strong>W3C</strong>）的 RDF。</li>\n<li><strong>Schema</strong> 与本体定义知识图谱的类集、属性集、关系集和词汇集。交换语法定义知识实际存在的物理格式，如<strong>Turtle</strong>、<strong>JSON</strong> 等。实体命名及 ID 体系定义实体的命名原则及唯一标识规范等。</li>\n</ul>\n<h3 id=\"什么是-rdf\">什么是 RDF？</h3>\n<p>w3school中是这样解释的：</p>\n<blockquote>\n<p>RDF 指资源描述框架（Resource Description Framework）<br />\nRDF 是一个用于描述 Web 上的资源的框架<br />\nRDF 提供了针对数据的模型以及语法，这样独立的团体们就可以交换和使用它<br />\nRDF 被设计为可被计算机阅读和理解<br />\nRDF 被设计的目的不是为了向人们显示出来<br />\nRDF 使用 XML 编写<br />\nRDF 是 W3C 语义网络活动的组成部分<br />\nRDF 是一个 W3C 推荐标准</p>\n</blockquote>\n<p>按知识类型的不同，知识图谱包括词（<strong>Vocabulary</strong>）、实体（<strong>Entity</strong>）、关系(<strong>Relation</strong>)、事件(<strong>Event</strong>)、术语体系（<strong>Taxonomy</strong>）、规则（<strong>Rule</strong>）等。</p>\n<ul>\n<li>词一级的知识以<strong>词</strong>为中心，并定义词与词之间的关系，如 <strong>WordNet</strong>，<strong>ConceptNet</strong> 等。</li>\n<li>实体一级的知识以实体以<strong>实体</strong>为中心，并定义实体之间的关系、描述实体的术语体系等。</li>\n<li>事件是一种复合的实体:</li>\n</ul>\n<p>W3C 的 RDF 把三元组（Triple）作为基本的数据模型，其基本的逻辑结构包含主语(<strong>Subject</strong>)、谓词（<strong>Predicate</strong>）、宾语（<strong>Object</strong>）三个部分。虽然不同知识库的描述框架的表述有所不同，但本质上都包含<strong>实体</strong>、<strong>实体的属性</strong>和<strong>实体之间的关系</strong>几个要素。</p>\n<h2 id=\"3知识抽取\">3.知识抽取</h2>\n<blockquote>\n<p>知识抽取按任务可以分为概念抽取、实体识别、关系抽取、事件抽取和规则抽取等。</p>\n</blockquote>\n<p>传统专家系统时代的知识主要依靠专家手工录入，难以扩大规模。现代知识图谱的构建通常大多依靠已有的结构化数据资源进行转化，形成基础数据集，再依靠<strong>自动化知识抽取</strong>和<strong>知识图谱补全技术</strong>，从多种数据来源进一步扩展知识图谱，并通过人工众包进一步提升知识图谱的质量。</p>\n<p><em><strong>结构化和文本数据是目前最主要的知识来源。</strong></em></p>\n<h2 id=\"4知识融合\">4.知识融合</h2>\n<p>在构建知识图谱时，可以从第三方知识库产品或已有结构化数据中获取知识输入。</p>\n<p>当多个知识图谱进行融合，或者将外部关系数据库合并到本体知识库时，需要处理两个层面的问题：</p>\n<ul>\n<li>通过模式层的融合，将新得到的本体融入已有的本体库中，以及新旧本体的融合；</li>\n<li>数据层的融合，包括实体的指称、属性、关系以及所属类别等，主要的问题是如何避免实例以及关系的冲突问题，造成不必要的冗余。</li>\n</ul>\n<p><strong>数据层的融合是指实体和关系（包括属性）元组的融合，主要是实体匹配或者对齐</strong><br />\n由于知识库中有些实体含义相同但是具有不同的标识符，因此需要对这些实体进行合并处理。</p>\n<p>此外，还需要对新增实体和关系进行验证和评估，以确保知识图谱的内容一致性和准确性，通常采用的方法是在评估过程中为新加入的知识赋予可信度值，据此进行知识的过滤和融合。</p>\n<blockquote>\n<p><strong>实体对齐</strong>的任务包括<strong>实体消歧</strong>和<strong>共指消解</strong>，即判断知识库中的同名实体是否代表不同的含义以及知识库中是否存在其他命名实体表示相同的含义。</p>\n</blockquote>\n<ul>\n<li>实体消歧专门用于解决同名实体产生歧义的问题，通常采用聚类法，其关键问题是如何定义实体对象与指称项之间的相似度，一些最新的工作利用知识图谱嵌入方法进行实体对齐，并引入人机协作方式提升实体对齐的质量。</li>\n<li>本体是针对特定领域中 Schema定义、概念模型和公理定义而言的，目的是弥合<strong>词汇异构性</strong>和<strong>语义歧义</strong>的间隙，使沟通达成共识。这种共识往往通过一个反复的过程达到，每次迭代都是一次共识的修改。因此，本体对齐通常带来的是共识模式的演化和变化，本体对齐的主要问题之一也可以转化为怎样管理这种演化和变化】。</li>\n</ul>\n<h2 id=\"5知识图谱补全与推理\">5.知识图谱补全与推理</h2>\n<p>常用的知识图谱补全方法包括:</p>\n<ul>\n<li>基于<strong>本体推理</strong>的补全方法，这类推理主要针对TBox，即概念层进行推理，也可以用来对实体级的关系进行补全。</li>\n<li>基<strong>于图结构和关系路径特征</strong>的方法，如基于随机游走获取路径特征的PRA算法、基于子图结构的SFE法基于层次随机游走模型的 PRA算法。这类算法的共同特点是通过两个实体节点之间的路径，以及节点周围图的结构提取特征，并通过随机游走等算法降低特征抽取的复杂度，然后叠加线性的学习模型进行关系的预测。此类算法依赖于图结构和路径的丰富程度</li>\n<li>更为常见的补全实现是基于表示学习和知识图谱嵌入的链接预测，简单的如前面介绍最基本的翻译模型、组合模型和神经元模型等。这类简单的嵌入模型一般只能实现单步的推理。对于更为复杂的模型，如向量空间中引入随机游走模型的方法，在同一个向量空间中将路径与实体和关系一起表示出来再进行补全的模型</li>\n<li>文本信息也被用来辅助实现知识图谱的补全[。例如，Jointly(w)、ointly(z)、 DKRL、TEKE、SSP 等方法将文本中的实体和结构化图谱中的实体对齐，然后利用双方的语义信息辅助实现关系预测或抽取。这类模型一般包含三个部分:三元组解码器、文本解码器和联合解码器。三元组解码器将知识图谱中的实体和关系转化为低维向量;文本解码器则要从文本语料库中学习实体(词)的向量表示;联合解码器的目的是要保证实体、关系和词的嵌入向量位于相同的空间中，并且集成实体向量和词向量。</li>\n</ul>\n<h2 id=\"6知识检索与知识分析\">6、知识检索与知识分析</h2>\n<p>基于知识图谱的知识检索的实现形式主要包括<strong>语义检索</strong>和<strong>智能问答</strong>。</p>\n<ul>\n<li>传统搜索引擎依靠网页之间的超链接实现网页的搜索，</li>\n<li>而语义搜索直接对事物进行搜索，如人物、机构、地点等。这些事物可能来自文本、图片、视频、音频、loT设备等各种信息资源。而知识图谱和语义技术提供了关于这些事物的分类、属性和关系的描述，使得搜索引擎可以直接对事物进行索引和搜索。</li>\n</ul>\n<p>知识图谱和语义技术也被用来辅助做数据分析与决策。例如，大数据公司 Plantir基于本体融合和集成多种来源的数据，通过知识图谱和语义技术增强数据之间的关联，使得用户可以用更加直观的图谱方式对数据进行关联挖掘与分析。近年来，描述性数据分析(Declarative Data Analysis)越来越受到重视。描述性数据分析是指依赖数据本身的语义描述实现数据分析的方法。不同于计算性数据分析主要以建立各种数据分析模型，如深度神经网络，描述性数据分析突出预先抽取数据的语义，建立数据之间的逻辑，并依靠逻辑推理的方法(如<strong>Datalog</strong>)实现数据分析。</p>\n<p>参考资料：<a href=\"http://product.dangdang.com/27920286.html\">知识图谱：方法、实践与应用</a></p>\n', 1, '', 0, 0, 1, '2022-05-21 18:02:02', '2022-05-21 18:05:24');
INSERT INTO `tb_article` VALUES (256, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1539', '知识图谱与数据库技术：RDF三元组库和Neo4j图数据库', '<p>﻿# 知识图谱与数据库系统</p>\n<blockquote>\n<p>随着知识图谱规模的日益增长，知识图谱数据管理问题愈加突出。近年来，知识图谱和数据库领域均认识到大规模知识图谱数据管理任务的紧迫性。</p>\n</blockquote>\n<p>由于传统关系数据库无法有效适应知识图谱的图数据模型，知识图谱领域形成了<strong>RDF数据的三元组库(Triple Store)</strong>，数据库领域开发了管理属性图的<strong>图数据库(Graph Database)</strong>。</p>\n<p>知识图谱的主要数据模型有<strong>RDF图(RDFgraph)</strong> 和 <strong>属性图(Property Graph)</strong> 两种;知识图谱查询语言可分为 <strong>声明式(Declarative)</strong> 和 <strong>导航式(Navigational)</strong> 两类。</p>\n<h2 id=\"rdf三元组库\">RDF三元组库</h2>\n<p>主要是由 Semantic Web 领域推动开发的数据库管理系统，其数据模型<strong>RDF</strong> 图和查询语言<strong>SPARQL</strong>均遵守<strong>W3C</strong> 标准。查询语言<strong>SPARQL</strong> 从语法上借鉴了 <strong>SQL</strong>语言，属于<strong>声明式查询语言</strong>。</p>\n<p>最新的SPARQL 1.1版本为有效查询<strong>RDF</strong>三元组集合设计了</p>\n<ul>\n<li>三元组模式(<strong>Triple Pattern</strong>)</li>\n<li>基本图模式(<strong>Basic Graph Pattern</strong>)</li>\n<li>属性路径(<strong>Property Path</strong>)</li>\n</ul>\n<p>等多种查询机制。</p>\n<h2 id=\"图数据库\">图数据库</h2>\n<p><strong>图数据库是数据库领域为更好地存储和管理图模型数据而开发的数据库管理系统。</strong> 其数据模型采用属性图，其上的声明式查询语言有:<strong>Cypher</strong>、<strong>PGQL</strong>和<strong>G-Core。</strong></p>\n<ul>\n<li><strong>Cypher</strong> 是开源图数据库 <strong>Neo4j</strong> 中实现的图查询语言。</li>\n<li><strong>PGQL</strong> 是<strong>Oracle</strong>公司开发的图查询语言。</li>\n<li><strong>G-Core</strong>是由**LDBC (Linked Data Benchmarks Council)**组织设计的图查询语言。</li>\n</ul>\n<blockquote>\n<p>考虑到关系数据库采用统一的查询语言<strong>SQL</strong>，目前学术和工业界关于开发统一图数据库语言的呼声越来越高。</p>\n</blockquote>\n<h2 id=\"存储方案\">存储方案</h2>\n<p>目前，基于三元组库和图数据库能够提供的知识图谱数据存储方案可分为三类:</p>\n<h3 id=\"1基于关系的存储方案\">(1)基于关系的存储方案</h3>\n<p>基于关系的存储方案。包括三元组表、水平表、属性表、垂直划分、六重索引和 <strong>DB2RDF</strong> 等。</p>\n<ul>\n<li>\n<p><strong>三元组表</strong>是将知识图谱中的每条三元组存储为一行具有三列的记录(主语，谓语，宾语)。三元组表存储方案虽然简单明了，但三元组表的行数与知识图谱的边数一样，其问题是将知识图谱查询翻译为<strong>SQL</strong>后会产生大量三元组表的自连接操作，影响效率。</p>\n</li>\n<li>\n<p><strong>水平表</strong>存储方案的每行记录存储知识图谱中一个主语的所有谓语和宾语，相当于知识图谱的邻接表。但其缺点在于所需列数目过多，表中产生大量空值，无法存储多值宾语等。</p>\n</li>\n<li>\n<p><strong>属性表</strong>存储方案将同一类主语分配到一个表中，是对水平表存储方案的细化。属性表解决了三元组表的自连接问题和水平表的列数目过多问题。但对于真实大规模知识图谱，属性表的问题包括:所需属性表过多，复杂查询的多表连接效率，空值问题和多值宾语问题。</p>\n</li>\n<li>\n<p><strong>垂直划分</strong>存储方案为知识图谱中的每种谓语建立一张两列的表(主语，宾语)，表中存放由该谓语连接的主语和宾语，支持“主语-主语”作为连接条件的查询操作的快速执行。垂直划分有效解决了空值问题和多值宾语问题;但其仍有缺点，包括:大规模知识图谱的谓语表数目过多、复杂查询表连接过多、更新维护代价大等</p>\n</li>\n<li>\n<p><strong>六重索引</strong>存储方案是将三元组全部6种排列对应地建立为6张表。六重索引通过“空间交换时间”策略有效缓解了三元组表的自连接问题，但需要更多的存储空间开销和索引更新维护代价。</p>\n</li>\n<li>\n<p><strong>DB2RDF</strong>存储方案，是以往存储方案的一种权衡优化。三元组表的灵活性体现在“行维度”上，无论多少行三元组数据，表核式只有3列固定不变;DB2RDF了“列维度”，列名称不再和语绑定，将同一主语的所有谓语和宾语动态分配到某列。</p>\n</li>\n</ul>\n<h2 id=\"2面向rdf的三元组\">(2)面向RDF的三元组。</h2>\n<p>主要的RDF三元组包括:</p>\n<ul>\n<li>商业系统Virtuoso、</li>\n<li>AllegroGraph</li>\n<li>GraphDB</li>\n<li>BlazeGraph</li>\n<li>开源系统Jena</li>\n<li>RDF-3X</li>\n<li>gStore</li>\n</ul>\n<p><strong>RDF4J</strong>目前是Eclipse基下的开源孵化项目，其功能包括RDF数据的解析、储、推理和查询等。RDF4J本身提供内存和磁盘两种RDF存储机制，支持全部的 SPARQL11 查询和更新语言，可以使用与访问本地RDF库相同的API访问远程RD库，支持所有主流的DF格式，包括DFXML、Turtle、N-Triples、N-Quads JSON-LD、TriG和TriXRDF4J框架的主要特点是其模块化的软件架构设计。</p>\n<p><strong>gStore</strong> 是由北京大学、加拿大滑铁卢大学和香港科技大学研究项目开发的基于图的RDF三元组数据库。gStore的底层存储使用RDF图对应的标签图(Signature Graph)并建立“VS树”索引结构以加速查找。gStore 系统提出建立“VS 树”索引，其基本思想实际上是为标签图G*建立不同详细程度的摘要图(SummaryGraph);利用“VS树”索引提供的摘要图，gStore 系统提出可以大幅削减 SPARQL 查询的搜索空间，以加快查询速度。</p>\n<h3 id=\"3原生图数据库neo4j\">(3)原生图数据库Neo4j</h3>\n<p><strong>Neo4j 是用 Java实现的开源图数据库。 可以说Neo4j是目前流行程度最高的图数据库产品。</strong></p>\n<p>Neo4j的不足之处在于其社区版是<strong>单机系统</strong>，虽然Neo4j企业版支持高可用性(<strong>High availability</strong>)集群，但其与分布式图存储系统的最大区别在于每个节点上存储图数据库的完整副本(类似于关系数据库镜像的副本集群)，而不是将图数据划分为子图进行分布式存储，而并非真正意义上的分布式数据库系统。如果图数据超过一定规模，系统性能就会因为磁盘、内存等限制而大幅降低。</p>\n<p><strong>JanusGraph</strong> 是在原有Titan系统基础上继续开发的开源分布式图数据库，目前是 Linux基金会旗下的一个开源项目。JanusGraph的存储后端与查询引擎是分离的，由于其可使用分布式Bigtable 存储库Cassandra或HBase 作为存储后端，<strong>因此 JanusGraph自然就成了分布式图数据库</strong>。JanusGraph分布式查询功能仅限于基于Cassandra或 HBase提供的分布式读写实现的简单导航查询，对于很多稍复杂的查询类型，目前还不了持真正意义上的分布式查询处理，例如子图匹配查询、正则路径查询等。</p>\n<h1 id=\"总结\">总结</h1>\n<blockquote>\n<p>总体来讲，基于关系的存储系统继承了关系数据库的优势，成熟度较高，在硬件性能和存储容量满足的前提下，通常能够适应千万到十亿三元组规模的管理。</p>\n</blockquote>\n<p>官方测评显示，关系数据库Oracle 12c配上空间和图数据扩展组件(Spatial and Graph)可以管理的三元组数量高达1.08万亿条。</p>\n<p>对于一般在百万到上亿三元组的管理，使用稍高配置的单机系统和主流RDF三元组数据库(如Jena、RDF4J、Virtuoso等)完全可以胜任。</p>\n<p>如果需要管理几亿到十几亿以上大规模的RDF三元组，则可尝试部署具备分布式存储与查询能力的数据库系统(如商业版的GraphDB 和BlazeGraph、开源的JanusGraph等)。</p>\n<p><strong>近年来，以 Neo4j 为代表的图数据库系统发展迅猛，使用图数据库管理 RDF三元组也是一种很好的选择</strong>;但目前大部分图数据库还不能直接支持RDF三元组存储，对于这种情况，可采用数据转换方式，先将RDF 预处理为图数据库支持的数据格式(如属性图模型)，再进行后续管理操作。</p>\n<p><em>目前，还没有一种数据库系统被公认为是具有主导地位的知识图谱数据库。但可以预见，随着三元组库和图数据库的相互融合发展，知识图谱的存储和数据管理手段将愈加丰富和强大。</em></p>\n<p>参考资料：<a href=\"http://product.dangdang.com/27920286.html\">知识图谱：方法、实践与应用：王昊奋 漆桂林等主编</a></p>\n', 1, '', 0, 0, 1, '2022-05-22 10:31:00', '2022-05-22 10:31:00');
INSERT INTO `tb_article` VALUES (257, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5475', '一篇文章带你入门python基础开发', '<p>》字节序列 === 序列化</p>\n<ul>\n<li>字节序列--》对象 ===反序列化</li>\n</ul>\n<p>Python中提供了JSON这个模块用来实现数据的序列化和反序列化。</p>\n<p><strong>JSON模块</strong></p>\n<blockquote>\n<ul>\n<li>JSON(JavaScriptObjectNotation, JS对象简谱)是一种轻量级的数据交换标准。JSON的本质是字符串。</li>\n</ul>\n</blockquote>\n<ul>\n<li>使用JSON实现序列化<br />\nJSON提供了<code>dump</code>和<code>dumps</code>方法，将一个对象进行序列化。</li>\n<li><strong>dumps方法的作用是把对象转换成为字符串，它本身不具备将数据写入到文件的功能。</strong></li>\n</ul>\n<pre><code>import json\nfile = open(\'names.txt\', \'w\')\nnames = [\'zhangsan\', \'lisi\', \'wangwu\', \'jerry\', \'henry\', \'merry\', \'chris\']\n# file.write(names) 出错，不能直接将列表写入到文件里\n# 可以调用 json的dumps方法，传入一个对象参数\nresult = json.dumps(names)\n# dumps 方法得到的结果是一个字符串\nprint(type(result)) # &lt;class \'str\'&gt;\n# 可以将字符串写入到文件里\nfile.write(result)\nfile.close()\n</code></pre>\n<ul>\n<li>dump方法可以在将对象转换成为字符串的同时，指定一个文件对象，把转换后的字符串写入到这个文件里。</li>\n</ul>\n<pre><code>import json\nfile = open(\'names.txt\', \'w\')\nnames = [\'zhangsan\', \'lisi\', \'wangwu\', \'jerry\', \'henry\', \'merry\', \'chris\']\n# dump方法可以接收一个文件参数，在将对象转换成为字符串的同时写入到文件里\njson.dump(names, file)\nfile.close()\n</code></pre>\n<p><strong>使用JSON实现反序列化</strong></p>\n<ul>\n<li>使用loads和load方法，可以将一个JSON字符串反序列化成为一个Python对象。</li>\n<li>loads方法需要一个字符串参数，用来将一个字符串加载成为Python对象。</li>\n</ul>\n<pre><code>import json\n# 调用loads方法，传入一个字符串，可以将这个字符串加载成为Python对象\nresult = json.loads(\'[&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;, &quot;jerry&quot;, &quot;henry&quot;, &quot;merry&quot;, &quot;chris&quot;]\')\nprint(type(result)) # &lt;class \'list\'&gt;\n</code></pre>\n<ul>\n<li>load方法可以传入一个文件对象，用来将一个文件对象里的数据加载成为Python对象。</li>\n</ul>\n<pre><code>import json\n# 以可读方式打开一个文件\nfile = open(\'names.txt\', \'r\')\n# 调用load方法，将文件里的内容加载成为一个Python对象\nresult = json.load(file)\nprint(result)\nfile.close()\n</code></pre>\n<h2 id=\"11-异常\">11. 异常</h2>\n<blockquote>\n<ul>\n<li>程序在运行过程中，由于我们的编码不规范，或者其他原因一些客观原因，导致我们的程序无法继续运行，此时，程序就会出现异常。如果我们不对异常进行处理，程序可能会由于异常直接中断掉。为了保证程序的健壮性，我们<br />\n在程序设计里提出了异常处理这个概念。</li>\n</ul>\n</blockquote>\n<h3 id=\"111-读取文件异常\">11.1 读取文件异常</h3>\n<ul>\n<li>在读取一个文件时，如果这个文件不存在，则会报出FileNotFoundError错误。<br />\n<img src=\"https://img-blog.csdnimg.cn/e78321b2672e42d2afa79dabc952f4fa.png\" alt=\"在这里插入图片描述\" /></li>\n</ul>\n<h3 id=\"112-tryexcept语句\">11.2 try...except语句</h3>\n<ul>\n<li>try...except语句可以对代码运行过程中可能出现的异常进行处理。 语法结构:</li>\n</ul>\n<pre><code>try:\n可能会出现异常的代码块\nexcept 异常的类型:\n出现异常以后的处理语句\n</code></pre>\n<ul>\n<li>示例：</li>\n</ul>\n<pre><code>try:\nf = open(\'test.txt\', \'r\')\nprint(f.read())\nexcept FileNotFoundError:\nprint(\'文件没有找到,请检查文件名称是否正确\')\n</code></pre>\n<h2 id=\"参考资料\">参考资料：</h2>\n<p><a href=\"https://www.bilibili.com/video/BV1Db4y1m7Ho?p=3\">尚硅谷Python爬虫教程小白零基础速通（含python基础+爬虫案例）</a></p>\n', 1, '', 0, 0, 1, '2022-05-28 16:40:32', '2022-05-28 16:40:32');
INSERT INTO `tb_article` VALUES (258, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=6346', 'SpringBoot启动报错：Failed to introspect Class [XXX] from ClassLoader解决办法', '<p>-记录处理异常<br />\nE:/repo\\duplicate_class.log----记录处理结果<br />\n如果是cmd运行，可以看到提示<br />\n<img src=\"https://img-blog.csdnimg.cn/eb41325005754dd5b401e232ee29e7b4.jpeg\" alt=\"在这里插入图片描述\" /></p>\n<p>最后生成出来的信息如图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/df45d11284c7495bb9ca9db721450143.png\" alt=\"在这里插入图片描述\" /><br />\n然后根据对应的相似文件找到冲突的包所在的位置，进而修改或者删除都可以。</p>\n<p><em><strong>一个小工具的使用，又是拯救世界的一天呢！~</strong></em></p>\n', 1, '', 0, 0, 1, '2022-06-03 21:41:08', '2022-06-03 21:41:08');
INSERT INTO `tb_article` VALUES (259, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4516', 'mysql根据父节点递归查询所有子节点，List转树形结构工具类', '<p>﻿&gt; 经常有业务需要递归查询MySQL树形结构某一节点的所有子节点，每次从网上扒拉找都得找半天，索性就自己总结一些自己遇到的比较好用的一些方法。</p>\n<h1 id=\"sql方法一\">SQL方法一：</h1>\n<pre><code class=\"language-sql\">SELECT\n	* \nFROM\n	(\n	SELECT\n		t1.*,\n	IF\n		( FIND_IN_SET( parent_id, @parent_ids ) &gt; 0, @parent_ids := CONCAT( @parent_ids, \',\', id ), \'0\' ) AS ischild \n	FROM\n		( SELECT * FROM blade_menu AS t WHERE t.is_deleted = 0 AND client_type = \'dianduyun_app\' ORDER BY t.id ASC ) t1,\n		( SELECT @parent_ids := \'1508255373140103170\' ) t2 \n	) t3 \nWHERE\n	ischild != \'0\'\n</code></pre>\n<h2 id=\"需要修改的地方\">需要修改的地方</h2>\n<ul>\n<li><em><strong>parent_id</strong></em>，改为你的父级id字段</li>\n<li><em><strong>blade_menu</strong></em> ，改为你的表名称</li>\n<li>WHERE <em><strong>t.is_deleted = 0</strong></em> ，改为你的查询条件</li>\n<li>@parent_ids := \'<em><strong>1508255373140103170</strong></em>\'，值改为你要传入的父级id</li>\n</ul>\n<h2 id=\"执行结果\">执行结果</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/87dc6bdc02a44b61b9396b95661a6443.png\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"sql方法二\">SQL方法二：</h1>\n<pre><code class=\"language-sql\">SELECT\n	rd.* \nFROM\n	( SELECT * FROM fine_authority_object WHERE parentId IS NOT NULL AND is_deleted = 0 ) rd,\n	( SELECT @pid := \'2342465874553522423\' ) pd \nWHERE\n	FIND_IN_SET( parentId, @pid ) &gt; 0 \n	AND @pid := concat( @pid, \',\', id ) \n\nUNION\nSELECT\n	* \nFROM\n	fine_authority_object \nWHERE\n	FIND_IN_SET( id, @pid ) &gt; 0;\n</code></pre>\n<h2 id=\"需要修改的地方-1\">需要修改的地方</h2>\n<ul>\n<li><em><strong>fine_authority_object</strong></em> ，改为你的表名，以及后面的查询条件进行修改。</li>\n<li>SELECT @pid := \'<em><strong>2342465874553522423</strong></em>\' ，值改为你要传的父id的值</li>\n<li>FIND_IN_SET( <em><strong>parentId</strong></em>, @pid ) ，parentId改为你的父级id字段名</li>\n</ul>\n<p><strong>备注：</strong></p>\n<ul>\n<li>当前这条SQL是根据多个父节点查询所有子节点（包含自身）</li>\n<li>如果不想查询结果包含自身，去掉后边的union</li>\n</ul>\n<h2 id=\"执行结果示例\">执行结果示例</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/b0d2d90d17b3433db11cfd9822570f80.png\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"java-list转树形结构\">Java List转树形结构</h1>\n<blockquote>\n<p>另外再分享一个将上面查询出来的list给转成树形结构的形式给前端返回的一个工具类。</p>\n</blockquote>\n<pre><code class=\"language-java\"> public static List&lt;ReportTemplateVo&gt; listToTree2(List&lt;ReportTemplateVo&gt; list) {\n        List&lt;ReportTemplateVo&gt; tree = new ArrayList&lt;&gt;();\n        for (ReportTemplateVo ReportTemplateVo : list) {\n            //找到根节点\n            if (ReportTemplateVo.getParentId().equals(&quot;reportlets&quot;)) {\n                tree.add(findChildren(ReportTemplateVo, list));\n            }\n        }\n        return tree;\n    }\n\n    /**\n     * 查找ReportTemplateVo的子节点\n     * @param ReportTemplateVo\n     * @param list\n     * @return\n     */\n    private static ReportTemplateVo findChildren(ReportTemplateVo ReportTemplateVo, List&lt;ReportTemplateVo&gt; list) {\n        List&lt;ReportTemplateVo&gt; children = new ArrayList&lt;&gt;();\n        for (ReportTemplateVo node : list) {\n            if (node.getParentId().equals(ReportTemplateVo.getId())) {\n                //递归调用\n                children.add(findChildren(node, list));\n            }\n        }\n        ReportTemplateVo.setChildren(children);\n        return ReportTemplateVo;\n    }\n</code></pre>\n<p><strong>ReportTemplateVo实体：</strong></p>\n<pre><code>public class ReportTemplateVo  {\n    private static final long serialVersionUID = 1L;\n    /**\n     * 主键ID\n     */\n    private String id;\n\n    /**\n     * 父节点ID\n     */\n    private String parentId;\n\n    /**\n     * 子孙节点\n     */\n    private List&lt;ReportTemplateVo&gt; children;\n\n    @ApiModelProperty(&quot;节点是否可以被选中&quot;)\n    private Boolean disabled;\n\n    /**\n     * 节点名称\n     */\n    @ApiModelProperty(&quot;节点名称&quot;)\n    private String title;\n \n</code></pre>\n<h1 id=\"总结\">总结</h1>\n<p>这两种方法都可以查询到自己想要的数据。然后调用这个方法可以直接生成相应的树形结构，这种东西很常用，又懒得自己写， 所以勤记录，多做备份会省很多事儿，</p>\n<p><em><strong>最后，愿大家都乐意分享一些高效开发小工具，减少重复造轮子~</strong></em></p>\n', 1, '', 0, 0, 1, '2022-06-06 17:09:52', '2022-06-06 17:09:52');
INSERT INTO `tb_article` VALUES (260, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4185', '【python】爬取CSDN博客文章（保存为html，txt，md）', '<p>--------  &lt;--<br />\nrequests==2.26.0 -------  &lt;--<br />\nurllib3==1.26.7<br />\n&quot;&quot;&quot;</p>\n<pre><code>def crawl(url):\n    headers = {\n        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36&quot;,\n    }\n    print(&quot;crawl...&quot;)\n    # 配置header破反爬\n    response = requests.get(url, headers=headers)\n    # 200就继续\n    if response.status_code == 200:\n        html = response.content.decode(&quot;utf8&quot;)\n        # print(html)\n        tree = etree.HTML(html)\n        print(&quot;look for text...&quot;)\n        # 找到需要的html块\n        title = tree.xpath(\'//*[@id=&quot;articleContentId&quot;]/text()\')[0]\n        block = tree.xpath(\'//*[@id=&quot;content_views&quot;]\')\n        # html\n        ohtml = unescape(etree.tostring(block[0]).decode(&quot;utf8&quot;))\n        # 纯文本\n        text = block[0].xpath(\'string(.)\').strip()\n        # print(&quot;html:&quot;, ohtml)\n        # print(&quot;text:&quot;, text)\n        print(&quot;title:&quot;, title)\n        save(ohtml, text)\n        # 完成！\n        print(&quot;finish!&quot;)\n    else:\n        print(&quot;failed!&quot;)\n\n\ndef save(html, text):\n    if &quot;output&quot; not in os.listdir():\n        # 不存在输出文件夹就创建\n        os.mkdir(&quot;output&quot;)\n        os.mkdir(&quot;output/html&quot;)\n        os.mkdir(&quot;output/text&quot;)\n        os.mkdir(&quot;output/markdown&quot;)\n    with open(f&quot;output/html/{title}.html&quot;, \'w\', encoding=\'utf8\') as html_file:\n        # 保存html\n        print(&quot;write html...&quot;)\n        html_file.write(html)\n    with open(f&quot;output/text/{title}.txt&quot;, \'w\', encoding=\'utf8\') as txt_file:\n        # 保存纯文本\n        print(&quot;write text...&quot;)\n        txt_file.write(text)\n    with open(f&quot;output/markdown/{title}.md&quot;, \'w\', encoding=\'utf8\') as md_file:\n        # 保存markdown\n        print(&quot;write markdown...&quot;)\n        text_maker = HTML2Text()\n        # md转换\n        md_text = text_maker.handle(html)\n        md_file.write(md_text)\n\n\nif __name__ == \'__main__\':\n    # 你想要爬取的文章url\n    url = &quot;url&quot;\n    crawl(url)\n</code></pre>\n<h2 id=\"参考资料\">参考资料</h2>\n<p>[Xpath如何提取一个标签里的所有文本？_对明天的期待丶的博客-<br />\nCSDN博客](<a href=\"https://blog.csdn.net/qq_39429962/article/details/84196938?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=xpath%20div%E6%A0%87%E7%AD%BE%E4%B8%8B%E7%BA%AF%E6%96%87%E6%9C%AC&amp;utm_medium=distribute.pc_search_result.none-\">https://blog.csdn.net/qq_39429962/article/details/84196938?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=xpath%20div%E6%A0%87%E7%AD%BE%E4%B8%8B%E7%BA%AF%E6%96%87%E6%9C%AC&amp;utm_medium=distribute.pc_search_result.none-</a><br />\ntask-<br />\nblog-2~all~sobaiduweb~default-0-84196938.pc_search_result_control_group&amp;spm=1018.2226.3001.4187<br />\n&quot;Xpath如何提取一个标签里的所有文本？_对明天的期待丶的博客-CSDN博客&quot;)</p>\n<p>[python中HTML文档转义与反转义方法介绍_codingforhaifeng的博客-CSDN博客_python<br />\n反转义](<a href=\"https://blog.csdn.net/codingforhaifeng/article/details/80615008?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163560612316780271561525%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163560612316780271561525&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-\">https://blog.csdn.net/codingforhaifeng/article/details/80615008?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163560612316780271561525%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163560612316780271561525&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-</a><br />\ntask-<br />\nblog-2~all~baidu_landing_v2~default-1-80615008.pc_search_result_control_group&amp;utm_term=python+html%E5%8F%8D%E8%BD%AC%E4%B9%89&amp;spm=1018.2226.3001.4187<br />\n&quot;python中HTML文档转义与反转义方法介绍_codingforhaifeng的博客-CSDN博客_python 反转义&quot;)</p>\n<p>[html文件转md文件_OzupeSir-<br />\nCSDN博客_html转md](<a href=\"https://blog.csdn.net/weixin_45611266/article/details/102563758?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163560314016780262529248%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163560314016780262529248&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-\">https://blog.csdn.net/weixin_45611266/article/details/102563758?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163560314016780262529248%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163560314016780262529248&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-</a><br />\ntask-<br />\nblog-2~all~sobaiduend~default-2-102563758.pc_search_result_control_group&amp;utm_term=html%E8%BD%ACmd&amp;spm=1018.2226.3001.4187<br />\n&quot;html文件转md文件_OzupeSir-CSDN博客_html转md&quot;)</p>\n<p>[两万字博文教你python爬虫requests库【详解篇】_孤寒者的博客-CSDN博客_python<br />\nrequests库](<a href=\"https://blog.csdn.net/qq_44907926/article/details/118667559?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163560953216780366582463%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163560953216780366582463&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-\">https://blog.csdn.net/qq_44907926/article/details/118667559?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163560953216780366582463%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163560953216780366582463&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-</a><br />\ntask-<br />\nblog-2~all~top_positive~default-1-118667559.pc_search_result_control_group&amp;utm_term=requests&amp;spm=1018.2226.3001.4187<br />\n&quot;两万字博文教你python爬虫requests库【详解篇】_孤寒者的博客-CSDN博客_python requests库&quot;)</p>\n<p>感谢大佬帮助</p>\n<h2 id=\"搞定\">搞定</h2>\n<p>快乐</p>\n<p>\\(￣︶￣*\\))</p>\n<p><img src=\"https://img-blog.csdnimg.cn/27cafccd372a44aa85dac9a552b2b992.png\" alt=\"\" /></p>\n<p>睡觉。</p>\n<p>(￣o￣) . z Z</p>\n', 1, '', 0, 0, 1, '2022-06-10 15:21:44', '2022-06-10 15:21:44');
INSERT INTO `tb_article` VALUES (261, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8577', 'Docker学习中文文档大全、docker&docker-compose实战', '<p>|---|---<br />\n磁盘占用| 几个GB到几十个GB左右| 几十MB到几百MB左右<br />\nCPU内存占用| 虚拟操作系统非常占用CPU和内存| Docker引擎占用极低<br />\n启动速度| （从开机到运行项目）几分钟| （从开启容器到运行项目）几秒<br />\n安装管理| 需要专门的运维技术| 安装、管理方便<br />\n应用部署| 每次部署都费时费力| 从第二次部署开始轻松简捷<br />\n耦合性| 多个应用服务安装到一起，容易互相影响| 每个应用服务一个容器，达成隔离<br />\n系统依赖| 无| 需求相同或相似的内核，目前推荐是Linux</p>\n<hr />\n<h2 id=\"4docker的安装\">4.Docker的安装</h2>\n<h3 id=\"41-安装dockercentos7x\">4.1 安装docker(centos7.x)</h3>\n<ul>\n<li>\n<p>卸载原始docker</p>\n<pre><code>$ sudo yum remove docker \\\n              docker-client \\\n              docker-client-latest \\\n              docker-common \\\n              docker-latest \\\n              docker-latest-logrotate \\\n              docker-logrotate \\\n              docker-engine\n</code></pre>\n</li>\n<li>\n<p>安装docker依赖</p>\n<pre><code>$ sudo yum install -y yum-utils \\\n</code></pre>\n<p>device-mapper-persistent-data <br />\nlvm2</p>\n</li>\n<li>\n<p>设置docker的yum源</p>\n<pre><code>$ sudo yum-config-manager \\\n--add-repo \\\nhttps://download.docker.com/linux/centos/docker-ce.repo\n</code></pre>\n</li>\n<li>\n<p>安装最新版的docker</p>\n<pre><code>$ sudo yum install docker-ce docker-ce-cli containerd.io\n</code></pre>\n</li>\n<li>\n<p>指定版本安装docker</p>\n<pre><code>$ yum list docker-ce --showduplicates | sort -r\n</code></pre>\n<p>$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io<br />\n$ sudo yum install docker-ce-18.09.5-3.el7 docker-ce-cli-18.09.5-3.el7 containerd.io</p>\n</li>\n<li>\n<p>启动docker</p>\n<pre><code>$ sudo systemctl enable docker\n</code></pre>\n<p>$ sudo systemctl start docker</p>\n</li>\n<li>\n<p>关闭docker</p>\n<p>$ sudo systemctl stop docker</p>\n</li>\n<li>\n<p>测试docker安装</p>\n<pre><code>$ sudo docker run hello-world\n</code></pre>\n</li>\n</ul>\n<h3 id=\"42-bash安装通用所有平台\">4.2 bash安装(通用所有平台)</h3>\n<ul>\n<li>\n<p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。</p>\n<pre><code>$ curl -fsSL get.docker.com -o get-docker.sh\n</code></pre>\n<p>$ sudo sh get-docker.sh --mirror Aliyun</p>\n</li>\n<li>\n<p>启动docker</p>\n<pre><code>$ sudo systemctl enable docker\n</code></pre>\n<p>$ sudo systemctl start docker</p>\n</li>\n<li>\n<p>创建docker用户组</p>\n<pre><code>$ sudo groupadd docker\n</code></pre>\n</li>\n<li>\n<p>将当前用户加入docker组</p>\n<pre><code>$ sudo usermod -aG docker $USER\n</code></pre>\n</li>\n<li>\n<p>测试docker安装是否正确</p>\n<pre><code>$ docker run hello-world\n</code></pre>\n</li>\n</ul>\n<h2 id=\"5docker-的核心架构\">5.Docker 的核心架构</h2>\n<p>![image-20200404111908085](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/img_convert/a1bc4b93d120d11567f6359251cb66da.png)</p>\n<ul>\n<li><code>镜像:</code> 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等</li>\n<li><code>容器:</code> 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写</li>\n<li><code>仓库:</code>用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置</li>\n<li><code>dockerFile:</code>docker生成镜像配置文件,用来书写自定义镜像的一些配置</li>\n<li><code>tar:</code>一个对镜像打包的文件,日后可以还原成镜像</li>\n</ul>\n<h2 id=\"6-docker-配置阿里镜像加速服务\">6. Docker 配置阿里镜像加速服务</h2>\n<h3 id=\"61-docker-运行流程\">6.1 docker 运行流程</h3>\n<p>![image-20200404120356784](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/img_convert/810545e95c8a3951e9f1608a2b506ba2.png)</p>\n<h3 id=\"62-docker配置阿里云镜像加速\">6.2 docker配置阿里云镜像加速</h3>\n<ul>\n<li>\n<p><code>访问阿里云登录自己账号查看docker镜像加速服务</code></p>\n<p>sudo mkdir -p /etc/docker<br />\nsudo tee /etc/docker/daemon.json &lt;&lt;-\'EOF\'<br />\n{<br />\n&quot;registry-mirrors&quot;: [&quot;https://lz2nib3q.mirror.aliyuncs.com&quot;]<br />\n}<br />\nEOF<br />\nsudo systemctl daemon-reload<br />\nsudo systemctl restart docker</p>\n</li>\n<li>\n<p><code>验证docker的镜像加速是否生效</code></p>\n<p>[root@localhost ~]# docker info<br />\n..........<br />\n127.0.0.0/8<br />\nRegistry Mirrors:<br />\n\'<a href=\"https://lz2nib3q.mirror.aliyuncs.com/\">https://lz2nib3q.mirror.aliyuncs.com/</a>\'<br />\nLive Restore Enabled: false<br />\nProduct License: Community Engine</p>\n</li>\n</ul>\n<hr />\n<h2 id=\"7docker的入门应用\">7.Docker的入门应用</h2>\n<h3 id=\"71-docker-的第一个程序\">7.1 docker 的第一个程序</h3>\n<blockquote>\n<p>docker run hello-world</p>\n</blockquote>\n<pre><code>[root@localhost ~]# docker run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></pre>\n<hr />\n<h2 id=\"8常用命令\">8.常用命令</h2>\n<h3 id=\"61-辅助命令\">6.1 辅助命令</h3>\n<pre><code># 1.安装完成辅助命令\n		docker version	--------------------------	查看docker的信息\n		docker info		--------------------------	查看更详细的信息\n		docker --help	--------------------------	帮助命令\n</code></pre>\n<h3 id=\"62-images-镜像命令\">6.2 Images 镜像命令</h3>\n<pre><code># 1.查看本机中所有镜像\n	docker images	--------------------------	列出本地所有镜像\n		-a			列出所有镜像（包含中间映像层）\n  	-q			只显示镜像id\n\n# 2.搜索镜像\n	docker search [options] 镜像名	-------------------	去dockerhub上查询当前镜像\n		-s 指定值		列出收藏数不少于指定值的镜像\n  	--no-trunc	  显示完整的镜像信息\n\n# 3.从仓库下载镜像\n	docker pull 镜像名[:TAG|@DIGEST]	----------------- 下载镜像\n\n# 4.删除镜像\n	docker rmi 镜像名	--------------------------  删除镜像\n		-f		强制删除\n</code></pre>\n<h3 id=\"63-contrainer-容器命令\">6.3 Contrainer 容器命令</h3>\n<pre><code># 1.运行容器\n	docker run 镜像名	--------------------------	镜像名新建并启动容器\n    --name 					别名为容器起一个名字\n    -d							启动守护式容器（在后台启动容器）\n    -p 							映射端口号：原始端口号		 指定端口号启动\n\n	例：docker run -it --name myTomcat -p 8888:8080 tomcat\n   	 docker run -d --name myTomcat -P tomcat\n\n# 2.查看运行的容器\n	docker ps					--------------------------	列出所有正在运行的容器\n	-a			正在运行的和历史运行过的容器\n	-q			静默模式，只显示容器编号\n\n# 3.停止|关闭|重启容器\n	docker start   容器名字或者容器id  --------------- 开启容器\n	docker restart 容器名或者容器id    --------------- 重启容器\n	docker stop  容器名或者容器id 	    ------------------ 正常停止容器运行\n	docker kill  容器名或者容器id      ------------------ 立即停止容器运行\n\n# 4.删除容器\n	docker rm -f 容器id和容器名     \n	docker rm -f $(docker ps -aq)		--------------------------	删除所有容器\n\n# 5.查看容器内进程\n	docker top 容器id或者容器名 ------------------ 查看容器内的进程\n\n# 6.查看查看容器内部细节\n	docker inspect 容器id 		------------------ 查看容器内部细节\n\n# 7.查看容器的运行日志\n	docker logs [OPTIONS] 容器id或容器名	------------------ 查看容器日志\n    -t			 加入时间戳\n    -f			 跟随最新的日志打印\n    --tail 	 数字	显示最后多少条\n\n# 8.进入容器内部\n	docker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令\n		-i		以交互模式运行容器，通常与-t一起使用\n    -t		分配一个伪终端    shell窗口   bash \n\n# 9.容器和宿主机之间复制文件\n	docker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部\n	docker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上\n\n# 10.数据卷(volum)实现与宿主机共享目录\n	docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名\n		注意: \n				1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容\n				2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中\n\n# 11.打包镜像\n		docker save 镜像名 -o  名称.tar\n\n# 12.载入镜像\n		docker load -i   名称.tar\n\n# 13.容器打包成新的镜像\n	  docker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;   （容器id或者名称）打包的镜像名称:标签\n</code></pre>\n<hr />\n<h2 id=\"7docker的镜像原理\">7.docker的镜像原理</h2>\n<h3 id=\"71-镜像是什么\">7.1 镜像是什么？</h3>\n<blockquote>\n<p>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p>\n</blockquote>\n<h3 id=\"72-为什么一个镜像会那么大\">7.2 为什么一个镜像会那么大？</h3>\n<p>![image-20200404142950068](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/img_convert/66681cbac2ca97685b1ab1c83fd81bec.png)</p>\n<p><code>镜像就是花卷</code></p>\n<ul>\n<li>UnionFS（联合文件系统）:</li>\n</ul>\n<p>Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录<br />\n。</p>\n<h3 id=\"73-docker镜像原理\">7.3 Docker镜像原理</h3>\n<blockquote>\n<p><code>docker的镜像实际是由一层一层的文件系统组成。</code></p>\n</blockquote>\n<ul>\n<li>\n<p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux/Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。</p>\n</li>\n<li>\n<p>rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的/dev，/proc，/bin，/etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu/CentOS等等。</p>\n</li>\n<li>\n<p>我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。</p>\n</li>\n</ul>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-6fexhWqn-1618300306216)(http://file.huistone.com/md/1567585172(1)].jpg)</p>\n<h3 id=\"74-为什么docker镜像要采用这种分层结构呢\">7.4 为什么docker镜像要采用这种分层结构呢?</h3>\n<blockquote>\n<p><code>最大的一个好处就是资源共享</code></p>\n</blockquote>\n<ul>\n<li>比如：有多个镜像都是从相同的base镜像构建而来的，那么宿主机只需在磁盘中保存一份base镜像。同时内存中也只需要加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。</li>\n</ul>\n<hr />\n<h2 id=\"8docker安装常用服务\">8.Docker安装常用服务</h2>\n<h3 id=\"81-安装mysql\">8.1 安装mysql</h3>\n<pre><code># 1.拉取mysql镜像到本地\n	docker pull mysql:tag (tag不加默认最新版本)\n	\n# 2.运行mysql服务\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:tag  						  --没有暴露外部端口外部不能连接\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d  mysql:tag  --没有暴露外部端口\n\n# 3.进入mysql容器\n	docker exec -it 容器名称|容器id bash\n\n# 4.外部查看mysql日志\n	docker logs 容器名称|容器id\n\n# 5.使用自定义配置参数\n	docker run --name mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:tag\n\n# 6.将容器数据位置与宿主机位置挂载保证数据安全\n	docker run --name mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:tag\n\n# 7.通过其他客户端访问 如在window系统|macos系统使用客户端工具访问\n	\n# 8.将mysql数据库备份为sql文件\n	docker exec mysql|容器id sh -c \'exec mysqldump --all-databases -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &gt; /root/all-databases.sql  --导出全部数据\n	docker exec mysql sh -c \'exec mysqldump --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &gt; /root/all-databases.sql  --导出指定库数据\n	docker exec mysql sh -c \'exec mysqldump --no-data --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &gt; /root/all-databases.sql  --导出指定库数据不要数据\n\n# 9.执行sql文件到mysql中\n	docker exec -i mysql sh -c \'exec mysql -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &lt; /root/xxx.sql\n</code></pre>\n<h3 id=\"82-安装redis服务\">8.2 安装Redis服务</h3>\n<pre><code># 1.在docker hub搜索redis镜像\n	docker search redis\n\n# 2.拉取redis镜像到本地\n	docker pull redis\n\n# 3.启动redis服务运行容器\n	docker run --name redis -d redis:tag (没有暴露外部端口)\n	docker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) \n\n# 4.查看启动日志\n	docker logs -t -f 容器id|容器名称\n\n# 5.进入容器内部查看\n	docker exec -it 容器id|名称 bash  \n\n# 6.加载外部自定义配置启动redis容器\n	默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件\n	1. wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包\n	2. 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件\n	3. 修改需要自定义的配置\n		 bind 0.0.0.0 开启远程权限\n		 appenonly yes 开启aof持久化\n	4. 加载配置启动\n	docker run --name redis -v /root/redis:/usr/local/etc/redis -p 6379:6379 -d redis redis-server /usr/local/etc/redis/redis.conf  \n\n# 7.将数据目录挂在到本地保证数据安全\n	docker run --name redis -v /root/redis/data:/data -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis redis-server 					/usr/local/etc/redis/redis.conf  \n</code></pre>\n<h3 id=\"83-安装nginx\">8.3 安装Nginx</h3>\n<pre><code># 1.在docker hub搜索nginx\n	docker search nginx\n\n# 2.拉取nginx镜像到本地\n	[root@localhost ~]# docker pull nginx\n    Using default tag: latest\n    latest: Pulling from library/nginx\n    afb6ec6fdc1c: Pull complete \n    b90c53a0b692: Pull complete \n    11fa52a0fdc0: Pull complete \n    Digest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097\n    Status: Downloaded newer image for nginx:latest\n    docker.io/library/nginx:latest\n\n# 3.启动nginx容器\n		docker run -p 80:80 --name nginx01 -d nginx\n\n# 4.进入容器\n		docker exec -it nginx01 /bin/bash\n		查找目录:  whereis nginx\n		配置文件:  /etc/nginx/nginx.conf\n\n# 5.复制配置文件到宿主机\n		docker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录\n\n# 6.挂在nginx配置以及html到宿主机外部\n		docker run --name nginx02 -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx		\n</code></pre>\n<hr />\n<h3 id=\"84-安装tomcat\">8.4 安装Tomcat</h3>\n<pre><code># 1.在docker hub搜索tomcat\n	docker search tomcat\n\n# 2.下载tomcat镜像\n	docker pull tomcat\n\n# 3.运行tomcat镜像\n	docker run -p 8080:8080 -d --name mytomcat tomcat\n\n# 4.进入tomcat容器\n	docker exec -it mytomcat /bin/bash\n\n# 5.将webapps目录挂载在外部\n	docker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d --name mytomcat tomcat\n</code></pre>\n<hr />\n<h3 id=\"85-安装mongodb数据库\">8.5 安装MongoDB数据库</h3>\n<pre><code># 1.运行mongDB\n	docker run -d -p 27017:27017 --name mymongo mongo  ---无须权限\n	docker logs -f mymongo --查看mongo运行日志\n\n# 2.进入mongodb容器\n	docker exec -it mymongo /bin/bash\n		直接执行mongo命令进行操作\n\n# 3.常见具有权限的容器\n	docker run --name  mymongo  -p 27017:27017  -d mongo --auth\n\n# 4.进入容器配置用户名密码\n	mongo\n	use admin 选择admin库\n	db.createUser({user:&quot;root&quot;,pwd:&quot;root&quot;,roles:[{role:\'root\',db:\'admin\'}]})   //创建用户,此用户创建成功,则后续操作都需要用户认证\n	exit\n\n# 5.将mongoDB中数据目录映射到宿主机中\n	docker run -d -p 27017:27017 -v /root/mongo/data:/data/db --name mymongo mongo \n</code></pre>\n<h3 id=\"86-安装elasticsearch\">8.6 安装ElasticSearch</h3>\n<ul>\n<li><code>注意:</code> <strong>调高JVM线程数限制数量</strong></li>\n</ul>\n<h4 id=\"0拉取镜像运行elasticsearch\">0.拉取镜像运行elasticsearch</h4>\n<pre><code># 1.dockerhub 拉取镜像\n	docker pull elasticsearch:6.4.2\n# 2.查看docker镜像\n	docker images\n# 3.运行docker镜像\n	docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.4.2\n</code></pre>\n<ul>\n<li>启动出现如下错误</li>\n<li><img src=\"https://img-blog.csdnimg.cn/img_convert/128c044cff7b0bac244428d4142e82fb.png\" alt=\"image-20200602184321790\" /></li>\n</ul>\n<h4 id=\"1-预先配置\">1. 预先配置</h4>\n<pre><code># 1.在centos虚拟机中，修改配置sysctl.conf\n	vim /etc/sysctl.conf\n# 2.加入如下配置\n	vm.max_map_count=262144 \n# 3.启用配置\n	sysctl -p\n	注：这一步是为了防止启动容器时，报出如下错误：\n	bootstrap checks failed max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]\n</code></pre>\n<h4 id=\"2启动eleasticsearch容器\">2.启动EleasticSearch容器</h4>\n<pre><code># 0.复制容器中data目录到宿主机中\n	docker cp 容器id:/usr/share/share/elasticsearch/data /root/es\n# 1.运行ES容器 指定jvm内存大小并指定ik分词器位置\n	docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=&quot;-Xms128m -Xmx128m&quot; -v /root/es/plugins:/usr/share/elasticsearch/plugins -v /root/es/data:/usr/share/elasticsearch/data elasticsearch:6.4.2\n</code></pre>\n<h4 id=\"3安装ik分词器\">3.安装IK分词器</h4>\n<pre><code># 1.下载对应版本的IK分词器\n	wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip\n\n# 2.解压到plugins文件夹中\n	yum install -y unzip\n	unzip -d ik elasticsearch-analysis-ik-6.4.2.zip\n\n# 3.添加自定义扩展词和停用词\n	cd plugins/elasticsearch/config\n	vim IKAnalyzer.cfg.xml\n	\n		IK Analyzer 扩展配置\n		\n		ext_dict.dic\n		\n		ext_stopwords.dic\n	\n\n# 4.在ik分词器目录下config目录中创建ext_dict.dic文件   编码一定要为UTF-8才能生效\n	vim ext_dict.dic 加入扩展词即可\n# 5. 在ik分词器目录下config目录中创建ext_stopword.dic文件 \n	vim ext_stopwords.dic 加入停用词即可\n\n# 6.重启容器生效\n	docker restart 容器id\n# 7.将此容器提交成为一个新的镜像\n	docker commit -a=&quot;xiaochen&quot; -m=&quot;es with IKAnalyzer&quot; 容器id xiaochen/elasticsearch:6.4.2\n</code></pre>\n<h4 id=\"4-安装kibana\">4. 安装Kibana</h4>\n<pre><code># 1.下载kibana镜像到本地\n	docker pull kibana:6.4.2\n\n# 2.启动kibana容器\n	docker run -d --name kibana -e ELASTICSEARCH_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2\n</code></pre>\n<hr />\n<h2 id=\"10docker中出现如下错误解决方案\">10.Docker中出现如下错误解决方案</h2>\n<pre><code>[root@localhost ~]# docker search mysql 或者 docker pull 这些命令无法使用\nError response from daemon: Get https://index.docker.io/v1/search?q=mysql&amp;n;=25: x509: certificate has expired or is not yet valid\n</code></pre>\n<p>![image-20200602183429286](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/img_convert/d7ac44892b1ec8cc113ee3f7274689f5.png)</p>\n<ul>\n<li>\n<p>注意: <strong>这个错误的原因在于是系统的时间和docker hub时间不一致,需要做系统时间与网络时间同步</strong></p>\n<h1 id=\"1安装时间同步\">1.安装时间同步</h1>\n<pre><code>sudo yum -y install ntp ntpdate\n</code></pre>\n<h1 id=\"2同步时间\">2.同步时间</h1>\n<pre><code>sudo ntpdate cn.pool.ntp.org\n</code></pre>\n<h1 id=\"3查看本机时间\">3.查看本机时间</h1>\n<pre><code>date\n</code></pre>\n<h1 id=\"4从新测试\">4.从新测试</h1>\n</li>\n</ul>\n<p>![image-20200602183718623](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/img_convert/a96f782bd86b0008b504a7c59642da70.png)</p>\n<h2 id=\"9dockerfile\">9.Dockerfile</h2>\n<h3 id=\"91-什么是dockerfile\">9.1 什么是Dockerfile</h3>\n<p>Dockerfile可以认为是 <strong>Docker镜像的描述文件，是由一系列命令和参数构成的脚本</strong> 。主要作用是 <strong>用来构建docker镜像的构建文件</strong><br />\n。</p>\n<p>![image-20200404111908085](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/img_convert/b17e8ed5ead6514a59b19878dfae934e.png)</p>\n<ul>\n<li><strong>通过架构图可以看出通过DockerFile可以直接构建镜像</strong></li>\n</ul>\n<h3 id=\"92-dockerfile解析过程\">9.2 Dockerfile解析过程</h3>\n<p>![image-20200603181253804](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/img_convert/72c167ceb74d8e0424bdcec69f682048.png)</p>\n<h3 id=\"93-dockerfile的保留命令\">9.3 Dockerfile的保留命令</h3>\n<p>官方说明:https://docs.docker.com/engine/reference/builder/</p>\n<table>\n<thead>\n<tr><th>保留字</th><th>作用</th></tr>\n</thead>\n<tbody>\n<tr><td><strong>FROM</strong></td><td><strong>当前镜像是基于哪个镜像的</strong> <code>第一个指令必须是FROM</code></td></tr>\n<tr><td>MAINTAINER</td><td>镜像维护者的姓名和邮箱地址</td></tr>\n<tr><td><strong>RUN</strong></td><td><strong>构建镜像时需要运行的指令</strong></td></tr>\n<tr><td><strong>EXPOSE</strong></td><td><strong>当前容器对外暴露出的端口号</strong></td></tr>\n<tr><td><strong>WORKDIR</strong></td><td><strong>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</strong></td></tr>\n<tr><td><strong>ENV</strong></td><td><strong>用来在构建镜像过程中设置环境变量</strong></td></tr>\n<tr><td><strong>ADD</strong></td><td><strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong></td></tr>\n<tr><td><strong>COPY</strong></td><td>**类似于ADD，拷贝文件和目录到镜像中</td></tr>\n</tbody>\n</table>\n<p>将从构建上下文目录中&lt;原路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置**<br />\n<strong>VOLUME</strong>|  <strong>容器数据卷，用于数据保存和持久化工作</strong><br />\n<strong>CMD</strong>|  <strong>指定一个容器启动时要运行的命令<br />\nDockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</strong><br />\n<strong>ENTRYPOINT</strong>|  <strong>指定一个容器启动时要运行的命令<br />\nENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</strong></p>\n<h4 id=\"931-from-命令\">9.3.1 FROM 命令</h4>\n<ul>\n<li>\n<p>基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code>FROM  \n</code></pre>\n<p>FROM  [:]     使用版本不写为latest<br />\nFROM  [@]  使用摘要</p>\n</li>\n</ul>\n<h4 id=\"932-maintainer-命令\">9.3.2 MAINTAINER 命令</h4>\n<ul>\n<li>\n<p>镜像维护者的姓名和邮箱地址[废弃]</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code>MAINTAINER \n</code></pre>\n</li>\n</ul>\n<h4 id=\"933-run-命令\">9.3.3 RUN 命令</h4>\n<ul>\n<li>\n<p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code>RUN  (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)\n</code></pre>\n<p>RUN echo hello</p>\n<p>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form)<br />\nRUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</p>\n</li>\n</ul>\n<h4 id=\"934-expose-命令\">9.3.4 EXPOSE 命令</h4>\n<ul>\n<li>\n<p>用来指定构建的镜像在运行为容器时对外暴露的端口</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code>EXPOSE 80/tcp  如果没有显示指定则默认暴露都是tcp\n</code></pre>\n<p>EXPOSE 80/udp</p>\n</li>\n</ul>\n<h4 id=\"935-cmd-命令\">9.3.5 CMD 命令</h4>\n<ul>\n<li>\n<p>用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</p>\n</li>\n<li>\n<p>注意: <strong>Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form)\n</code></pre>\n<p>CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)<br />\nCMD command param1 param2 (shell form)</p>\n</li>\n</ul>\n<h4 id=\"936-workdir-命令\">9.3.6 WORKDIR 命令</h4>\n<ul>\n<li>\n<p>用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code>WORKDIR /path/to/workdir\n</code></pre>\n<p>WORKDIR /a<br />\nWORKDIR b<br />\nWORKDIR c<br />\n<code>注意:WORKDIR指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对</code></p>\n</li>\n</ul>\n<h4 id=\"937-env-命令\">9.3.7 ENV 命令</h4>\n<ul>\n<li>\n<p>用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。</p>\n</li>\n<li>\n<p>语法：</p>\n<pre><code>ENV  \n</code></pre>\n<p>ENV = ...</p>\n</li>\n</ul>\n<h4 id=\"938-add-命令\">9.3.8 ADD 命令</h4>\n<ul>\n<li>\n<p>用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code>ADD hom* /mydir/       通配符添加多个文件\n</code></pre>\n<p>ADD hom?.txt /mydir/   通配符添加<br />\nADD test.txt relativeDir/  可以指定相对路径<br />\nADD test.txt /absoluteDir/ 也可以指定绝对路径<br />\nADD url</p>\n</li>\n</ul>\n<h4 id=\"939-copy-命令\">9.3.9 COPY 命令</h4>\n<ul>\n<li>\n<p>用来将context目录中指定文件复制到镜像的指定目录中</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code>COPY src dest\n</code></pre>\n<p>COPY [&quot;&quot;,... &quot;&quot;]</p>\n</li>\n</ul>\n<h4 id=\"9310-volume-命令\">9.3.10 VOLUME 命令</h4>\n<ul>\n<li>\n<p>用来定义容器运行时可以挂在到宿主机的目录</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code>VOLUME [&quot;/data&quot;]\n</code></pre>\n</li>\n</ul>\n<h4 id=\"9311-entrypoint命令\">9.3.11 ENTRYPOINT命令</h4>\n<ul>\n<li>\n<p>用来指定容器启动时执行命令和CMD类似</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code>  [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]\n</code></pre>\n<p>ENTRYPOINT command param1 param2</p>\n</li>\n</ul>\n<p>ENTRYPOINT指令，往往用于设置容器启动后的 <strong>第一个命令</strong> ，这对一个容器来说往往是固定的。<br />\nCMD指令，往往用于设置容器启动的第一个命令的 <strong>默认参数</strong> ，这对一个容器来说可以是变化的。</p>\n<h4 id=\"9311-entrypoint命令-1\">9.3.11 ENTRYPOINT命令</h4>\n<h3 id=\"94-dockerfile构建springboot项目部署\">9.4 Dockerfile构建springboot项目部署</h3>\n<h5 id=\"1准备springboot可运行项目\">1.准备springboot可运行项目</h5>\n<p>![image-20200605172151266](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/img_convert/b9436e1e565f736b8635ad515ad7414e.png)</p>\n<h5 id=\"2将可运行项目放入linux虚拟机中\">2.将可运行项目放入linux虚拟机中</h5>\n<p>![image-20200605172340380](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/img_convert/07b79c412d29ed2d9bdeb01f868a2d3a.png)</p>\n<h5 id=\"3编写dockerfile\">3.编写Dockerfile</h5>\n<pre><code>FROM openjdk:8\nWORKDIR /ems\nADD ems.jar /ems\nEXPOSE 8989\nENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;]\nCMD [&quot;ems.jar&quot;]\n</code></pre>\n<h5 id=\"4构建镜像\">4.构建镜像</h5>\n<pre><code>[root@localhost ems]# docker build -t ems .\n</code></pre>\n<h5 id=\"5运行镜像\">5.运行镜像</h5>\n<pre><code>[root@localhost ems]# docker run -p 8989:8989 ems\n</code></pre>\n<h5 id=\"6访问项目\">6.访问项目</h5>\n<pre><code>http://10.15.0.8:8989/ems/login.html\n</code></pre>\n<p>![image-20200605173141636](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/img_convert/0aa89bf9d1ea619bd0f112deb26fd1b5.png)</p>\n<hr />\n<h2 id=\"10高级网络配置\">10.高级网络配置</h2>\n<h3 id=\"101-说明\">10.1 说明</h3>\n<p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个<br />\nbridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>\n<p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a href=\"https://tools.ietf.org/html/rfc1918\">RFC1918</a><br />\n中定义）中的一个地址给 <code>docker0</code> 接口。比如典型的 <code>172.17.42.1</code>，掩码为<br />\n<code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p>\n<p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code><br />\n接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code><br />\n网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker<br />\n就创建了在主机和所有容器之间一个虚拟共享网络。</p>\n<p>![image-20201125105847896](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/img_convert/4aa28b18fcc92255b0fc66341d3be1a8.png)</p>\n<h3 id=\"102-查看网络信息\">10.2 查看网络信息</h3>\n<pre><code># docker network ls\n</code></pre>\n<h3 id=\"103-创建一个网桥\">10.3 创建一个网桥</h3>\n<pre><code># docker network create -d bridge 网桥名称\n</code></pre>\n<h3 id=\"104-删除一个网桥\">10.4 删除一个网桥</h3>\n<pre><code># docker network rm 网桥名称\n</code></pre>\n<h3 id=\"105-容器之前使用网络通信\">10.5 容器之前使用网络通信</h3>\n<pre><code># 1.查询当前网络配置\n- docker network ls\n\n\n\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n\n\n\n# 2.创建桥接网络\n- docker network create -d bridge info\n\n\n\n[root@centos ~]# docker network create -d bridge info\n6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f\n[root@centos ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n6e4aaebff79b        info                bridge              local\n\n\n\n# 3.启动容器指定使用网桥\n- docker run -d -p 8890:80 --name nginx001 --network info nginx \n- docker run -d -p 8891:80 --name nginx002 --network info nginx \n	`注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通`\n\n\n\n[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx \nc315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe\n[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx\nf8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5\n[root@centos ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\nf8682db35dd7        nginx               &quot;/docker-entrypoint.…&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8891-&gt;80/tcp   nginx002\nc315bcc94e9d        nginx               &quot;/docker-entrypoint.…&quot;   7 minutes ago       Up 7 minutes        0.0.0.0:8890-&gt;80/tcp   nginx001\nb63169d43792        mysql:5.7.19        &quot;docker-entrypoint.s…&quot;   7 minutes ago       Up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda\n[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash\nroot@f8682db35dd7:/# curl http://nginx001\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n.....\n</code></pre>\n<hr />\n<h2 id=\"11高级数据卷配置\">11.高级数据卷配置</h2>\n<h3 id=\"111-说明\">11.1 说明</h3>\n<p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>\n<ul>\n<li><code>数据卷</code> 可以在容器之间共享和重用</li>\n<li>对 <code>数据卷</code> 的修改会立马生效</li>\n<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>\n<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>\n</ul>\n<blockquote>\n<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行<br />\nmount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>\n</blockquote>\n<h3 id=\"112-创建数据卷\">11.2 创建数据卷</h3>\n<pre><code>[root@centos ~]# docker volume create my-vol\nmy-vol\n</code></pre>\n<h3 id=\"113-查看数据卷\">11.3 查看数据卷</h3>\n<pre><code>[root@centos ~]# docker volume inspect my-vol       \n[\n    {\n        &quot;CreatedAt&quot;: &quot;2020-11-25T11:43:56+08:00&quot;,\n        &quot;Driver&quot;: &quot;local&quot;,\n        &quot;Labels&quot;: {},\n        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,\n        &quot;Name&quot;: &quot;my-vol&quot;,\n        &quot;Options&quot;: {},\n        &quot;Scope&quot;: &quot;local&quot;\n    }\n]\n</code></pre>\n<h3 id=\"114-挂载数据卷\">11.4 挂载数据卷</h3>\n<pre><code>[root@centos ~]# docker run -d -P --name web  -v my-vol:/usr/share/nginx/html  nginx\n[root@centos ~]# docker inspect web\n				&quot;Mounts&quot;: [\n            {\n                &quot;Type&quot;: &quot;volume&quot;,\n                &quot;Name&quot;: &quot;my-vol&quot;,\n                &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,\n                &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,\n                &quot;Driver&quot;: &quot;local&quot;,\n                &quot;Mode&quot;: &quot;z&quot;,\n                &quot;RW&quot;: true,\n                &quot;Propagation&quot;: &quot;&quot;\n            }\n        ],\n</code></pre>\n<h3 id=\"115-删除数据卷\">11.5 删除数据卷</h3>\n<pre><code>docker volume rm my-vol\n</code></pre>\n<hr />\n<h2 id=\"12docker-compose\">12.Docker Compose</h2>\n<h3 id=\"121-简介\">12.1 简介</h3>\n<p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的<br />\n<code>Heat</code> 十分类似。</p>\n<p>其代码目前在 <a href=\"https://github.com/docker/compose\">https://github.com/docker/compose</a> 上开源。</p>\n<p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container<br />\nDocker applications）」，其前身是开源项目 Fig。</p>\n<p>通过第一部分中的介绍，我们知道使用一个 <code>Dockerfile</code><br />\n模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web<br />\n项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>\n<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML<br />\n格式）来定义一组相关联的应用容器为一个项目（project）。</p>\n<p><code>Compose</code> 中有两个重要的概念：</p>\n<ul>\n<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>\n<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>\n</ul>\n<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>\n<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker<br />\nAPI，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>\n<h3 id=\"122-安装与卸载\">12.2 安装与卸载</h3>\n<h6 id=\"1linux\">1.linux</h6>\n<ul>\n<li>\n<p>在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。</p>\n<p>$ sudo curl -L <a href=\"https://github.com/docker/compose/releases/download/1.25.5/docker-compose-\">https://github.com/docker/compose/releases/download/1.25.5/docker-compose-</a><code>uname -s</code>-<code>uname -m</code> &gt; /usr/local/bin/docker-compose<br />\n$ sudo chmod +x /usr/local/bin/docker-compose</p>\n</li>\n</ul>\n<h6 id=\"2macoswindow\">2.macos、window</h6>\n<ul>\n<li>Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。<code>Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用</code>。</li>\n</ul>\n<h6 id=\"3bash命令补全\">3.bash命令补全</h6>\n<pre><code>$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose\n</code></pre>\n<h6 id=\"4卸载\">4.卸载</h6>\n<ul>\n<li>\n<p>如果是二进制包方式安装的，删除二进制文件即可。</p>\n<p>$ sudo rm /usr/local/bin/docker-compose</p>\n</li>\n</ul>\n<h6 id=\"5测试安装成功\">5.测试安装成功</h6>\n<pre><code>$ docker-compose --version\n docker-compose version 1.25.5, build 4667896b\n</code></pre>\n<h3 id=\"123-docker-compose使用\">12.3 docker compose使用</h3>\n<pre><code># 1.相关概念\n</code></pre>\n<p>首先介绍几个术语。</p>\n<ul>\n<li>\n<p>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</p>\n</li>\n<li>\n<p>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</p>\n<h1 id=\"2场景\">2.场景</h1>\n</li>\n</ul>\n<p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>\n<ul>\n<li>\n<p>springboot应用</p>\n</li>\n<li>\n<p>mysql服务</p>\n</li>\n<li>\n<p>redis服务</p>\n</li>\n<li>\n<p>elasticsearch服务</p>\n</li>\n<li>\n<p>…</p>\n<h1 id=\"3docker-compose模板\">3.docker-compose模板</h1>\n<ul>\n<li>参考文档:https://docker_practice.gitee.io/zh-cn/compose/compose_file.html</li>\n</ul>\n<p>version: &quot;3.0&quot;<br />\nservices:<br />\nmysqldb:<br />\nimage: mysql:5.7.19<br />\ncontainer_name: mysql<br />\nports:<br />\n- &quot;3306:3306&quot;<br />\nvolumes:<br />\n- /root/mysql/conf:/etc/mysql/conf.d<br />\n- /root/mysql/logs:/logs<br />\n- /root/mysql/data:/var/lib/mysql<br />\nenvironment:<br />\nMYSQL_ROOT_PASSWORD: root<br />\nnetworks:<br />\n- ems<br />\ndepends_on:<br />\n- redis</p>\n<p>redis:<br />\nimage: redis:4.0.14<br />\ncontainer_name: redis<br />\nports:<br />\n- &quot;6379:6379&quot;<br />\nnetworks:<br />\n- ems<br />\nvolumes:<br />\n- /root/redis/data:/data<br />\ncommand: redis-server</p>\n<p>networks:<br />\nems:</p>\n<h1 id=\"4通过docker-compose运行一组容器\">4.通过docker-compose运行一组容器</h1>\n<ul>\n<li>参考文档:https://docker_practice.gitee.io/zh-cn/compose/commands.html</li>\n</ul>\n<p>[root@centos ~]# docker-compose up    							//前台启动一组服务<br />\n[root@centos ~]# docker-compose up -d 							//后台启动一组服务</p>\n</li>\n</ul>\n<hr />\n<h3 id=\"124-docker-compose-模板文件\">12.4 docker-compose 模板文件</h3>\n<p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code><br />\n相关参数的含义都是类似的。</p>\n<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>\n<pre><code>version: &quot;3&quot;\n\nservices:\n  webapp:\n    image: examples/web\n    ports:\n      - &quot;80:80&quot;\n    volumes:\n      - &quot;/data&quot;\n</code></pre>\n<p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p>\n<p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等)<br />\n将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>\n<p>下面分别介绍各个指令的用法。</p>\n<h4 id=\"build\"><code>build</code></h4>\n<p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code><br />\n将会利用它自动构建这个镜像，然后使用这个镜像。</p>\n<pre><code>version: \'3\'\nservices:\n\n  webapp:\n    build: ./dir\n</code></pre>\n<p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p>\n<p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p>\n<p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p>\n<pre><code>version: \'3\'\nservices:\n\n  webapp:\n    build:\n      context: ./dir\n      dockerfile: Dockerfile-alternate\n      args:\n        buildno: 1\n</code></pre>\n<h4 id=\"command\"><code>command</code></h4>\n<p>覆盖容器启动后默认执行的命令。</p>\n<pre><code>command: echo &quot;hello world&quot;\n</code></pre>\n<h4 id=\"container-name\"><code>container_name</code></h4>\n<p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p>\n<pre><code>container_name: docker-web-container\n</code></pre>\n<blockquote>\n<p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p>\n</blockquote>\n<h4 id=\"depends-on\"><code>depends_on</code></h4>\n<p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p>\n<pre><code>version: \'3\'\n\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n      - redis\n\n  redis:\n    image: redis\n\n  db:\n    image: postgres\n</code></pre>\n<blockquote>\n<p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p>\n</blockquote>\n<h4 id=\"env-file\"><code>env_file</code></h4>\n<p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>\n<p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p>\n<p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p>\n<pre><code>env_file: .env\n\nenv_file:\n  - ./common.env\n  - ./apps/web.env\n  - /opt/secrets.env\n</code></pre>\n<p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p>\n<pre><code># common.env: Set development environment\nPROG_ENV=development\n</code></pre>\n<h4 id=\"environment\"><code>environment</code></h4>\n<p>设置环境变量。你可以使用数组或字典两种格式。</p>\n<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>\n<pre><code>environment:\n  RACK_ENV: development\n  SESSION_SECRET:\n\nenvironment:\n  - RACK_ENV=development\n  - SESSION_SECRET\n</code></pre>\n<p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href=\"https://yaml.org/type/bool.html\">布尔</a><br />\n含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>\n<pre><code>y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF\n</code></pre>\n<h4 id=\"healthcheck\"><code>healthcheck</code></h4>\n<p>通过命令检查容器是否健康运行。</p>\n<pre><code>healthcheck:\n  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]\n  interval: 1m30s\n  timeout: 10s\n  retries: 3\n</code></pre>\n<h4 id=\"image\"><code>image</code></h4>\n<p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p>\n<pre><code>image: ubuntu\nimage: orchardup/postgresql\nimage: a4bc65fd\n</code></pre>\n<h4 id=\"networks\"><code>networks</code></h4>\n<p>配置容器连接的网络。</p>\n<pre><code>version: &quot;3&quot;\nservices:\n\n  some-service:\n    networks:\n     - some-network\n     - other-network\n\nnetworks:\n  some-network:\n  other-network:\n</code></pre>\n<h4 id=\"ports\"><code>ports</code></h4>\n<p>暴露端口信息。</p>\n<p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>\n<pre><code>ports:\n - &quot;3000&quot;\n - &quot;8000:8000&quot;\n - &quot;49100:22&quot;\n - &quot;127.0.0.1:8001:8001&quot;\n</code></pre>\n<p><em>注意：当使用<code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code><br />\n会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p>\n<h4 id=\"sysctls\"><code>sysctls</code></h4>\n<p>配置容器内核参数。</p>\n<pre><code>sysctls:\n  net.core.somaxconn: 1024\n  net.ipv4.tcp_syncookies: 0\n\nsysctls:\n  - net.core.somaxconn=1024\n  - net.ipv4.tcp_syncookies=0\n</code></pre>\n<h4 id=\"ulimits\"><code>ulimits</code></h4>\n<p>指定容器的 ulimits 限制值。</p>\n<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root<br />\n用户提高）。</p>\n<pre><code>  ulimits:\n    nproc: 65535\n    nofile:\n      soft: 20000\n      hard: 40000\n</code></pre>\n<h4 id=\"volumes\"><code>volumes</code></h4>\n<p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式<br />\n（<code>HOST:CONTAINER:ro</code>）。</p>\n<p>该指令中路径支持相对路径。</p>\n<pre><code>volumes:\n - /var/lib/mysql\n - cache/:/tmp/cache\n - ~/configs:/etc/configs/:ro\n</code></pre>\n<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>\n<pre><code>version: &quot;3&quot;\n\nservices:\n  my_src:\n    image: mysql:8.0\n    volumes:\n      - mysql_data:/var/lib/mysql\n\nvolumes:\n  mysql_data:\n</code></pre>\n<hr />\n<h3 id=\"125-docker-compose-常用命令\">12.5 docker-compose 常用命令</h3>\n<h5 id=\"1-命令对象与格式\">1. 命令对象与格式</h5>\n<p>对于 Compose<br />\n来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>\n<p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code><br />\n可以查看具体某个命令的使用格式。</p>\n<p><code>docker-compose</code> 命令的基本的使用格式是</p>\n<pre><code>docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]\n</code></pre>\n<h5 id=\"2-命令选项\">2. 命令选项</h5>\n<ul>\n<li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li>\n<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>\n<li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li>\n<li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li>\n<li><code>--verbose</code> 输出更多调试信息。</li>\n<li><code>-v, --version</code> 打印版本并退出。</li>\n</ul>\n<h5 id=\"3命令使用说明\">3.命令使用说明</h5>\n<h5 id=\"up\"><code>up</code></h5>\n<p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p>\n<ul>\n<li>\n<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>\n</li>\n<li>\n<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>\n</li>\n<li>\n<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>\n</li>\n<li>\n<p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>\n</li>\n<li>\n<p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>\n</li>\n<li>\n<p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>\n</li>\n<li>\n<p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容</p>\n</li>\n</ul>\n<hr />\n<h5 id=\"down\"><code>down</code></h5>\n<ul>\n<li>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</li>\n</ul>\n<hr />\n<h5 id=\"exec\"><code>exec</code></h5>\n<ul>\n<li>进入指定的容器。</li>\n</ul>\n<hr />\n<h5 id=\"ps\"><code>ps</code></h5>\n<p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>\n<p>列出项目中目前的所有容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-q</code> 只打印容器的 ID 信息。</li>\n</ul>\n<hr />\n<h5 id=\"restart\"><code>restart</code></h5>\n<p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>\n<p>重启项目中的服务。</p>\n<p>选项：</p>\n<ul>\n<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>\n</ul>\n<hr />\n<h5 id=\"rm\"><code>rm</code></h5>\n<p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>\n<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>\n<li><code>-v</code> 删除容器所挂载的数据卷。</li>\n</ul>\n<hr />\n<h5 id=\"start\"><code>start</code></h5>\n<p>格式为 <code>docker-compose start [SERVICE...]</code>。</p>\n<p>启动已经存在的服务容器。</p>\n<hr />\n<h5 id=\"stop\"><code>stop</code></h5>\n<p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>\n<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>\n</ul>\n<hr />\n<h5 id=\"top\"><code>top</code></h5>\n<p>查看各个服务容器内运行的进程。</p>\n<hr />\n<h5 id=\"unpause\"><code>unpause</code></h5>\n<p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>\n<p>恢复处于暂停状态中的服务。</p>\n<hr />\n<h2 id=\"13docker可视化工具\">13.docker可视化工具</h2>\n<h4 id=\"131-安装portainer\">13.1 安装Portainer</h4>\n<p>官方安装说明：<a href=\"http://www.yunweipai.com/go?_=8fe4813824aHR0cHM6Ly93d3cucG9ydGFpbmVyLmlvL2luc3RhbGxhdGlvbi8=\">https://www.portainer.io/installation/</a></p>\n<pre><code>[root@ubuntu1804 ~]#docker pull  portainer/portainer\n\n[root@ubuntu1804 ~]#docker volume create portainer_data\nportainer_data\n[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n20db26b67b791648c2ef6aee444a5226a9c897ebcf0160050e722dbf4a4906e3\n[root@ubuntu1804 ~]#docker ps \nCONTAINER ID        IMAGE                 COMMAND             CREATED             STATUS              PORTS                                            NAMES\n20db26b67b79        portainer/portainer   &quot;/portainer&quot;        5 seconds ago       Up 4 seconds        0.0.0.0:8000-&gt;8000/tcp, 0.0.0.0:9000-&gt;9000/tcp   portainer\n</code></pre>\n<h4 id=\"132-登录和使用portainer\">13.2 登录和使用Portainer</h4>\n<blockquote>\n<p>用浏览器访问：<code>http://localhost:9000</code></p>\n</blockquote>\n<p>![image-20201223231707738](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/img_convert/df2151ddea1b49e429294a47148d2378.png)</p>\n<hr />\n', 1, '', 0, 0, 1, '2022-06-10 15:22:08', '2022-06-10 15:22:08');
INSERT INTO `tb_article` VALUES (262, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5798', 'IP地址分类（A类B类C类D类E类）', '<p>一、简介<br />\nIP地址由四段组成，每个字段是一个字节，即4个字节、 每个字节有8位，最大值是255(=256：0~255)。</p>\n<pre><code>  全世界范围是唯一的 32 位（4个字节 * 8位）的标识符。\n\n  IP地址由两部分组成，即网络地址和主机地址，二者是主从关系：\n\n                      1. 网络号 net-id，它标志主机（或路由器）所连接到的网络，网络地址表示其属于互联网的哪一个网络\n\n                      2.主机号 host-id，它标志该主机（或路由器），主机地址表示其属于该网络中的哪一台主机。\n\n  两级的 IP 地址可以记为：   IP 地址 ::= { &lt;网络号&gt;, &lt;主机号&gt;}   \n\n  简而言之就是：IP地址 = 网络号+主机号\n</code></pre>\n<p>二、点分十进制记法：<br />\nIPv4的地址长度为32位，共4个字节，但实际中我们用点分十进制记法。</p>\n<p>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/20190110221035442.png?x-oss-\">https://img-blog.csdnimg.cn/20190110221035442.png?x-oss-</a><br />\nprocess=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70)</p>\n<p>三、IP分类<br />\nIP地址 = 网络号+主机号。</p>\n<pre><code>  分为A、B、C三类及特殊地址D、E。   \n\n    全0和全1的都保留不用。\n</code></pre>\n<p>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/20190110221221227.png?x-oss-\">https://img-blog.csdnimg.cn/20190110221221227.png?x-oss-</a><br />\nprocess=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70)</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190110221239805.png\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>A类：</strong><br />\n地址范围：1.0.0.1-126.255.255.254 (0000<br />\n0001.00000000.00000000.00000000~01111110.111111111.11111111.11111110）</p>\n<pre><code>   地址范围：1.0.0.0-126.255.255.255 （这种写法是把全0全1都算进去了，其它几类类似）\n\n   网络号范围： 1~126                        （0000 0001 ~ 0111 1110）\n\n   默认子网掩码：255.0.0.0 或  0xFF000000（十六进制）\n\n   私有号段：10.0.0.0-10.255.255.255\n\n   前1个字节(8位)为网络号，后3个字节(24位)为主机号。\n\n   A类第1位必须是0。\n\n   最大网络数：      126个\n\n   最大主机数：\n\n   全0全1的地址不可分配，作为保留地址。 上面减2也是这个原因。\n\n   一般用于大型网络。\n</code></pre>\n<p><strong>B类：</strong><br />\n地址范围：128.1.0.1-191.255.255.254</p>\n<pre><code>      网络号范围：128.1 ~ 191.255\n\n       默认子网掩码：255.255.0.0 或 0xFFFF0000(十六进制)\n\n      私有号段：172.16.0.0-172.31.255.255\n\n      前2个字节(16位)为网络号，后2个字节(16位)为主机号。\n\n      前两位固定为10。\n\n      最大网络数：\n\n      最大主机数：\n\n      一般用于中等规模网络。\n</code></pre>\n<p>C类：<br />\n地址范围：192.0.1.1-223.255.255.254</p>\n<pre><code>        网络号段范围：192.0.1 ~ 223.255.255\n\n        子网掩码：255.255.255.0 或  0xFFFFFF00 (十六进制)\n\n         私有号段：192.168.0.0-192.168.255.255\n\n         前3个字节(24位)为网络号，后1个字节(8位)为主机号。\n\n         前3位固定为110。\n\n         最大网络数：\n\n         最大主机数：\n\n        一般用于小型网络。\n</code></pre>\n<p>D类：<br />\n地址范围：224.0.0.1-239.255.255.254</p>\n<pre><code>     是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。\n\n     一般用于多路广播用户 。\n</code></pre>\n<p>E类：<br />\n是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。</p>\n<p>回送地址：<br />\n127.x.x.x 有的资料说，它属于A类。</p>\n<pre><code>      如127.0.0.1  等效于localhost或本机IP。  一般用于测试使用。\n\n      例如：ping 127.0.0.1来测试本机TCP/IP是否正常。http://127.0.0.1:8080 等效 http://localhost:8080\n</code></pre>\n<p>特殊说明<br />\n每一个字节都为0的地址（0.0.0.0）对应当前主机。</p>\n<pre><code>    IP地址中的每一个字节都为1的IP地址（255.255.255.255）是当前子网的广播地址。\n\n    IP地址中凡是以11110开头的E类IP的地址，都保留用于将来和实验使用。\n\n    网络号的第一个8位不能全为0。\n\n    IP地址不能以127为开头，该类地址中数字127.0.0.1~127.255.255.254用于回路测试。\n</code></pre>\n', 1, '', 0, 0, 1, '2022-06-10 15:22:17', '2022-06-10 15:22:17');
INSERT INTO `tb_article` VALUES (263, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5965', 'java存储机制（堆、栈、方法区）', '<h2 id=\"堆栈方法区存储的内容\">堆、栈、方法区存储的内容</h2>\n<p><strong>堆：</strong><br />\n堆中存放的都是new出来的对象，每个对象都包含一个与之对应的.class文件，凡是new出来的对象都存放在堆中，堆中不存放基本类型和对象引用，只存放对象本身。</p>\n<p>非静态成员变量在类的实例化时开辟空间并初始化，所以 <strong>类的非静态成员变量也放在堆中。</strong></p>\n<p>对于堆中的对象生命周期的管理由Java虚拟机的垃圾回收机制GC进行回收和统一管理。</p>\n<p><strong>栈：</strong><br />\n每个线程包含一个栈区，栈中只保存 <strong>基础数据类型的值和对象的引用</strong><br />\n。在方法执行时，被分配的内存就存在栈中，所以当然存储的局部变量就在栈中。当一段代码或者一个方法调用完毕后，栈中为这段代码所提供的基本数据类型或者对象的引用立即被释放；</p>\n<p>每个栈中的数据(基础数据类型和对象引用)都是私有的，其他栈不能访问。</p>\n<p>栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。</p>\n<p><strong>方法区：</strong><br />\n方法区又叫静态区，方法区中包含的都是在整个程序中永远唯一的元素比如class，static变量</p>\n<p>方法区和堆一样都是被各个线程所共享，它用于存储class二进制文件，包含了虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p>\n<p>常量池是方法区的一部分内存，常量池在编译期间就将一部分数据存放于该区域，包含基本数据类型如int、long等以final声明的常量值，<br />\n串池也是方法区中的一部分内存，用于存放String字符串，对于方法运行期位于栈中的局部变量String常量的值可以通过<br />\nString.intern()方法将该值置入到常量池中。</p>\n<p>方法区是线程安全的，由于 <strong>所有的线程都共享方法区</strong><br />\n，所以，方法区里的数据访问必须被设计成线程安全的。方法区的静态变量一个线程访问的时候另一个线程必须等待。</p>\n<p>下面一个图展示上面内容：<br />\n![java存储机制图示](<a href=\"https://img-blog.csdnimg.cn/20190509102725256.png?x-oss-\">https://img-blog.csdnimg.cn/20190509102725256.png?x-oss-</a><br />\nprocess=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70)</p>\n', 1, '', 0, 0, 1, '2022-06-10 15:25:04', '2022-06-10 15:25:04');
INSERT INTO `tb_article` VALUES (264, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7810', 'java中的集合框架（Set、List、Map）及其实现类', '<p>-&quot;+value);  //获取所有的key<br />\n}</p>\n<p>2值遍历 只能够获取到值（value）<br />\n获取所有的value 存放在集合中</p>\n<pre><code>Collection values = map.values();\n</code></pre>\n<p>遍历集合</p>\n<pre><code>		for(String value:values){\n			System.out.println(value);\n		}\n</code></pre>\n<p>键值对遍历 能够获取到键和值<br />\n将key和value 封装成一个对象Map.Entry，把封装的对象存放在集合里面<br />\nentrySet() :能够获取 键值对对象 存放的集合</p>\n<pre><code>Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set = map.entrySet();\n</code></pre>\n<p>遍历集合 获取对应键和值</p>\n<pre><code>    for(Map.Entry&lt;Integer, String&gt; entry:set){\n    			Integer key = entry.getKey();\n    			String value = entry.getValue();\n    			System.out.println(key+&quot;---&quot;+value);\n    		}\n</code></pre>\n<p>Map的常用方法示例：</p>\n<pre><code>package test;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\npublic class testMap {\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();\n		//增\n		map.put(&quot;a&quot;, 1);\n		map.put(&quot;b&quot;, 2);\n		map.put(&quot;c&quot;, 3);\n		map.put(&quot;d&quot;, 4);\n		map.put(&quot;e&quot;, 5);\n		\n		//查\n		System.out.println(map.get(&quot;c&quot;));\n		//改\n		map.put(&quot;c&quot;, 33);\n		System.out.println(map.get(&quot;c&quot;));\n		//删\n		map.remove(&quot;d&quot;);\n		//遍历\n		System.out.println(map);\n		//查找map中是否包含指定的key\n		System.out.println(map.containsKey(&quot;e&quot;));\n		//查找map中是否包含指定的value\n		map.containsValue(&quot;5&quot;);\n		//长度\n		System.out.println(map.size());\n		System.out.println();\n		//遍历key\n		System.out.println(&quot;遍历key&quot;);\n		Set&lt;String&gt; set = map.keySet();\n		for (String string : set) {\n			Integer val = map.get(string);\n			System.out.print(string+&quot;\\t&quot;+val+&quot;\\n&quot;);\n		}\n		System.out.println();\n		\n		//遍历value\n		System.out.println(&quot;遍历value：&quot;);\n		Collection&lt;Integer&gt; values = map.values();\n		for (Integer integer : values) {\n			System.out.print(integer+&quot;\\t&quot;);\n		}\n		System.out.println();\n		System.out.println(&quot;遍历键值对：&quot;);\n		Set&lt;Entry&lt;String,Integer&gt;&gt; set2 = map.entrySet();\n		for (Entry&lt;String, Integer&gt; entry : set2) {		\n			System.out.println(entry);\n		}	\n	}\n}\n</code></pre>\n<p>通过上面程序可以看到，元素的key值是可以进行排序的，可以通过TreeMap进行排序，和TreeSet的排序类似。就不多介绍了。<br />\nMap实现类 之间的区别、</p>\n<p>HashMap JDk1.2 线程不安全 轻量级实现 运行效率高 允许key和value为null值<br />\n自定义的类型作为key时，必须重写hashCode和equals方法</p>\n<p>LinkedHashMap JDK1.2<br />\n自定义的类型作为key时，必须重写hashCode和equals方法<br />\n保证遍历的顺序跟添加的顺序一致</p>\n<p>TreeMap JDK1.2<br />\n保证遍历的顺序为key升序排列后的结果<br />\n自定义的类型作为key时，需要实现Comparable接口，以及实现compareTo方法</p>\n<p>Propertis jdK 1.0<br />\n键和值都必须是String类型，通过用来读取配置文件时</p>\n<p>HashTable jdK 1.0 线程安全 重量级实现 运行效率低 不允许key和value为null</p>\n', 1, '', 0, 0, 1, '2022-06-10 15:25:26', '2022-06-10 15:25:26');
INSERT INTO `tb_article` VALUES (265, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=9705', 'Maven 手动导入jar包命令', '<p><strong>Maven导入jar包可不仅仅是把jar包复制到仓库那么简单啊，那样是不起任何效果的</strong><br />\n必须通过命令行导入，如下所示：</p>\n<p><strong>为什么要手动向maven仓库导入jar包？</strong></p>\n<p>因为我们所需的一些jar包是在mvn repository 下载不到的，不论是国内还是国外镜像，都无法下载到，但我们又需要，所以我们只能手动导入啦！<br />\n<strong>这些不能下载的常见jar有：</strong><br />\n连接数据库的 ojdbc6.jar 。<br />\n以及验证码所需的jar等。</p>\n<p><strong>如何导入jar包？</strong><br />\n使用windows命令行工具：<br />\n命令如下：</p>\n<pre><code>mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=11.2 -Dpackaging=jar -Dfile=C:6.jar\n</code></pre>\n<p><strong>需要修改的地方：</strong> （等号右边的值修改为你自己的）<br />\n-DgroupId=com.oracle ：这个是项目的包路径，叫什么都可以，一般我们用什么类型的jar包名就叫啥。<br />\n-DartifactId=ojdbc6 ：jar包名称。叫什么无所谓，但最好和jar名一致。<br />\n-Dversion=11.2 版本号，j<br />\n-Dfile=C:6.jar jar包所在路径，一定要写对，否则会找不到。<br />\n这个命令有点长，中间不要有换行，换行会出问题。</p>\n<p><strong>然后再在pom.xml文件中配置dependency</strong></p>\n<pre><code>      com.oracle\n	   \n      ojdbc6\n       \n      11.2\n</code></pre>\n<p>如此，这个jar包我们的maven项目就可以使用啦！</p>\n', 1, '', 0, 0, 1, '2022-06-10 15:25:34', '2022-06-10 15:25:34');
INSERT INTO `tb_article` VALUES (266, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7188', 'Netty最全入门教程！', '<h3 id=\"目录\">目录</h3>\n<ul>\n<li>什么是Netty？</li>\n<li>Netty和Tomcat有什么区别？</li>\n<li>为什么Netty受欢迎？</li>\n<li>Netty为什么并发高</li>\n<li>五种常见的IO模型</li>\n<li>Netty为什么传输快</li>\n<li>为什么说Netty封装好？</li>\n<li>\n<pre><code>* 他有三种使用模式：\n</code></pre>\n</li>\n</ul>\n<h1 id=\"什么是netty\">什么是Netty？</h1>\n<blockquote>\n<p>Netty 是一个利用 Java 的高级网络的能力，隐藏其背后的复杂性而提供一个易于使用的 API 的客户端/服务器框架。 Netty<br />\n是一个广泛使用的 Java 网络编程框架（Netty 在 2011 年获得了Duke’s Choice<br />\nAward，见<a href=\"https://www.java.net/dukeschoice/2011）。它活跃和成长于用户社区，像大型公司\">https://www.java.net/dukeschoice/2011）。它活跃和成长于用户社区，像大型公司</a><br />\nFacebook 和 Instagram 以及流行 开源项目如 Infinispan, HornetQ, Vert.x, Apache<br />\nCassandra 和 Elasticsearch 等，都利用其强大的对于网络抽象的核心代码。</p>\n</blockquote>\n<p><em>以上是摘自《Essential Netty In Action》这本书，本文的内容也是本人读了这本书之后的一些整理心得，如有不当之处欢迎大虾们指正</em></p>\n<h1 id=\"netty和tomcat有什么区别\">Netty和Tomcat有什么区别？</h1>\n<p>Netty和Tomcat最大的区别就在于通信协议，Tomcat是基于Http协议的，他的实质是一个基于http协议的web容器，但是Netty不一样，他能通过编程自定义各种协议，因为netty能够通过codec自己来编码/解码字节流，完成类似redis访问的功能，这就是netty和tomcat最大的不同。</p>\n<p><em>有人说netty的性能就一定比tomcat性能高，其实不然，tomcat从6.x开始就支持了nio模式，并且后续还有APR模式——一种通过jni调用apache网络库的模式，相比于旧的bio模式，并发性能得到了很大提高，特别是APR模式，而netty是否比tomcat性能更高，则要取决于netty程序作者的技术实力了。</em></p>\n<h1 id=\"为什么netty受欢迎\">为什么Netty受欢迎？</h1>\n<p>如第一部分所述，netty是一款收到大公司青睐的框架，在我看来，netty能够受到青睐的原因有三：</p>\n<ol>\n<li>并发高</li>\n<li>传输快</li>\n<li>封装好</li>\n</ol>\n<h1 id=\"netty为什么并发高\">Netty为什么并发高</h1>\n<p>Netty是一款基于NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架，对比于BIO（Blocking<br />\nI/O，阻塞IO），他的并发性能得到了很大提高，两张图让你了解BIO和NIO的区别：</p>\n<p>阻塞IO的通信方式：<br />\n![阻塞IO的通信方式](<a href=\"https://img-blog.csdnimg.cn/20210319182041984.png?x-oss-\">https://img-blog.csdnimg.cn/20210319182041984.png?x-oss-</a><br />\nprocess=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70)</p>\n<p>非阻塞IO的通信方式：<br />\n![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/20210319182127347.png?x-oss-\">https://img-blog.csdnimg.cn/20210319182127347.png?x-oss-</a><br />\nprocess=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70)</p>\n<p>从这两图可以看出，NIO的单线程能处理连接的数量比BIO要高出很多，而为什么单线程能处理更多的连接呢？原因就是图二中出现的Selector。</p>\n<p>当一个连接建立之后，他有两个步骤要做，第一步是接收完客户端发过来的全部数据，第二步是服务端处理完请求业务之后返回response给客户端。NIO和BIO的区别主要是在第一步。</p>\n<p>在BIO中，等待客户端发数据这个过程是阻塞的，这样就造成了一个线程只能处理一个请求的情况，而机器能支持的最大线程数是有限的，这就是为什么BIO不能支持高并发的原因。</p>\n<p>而NIO中，当一个Socket建立好之后，Thread并不会阻塞去接受这个Socket，而是将这个请求交给Selector，Selector会不断的去遍历所有的Socket，一旦有一个Socket建立完成，他会通知Thread，然后Thread处理完数据再返回给客户端——<br />\n<strong>这个过程是不阻塞的</strong> ，这样就能让一个Thread处理更多的请求了。</p>\n<p>下面两张图是基于BIO的处理流程和netty的处理流程，辅助你理解两种方式的差别：<br />\nBIO的处理流程<br />\n![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/20210319182159452.png?x-oss-\">https://img-blog.csdnimg.cn/20210319182159452.png?x-oss-</a><br />\nprocess=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70)</p>\n<p>NIO的处理流程<br />\n![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/20210319182207649.png?x-oss-\">https://img-blog.csdnimg.cn/20210319182207649.png?x-oss-</a><br />\nprocess=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70)<br />\n除了BIO和NIO之外，还有一些其他的IO模型，下面这张图就表示了五种IO模型的处理流程：<br />\n![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/20210319182226864.png?x-oss-\">https://img-blog.csdnimg.cn/20210319182226864.png?x-oss-</a><br />\nprocess=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70)</p>\n<h1 id=\"五种常见的io模型\">五种常见的IO模型</h1>\n<ol>\n<li>BIO，同步阻塞IO，阻塞整个步骤，如果连接少，他的延迟是最低的，因为一个线程只处理一个连接，适用于少连接且延迟低的场景，比如说数据库连接。</li>\n<li>NIO，同步非阻塞IO，阻塞业务处理但不阻塞数据接收，适用于高并发且处理简单的场景，比如聊天软件。</li>\n<li>多路复用IO，他的两个步骤处理是分开的，也就是说，一个连接可能他的数据接收是线程a完成的，数据处理是线程b完成的，他比BIO能处理更多请求。</li>\n<li>信号驱动IO，这种IO模型主要用在嵌入式开发，不参与讨论。</li>\n<li>异步IO，他的数据请求和数据处理都是异步的，数据请求一次返回一次，适用于长连接的业务场景。</li>\n</ol>\n<p><em>以上摘自Linux IO模式及 select、poll、epoll详解</em></p>\n<h1 id=\"netty为什么传输快\">Netty为什么传输快</h1>\n<p>Netty的传输快其实也是依赖了NIO的一个特性——零拷贝。我们知道，Java的内存有堆内存、栈内存和字符串常量池等等，其中堆内存是占用内存空间最大的一块，也是Java对象存放的地方，一般我们的数据如果需要从IO读取到堆内存，中间需要经过Socket缓冲区，也就是说一个数据会被拷贝两次才能到达他的的终点，如果数据量大，就会造成不必要的资源浪费。<br />\nNetty针对这种情况，使用了NIO中的另一大特性——零拷贝，当他需要接收数据的时候，他会在堆内存之外开辟一块内存，数据就直接从IO读到了那块内存中去，在netty里面通过ByteBuf可以直接对这些数据进行直接操作，从而加快了传输速度。<br />\n<em>下两图就介绍了两种拷贝方式的区别，摘自Linux 中的零拷贝技术，第 1 部分</em><br />\n传统数据拷贝<br />\n![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/20210319182332702.png?x-oss-\">https://img-blog.csdnimg.cn/20210319182332702.png?x-oss-</a><br />\nprocess=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70)</p>\n<p>零拷贝<br />\n![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/20210319182340315.png?x-oss-\">https://img-blog.csdnimg.cn/20210319182340315.png?x-oss-</a><br />\nprocess=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70)</p>\n<p>上文介绍的ByteBuf是Netty的一个重要概念，他是netty数据处理的容器，也是Netty封装好的一个重要体现，将在下一部分做详细介绍。</p>\n<h1 id=\"为什么说netty封装好\">为什么说Netty封装好？</h1>\n<p>要说Netty为什么封装好，这种用文字是说不清的，直接上代码：</p>\n<p><strong>- 阻塞I/O</strong></p>\n<pre><code>public class PlainOioServer {\n\n    public void serve(int port) throws IOException {\n        final ServerSocket socket = new ServerSocket(port);     //1\n        try {\n            for (;;) {\n                final Socket clientSocket = socket.accept();    //2\n                System.out.println(&quot;Accepted connection from &quot; + clientSocket);\n\n                new Thread(new Runnable() {                        //3\n                    @Override\n                    public void run() {\n                        OutputStream out;\n                        try {\n                            out = clientSocket.getOutputStream();\n                            out.write(&quot;Hi!\\r\\n&quot;.getBytes(Charset.forName(&quot;UTF-8&quot;)));                            //4\n                            out.flush();\n                            clientSocket.close();                //5\n\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                            try {\n                                clientSocket.close();\n                            } catch (IOException ex) {\n                                // ignore on close\n                            }\n                        }\n                    }\n                }).start();                                        //6\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<p><strong>- 非阻塞IO</strong></p>\n<pre><code>public class PlainNioServer {\n   public void serve(int port) throws IOException {\n       ServerSocketChannel serverChannel = ServerSocketChannel.open();\n       serverChannel.configureBlocking(false);\n       ServerSocket ss = serverChannel.socket();\n       InetSocketAddress address = new InetSocketAddress(port);\n       ss.bind(address);                                            //1\n       Selector selector = Selector.open();                        //2\n       serverChannel.register(selector, SelectionKey.OP_ACCEPT);    //3\n       final ByteBuffer msg = ByteBuffer.wrap(&quot;Hi!\\r\\n&quot;.getBytes());\n       for (;;) {\n           try {\n               selector.select();                                    //4\n           } catch (IOException ex) {\n               ex.printStackTrace();\n               // handle exception\n               break;\n           }\n           Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys();    //5\n           Iterator&lt;SelectionKey&gt; iterator = readyKeys.iterator();\n           while (iterator.hasNext()) {\n               SelectionKey key = iterator.next();\n               iterator.remove();\n               try {\n                   if (key.isAcceptable()) {                //6\n                       ServerSocketChannel server =\n                               (ServerSocketChannel)key.channel();\n                       SocketChannel client = server.accept();\n                       client.configureBlocking(false);\n                       client.register(selector, SelectionKey.OP_WRITE |\n                               SelectionKey.OP_READ, msg.duplicate());    //7\n                       System.out.println(\n                               &quot;Accepted connection from &quot; + client);\n                   }\n                   if (key.isWritable()) {                //8\n                       SocketChannel client =\n                               (SocketChannel)key.channel();\n                       ByteBuffer buffer =\n                               (ByteBuffer)key.attachment();\n                       while (buffer.hasRemaining()) {\n                           if (client.write(buffer) == 0) {        //9\n                               break;\n                           }\n                       }\n                       client.close();                    //10\n                   }\n               } catch (IOException ex) {\n                   key.cancel();\n                   try {\n                       key.channel().close();\n                   } catch (IOException cex) {\n                       // 在关闭时忽略\n                   }\n               }\n           }\n       }\n   }\n}\n</code></pre>\n<p><strong>- Netty</strong></p>\n<pre><code>public class NettyOioServer {\n\n    public void server(int port) throws Exception {\n        final ByteBuf buf = Unpooled.unreleasableBuffer(\n                Unpooled.copiedBuffer(&quot;Hi!\\r\\n&quot;, Charset.forName(&quot;UTF-8&quot;)));\n        EventLoopGroup group = new OioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();        //1\n\n            b.group(group)                                    //2\n             .channel(OioServerSocketChannel.class)\n             .localAddress(new InetSocketAddress(port))\n             .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {//3\n                 @Override\n                 public void initChannel(SocketChannel ch) \n                     throws Exception {\n                     ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {            //4\n                         @Override\n                         public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                             ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);//5\n                         }\n                     });\n                 }\n             });\n            ChannelFuture f = b.bind().sync();  //6\n            f.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully().sync();        //7\n        }\n    }\n}\n</code></pre>\n<p>从代码量上来看，Netty就已经秒杀传统Socket编程了，但是这一部分博大精深，仅仅贴几个代码岂能说明问题，在这里给大家介绍一下Netty的一些重要概念，让大家更理解Netty。</p>\n<p><strong>Channel</strong><br />\n数据传输流，与channel相关的概念有以下四个，上一张图让你了解netty里面的Channel。<br />\n![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/20210319182541384.png?x-oss-\">https://img-blog.csdnimg.cn/20210319182541384.png?x-oss-</a><br />\nprocess=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70)</p>\n<ul>\n<li>Channel，表示一个连接，可以理解为每一个请求，就是一个Channel。</li>\n<li>ChannelHandler，核心处理业务就在这里，用于处理业务请求。</li>\n<li>ChannelHandlerContext，用于传输业务数据。</li>\n<li>ChannelPipeline，用于保存处理过程需要用到的ChannelHandler和ChannelHandlerContext。</li>\n<li>ByteBuf<br />\nByteBuf是一个存储字节的容器，最大特点就是使用方便，它既有自己的读索引和写索引，方便你对整段字节缓存进行读写，也支持get/set，方便你对其中每一个字节进行读写，他的数据结构如下图所示：<br />\nByteBuf数据结构</li>\n</ul>\n<h2 id=\"他有三种使用模式\">他有三种使用模式：</h2>\n<p><strong>Heap Buffer 堆缓冲区</strong><br />\n堆缓冲区是ByteBuf最常用的模式，他将数据存储在堆空间。</p>\n<p><strong>Direct Buffer 直接缓冲区</strong><br />\n直接缓冲区是ByteBuf的另外一种常用模式，他的内存分配都不发生在堆，jdk1.4引入的nio的ByteBuffer类允许jvm通过本地方法调用分配内存，这样做有两个好处<br />\n通过免去中间交换的内存拷贝, 提升IO处理速度; 直接缓冲区的内容可以驻留在垃圾回收扫描的堆区以外。</p>\n<p>DirectBuffer 在 -XX:MaxDirectMemorySize=xxM大小限制下, 使用 Heap 之外的内存,<br />\nGC对此”无能为力”,也就意味着规避了在高负载下频繁的GC过程对应用线程的中断影响.<br />\nComposite Buffer 复合缓冲区<br />\n复合缓冲区相当于多个不同ByteBuf的视图，这是netty提供的，jdk不提供这样的功能。<br />\n除此之外，他还提供一大堆api方便你使用，在这里我就不一一列出了，具体参见ByteBuf字节缓存。</p>\n<p><strong>Codec</strong><br />\nNetty中的编码/解码器，通过他你能完成字节与pojo、pojo与pojo的相互转换，从而达到自定义协议的目的。<br />\n在Netty里面最有名的就是HttpRequestDecoder和HttpResponseEncoder了。</p>\n', 1, '', 0, 0, 1, '2022-06-10 15:25:52', '2022-06-10 15:25:52');
INSERT INTO `tb_article` VALUES (267, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7998', '带你读透 SEATA 的 AT 模式', '<p>|---|---<br />\nid| bigint(20)| PRI<br />\nname| varchar(100)|<br />\nsince| varchar(100)|</p>\n<p>AT 分支事务的业务逻辑：</p>\n<pre><code>update product set name = \'GTS\' where name = \'TXC\';\n</code></pre>\n<h4 id=\"执行阶段\">执行阶段</h4>\n<p>过程：</p>\n<ol>\n<li>解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name = ‘TXC’）等相关的信息。</li>\n<li>查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。</li>\n</ol>\n<pre><code>select id, name, since from product where name = \'TXC\';\n</code></pre>\n<p>得到前镜像：</p>\n<table>\n<thead>\n<tr><th>id</th><th>name</th><th>since</th></tr>\n</thead>\n<tbody>\n<tr><td>1</td><td>TXC</td><td>2014</td></tr>\n</tbody>\n</table>\n<ol start=\"3\">\n<li>执行业务 SQL：更新这条记录的 name 为 ‘GTS’。</li>\n<li>查询后镜像：根据前镜像的结果，通过 主键 定位数据。</li>\n</ol>\n<pre><code>select id, name, since from product where id = 1`;\n</code></pre>\n<p>得到后镜像：</p>\n<table>\n<thead>\n<tr><th>id</th><th>name</th><th>since</th></tr>\n</thead>\n<tbody>\n<tr><td>1</td><td>GTS</td><td>2014</td></tr>\n</tbody>\n</table>\n<ol>\n<li>插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 <code>UNDO_LOG</code> 表中。</li>\n</ol>\n<pre><code>{\n    &quot;branchId&quot;: 641789253,\n    &quot;undoItems&quot;: [{\n        &quot;afterImage&quot;: {\n            &quot;rows&quot;: [{\n                &quot;fields&quot;: [{\n                    &quot;name&quot;: &quot;id&quot;,\n                    &quot;type&quot;: 4,\n                    &quot;value&quot;: 1\n                }, {\n                    &quot;name&quot;: &quot;name&quot;,\n                    &quot;type&quot;: 12,\n                    &quot;value&quot;: &quot;GTS&quot;\n                }, {\n                    &quot;name&quot;: &quot;since&quot;,\n                    &quot;type&quot;: 12,\n                    &quot;value&quot;: &quot;2014&quot;\n                }]\n            }],\n            &quot;tableName&quot;: &quot;product&quot;\n        },\n        &quot;beforeImage&quot;: {\n            &quot;rows&quot;: [{\n                &quot;fields&quot;: [{\n                    &quot;name&quot;: &quot;id&quot;,\n                    &quot;type&quot;: 4,\n                    &quot;value&quot;: 1\n                }, {\n                    &quot;name&quot;: &quot;name&quot;,\n                    &quot;type&quot;: 12,\n                    &quot;value&quot;: &quot;TXC&quot;\n                }, {\n                    &quot;name&quot;: &quot;since&quot;,\n                    &quot;type&quot;: 12,\n                    &quot;value&quot;: &quot;2014&quot;\n                }]\n            }],\n            &quot;tableName&quot;: &quot;product&quot;\n        },\n        &quot;sqlType&quot;: &quot;UPDATE&quot;\n    }],\n    &quot;xid&quot;: &quot;xid:xxx&quot;\n}\n</code></pre>\n<ol start=\"6\">\n<li>提交前，向 TC 注册分支：申请 product 表中，主键值等于 1 的记录的 全局锁 。</li>\n<li>本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。</li>\n<li>将本地事务提交的结果上报给 TC。</li>\n</ol>\n<h4 id=\"完成阶段-回滚\">完成阶段-回滚</h4>\n<ol>\n<li>\n<p>收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。</p>\n</li>\n<li>\n<p>通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。</p>\n</li>\n<li>\n<p>数据校验：拿 UNDO LOG<br />\n中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理，详细的说明在另外的文档中介绍。</p>\n</li>\n<li>\n<p>根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句：</p>\n</li>\n</ol>\n<pre><code>update product set name = \'TXC\' where id = 1;\n</code></pre>\n<ol start=\"5\">\n<li>提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC。</li>\n</ol>\n<h4 id=\"完成阶段-提交\">完成阶段-提交</h4>\n<ol>\n<li>收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。</li>\n<li>异步任务阶段的分支提交请求将异步和批量地删除相应 UNDO LOG 记录。</li>\n</ol>\n<h2 id=\"和-xa-的关系\">和 XA 的关系</h2>\n<p>前面一直拿 AT 和 XA 做比较。</p>\n<p>这里特别说明一下，并不是说 XA 协议本身有问题，只是说在某些场景的需求下，基于 XA 做不理想。</p>\n<p>但同样，另外还有一些对内外部 <strong>一致性要求非常高</strong> 的场景，可能 XA 又是非常适合，甚至必需的。</p>\n<p>这也是接下来 Seata 将提供 XA 模式的原因。</p>\n<p>关于 <strong>XA 模式</strong> 这里就不展开了，后面会有专门的文章和大家交流。</p>\n<h2 id=\"at-的核心价值\">AT 的核心价值</h2>\n<p>AT 模式到底带给我们什么价值呢？</p>\n<p>首先，从技术原理角度来看，非常重要的一点是： <strong>平衡</strong> 。</p>\n<p>![Balance](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/eeaef401004c4f5abbb984684620b3ef.png?x-oss-<br />\nprocess=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSn5qCR5YWI55SfLg==,size_20,color_FFFFFF,t_70,g_se,x_16)</p>\n<p>必须承认，分布式事务是个复杂的问题，目前还没有任何一种解决方案可以非常完美地适应所有应用场景。</p>\n<p>如果把分布式事务方案按 <strong>一致性</strong> 、 <strong>性能</strong> 和 <strong>易用性</strong> 这 3 个维度来考量：AT<br />\n模式，实际上是在业务需求允许的前提下，找到一个比较好的平衡点。</p>\n<p>编程模型不做改变的前提下，达到确定的一致性，而且保证了性能和系统可用性。</p>\n<p>其次，从用户的角度来看。我们设想一个企业业务的成长过程：</p>\n<p>![Demo Business Growth](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/34294bbe906c4358a3f815ae16ebeeac.png?x-oss-<br />\nprocess=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSn5qCR5YWI55SfLg==,size_20,color_FFFFFF,t_70,g_se,x_16)</p>\n<ul>\n<li>\n<p>1.0：单体应用，快速上线，这个时候完全不涉及分布式事务。</p>\n</li>\n<li>\n<p>2.0：单个数据库无法支撑，数据分布到多个数据库，产生分布式事务问题。</p>\n</li>\n<li>\n<p>3.0：微服务化，进一步产生跨服务的分布式事务。</p>\n</li>\n<li>\n<p>4.0：跨应用的整合，成为 SaaS 或 FaaS 的平台，在更大的范围，产生分布式事务问题。</p>\n</li>\n</ul>\n<p>基于 Seata 的 AT 模式构建企业业务的分布式事务解决方案，可以带来以下 3 个方面的 <strong>核心价值</strong> ：</p>\n<ul>\n<li><strong>低成本</strong> ： <strong>编程模型</strong> 不变，轻依赖 不需要为分布式事务场景做特定设计，业务像搭积木一样自然地构建成长。</li>\n<li><strong>高性能</strong> ：协议 <strong>不阻塞</strong> ；资源释放快，保证业务的吞吐。</li>\n<li><strong>高可用</strong> ：极端的异常情况下，可以暂时 <strong>跳过异常事务</strong> ，保证整个业务系统的高可用。</li>\n</ul>\n<h2 id=\"at-的现在和未来\">AT 的现在和未来</h2>\n<p>没有 <strong>银蛋</strong> ，AT 模式带来上面提到的价值的同时，也必定有一些局限和不足。</p>\n<h4 id=\"较重的-sdk\">较重的 SDK</h4>\n<p>![Heavy SDK](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/a9655036309640d0919f8402836cce67.png?x-oss-<br />\nprocess=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSn5qCR5YWI55SfLg==,size_20,color_FFFFFF,t_70,g_se,x_16)</p>\n<p>AT 模式有很大一部分功能依赖于 SDK 的实现，包括 SQL 解析、回滚日志的生成、分支提交回滚逻辑的执行等等。</p>\n<p>这些关键运行机制是基于 Java 的 JDBC 构建起来的。如果要支持其他语言，迁移成本非常高。</p>\n<p>面向云原生时代，AT 模式未来的方向将是 SDK 的轻量化和标准化，把大部分能力下沉到代理层（Agent 或 Sidecar 的形式），让应用只需要很简单的<br />\nSDK 和标准的 SQL 就可以工作。</p>\n<p>![Light SDK](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/a94c8de8b5624b5b9da2d438b6284340.png?x-oss-<br />\nprocess=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSn5qCR5YWI55SfLg==,size_20,color_FFFFFF,t_70,g_se,x_16)</p>\n<h2 id=\"能力边界\">能力边界</h2>\n<p>从工作原理来看，AT 模式有一些特定的使用条件和局限。</p>\n<p>首先，AT 模式的 <strong>基本条件</strong> 是：数据库本身必须支持 <strong>本地事务</strong> 。AT 的基本工作机制是基于本地事务的。</p>\n<p>其次，数据表必须定义 <strong>主键</strong> 。回滚日志的生成和使用，是基于数据主键的。</p>\n<p>另外， <strong>隔离性</strong> ，这也是所有基于 <strong>补偿</strong><br />\n的分布式事务解决方案，都面临的问题：隔离性很难做到很高，或者说，要做到较高隔离性的成本和收益是不匹配的。</p>\n<p>基于这些目前的局限，Seata 项目整体的应对策略是，提供各类不同的事务模式来取长补短，实现全场景的覆盖。</p>\n<p>目前已经具备和正在规划中的，一共是两大类，4 种事务模式：</p>\n<p>![Landscape of Seata](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/58f0a43264364c93ae364367752bdb10.png?x-oss-<br />\nprocess=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSn5qCR5YWI55SfLg==,size_20,color_FFFFFF,t_70,g_se,x_16)</p>\n<ul>\n<li>\n<p>业务无侵入的：AT、XA</p>\n</li>\n<li>\n<p>业务侵入的：TCC、Saga</p>\n</li>\n</ul>\n<p>这些模式各自有其适用和不适用的场景，Seata 将把这些模式很好地融合起来，给用户提供一站式的解决方案。</p>\n<h2 id=\"总结\">总结</h2>\n<p>Seata 的 AT 模式是分布式架构演进过程中，分布式事务中间件在阿里巴巴实践的创造性解决方案。</p>\n<p>Seata 的 AT 模式基于本地事务的特性，通过拦截并解析 SQL 的方式，记录自定义的回滚日志，从而打破 XA 协议阻塞性的制约，在一致性、性能、易用性<br />\n3 个方面取得平衡：在达到确定一致性（非最终一致）的前提下，即保障较高的性能，又能完全不侵入业务。</p>\n<p>在绝大部分应用场景下，Seata 的 AT 模式都能很好地发挥作用，把应用的分布式事务支持成本降到极低的水平。</p>\n<p>对于一些不适用 AT 模式的场景，Seata 也提供其他几类主流的分布式事务解决方案来补齐。</p>\n<h2 id=\"附录\">附录</h2>\n<ul>\n<li>Seata 官网：<a href=\"http://seata.io/zh-cn/\">http://seata.io/zh-cn/</a></li>\n<li>Seata on GitHub：<a href=\"https://github.com/seata/seata\">https://github.com/seata/seata</a></li>\n<li>支持 Seata AT 模式的阿里云 GTS（Global Transaction Service）：<a href=\"https://www.aliyun.com/aliware/txc\">https://www.aliyun.com/aliware/txc</a></li>\n</ul>\n<p>作者：sharajava<br />\n链接：<a href=\"https://www.jianshu.com/p/0ed828c2019a\">https://www.jianshu.com/p/0ed828c2019a</a><br />\n来源：简书<br />\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n', 1, '', 0, 0, 1, '2022-06-10 15:26:35', '2022-06-10 15:26:35');
INSERT INTO `tb_article` VALUES (268, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5095', '一文理解什么是DTO、VO、BO、PO、DO，并推荐一款IDEA转换插件', '<h2 id=\"1什么是dtovobopodopojo\">1、什么是DTO、VO、BO、PO、DO、POJO</h2>\n<p>POJO的定义是无规则简单的对象，在日常的代码分层中pojo会被分为VO、BO、 PO、 DTO。通过各层POJO的使用，有助于提高代码的可读性和可维护性。</p>\n<p>概念看似简单，但是想区分好或者理解好也不容易，本文简单梳理一下。</p>\n<p>![在这里插入图片描述](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/4413ca57c2274630a83a1fb5c3fe109a.png?x-oss-<br />\nprocess=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSn5qCR5YWI55SfLg==,size_13,color_FFFFFF,t_70,g_se,x_16)</p>\n<p><strong>DTO（Data Transfer Object）数据传输对象</strong></p>\n<ul>\n<li>\n<p>在服务间的调用中，传输的数据对象</p>\n</li>\n<li>\n<p>个人理解，DTO是可以存在于各层服务中（接口、服务、数据库等等）服务间的交互使用DTO来解耦</p>\n</li>\n</ul>\n<p><strong>VO （view object/value object）表示层对象</strong></p>\n<ul>\n<li>前端展示的数据，在接口数据返回给前端的时候需要转成VO</li>\n<li>使用场景，在接口层服务中，将DTO转成VO,返回给前台</li>\n</ul>\n<p><strong>B0（bussines object）业务层对象</strong></p>\n<ul>\n<li>主要在服务内部使用的业务对象</li>\n<li>主要在服务内部使用的业务对象</li>\n<li>使用场景，在服务层服务中，由DTO转成BO然后进行业务处理后，转成DTO返回到接口层</li>\n</ul>\n<p><strong>PO（persistent object）持久对象</strong></p>\n<ul>\n<li>\n<p>出现位置为数据库数据，用来存储数据库提取的数据</p>\n</li>\n<li>\n<p>只存储数据，不包含数据操作</p>\n</li>\n<li>\n<p>使用场景，在数据库层中，获取的数据库数据存储到PO中，然后转为DTO返回到服务层中</p>\n</li>\n</ul>\n<p><strong>DO（domain object）领域实体对象</strong></p>\n<p>DO 现在主要有两个版本：</p>\n<ul>\n<li>\n<p>①阿里巴巴的开发手册中的定义，DO（ Data Object）这个等同于上面的PO</p>\n</li>\n<li>\n<p>②DDD（Domain-Driven Design）领域驱动设计中，DO（Domain Object）这个等同于上面的BO</p>\n</li>\n</ul>\n<h2 id=\"2区别\">2、区别</h2>\n<p>《阿里巴巴Java开发规范》关于领域模型的部分介绍如下：</p>\n<blockquote>\n<p>分层领域模型规约:</p>\n<ul>\n<li>DO(Data Object):此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</li>\n<li>DTO(Data Transfer Object):数据传输对象，Service 或 Manager 向外传输的对象。</li>\n<li>BO(Business Object):业务对象，由 Service 层输出的封装业务逻辑的对象。</li>\n<li>AO(ApplicationObject):应用对象，在Web层与Service层之间抽象的复用对象模型， 极为贴近展示层，复用度不高。</li>\n<li>VO(View Object):显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li>\n<li>Query:数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装， <strong>禁止使用 Map 类来传输。</strong></li>\n</ul>\n</blockquote>\n<p><strong>最难理解的是BO，大致这么理解：</strong></p>\n<p>BO这个对象可以包括一个或多个其它的对象。</p>\n<p>比如一个简历，有教育经历、工作经历、社会关系等等。</p>\n<p>我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。</p>\n<p>建立一个对应简历的BO对象处理简历，每个BO包含这些PO。这样处理业务逻辑时，我们就可以针对BO去处理。</p>\n<h2 id=\"3示例代码\">3、示例代码</h2>\n<p>Controller层<br />\n此层常见的转换为：DTO转VO，将Services层传过来的DTO转换成VO表示数据返回给前端</p>\n<pre><code>public List getUsers(UserQuery userQuery);\n</code></pre>\n<p>Service层、Manager层</p>\n<p>此层常见的转换为：DO转BO、BO转DTO</p>\n<pre><code>// 普通的service层接口，对数据处理，返回DTO对象\n\n List&lt;UserDTO&gt; getUsers(UserQuery userQuery);\n \n 然后在Service内部使用UserBO封装中间所需的逻辑对象\n</code></pre>\n<p>DAO层<br />\n此层常见的转换为：DTO转换为DO，与数据库进行交互</p>\n<pre><code>List&lt;UserDO&gt; getUsers(UserQuery userQuery);\n</code></pre>\n<h4 id=\"领域模型定义\">领域模型定义</h4>\n<ul>\n<li>Entity表结构实体，对应DO</li>\n<li>BO业务实体</li>\n<li>VO视图实体,DTO可共用</li>\n<li>入参封装<br />\n○ xxxParam<br />\n○ Query xxx Param<br />\n○ Save xxx Param<br />\n○ Edit xxx Param<br />\n○ Remove xxx Param</li>\n</ul>\n<h2 id=\"4idea插件完成转换\">4、IDEA插件完成转换</h2>\n<h4 id=\"1插件名称simple-object-copy\">1、插件名称：Simple Object Copy</h4>\n<p>这个插件是收费的，好像是6元（人民币）每年，当然学生、教育机构、公益免费。<br />\n可以试用30天，好用不好用试试才知道，先来体验一下吧！</p>\n<h4 id=\"2安装\">2、安装</h4>\n<p>安装就不多说了，直接在idea的Plugins应用商店搜索插件名就出来了，然后下载安装就好，安装好后会让重启idea，那就重启呗，重启后选择30天的试用。<br />\n![在这里插入图片描述](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/ba8cf141f9c64e1587a696752e7427dc.png?x-oss-<br />\nprocess=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSn5qCR5YWI55SfLg==,size_20,color_FFFFFF,t_70,g_se,x_16)</p>\n<h4 id=\"3如何使用\">3、如何使用</h4>\n<ol>\n<li>定义方法出入参，出入参就是要转换的实体</li>\n<li>光标定位方法内，使用快捷键ALT+INSERT(WIN) 、 command + N(mac) ，或者右键鼠标选择Generate，弹出生成选项框后，选择genCopyMethod，代码就生成好了<br />\n![在这里插入图片描述](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/0bb15b30759b4bbe9df5eae4e6923822.png?x-oss-<br />\nprocess=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSn5qCR5YWI55SfLg==,size_20,color_FFFFFF,t_70,g_se,x_16)<br />\n结果是这样的：<br />\n![在这里插入图片描述](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/7ce6924e1d49474cba2e476b11285a6c.png?x-oss-<br />\nprocess=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSn5qCR5YWI55SfLg==,size_20,color_FFFFFF,t_70,g_se,x_16)</li>\n</ol>\n<p>复杂对象转化展示：<br />\n![在这里插入图片描述](<a href=\"https://img-\">https://img-</a><br />\nblog.csdnimg.cn/10b479d1ffeb45fa992b5f81322ab5fa.png?x-oss-<br />\nprocess=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSn5qCR5YWI55SfLg==,size_20,color_FFFFFF,t_70,g_se,x_16)</p>\n<h2 id=\"5结语\">5、结语</h2>\n<p>通过插件的使用</p>\n<p>1、可以节省一个个字段的设置的开发时间</p>\n<p>2、避免了漏字段设置，ps：前端同学总是来问为啥字段总是null。</p>\n<p>3、而且通过出入参的设计思想去开发，规范了代码，在有特殊请求转化的时候也比较方便。</p>\n', 1, '', 0, 0, 1, '2022-06-10 15:26:49', '2022-06-10 15:26:49');
INSERT INTO `tb_article` VALUES (269, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=6285', '沙箱支付存在钓鱼风险解决办法', '<p>支付宝开放平台开发 电脑网站支付，在沙箱环境中运行</p>\n<p>提交支付请求后，却给我拦截了，跳到了，存在钓鱼风险提示页面<br />\n![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/20200717160034421.png?x-oss-\">https://img-blog.csdnimg.cn/20200717160034421.png?x-oss-</a><br />\nprocess=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70)<br />\n这个好尴尬，自己研究了一下午，在网络上查阅了有关资料，根本没有实质性解决这一方面的答案。</p>\n<p>查阅了网上的一些资料，有人说回顾检查下流程，还有人说把浏览器关掉重新打开。我试了下都不行。</p>\n<p>后来抱着试试的态度， <strong>把浏览器上打开的所有沙箱支付、支付宝官方等的页面全部关闭，然后Crtl+Shift+delete,清空浏览器缓存</strong><br />\n。再试一下果然就打开了。</p>\n<p>莫名其妙的问题，记录一下。<br />\n![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/2020071716054535.png?x-oss-\">https://img-blog.csdnimg.cn/2020071716054535.png?x-oss-</a><br />\nprocess=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70)</p>\n', 1, '', 0, 0, 1, '2022-06-10 15:27:11', '2022-06-10 15:27:11');
INSERT INTO `tb_article` VALUES (270, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=850', 'Neo4j入门实战，以三国英雄关系为例入门Neo4j知识图谱', '<p>﻿@<a href=\"Neo4j入门实战，以三国英雄关系为例入门Neo4j知识图谱\">TOC</a></p>\n<h1 id=\"前言\">前言</h1>\n<p>今天，我们一起来学习知识图谱中的Neo4J。首先，什么是知识图谱？先摘一段百度百科：</p>\n<blockquote>\n<p>Neo4j是一个高性能的,NOSQL图形数据库，它将结构化数据存储在网络上而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎，但是它将结构化数据存储在网络(从数学角度叫做图)上而不是表中。Neo4j也可以被看作是一个高性能的图引擎，该引擎具有成熟数据库的所有特性。程序员工作在一个面向对象的、灵活的网络结构下而不是严格、静态的表中——但是他们可以享受到具备完全的事务特性、企业级的数据库的所有好处。<br />\nNeo4j因其嵌入式、高性能、轻量级等优势，越来越受到关注.</p>\n</blockquote>\n<p>Neo是一个网络——<strong>面向网络的数据库</strong>——也就是说，它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎，但是它将结构化数据存储在网络上而不是表中。网络（从数学角度叫做图）是一个灵活的数据结构，可以应用更加敏捷和快速的开发模式。</p>\n<p>简单说来，知识图谱就是通过不同知识的关联性形成一个网状的知识结构，而这个知识结构，恰好就是人工智能AI的基石。当前AI领域热门的计算机图像、语音识别甚至是NLP，其实都是AI的感知能力，真正AI的认知能力，就要靠知识图谱。</p>\n<p>知识图谱目前的应用主要在<strong>搜索</strong>、<strong>智能问答</strong>、<strong>推荐系统</strong>等方面。知识图谱的建设，一般包括<strong>数据获取</strong>、<strong>实体识别</strong>和<strong>关系抽取</strong>、<strong>数据存储</strong>、<strong>图谱应用</strong>都几个方面。</p>\n<p>本文，从Neo4j的数据存储来学习如何使用</p>\n<h1 id=\"一neo4j简介\">一、Neo4J简介</h1>\n<p>官网： <a href=\"https://neo4j.com/\">https://neo4j.com/</a><br />\n知识图谱由于其数据包含实体、属性、关系等，常见的关系型数据库诸如MySQL之类不能很好的体现数据的这些特点，因此知识图谱数据的存储一般是采用<strong>图数据库（Graph Databases）</strong>。而Neo4j是其中最为常见的图数据库。</p>\n<h2 id=\"对比关系型数据库\">对比关系型数据库：</h2>\n<table>\n<thead>\n<tr><th>关系型数据库（RDBMS）</th><th>图数据库</th></tr>\n</thead>\n<tbody>\n<tr><td>表</td><td>图</td></tr>\n<tr><td>行</td><td>节点</td></tr>\n<tr><td>列和数据</td><td>属性和数据</td></tr>\n<tr><td>约束</td><td>关系</td></tr>\n</tbody>\n</table>\n<h2 id=\"对比其他nosql数据库\">对比其他NoSQL数据库</h2>\n<p>NoSQL数据库大致可以分为四类：</p>\n<ul>\n<li>键值(key/value)数据库</li>\n<li>列存储数据库</li>\n<li>文档型数据库</li>\n<li>图数据库</li>\n</ul>\n<table>\n<thead>\n<tr><th>分类</th><th>数据模型</th><th>优势</th><th>劣势</th><th>举例</th></tr>\n</thead>\n<tbody>\n<tr><td>键值数据库</td><td>哈希表</td><td>查找速度快</td><td>数据无结构化，通常只被当作字符串或者二进制数据</td><td>Redis</td></tr>\n<tr><td>列存储数据库</td><td>列式数据存储</td><td>查找速度快；支持分布横向扩展；数据压缩率高</td><td>功能相对受限</td><td>HBase</td></tr>\n<tr><td>文档型数据库</td><td>键值对扩展</td><td>数据结构要求不严格；表结构可变；不需要预先定义表结构</td><td>查询性能不高，缺乏统一的查询语法</td><td>MongoDB</td></tr>\n<tr><td>图数据库</td><td>节点和关系组成的图</td><td>利用图结构相关算法(最短路径、节点度关系查找等)</td><td>可能需要对整个图做计算，不利于图数据分布存储</td><td>Neo4j、JanusGraph</td></tr>\n</tbody>\n</table>\n<h1 id=\"二neo4j下载安装\">二、Neo4J下载安装</h1>\n<h2 id=\"方法1安装neo4j-community-server\">方法1：安装Neo4j Community Server</h2>\n<p>Neo4j和MySQL类似，我们也需要安装一个服务端程序，再安装一个客户端程序，客户端程序不安装直接使用命令行操作也可以。接下来先安装服务端程序。<br />\n首先在 <a href=\"https://neo4j.com/download-center/\">https://neo4j.com/download-center//</a> 下载Neo4J。Neo4J分为社区版和企业版，企业版在横向扩展、权限控制、运行性能、HA等方面都比社区版好，适合正式的生产环境，普通的学习和开发采用免费社区版就好。<br />\n<strong>注意： neo4j最新版对应的java版本是jdk11</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/9910576e8e3e42369dd4cd32330d5a20.png\" alt=\"neo4j\" /><br />\njdk8可以下载<strong>Neo4j Community Edition 3.5.28</strong></p>\n<p>官方文档：<a href=\"https://neo4j.com/docs/operations-manual/3.5/\">https://neo4j.com/docs/operations-manual/3.5/</a><br />\n解压到新目录（注意：目录名称不要有中文）,比如： D:\\neo4j\\</p>\n<pre><code class=\"language-Shell\"># 将Neo4j作为控制台应用程序运行\n&lt;NEO4J_HOME&gt;\\bin\\neo4j console\n# 将Neo4j作为服务使用进行安装\n&lt;NEO4J_HOME&gt;\\bin\\neo4j install-service\n</code></pre>\n<p>进入到bin目录，执行<br />\n<strong>neo4j console</strong>: 直接启动 neo4j 服务，<br />\n此外，还有其他几个命令：</p>\n<blockquote>\n<p>install-service | uninstall-ser update-service ： 安装/卸载/更新 neo4j 服务<br />\nstart/stop/restart/status: 启动/停止/重启/状态<br />\n-V 输出更多信息</p>\n</blockquote>\n<p>启动成功之后就可以在浏览器进行访问了，默认端口号是<strong>7474</strong>，ip改为服务器地址。<br />\n<a href=\"http://localhost:7474\">http://localhost:7474</a><br />\n访问成功应该是下图这个页面，能访问到说明正常启动，输入默认用户名neo4j和密码neo4j进行连接。<br />\n<img src=\"https://img-blog.csdnimg.cn/6d25faf589834101b38e6f2ce9c4f72a.png\" alt=\"在这里插入图片描述\" /><br />\n连接成功后如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/b51a3c157f14441babb1273feb5050bc.png\" alt=\"neo4j向导页面\" /><br />\n这个界面很友好，英文好的同学可以根据官方向导开始学习了。而像我这种英文渣渣就只能一步步慢慢摸索了。</p>\n<h2 id=\"安装方法2直接按照带服务端的客户端\">安装方法2：直接按照带服务端的客户端</h2>\n<p>对于初学者来说大多数还都是在Windows系统上进行入门学习，所以我们可以直接下载Windows的客户端运行使用。</p>\n<p>这里可以直接下载最新版客户端版本<br />\n<img src=\"https://img-blog.csdnimg.cn/e91001cd53c2452da06a20cd4ddcfd2d.png\" alt=\"在这里插入图片描述\" /><br />\n安装客户端后可以自行选择任何neo4j  server版本进行安装，都是界面化操作，安装好server之后可以直接一键启动，启动成功后也可以使用浏览器<a href=\"http://localhost:7474进行连接，也可以使用客户端连接，很方便。\">http://localhost:7474进行连接，也可以使用客户端连接，很方便。</a><br />\n<img src=\"https://img-blog.csdnimg.cn/6d3448532aa04c9797e3eaf2d393b574.png\" alt=\"在这里插入图片描述\" /><br />\n基础工作完成之后，我们开始命令CQL语句的学习。</p>\n<h1 id=\"三neo4j-cypher-语言\">三：Neo4j Cypher 语言</h1>\n<p>到这里还是先学习一下Neo4j的数据模型再写CQL吧。</p>\n<h2 id=\"neo4j数据模型\">Neo4j数据模型</h2>\n<p>Neo4j是一个表示关系连接的图数据库，既然是图，那么必然有节点，和连接两个节点之间的关系组成。每个节点相当于一个实体，每个实体都有构成它的属性。<br />\n比如刘备和关羽，刘备和关羽都是一个个的实体，都可以称作为一个<strong>节点</strong>，他们有一个共同的<strong>标签</strong>：都是人，。他们之间的<strong>关系</strong>为：兄弟，刘备的<strong>属性</strong>是仁义、大耳贼、汉皇后裔等等。关羽的属性有：勇猛、忠义等等。<br />\n<img src=\"https://img-blog.csdnimg.cn/aa0d3d63b3eb45da93446c2dda76fced.png\" alt=\"在这里插入图片描述\" /><br />\n在Neo4j中，数据模型的主要构建块是：</p>\n<ul>\n<li>节点</li>\n<li>关系</li>\n<li>属性</li>\n<li>标签</li>\n</ul>\n<h3 id=\"节点\">节点</h3>\n<p>节点（Node)是图数据库中的一个基本元素，用来表示一个实体记录，就像关系数据库中的一条记录一 样。在Neo4j中节点可以包含多个属性(Property)和多个标签(Label)。</p>\n<ul>\n<li>节点是主要的数据元素，节点通过<strong>关系</strong>连接到其他节点</li>\n<li>节点可以具有一个或多个<strong>属性</strong>（即，存储为键/值对的属性）</li>\n<li>节点有一个或多个<strong>标签</strong>，用于描述其在图表中的作用</li>\n</ul>\n<h3 id=\"属性\">属性</h3>\n<p>属性（Property）是用于描述图节点和关系的<strong>键值对</strong>。其中Key是一个字符串，值可以通过使用任何 Neo4j数据类型来表示</p>\n<ul>\n<li>属性是命名值，其中名称（或键）是字符串</li>\n<li>属性可以被索引和约束 可以从多个属性创建复合索引</li>\n</ul>\n<h3 id=\"关系\">关系</h3>\n<p>关系（Relationship）同样是图数据库的基本元素。<br />\n当数据库中已经存在节点后，需要将节点连接起来构成图。<strong>关系就是用来连接两个节点</strong>，关系也称为图论的<strong>边</strong>(Edge) ,其始端和末端都必须是节点，关系不 能指向空也不能从空发起。关系和节点一样可以包含<strong>多个属性</strong>，但关系只能有<strong>一个类型(Type)</strong> 。</p>\n<ul>\n<li>关系连接两个节点</li>\n<li>关系是方向性的</li>\n<li>节点可以有多个甚至递归的关系</li>\n<li>关系可以有一个或多个属性（即存储为键/值对的属性）</li>\n</ul>\n<p>基于方向性，Neo4j关系被分为两种主要类型：</p>\n<ul>\n<li>单向关系</li>\n<li>双向关系</li>\n</ul>\n<h3 id=\"标签\">标签</h3>\n<p>标签（Label）将一个公共名称与一组节点或关系相关联， 节点或关系可以包含一个或多个标签。 我们可以为现有节点或关系创建新标签， 我们可以从现有节点或关系中删除标签。</p>\n<ul>\n<li>标签用于将<strong>节点</strong>分组</li>\n<li>一个节点可以具有多个标签</li>\n<li>对标签进行索引以加速在图中查找节点</li>\n<li>本机标签索引针对速度进行了优化</li>\n</ul>\n<h2 id=\"cypher-语言\">Cypher 语言</h2>\n<p>Neo4j的<strong>Cypher</strong>语言是为处理图形数据而构建的，CQL代表Cypher查询语言。像Oracle数据库具有查询 语言SQL，Neo4j具有CQL作为查询语言。</p>\n<ul>\n<li>它是Neo4j图形数据库的查询语言。</li>\n<li>它是一种声明性模式匹配语言</li>\n<li>它遵循SQL语法。</li>\n<li>它的语法是非常简单且人性化可读的格式。</li>\n</ul>\n<table>\n<thead>\n<tr><th>CQL命令</th><th>用法</th></tr>\n</thead>\n<tbody>\n<tr><td>CREATE</td><td>创建节点，关系和属性</td></tr>\n<tr><td>MATCH</td><td>检索有关节点，关系和属性数据</td></tr>\n<tr><td>RETURN</td><td>返回查询结果</td></tr>\n<tr><td>WHERE</td><td>提供条件过滤检索数据</td></tr>\n<tr><td>DELETE</td><td>删除节点和关系</td></tr>\n<tr><td>REMOVE</td><td>删除节点和关系的属性</td></tr>\n<tr><td>ORDER BY</td><td>排序检索数据</td></tr>\n<tr><td>SET</td><td>添加或更新标签</td></tr>\n</tbody>\n</table>\n<p>官方文档命令说明：<a href=\"https://neo4j.com/docs/cypher-manual/3.5/clauses/\">https://neo4j.com/docs/cypher-manual/3.5/clauses/</a></p>\n<h2 id=\"cql命令实战\">CQL命令实战</h2>\n<p>直接看Cypher的语法会非常枯燥，本文通过一个实际的案例来一步一步学习如何使用Cypher来操作Neo4J。</p>\n<ul>\n<li>1、创建节点</li>\n</ul>\n<pre><code>#创建简单节点\ncreate (n)\n#创建多个节点\ncreate (n),(m)\n#创建带标签和属性的人物节点并返回节点\ncreate (n:Person {name:\'刘备\'}) return n\n</code></pre>\n<p>CREATE是创建操作，n是节点，Person是<strong>标签</strong>，代表节点的类型。花括号{}代表节点的<strong>属性</strong>，属性类似Python的字典。这条语句的含义就是创建一个标签为Person的节点，该节点具有一个name属性，属性值是刘备。return n 就是返回当前节点的值</p>\n<p>如图所示，在Neo4J的界面上可以看到创建成功的节点。<br />\n<img src=\"https://img-blog.csdnimg.cn/d6574e633b5245b58ca1d1c7688aba7f.png\" alt=\"在这里插入图片描述\" /><br />\n我们继续来创建三国更多的人物节点，并分别命名：</p>\n<pre><code class=\"language-powershell\">create (country:shu { name:\'刘备\'});\ncreate (country:shu { name:\'关羽\'});\ncreate (country:shu { name:\'张飞\'});\ncreate (country:shu { name:\'诸葛亮\'});\ncreate (country:shu { name:\'张苞\'});\ncreate (country:shu { name:\'关平\'});\ncreate (country:shu { name:\'关兴\'});\ncreate (country:shu { name:\'韩遂\'});\ncreate (country:shu { name:\'黄承彦\'});\ncreate (country:shu { name:\'黄月英\'});\ncreate (country:shu { name:\'黄忠\'});\ncreate (country:shu { name:\'姜维\'});\ncreate (country:shu { name:\'刘禅\'});\ncreate (country:shu { name:\'刘启\'});\ncreate (country:shu { name:\'刘胜\'});\ncreate (country:shu { name:\'刘协\'});\ncreate (country:shu { name:\'马超\'});\ncreate (country:shu { name:\'马良\'});\ncreate (country:shu { name:\'马谡\'});\ncreate (country:shu { name:\'马腾\'});\ncreate (country:shu { name:\'孟获\'});\ncreate (country:shu { name:\'糜芳\'});\ncreate (country:shu { name:\'糜夫人\'});\ncreate (country:shu { name:\'庞统\'});\ncreate (country:shu { name:\'孙尚香\'});\ncreate (country:shu { name:\'魏延\'});\ncreate (country:shu { name:\'赵云\'});\ncreate (country:shu { name:\'诸葛瑾\'});\n\ncreate (country:wei { name:\'曹操\'});\ncreate (country:wei { name:\'曹植\'});\ncreate (country:wei { name:\'曹丕\'});\n\ncreate (country:wu { name:\'孙策\'});\ncreate (country:wu { name:\'孙权\'});\ncreate (country:wu { name:\'周瑜\'});\n\n</code></pre>\n<p>查看刚创建的这些节点信息</p>\n<pre><code>match(n) return n\n</code></pre>\n<p>这里，MATCH是匹配操作，而小括号()代表一个<strong>节点</strong> node（可理解为括号类似一个圆形），括号里面的n为 <strong>标识符</strong> 。<br />\n这里为便于直观感受先使用基本的查询语句，后面再详细讲解。</p>\n<p>Neo4J贴心地使用不用的颜色来表示不同类型的节点。<br />\n<img src=\"https://img-blog.csdnimg.cn/0305af3bfb01455c9ebe5f7be262b963.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>接下来创建关系</li>\n</ul>\n<pre><code class=\"language-powershell\">MATCH (a:shu {name:\'刘备\'}), \n      (b:shu {name:\'关羽\'}) \nMERGE (a)-[:大哥]-&gt;(b)\n</code></pre>\n<p>这里的方括号[]即为关系，大哥为关系的类型。注意这里的箭头--&gt;是有方向的，表示是从a到b的关系。 如图，刘备和关羽之间建立了大哥关系，</p>\n<p>再使用这个命令查看我们刚才创建的关系，通过Neo4J的可视化很明显的可以看出：</p>\n<pre><code>match(n) return n\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/d18f4e5e644740688f6cae55c9146157.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>关系也可以增加属性</li>\n</ul>\n<pre><code>MATCH (a:shu {name:\'刘备\'}), \n      (b:shu {name:\'张飞\'}) \nMERGE (a)-[:大哥  {since:&quot;桃园结义&quot;}]-&gt;(b)\n</code></pre>\n<p>在关系中，同样的使用花括号{}来增加关系的属性，也是类似Python的字典，这里给大哥关系增加了since属性，属性值为“桃园结义”，表示他们建立兄弟关系的时间。<br />\n<img src=\"https://img-blog.csdnimg.cn/aa11b583f7774313ad347070d08e2a52.png\" alt=\"在这里插入图片描述\" /><br />\n-接下来增加更多的关系</p>\n<pre><code>match (p1:shu {name:\'刘备\'}),(p2:shu{name:\'关羽\'}) create (p1)- [r:rel {relation:\'结义兄弟\'}]-&gt;(p2);\nmatch (p1:shu {name:\'刘备\'}),(p2:shu{name:\'张飞\'}) create (p1)- [r:rel {relation:\'结义兄弟\'}]-&gt;(p2);\nmatch (p1:shu {name:\'刘备\'}),(p2:shu{name:\'马超\'}) create (p1)- [r:rel {relation:\'主公\'}]-&gt;(p2);\nmatch (p1:shu {name:\'刘备\'}),(p2:shu{name:\'庞统\'}) create (p1)- [r:rel {relation:\'主公\'}]-&gt;(p2);\nmatch (p1:shu {name:\'刘备\'}),(p2:shu{name:\'黄忠\'}) create (p1)- [r:rel {relation:\'主公\'}]-&gt;(p2);\nmatch (p1:shu {name:\'刘备\'}),(p2:shu{name:\'赵云\'}) create (p1)- [r:rel {relation:\'主公\'}]-&gt;(p2);\nmatch (p1:shu {name:\'刘备\'}),(p2:shu{name:\'魏延\'}) create (p1)- [r:rel {relation:\'主公\'}]-&gt;(p2);\nmatch (p1:shu {name:\'刘备\'}),(p2:shu{name:\'法正\'}) create (p1)- [r:rel {relation:\'主公\'}]-&gt;(p2);\nmatch (p1:shu {name:\'刘备\'}),(p2:shu{name:\'糜芳\'}) create (p1)- [r:rel {relation:\'主公\'}]-&gt;(p2);\nmatch (p1:shu {name:\'甘夫人\'}),(p2:shu{name:\'刘备\'}) create (p1)- [r:rel {relation:\'妻\'}]-&gt;(p2);\nmatch (p1:shu {name:\'糜夫人\'}),(p2:shu{name:\'刘备\'}) create (p1)- [r:rel {relation:\'次妻\'}]-&gt;(p2);\nmatch (p1:shu {name:\'孙尚香\'}),(p2:shu{name:\'刘备\'}) create (p1)- [r:rel {relation:\'妻\'}]-&gt;(p2);\nmatch (p1:shu {name:\'关羽\'}),(p2:shu{name:\'关兴\'}) create (p1)- [r:rel {relation:\'父子\'}]-&gt;(p2);\nmatch (p1:shu {name:\'关平\'}),(p2:shu{name:\'关羽\'}) create (p1)- [r:rel {relation:\'义子\'}]-&gt;(p2);\nmatch (p1:shu {name:\'张飞\'}),(p2:shu{name:\'张苞\'}) create (p1)- [r:rel {relation:\'父子\'}]-&gt;(p2);\nmatch (p1:shu {name:\'马腾\'}),(p2:shu{name:\'马超\'}) create (p1)- [r:rel {relation:\'父子\'}]-&gt;(p2);\nmatch (p1:shu {name:\'马腾\'}),(p2:shu{name:\'韩遂\'}) create (p1)- [r:rel {relation:\'异性兄弟\'}]-&gt;(p2);\nmatch (p1:shu {name:\'马谡\'}),(p2:shu{name:\'马良\'}) create (p1)- [r:rel {relation:\'弟弟\'}]-&gt;(p2);\nmatch (p1:shu {name:\'糜芳\'}),(p2:shu{name:\'糜夫人\'}) create (p1)- [r:rel {relation:\'兄妹\'}]-&gt;(p2);\nmatch (p1:shu {name:\'刘备\'}),(p2:shu{name:\'诸葛亮\'}) create (p1)- [r:rel {relation:\'主公\'}]-&gt;(p2);\nmatch (p1:shu {name:\'黄月英\'}),(p2:shu{name:\'诸葛亮\'}) create (p1)- [r:rel {relation:\'妻\'}]-&gt;(p2);\nmatch (p1:shu {name:\'黄承彦\'}),(p2:shu{name:\'黄月英\'}) create (p1)- [r:rel {relation:\'父女\'}]-&gt;(p2);\nmatch (p1:shu {name:\'姜维\'}),(p2:shu{name:\'诸葛亮\'}) create (p1)- [r:rel {relation:\'弟子\'}]-&gt;(p2);\nmatch (p1:shu {name:\'诸葛亮\'}),(p2:shu{name:\'诸葛瑾\'}) create (p1)- [r:rel {relation:\'兄弟\'}]-&gt;(p2);\nmatch (p1:shu {name:\'诸葛亮\'}),(p2:shu{name:\'诸葛瞻\'}) create (p1)- [r:rel {relation:\'父子\'}]-&gt;(p2);\nmatch (p1:shu {name:\'刘备\'}),(p2:shu{name:\'刘禅\'}) create (p1)- [r:rel {relation:\'父子\'}]-&gt;(p2);\nmatch (p1:shu {name:\'甘夫人\'}),(p2:shu{name:\'刘禅\'}) create (p1)- [r:rel {relation:\'母子\'}]-&gt;(p2);\nmatch (p1:shu {name:\'刘禅\'}),(p2:shu{name:\'姜维\'}) create (p1)- [r:rel {relation:\'主公\'}]-&gt;(p2);\nmatch (p1:shu {name:\'诸葛瞻\'}),(p2:shu{name:\'刘禅\'}) create (p1)- [r:rel {relation:\'女婿\'}]-&gt;(p2);\nmatch (p1:shu {name:\'刘备\'}),(p2:shu{name:\'刘胜\'}) create (p1)- [r:rel {relation:\'后代\'}]-&gt;(p2);\nmatch (p1:shu {name:\'刘胜\'}),(p2:shu{name:\'刘启\'}) create (p1)- [r:rel {relation:\'父子\'}]-&gt;(p2);\nmatch (p1:shu {name:\'刘启\'}),(p2:shu{name:\'刘辩\'}) create (p1)- [r:rel {relation:\'宗亲\'}]-&gt;(p2);\nmatch (p1:shu {name:\'刘辩\'}),(p2:shu{name:\'刘协\'}) create (p1)- [r:rel {relation:\'让位\'}]-&gt;(p2);\n\nMATCH (p1:wei {name:\'曹植\'}), (p2:wei {name:\'曹操\'}) MERGE (p1)-[:儿子]-&gt;(p2);\nMATCH (p1:wei {name:\'曹丕\'}), (p2:wei {name:\'曹操\'}) MERGE (p1)-[:儿子]-&gt;(p2);\nMATCH (p1:wei {name:\'曹操\'}), (p2:wei {name:\'曹丕\'}) MERGE (p1)-[:父亲]-&gt;(p2);\nMATCH (p1:wei {name:\'曹操\'}), (p2:wei {name:\'曹植\'}) MERGE (p1)-[:父亲]-&gt;(p2);\n\nMATCH (p1:wu {name:\'孙策\'}), (p2:wu {name:\'孙权\'}) MERGE (p1)-[:弟弟  {type:&quot;亲情&quot;}]-&gt;(p2);\nMATCH (p1:wu {name:\'孙权\'}), (p2:wu {name:\'孙策\'}) MERGE (p1)-[:哥哥  {type:&quot;亲情&quot;}]-&gt;(p2)\nMATCH (p1:wu {name:\'周瑜\'}), (p2:wu {name:\'孙策\'}) MERGE (p1)-[:主公  {type:&quot;主从&quot;}]-&gt;(p2);\n\n</code></pre>\n<p>将上面生成的节点和关系语句在neo4j中执行，就可以了。然后查询，就可以看到效果图了,<br />\n有点图谱的意思了吧？<br />\n<img src=\"https://img-blog.csdnimg.cn/fe12bcb924f6407caa930367235b1dad.png\" alt=\"在这里插入图片描述\" /></p>\n<p>篇幅太长了，剩下的详细查询方法，更新，删除，等另起一篇文章写。<br />\n拜拜~</p>\n', 1, '', 0, 0, 1, '2022-07-22 10:47:50', '2022-07-22 10:47:50');
INSERT INTO `tb_article` VALUES (271, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7638', 'A001-消息队列客户端V1.0.0-MQTT技术预研', '<p>| --- | --- | --- |<br />\n| <strong>更新日期</strong> | 2022年04月13日 | <strong>作        者</strong> | 张留杨 |<br />\n| <strong>保密等级</strong> | C | <strong>开放范围</strong> | 研发测试部 |</p>\n<p><strong>版本历史</strong></p>\n<table>\n<thead>\n<tr><th><strong>版        本</strong></th><th><strong>更新日期</strong></th><th><strong>作        者</strong></th><th><strong>备注</strong></th></tr>\n</thead>\n<tbody>\n<tr><td>1.0.0</td><td>2022年04月13日</td><td>张留杨</td><td>新建文档</td></tr>\n<tr><td> </td><td> </td><td> </td><td> </td></tr>\n</tbody>\n</table>\n<p><a name=\"AAFKl\"></a></p>\n<h2 id=\"1-mqtt简介\">1. MQTT简介</h2>\n<p><code>MQTT</code>（<code>MessageQueuingTelemetryTransport</code>，消息队列遥测传输协议）是一种基于发布/订阅（<code>publish</code>/<code>subscribe</code>）模式的“轻量级”通讯协议，该协议构建于<code>TCP/IP</code>协议上，由IBM在1999年发布。<br />MQTT最大优点在于，作为一种低开销、低带宽占用的即时通讯协议，<strong>可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务</strong>。使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p>\n<blockquote>\n<p><code>TCP/IP</code>参考模型可以分为四层：应用层、传输层、网络层、链路层。<code>TCP</code>和<code>UDP</code>位于传输层，应用层常见的协议有<code>HTTP</code>、<code>FTP</code>、<code>SSH</code>等。<code>**MQTT**</code><strong>协议运行于</strong><code>**TCP**</code>**之上，属于应用层协议，**因此只要是支持<code>TCP/IP</code>协议栈的地方，都可以使用<code>MQTT</code>。</p>\n</blockquote>\n<p><a name=\"OsNP2\"></a></p>\n<h2 id=\"2-mqtt特性\">2. MQTT特性</h2>\n<ul>\n<li>使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合；</li>\n<li>对负载内容屏蔽的消息传输；</li>\n<li>使用<code>TCP/IP</code>提供网络连接；</li>\n<li>小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量；</li>\n<li>使用<code>LastWill</code>和<code>Testament</code>特性（最后遗嘱）通知有关各方客户端异常中断的机制。<br />\n<a name=\"GDjPd\"></a></li>\n</ul>\n<h2 id=\"3-mqtt术语\">3. MQTT术语</h2>\n<p><a name=\"OlGfa\"></a></p>\n<h3 id=\"31-应用消息applicationmessage\">3.1 应用消息<code>ApplicationMessage</code></h3>\n<ul>\n<li><code>MQTT</code>协议通过网络传输应用数据；</li>\n<li>应用消息通过<code>MQTT</code>传输时，它们有关联的服务质量（<code>QoS</code>）和主题（<code>Topic</code>）。<br />\n<a name=\"HaivK\"></a></li>\n</ul>\n<h3 id=\"32-客户端client\">3.2 客户端<code>Client</code></h3>\n<p>使用<code>MQTT</code>的程序或设备。客户端总是通过网络连接到服务端。它可以：</p>\n<ul>\n<li>发布应用消息给其它相关的客户端；</li>\n<li>订阅以请求接受相关的应用消息；</li>\n<li>取消订阅以移除接受应用消息的请求；</li>\n<li>从服务端断开连接。<br />\n<a name=\"C429T\"></a></li>\n</ul>\n<h3 id=\"33-服务端server\">3.3 服务端<code>Server</code></h3>\n<p>一个程序或设备，作为发送消息的客户端和请求订阅的客户端之间的中介。它可以：</p>\n<ul>\n<li>服务端接受来自客户端的网络连接；</li>\n<li>接受客户端发布的应用消息；</li>\n<li>处理客户端的订阅和取消订阅请求；</li>\n<li>转发应用消息给符合条件的已订阅客户端。<br />\n<a name=\"VFTs7\"></a></li>\n</ul>\n<h3 id=\"34-订阅subscription\">3.4 订阅<code>Subscription</code></h3>\n<ul>\n<li>订阅包含一个主题过滤器（<code>TopicFilter</code>）和一个最大的服务质量（<code>QoS</code>）等级；</li>\n<li>订阅与单个会话（<code>Session</code>）关联；</li>\n<li>会话可以包含多于一个的订阅。会话的每个订阅都有一个不同的主题过滤器。<br />\n<a name=\"Zco3s\"></a></li>\n</ul>\n<h3 id=\"35-主题名topicname\">3.5 主题名<code>TopicName</code></h3>\n<ul>\n<li>附加在应用消息上的一个标签，服务端已知且与订阅匹配；</li>\n<li>服务端发送应用消息的一个副本给每一个匹配的客户端订阅。<br />\n<a name=\"hTgTD\"></a></li>\n</ul>\n<h3 id=\"36-主题过滤器topicfilter\">3.6 主题过滤器<code>TopicFilter</code></h3>\n<ul>\n<li>订阅中包含的一个表达式，用于表示相关的一个或多个主题；</li>\n<li>主题过滤器可以使用通配符。<br />\n<a name=\"BqggD\"></a></li>\n</ul>\n<h3 id=\"37-会话session\">3.7 会话<code>Session</code></h3>\n<ul>\n<li>客户端和服务端之间的状态交互；</li>\n<li>一些会话持续时长与网络连接一样，另一些可以在客户端和服务端的多个连续网络连接间扩展。<br />\n<a name=\"hvOVw\"></a></li>\n</ul>\n<h3 id=\"38-控制报文mqttcontrolpacket\">3.8 控制报文<code>MQTTControlPacket</code></h3>\n<ul>\n<li>通过网络连接发送的信息数据包；</li>\n<li><code>MQTT</code>规范定义了十四种不同类型的控制报文，其中一个（<code>PUBLISH</code>报文）用于传输应用消息。<br />\n<a name=\"tlXSd\"></a></li>\n</ul>\n<h2 id=\"4-什么是主题\">4. 什么是主题</h2>\n<p><code>MQTT</code>协议通过网络传输应用消息，应用消息通过<code>MQTT</code>传输时，它们有关联的服务质量（<code>QoS</code>）和主题（<code>Topic</code>）。主题本质上是一个字符串，<code>MQTT</code>协议规定主题是<code>UTF-8</code>编码的字符串，这意味着，主题过滤器和主题名的比较可以通过比较编码后的<code>UTF-8</code>字节或解码后的<code>Unicode</code>字符。<br />\n<a name=\"C6KM0\"></a></p>\n<h3 id=\"41-主题名和主题过滤器\">4.1 主题名和主题过滤器</h3>\n<p><a name=\"pndec\"></a></p>\n<h4 id=\"411-主题名\">4.1.1 主题名</h4>\n<ul>\n<li>附加在应用消息上的一个标签，服务端已知且与订阅匹配。</li>\n<li>服务端发送应用消息的一个副本给每一个匹配的客户端订阅。<br />\n<a name=\"m0o3S\"></a></li>\n</ul>\n<h4 id=\"412-主题过滤器\">4.1.2 主题过滤器</h4>\n<ul>\n<li>订阅中包含的一个表达式，用于表示相关的一个或多个主题。主题过滤器可以使用通配符。</li>\n<li>如果订阅的主题过滤器与消息的主题名匹配，应用消息会被发送给每一个匹配的客户端订阅。</li>\n<li>主题资源可以是管理员在服务端预先定义好的，也可以是服务端收到第一个订阅或使用那个主题名的应用消息时动态添加的。</li>\n<li>服务端可以使用一个安全组件有选择地授权客户端使用某个主题资源。<br />\n<a name=\"yGSLd\"></a></li>\n</ul>\n<h3 id=\"42-主题和主题过滤器命名的规则\">4.2 主题和主题过滤器命名的规则</h3>\n<p><code>MQTT</code>协议中规定了主题是一段<code>UTF-8</code>编码的字符串，主题需要满足以下规则：</p>\n<ul>\n<li>所有的主题名和主题过滤器必须至少包含一个字符。</li>\n<li>主题名和主题过滤器是大小写敏感的。<code>ACCOUNTS</code>和<code>Accounts</code>是不同的主题名。</li>\n<li>主题名和主题过滤器可以包含空格字符。<code>Accountspayable</code>是合法的主题名</li>\n<li>主题名或主题过滤器以前置或后置斜杠<code>/</code>区分。<code>/finance</code>和<code>finance</code>是不同的。</li>\n<li>只包含斜杠<code>/</code>的主题名或主题过滤器是合法的。</li>\n<li>主题名和主题过滤器不能包含<code>null</code>字符(<code>UnicodeU+0000</code>)。</li>\n<li>主题名和主题过滤器是<code>UTF-8</code>编码字符串，除了不能超过<code>UTF-8</code>编码字符串的长度限制之外，主题名或主题过滤器的层级数量没有其它限制。<br />\n<a name=\"c6T7x\"></a></li>\n</ul>\n<h3 id=\"43-主题层级\">4.3 主题层级</h3>\n<p><a name=\"lgmbP\"></a></p>\n<h4 id=\"431-主题层级分隔符\">4.3.1 主题层级分隔符</h4>\n<p>斜杠（<code>“/”U+002F</code>）用于分割主题的每个层级，为主题名提供一个分层结构。分隔符用于将结构化引入主题名。如果存在分隔符，它将主题名分割为多个主题层级，是消息主题层级设计中很重要的符号。比方说：<code>aaa/bbb</code>、<code>aaa/bbb/ccc</code>和<code>aaa/bbb/ccc/ddd</code>这样的消息主题格式，是一个层层递进的关系，可通过多层通配符同时匹配两者，或者单层通配符只匹配一个。这在现实场景中，可以应用到：公司的部门层级推送、国家城市层级推送等包含层级关系的场景。<br /><code>MQTT</code>订阅报文包含一个主题过滤器（<code>TopicFilter</code>）和一个最大的服务质量（<code>QoS</code>）等级。订阅的主题过滤器可以包含特殊的通配符，允许客户端一次订阅多个主题。当客户端订阅指定的主题过滤器包含两种通配符时，主题层级分隔符就很有用了。主题层级分隔符可以出现在主题过滤器或主题名字的任何位置。相邻的主题层次分隔符表示一个零长度的主题层级。</p>\n<blockquote>\n<p>主题过滤器中可以使用通配符，但是主题名不能使用通配符。单层通配符和多层通配符只能用于订阅(<code>subscribe</code>)消息而不能用于发布(<code>publish</code>)消息，层级分隔符两种情况下均可使用。</p>\n</blockquote>\n<p><a name=\"uk0f5\"></a></p>\n<h4 id=\"432-多层通配符\">4.3.2 多层通配符</h4>\n<p>井字符号（<code>“#”U+0023</code>）是用于匹配主题中任意层级的通配符。多层通配符表示它的父级和任意数量的子层级。</p>\n<p>例如，如果客户端订阅主题<code>sport/tennis/player1/#</code>，它会收到使用下列主题名发布的消息：</p>\n<ul>\n<li><code>sport/tennis/player1</code></li>\n<li><code>sport/tennis/player1/ranking</code></li>\n<li><code>sport/tennis/player1/score/wimbledon</code></li>\n</ul>\n<p>因为多层通配符包括它自己的父级，所以<code>sport/#</code>也匹配单独的<code>sport</code>主题名，<code>sport/tennis/player1/#</code>也可以匹配<code>sport/tennis/player1</code>。</p>\n<p>单独的多层通配符<code>#</code>是有效的，它会收到所有的应用消息。</p>\n<p>多层通配符必须单独指定，或者跟在主题层级分隔符后面。多层通配符必须是主题过滤器的最后一个字符。因此，<code>sport/tennis#</code>和<code>sport/tennis/#/ranking</code>都是无效的多层通配符。<br />\n<a name=\"r9qtl\"></a></p>\n<h4 id=\"433-单层通配符\">4.3.3 单层通配符</h4>\n<p>加号(<code>“+”U+002B</code>)是只能用于单个主题层级匹配的通配符。例如，<code>sport/tennis/</code>+匹配<code>sport/tennis/player1</code>和<code>sport/tennis/player2</code>，但是不匹配<code>sport/tennis/player1/ranking</code>。同时，由于单层通配符只能匹配一个层级，<code>sport/</code>+不匹配<code>sport</code>但是却匹配<code>sport/</code>。</p>\n<p>在主题过滤器的任意层级都可以使用单层通配符，包括第一个和最后一个层级，可以在主题过滤器中的多个层级中使用它，也可以和多层通配符一起使用，<code>+</code>、<code>+/tennis/#</code>、<code>sport/+/player1</code>都有有效的。在使用单层通配符时，单层通配符占据过滤器的整个层级，<code>sport+</code>是无效的。</p>\n<p><a name=\"JS1jZ\"></a></p>\n<h4 id=\"434-以开头的主题\">4.3.4 以<code>\\$</code>开头的主题</h4>\n<p>服务端不能将<code>$</code>字符开头的主题名匹配通配符（<code>#</code>或``+）开头的主题过滤器，订阅<code>#</code>的客户端不会收到任何发布到以<code>$</code>开头主题的消息，订阅<code>+/monitor/Clients</code>的客户端也不会收到任何发布到<code>$SYS/monitor/Clients</code>的消息。服务端应该阻止客户端使用这种主题名与其他客户端交换消息，客户端注意不能使用<code>$</code>字符开头的主题。</p>\n<p>服务端实现可以将<code>$</code>开头的主题名用作其他目的。,例如<code>$SYS/</code>被广泛用作包含服务器特定信息或控制接口的主题的前缀。订阅<code>$SYS/#</code>的客户端会收到发布到以<code>$SYS/</code>开头主题的消息，订阅<code>$SYS/monitor/+</code>的客户端会收到发布到<code>$SYS/monitor/Clients</code>主题的消息，如果客户端想同时接受以<code>$SYS/</code>开头主题的消息和不以$开头主题的消息，它需要同时订阅<code>#</code>和<code>$SYS/#</code>。</p>\n<p><a name=\"wlFGn\"></a></p>\n<h4 id=\"435-举个例子\">4.3.5 举个例子</h4>\n<p>比如我们用传感器监视家里的卧室、客厅以及厨房的温度、湿度和空气质量，可以设计一下几个主题：</p>\n<ul>\n<li><code>myhome/bedroom/temperature</code></li>\n<li><code>myhome/bedroom/humidity</code></li>\n<li><code>myhome/bedroom/airquality</code></li>\n<li><code>myhome/livingroom/temperature</code></li>\n<li><code>myhome/livingroom/humidity</code></li>\n<li><code>myhome/livingroom/airquality</code></li>\n<li><code>myhome/kitchen/temperature</code></li>\n<li><code>myhome/kitchen/humidity</code></li>\n<li><code>myhome/kitchen/airquality</code></li>\n</ul>\n<p>当我们想获取卧室的所有数据时，可以订阅<code>myhome/bedroom+</code>主题，当我们想获取三个房间的温度数据的时候，可以订阅<code>myhome/+/temperature</code>主题，当我们想获取所有的数据的时候，可以订阅<code>myhome/#</code>或者<code>#</code>。<br />\n<a name=\"bWtlN\"></a></p>\n<h2 id=\"5-消息服务质量\">5. 消息服务质量</h2>\n<p><a name=\"CrIs8\"></a></p>\n<h3 id=\"51-qos0\">5.1 <code>QoS0</code></h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1649828742946-96cfcab8-c1d6-4919-b222-81e66044639c.png#clientId=u3b1a1070-7237-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=385&amp;id=u7a3842dc&amp;name=image.png&amp;originHeight=770&amp;originWidth=1498&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=172692&amp;status=done&amp;style=none&amp;taskId=u215898d8-e6e6-497b-a045-c75071ece5d&amp;title=&amp;width=749\" alt=\"image.png\" /><br />**消息最多传递一次。**如果当时<code>MQTT</code>客户端不可用，则会丢失该消息。<br /><code>Sender</code>(可能是<code>Publisher</code>或者<code>Broker</code>)发送一条消息之后，就不再关心它有没有发送到对方，也不设置任何重发机制。消息发布完全依赖底层<code>TCP/IP</code>网络。<strong>会发生消息丢失。</strong><br />\n<a name=\"FMmvB\"></a></p>\n<h3 id=\"52-qos1\">5.2 <code>QoS1</code></h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1649828857476-ae2b94cd-2785-4a2b-8b57-c186178a2d11.png#clientId=u3b1a1070-7237-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=518&amp;id=ue23b2cdc&amp;name=image.png&amp;originHeight=1036&amp;originWidth=1496&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=270455&amp;status=done&amp;style=none&amp;taskId=u11e0b801-4869-48b0-b782-63aaa2c7301&amp;title=&amp;width=748\" alt=\"image.png\" /><br />**消息传递至少1次。**包含了简单的重发机制。<code>Sender</code>发送消息之后等待接收者的<code>ACK</code>，如果没收到<code>ACK</code>则重新发送消息。<strong>这种模式能保证消息至少能到达一次，但无法保证消息重复。</strong><br /><code>PUBACK</code>消息是对<code>QoS</code>级别为<code>1</code>的<code>PUBLISH</code>消息的响应。<code>PUBACK</code>消息由服务器发送以响应来自发布端的<code>PUBLISH</code>消息，或订阅端响应来自服务器的<code>PUBLISH</code>消息。当发布端收到<code>PUBACK</code>消息时，它会丢弃原始消息，因为它已被服务器接收（并记录）。如果一定时间内，发布端或服务器没有收到<code>PUBACK</code>消息，则会进行重发。<br />\n<a name=\"bB7xV\"></a></p>\n<h3 id=\"53-qos-2\">5.3 <code>QoS 2</code></h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1649828976155-92929034-61e9-4e02-807b-e42abb38bfe4.png#clientId=u3b1a1070-7237-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=621&amp;id=ub735dff6&amp;name=image.png&amp;originHeight=1242&amp;originWidth=1490&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=338702&amp;status=done&amp;style=none&amp;taskId=u368dd89b-fd2b-4862-9594-f95d5b0b3d8&amp;title=&amp;width=745\" alt=\"image.png\" /><br />**消息仅传送一次。**设计了重发和重复消息发现机制，<strong>保证消息到达对方并且严格只到达一次。</strong></p>\n<ul>\n<li><code>PUBREC</code>消息</li>\n</ul>\n<p>发布收到。是对<code>QoS</code>级别为<code>2</code>的<code>PUBLISH</code>消息的响应。它是<code>QoS</code>级别<code>2</code>协议流的第二个消息。<code>PUBREC</code>消息由服务器响应来自发布端的<code>PUBLISH</code>消息，或订阅端响应来自服务器的<code>PUBLISH</code>消息。发布端或服务器收到<code>PUBREC</code>消息时，会响应<code>PUBREL</code>消息。</p>\n<ul>\n<li><code>PUBREL</code>消息</li>\n</ul>\n<p>发布释放。是从发布端对<code>PUBREC</code>的响应，或从服务器对订阅端<code>PUBREC</code>消息的响应。这是<code>QoS</code>级别<code>2</code>协议流中第三个消息。当服务器从发布者收到<code>PUBREL</code>消息时，服务器会将<code>PUBLISH</code>消息发送到订阅端，并发送<code>PUBCOMP</code>消息到发布端。当订阅端收到来自服务器的消息<code>PUBREL</code>时，使得消息可用于应用程序并将<code>PUBCOMP</code>消息发送到服务器。</p>\n<ul>\n<li><code>PUBCOMP</code>消息</li>\n</ul>\n<p>发布完成。是服务器对来自发布端的<code>PUBREL</code>消息的响应，或订阅者对来自服务器的<code>PUBREL</code>消息的响应。它是<code>QoS</code>级别<code>2</code>协议流程中的第四个也是最后一个消息。当发布端收到<code>PUBCOMP</code>消息时，它会丢弃原始消息，因为它已经将消息发给了服务器。<br />\n<a name=\"GsByB\"></a></p>\n<h3 id=\"54-特别注意\">5.4 特别注意</h3>\n<p>需要注意的是<code>MQTT</code>发布与订阅操作中的<code>QoS</code>代表了不同的含义：</p>\n<ul>\n<li>发布时的<code>QoS</code>表示消息发送到<code>MQTT</code>服务器使用的<code>QoS</code>等级；</li>\n<li>订阅时的<code>QoS</code>表示<code>MQTTBroker</code>向自己转发消息时可以使用的最大<code>QoS</code>等级。</li>\n</ul>\n<p><strong>需要保障发送与订阅的</strong><code>**QoS**</code><strong>一致，才能确保最终收到的消息是固定的</strong><code>**QoS**</code><strong>等级</strong>，否则会出现消费降级的情况。例如：<code>A</code>发送的消息<code>QoS</code>为<code>2</code>，B订阅的消息<code>QoS</code>为<code>1</code>，则最终接收到消息的<code>QoS</code>为<code>1</code>。<br />\n<a name=\"zGDYh\"></a></p>\n<h2 id=\"6-保留消息和最后遗嘱\">6. 保留消息和最后遗嘱</h2>\n<p><a name=\"mxacK\"></a></p>\n<h3 id=\"61-保留消息\">6.1 保留消息</h3>\n<p><code>RetainedMessages</code>。<code>MQTT</code>中，无论是发布还是订阅都不会有任何触发事件。1个<code>Topic</code>只有唯一的<code>retain</code>消息，<code>Broker</code>会保存每个<code>Topic</code>的最后一条<code>retain</code>消息。发布消息时把<code>retain</code>设置为<code>true</code>，即为保留信息。每个<code>Client</code>订阅<code>Topic</code>后会立即读取到<code>retain</code>消息。如果需要删除<code>retain</code>消息，可以发布一个空的<code>retain</code>消息，因为每个新的<code>retain</code>消息都会覆盖最后一个<code>retain</code>消息。<br />\n<a name=\"HSAaV\"></a></p>\n<h3 id=\"62-最后遗嘱\">6.2 最后遗嘱</h3>\n<p><code>LastWill&amp;Testament</code>。<code>MQTT</code>本身就是为信号不稳定的网络设计的，所以难免一些客户端会无故的和<code>Broker</code>断开连接。当客户端连接到<code>Broker</code>时，可以指定<code>LWT</code>，<code>Broker</code>会定期检测客户端是否有异常。当客户端异常掉线时，<code>Broker</code>就往连接时指定的<code>Topic</code>里推送当时指定的<code>LWT</code>消息。</p>\n', 1, '', 0, 0, 1, '2022-08-05 13:41:23', '2022-08-09 10:20:35');
INSERT INTO `tb_article` VALUES (272, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5704', 'A001-物联网消息队列客户端V1.0.0-使用手册', '<p>| --- | --- | --- |<br />\n| <strong>更新日期</strong> | 2022年07月19日 | <strong>作        者</strong> | 张留杨 |<br />\n| <strong>保密等级</strong> | C | <strong>开放范围</strong> | 研发测试部 |</p>\n<p><strong>版本历史</strong></p>\n<table>\n<thead>\n<tr><th><strong>版        本</strong></th><th><strong>更新日期</strong></th><th><strong>作        者</strong></th><th><strong>备注</strong></th></tr>\n</thead>\n<tbody>\n<tr><td>1.0.0</td><td>2022年07月19日</td><td>张留杨</td><td>新建文档</td></tr>\n</tbody>\n</table>\n<p><a name=\"FEATURE\"></a></p>\n<h2 id=\"1-支持功能\">1. 支持功能</h2>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;支持自动配置</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;支持消息自动解析</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;支持消息分组共享订阅</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;支持消息不分组共享订阅</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;支持消息排它订阅</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;支持延时发布</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;支持多数据源<br />\n<a name=\"UPGRADE\"></a></li>\n</ul>\n<h2 id=\"2-版本记录\">2. 版本记录</h2>\n<ul>\n<li><code>1.0.0</code>\n<ul>\n<li>支持自动配置</li>\n<li>支持消息自动解析</li>\n<li>支持消息分组共享订阅</li>\n<li>支持消息不分组共享订阅</li>\n<li>支持消息排它订阅</li>\n<li>支持延时发布</li>\n<li>支持多数据源<br />\n<a name=\"g4zG5\"></a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-使用示例\">3. 使用示例</h2>\n<p><a href=\"https://git.ddysq.com/common/example/simple-example/-/tree/master/mqttclient-example\"><strong>mqttclient-example</strong></a><br />\n<a name=\"FASTSTART\"></a></p>\n<h2 id=\"4-快速开始\">4. 快速开始</h2>\n<p><a name=\"3a432485\"></a></p>\n<h3 id=\"41-引入依赖\">4.1 引入依赖</h3>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;com.dindo&lt;/groupId&gt;\n    &lt;artifactId&gt;mqtt-client&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p><a name=\"ed6e9acd\"></a></p>\n<h3 id=\"42-配置\">4.2 配置</h3>\n<pre><code class=\"language-yaml\">spring:\n  mqtt:\n    emq:\n      client:\n        # 多数据源客户端名称，默认default\n        default:\n          # broker地址\n          host: 116.255.133.244\n          # 端口\n          port: 31883\n          # 用户名\n          username: admin\n          # 密码\n          password: ddhl@2022\n</code></pre>\n<p>更多配置如下</p>\n<pre><code class=\"language-yaml\">spring:\n  mqtt:\n    emq:\n      client:\n        # 多数据源客户端名称，默认default\n        default:\n          # broker地址\n          host: 116.255.133.244\n          # 端口\n          port: 31883\n          # 用户名\n          username: admin\n          # 密码\n          password: ddhl@2022\n          # 客户端标识，需保持全局唯一\n          client-id: parking_server\n          # 是否清除session\n          clean-session: false\n          # 连接超时时间，单位秒\n          connection-timeout: 10\n          # 心跳间隔时间，单位秒\n          keep-alive-interval: 10\n          # 全局消息质量\n          global-qos: 1\n          # 重新连接之间等待的最长时间\n          maxReconnect-delay: 128000\n          # 是否自动重新连接\n          automatic-reconnect: true\n          # 最大消息并发数量，超过此数量并发时可能会丢消息\n          maxInflight: 1000\n</code></pre>\n<p><a name=\"6b9a2d1b\"></a></p>\n<h3 id=\"43-开启自动配置\">4.3 开启自动配置</h3>\n<p>在启动类上增加<code>@EnableRabbitMqAutoConfiguration</code>注解</p>\n<pre><code class=\"language-java\">import com.dindo.mqttclient.anno.EnableEmqAutoConfiguration;\n\n\n@SpringBootApplication\n@EnableEmqAutoConfiguration\npublic class TestApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(TestApplication.class, args);\n    }\n\n}\n</code></pre>\n<p><a name=\"8b7e3591\"></a></p>\n<h3 id=\"44-发布消息\">4.4 发布消息</h3>\n<p>在生产者的业务程序中，注入<code>MQTTClient</code></p>\n<pre><code class=\"language-java\">import com.dindo.mqttclient.MQTTClient;\n\n@Resource\nprivate MQTTClient defaultMQTTClient;\n</code></pre>\n<p>为了兼容第三方及优化内部使用逻辑，所以内置提供了两种消息发送方式。<br />\n<a name=\"glVxx\"></a></p>\n<h4 id=\"441-第三方消息发送\">4.4.1 第三方消息发送</h4>\n<pre><code class=\"language-java\">public String publishHeartbeatReply() {\n    HeartbeatReplyMessage heartbeatReplyMessage = new HeartbeatReplyMessage();\n    heartbeatReplyMessage.setCmd(32896);\n    heartbeatReplyMessage.setExpire(1605252875L);\n    heartbeatReplyMessage.setDevid(&quot;095437323930030130523933&quot;);\n    heartbeatReplyMessage.setServer_time(&quot;1605252875&quot;);\n\n    defaultMQTTClient.publish2ThirdParty(&quot;npt/park/type1/dev/095437323930030130523933&quot;, 1, heartbeatReplyMessage);\n\n    return &quot;success&quot;;\n}\n</code></pre>\n<p><a name=\"aYfMo\"></a></p>\n<h4 id=\"442-内部消息发送\">4.4.2 内部消息发送</h4>\n<p>消息实体实现<code>Message</code>接口</p>\n<pre><code class=\"language-java\">package com.example.test.message;\n\nimport com.dindo.mqttclient.MQTTMessage;\nimport lombok.Data;\n\nimport java.util.UUID;\n\n@Data\npublic class DindoMessage implements MQTTMessage {\n    \n    private String msgId = UUID.randomUUID().toString();\n    \n    private String name;\n    \n    private String gender;\n    \n    @Override\n    public String getMsgId() {\n        return this.msgId;\n    }\n    \n}\n</code></pre>\n<p>然后直接调用该类的<code>publish</code>方法发送即可</p>\n<pre><code class=\"language-java\">@GetMapping(&quot;dindo/publish&quot;)\npublic String dindoPublish() {\n    DindoMessage dindoMessage = new DindoMessage();\n    dindoMessage.setName(&quot;点都&quot;);\n    dindoMessage.setGender(&quot;xx&quot;);\n\n    defaultMQTTClient.publish(&quot;dindo/topic&quot;, dindoMessage);\n\n    return &quot;success&quot;;\n}\n</code></pre>\n<p>其中存在多个重载的方法。</p>\n<pre><code class=\"language-java\">package com.dindo.mqttclient;\n\nimport com.dindo.mqttclient.enums.ShareModelEnum;\nimport com.dindo.plugin.core.lang.json.JSONUtil;\nimport org.eclipse.paho.client.mqttv3.MqttMessage;\n\n/**\n * mqtt客户端\n *\n * @author zhangliuyang\n * @date 2022/07/18\n * @since 1.0.0\n */\npublic interface MQTTClient {\n\n    /**\n     * 启动客户端\n     */\n    void start();\n\n    /**\n     * 关闭客户端\n     */\n    void close();\n\n    /**\n     * 发布\n     *\n     * @param topic   主题\n     * @param message 消息\n     */\n    default &lt;T extends MQTTMessage&gt; void publish(String topic, T message) {\n        this.publish(topic, message, 1);\n    }\n\n    /**\n     * 发布\n     *\n     * @param topic   主题\n     * @param message 消息\n     * @param qos     消息质量\n     */\n    default &lt;T extends MQTTMessage&gt; void publish(String topic, T message, int qos) {\n        this.publish(topic, message, qos, 0);\n    }\n\n    /**\n     * 发布\n     *\n     * @param topic   主题\n     * @param message 消息\n     * @param qos     消息质量\n     * @param delay   延迟时间[unit:s, max:4294967s, condition: &gt; 0]\n     */\n    default &lt;T extends MQTTMessage&gt; void publish(String topic, T message, int qos, long delay) {\n        this.publish(topic, message, qos, delay, false);\n    }\n\n    /**\n     * 发布\n     *\n     * @param topic    主题\n     * @param message  消息\n     * @param qos      消息质量\n     * @param delay    延迟时间[unit:s, max:4294967s, condition: &gt; 0]\n     * @param retained 保留消息\n     */\n    default &lt;T extends MQTTMessage&gt; void publish(String topic, T message, int qos, long delay, boolean retained) {\n        MQTTMessageContext mqttMessageContext = new MQTTMessageContext();\n        mqttMessageContext.setId(message.getMsgId());\n        mqttMessageContext.setPayload(JSONUtil.write(message));\n        mqttMessageContext.setQos(qos);\n        mqttMessageContext.setDelay(delay);\n        mqttMessageContext.setRetained(retained);\n        mqttMessageContext.setTimestamp(System.currentTimeMillis());\n\n        this.publish(topic, mqttMessageContext);\n    }\n\n    /**\n     * 发布\n     *\n     * @param topic          主题\n     * @param messageContext 消息上下文\n     */\n    void publish(String topic, MQTTMessageContext messageContext);\n\n    /**\n     * 发送到第三方\n     *\n     * @param topic   主题\n     * @param message 消息\n     */\n    default void publish2ThirdParty(String topic, Object message) {\n        this.publish2ThirdParty(topic, 1, message);\n    }\n\n    /**\n     * 发送到第三方\n     *\n     * @param topic   主题\n     * @param qos     消息质量\n     * @param message 消息\n     */\n    default void publish2ThirdParty(String topic, int qos, Object message) {\n        this.publish2ThirdParty(topic, qos, message, Constant.DEFAULT_CHARSET.name());\n    }\n\n    /**\n     * 发送到第三方\n     *\n     * @param topic       主题\n     * @param qos         消息质量\n     * @param message     消息\n     * @param charsetName 字符集名称\n     */\n    default void publish2ThirdParty(String topic, int qos, Object message, String charsetName) {\n        this.publish2ThirdParty(topic, qos, message, charsetName, 0);\n    }\n\n    /**\n     * publish2第三方\n     *\n     * @param topic       主题\n     * @param qos         qos\n     * @param message     消息\n     * @param charsetName 字符集名称\n     * @param delay       延迟时间\n     */\n    default void publish2ThirdParty(String topic, int qos, Object message, String charsetName, long delay) {\n        this.publish2ThirdParty(topic, qos, message, charsetName, delay, false);\n    }\n\n    /**\n     * publish2第三方\n     *\n     * @param topic       主题\n     * @param qos         qos\n     * @param message     消息\n     * @param charsetName 字符集名称\n     * @param delay       延迟时间\n     * @param retained    是否保留消息\n     */\n    default void publish2ThirdParty(String topic, int qos, Object message, String charsetName, long delay, boolean retained) {\n        this.publish2ThirdParty(topic, qos, JSONUtil.toString(message).getBytes(charsetName), delay, retained);\n    }\n\n    /**\n     * 发送到第三方\n     *\n     * @param topic   主题\n     * @param payload 有效载荷\n     */\n    default void publish2ThirdParty(String topic, byte[] payload) {\n        this.publish2ThirdParty(topic, 1, payload, 0);\n    }\n\n    /**\n     * 发送到第三方\n     *\n     * @param topic   主题\n     * @param qos     消息质量\n     * @param payload 有效载荷\n     */\n    default void publish2ThirdParty(String topic, int qos, byte[] payload) {\n        this.publish2ThirdParty(topic, qos, payload, 0);\n    }\n\n    /**\n     * 发送到第三方\n     *\n     * @param topic   主题\n     * @param qos     消息质量\n     * @param payload 有效载荷\n     * @param delay   延迟时间\n     */\n    default void publish2ThirdParty(String topic, int qos, byte[] payload, long delay) {\n        this.publish2ThirdParty(topic, qos, payload, delay, false);\n    }\n\n    /**\n     * 发送到第三方\n     *\n     * @param topic    主题\n     * @param qos      消息质量\n     * @param payload  有效载荷\n     * @param delay    延迟时间\n     * @param retained 是否保留消息\n     */\n    default void publish2ThirdParty(String topic, int qos, byte[] payload, long delay, boolean retained) {\n        MqttMessage mqttMessage = new MqttMessage();\n        mqttMessage.setPayload(payload);\n        mqttMessage.setQos(qos);\n        mqttMessage.setRetained(retained);\n\n        this.publish2ThirdParty(topic, delay, mqttMessage);\n    }\n\n    /**\n     * 发送到第三方\n     *\n     * @param topic       主题\n     * @param mqttMessage mqtt消息\n     * @param delay       延迟时间\n     */\n    void publish2ThirdParty(String topic, long delay, MqttMessage mqttMessage);\n\n    /**\n     * 订阅\n     *\n     * @param topic          主题\n     * @param qos            消息质量\n     * @param shareModel     共享模型\n     * @param groupName      分组名称\n     * @param exclusive      排它\n     * @param messageHandler 消息处理程序\n     */\n    void subscribe(String topic, int qos, ShareModelEnum shareModel, String groupName, boolean exclusive, MessageHandler messageHandler);\n\n}\n</code></pre>\n<p><a name=\"7cd9bafb\"></a></p>\n<h3 id=\"45-接收消息\">4.5 接收消息</h3>\n<p>消费者需要在消息处理类上添加<code>@MQTTSubscriber(topics = {&quot;npt/park/type1/server/10010&quot;})</code>注解，指定要监听<code>topics</code>和客户端名称即可。如果没有显示的指定客户端名称，则使用<code>defaultMQTTClient</code>，使用<code>qos</code>执行订阅消息质量。<br />当消息处理类中有多个<code>public</code>方法时，需要<code>@MQTTConsumerMethod</code>标记具体消费方法</p>\n<pre><code class=\"language-java\">package com.example.test.handler;\n\nimport com.dindo.mqttclient.MessageHandler;\nimport com.dindo.mqttclient.anno.MQTTConsumerMethod;\nimport com.dindo.mqttclient.anno.MQTTSubscriber;\nimport com.dindo.mqttclient.enums.ShareModelEnum;\nimport com.dindo.plugin.core.lang.json.JSONUtil;\nimport com.example.test.message.DeviceStartMessage;\nimport com.example.test.message.PlateRecognitionReportMessage;\nimport lombok.extern.slf4j.Slf4j;\nimport org.eclipse.paho.client.mqttv3.MqttMessage;\n\nimport java.util.Map;\n\n\n@Slf4j\n@MQTTSubscriber(topics = ParkingMessageHandler.TOPIC, qos = 1, share = ShareModelEnum.GROUP_SHARE)\npublic class ParkingMessageHandler {\n\n    public static final String TOPIC = &quot;npt/park/type1/server/10010&quot;;\n\n    public static final String CMD_KEY = &quot;cmd&quot;;\n\n    @MQTTConsumerMethod\n    public void handle(Map&lt;String, Object&gt; message) {\n        log.info(&quot;handle:{}&quot;, message);\n        if (message.containsKey(CMD_KEY)) {\n            Integer cmd = (Integer) message.get(CMD_KEY);\n\n            switch (cmd) {\n                case 129:\n                    handleDeviceStartMessage(message);\n                    break;\n                case 140:\n                    handlePlateRecognitionReportMessage(message);\n                    break;\n                default:\n                    log.warn(&quot;不支持此cmd:[{}]&quot;, cmd);\n                    break;\n            }\n        } else {\n            log.warn(&quot;消息消费异常&quot;);\n        }\n    }\n\n    private void handleDeviceStartMessage(Map&lt;String, Object&gt; message) {\n        DeviceStartMessage deviceStartMessage = JSONUtil.toObject(JSONUtil.toString(message), DeviceStartMessage.class);\n        log.info(&quot;接收到设备启动消息:{}&quot;, deviceStartMessage);\n    }\n\n    private void handlePlateRecognitionReportMessage(Map&lt;String, Object&gt; message) {\n        PlateRecognitionReportMessage plateRecognitionReportMessage = JSONUtil.toObject(JSONUtil.toString(message), PlateRecognitionReportMessage.class);\n        log.info(&quot;接收到车牌上报识别消息:{}&quot;, plateRecognitionReportMessage);\n    }\n\n}\n</code></pre>\n<p><a name=\"c00d8d17\"></a></p>\n<h3 id=\"46-发送延迟消息\">4.6 发送延迟消息</h3>\n<p>要发送延迟消息，需要先开启<code>emq</code>延迟发布配置。<br />发送延时消息的方式相比之前，仅仅增加一个延时时间。其中延时时长的单位为<code>秒</code>，最大为<code>4294967</code>秒</p>\n<pre><code class=\"language-java\">//发送一个延时时长为10s的消息\ndefaultMQTTClient.publish2ThirdParty(&quot;npt/park/type1/dev/095437323930030130523933&quot;, 1, heartbeatReplyMessage, 10);\n</code></pre>\n<p><a name=\"mbY3o\"></a></p>\n<h3 id=\"47-多数据源\">4.7 多数据源</h3>\n<p>多数据源与单数据源配置属性相同，在配置文件中声明即可</p>\n<pre><code class=\"language-yaml\">spring:\n  mqtt:\n    emq:\n      client:\n        # 多数据源客户端名称，默认default\n        default:\n          # broker地址\n          host: 116.255.133.244\n          # 端口\n          port: 31883\n          # 用户名\n          username: admin\n          # 密码\n          password: ddhl@2022\n        # 多数据源客户端名称\n        parking:\n          # broker地址\n          host: 116.255.133.244\n          # 端口\n          port: 31883\n          # 用户名\n          username: admin\n          # 密码\n          password: ddhl@2022\n</code></pre>\n<p><a name=\"154067c4\"></a></p>\n<h4 id=\"471-发布消息\">4.7.1 发布消息</h4>\n<p>首先注入<code>MQTTClient</code>，与单数据源的唯一区别就是<code>bean</code>的名称。默认向<code>Spring</code>容器中添加的实现类名称为<code>“${数据源名称}MQTTClient”</code><br />以上面的配置文件为例，默认的<code>bean</code>名称为 <code>defaultMQTTClient</code> 和 <code>billMQTTClient</code></p>\n<pre><code class=\"language-java\">import com.dindo.mqttclient.MQTTClient;\n\n@Resource\nprivate MQTTClient defaultMQTTClient;\n\n@Resource\nprivate MQTTClient billMQTTClient;\n</code></pre>\n<p>其他操作同单数据源<br />\n<a name=\"6e3ee716\"></a></p>\n<h4 id=\"472-接收消息\">4.7.2 接收消息</h4>\n<p>接收消息与单数据源基本一致，唯一的区别是在<code>@MQTTSubscriber</code>中指定<code>clientName</code>属性，指定当前从哪个数据源进行消费。</p>\n<pre><code class=\"language-java\">import com.dindo.mqttclient.anno.MQTTSubscriber;\n\n@MQTTSubscriber(topics = {&quot;npt/park/type1/server/10010&quot;}, clientName = &quot;parking&quot;)\npublic class ParkingMessageHandler {}\n</code></pre>\n<p><a name=\"821f84c4\"></a></p>\n<h3 id=\"48-分组共享订阅\">4.8 分组共享订阅</h3>\n<p>系统默认使用<code>spring.application.name</code>作为分组名称，用户可在消息消费类上指定<code>@MQTTSubscriber</code>属性中<code>groupName = &quot;group_name&quot;</code>即可</p>\n<pre><code class=\"language-java\">import com.dindo.mqttclient.anno.MQTTSubscriber;\n\n@MQTTSubscriber(topics = ParkingMessageHandler.TOPIC, qos = 1, share = ShareModelEnum.GROUP_SHARE, groupName = &quot;group_name&quot;)\npublic class ParkingMessageHandler {}\n</code></pre>\n<p><a name=\"3ea986e3\"></a></p>\n<h3 id=\"49-不分组共享订阅\">4.9 不分组共享订阅</h3>\n<p>只需要在消息消费类上指定<code>@MQTTSubscriber</code>属性中<code>share = ShareModelEnum.UN_GROUP_SHARE</code>即可。</p>\n<pre><code class=\"language-java\">import com.dindo.mqttclient.anno.MQTTSubscriber;\n\n@MQTTSubscriber(topics = ParkingMessageHandler.TOPIC, qos = 1, share = ShareModelEnum.UN_GROUP_SHARE)\npublic class ParkingMessageHandler {}\n</code></pre>\n<p><a name=\"Ie5JJ\"></a></p>\n<h3 id=\"410-排它订阅\">4.10 排它订阅</h3>\n<p>只需要在消息消费类上指定<code>@MQTTSubscriber</code>属性中<code>exclusive = true</code>即可，开启排它订阅时，默认关闭共享订阅。</p>\n<pre><code class=\"language-java\">import com.dindo.mqttclient.anno.MQTTSubscriber;\n\n@MQTTSubscriber(topics = ParkingMessageHandler.TOPIC, qos = 1, exclusive = true)\npublic class ParkingMessageHandler {}\n</code></pre>\n', 1, '', 0, 0, 1, '2022-08-05 14:10:26', '2022-08-05 14:10:26');
INSERT INTO `tb_article` VALUES (273, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=331', 'A001-消息队列客户端V1.0.0-设计文档', '<p>| --- | --- | --- |<br />\n| <strong>更新日期</strong> | 2022年04月05日 | <strong>作        者</strong> | 张留杨 |<br />\n| <strong>保密等级</strong> | C | <strong>开放范围</strong> | 研发测试部 |</p>\n<p><strong>版本历史</strong></p>\n<table>\n<thead>\n<tr><th><strong>版        本</strong></th><th><strong>更新日期</strong></th><th><strong>作        者</strong></th><th><strong>备注</strong></th></tr>\n</thead>\n<tbody>\n<tr><td>1.0.0</td><td>2022年04月05日</td><td>张留杨</td><td>新建文档</td></tr>\n<tr><td><br /></td><td><br /></td><td><br /></td><td><br /></td></tr>\n</tbody>\n</table>\n<p><a name=\"lcaag\"></a></p>\n<h2 id=\"1-业务背景\">1. 业务背景</h2>\n<p>开发中经常需要用到定时任务，比如：</p>\n<ul>\n<li>当订单一直处于未支付状态时，如何及时的关闭订单，并退还库存？</li>\n<li>如何定期检查处于退款状态的订单是否已经退款成功？</li>\n</ul>\n<p>为了解决以上问题，最简单直接的办法就是定时去扫表。一般来说我们都是通过定时轮询查询数据库来判断是否有任务需要执行，也就是说不管怎么样，我们需要先查询数据库，而且有些任务对时间准确要求比较高的，需要每秒查询一次，对于系统小倒是无所谓，如果系统本身就大而且数据也多的情况下，这就不大现实了，所以需要选择其他方式，比如使用分布式任务调度，但也避免不了频繁的创建和删除任务。<br />因为我们项目中本身就使用到了<code>RabbitMQ</code>，所以基于方便开发和维护的原则，于是采用基于<code>RabbitMQ</code>的延迟队列来实现定时任务。<br />\n<a name=\"Nv3AQ\"></a></p>\n<h2 id=\"2-设计目标\">2. 设计目标</h2>\n<ul>\n<li>消息传输可靠性：消息进入到延迟队列后，保证至少被消费一次</li>\n<li>支持丰富：先支持<code>RabbitMQ</code>，后续可考虑支持<code>Kafka</code></li>\n<li>实时性：允许存在一定的时间误差</li>\n<li>消费方式：用户可以自定义消费方式</li>\n<li>消息推送方式：提供统一的API供调用</li>\n<li>延迟消息：可指定延迟时间进行消息消费</li>\n<li>多数据源：自定义数据源使用</li>\n<li>消息共享：多消费者共享消息消费<br />\n<a name=\"tBOJ1\"></a></li>\n</ul>\n<h2 id=\"3-设计要点\">3. 设计要点</h2>\n<p><a name=\"zODog\"></a></p>\n<h3 id=\"31-基本概念\">3.1 基本概念</h3>\n<ul>\n<li><code>topic</code></li>\n</ul>\n<p>消息类型，比如有一个名为<code>user-change</code>的<code>topic</code>，那么这个<code>topic</code>下的消息应该是与用户变更相关的</p>\n<ul>\n<li><code>queue</code></li>\n</ul>\n<p>队列，每一个消息处理器都会有一个队列</p>\n<ul>\n<li><code>bind</code></li>\n</ul>\n<p>绑定，比如说一个账单的服务，需要在用户信息变更时执行一些操作，于是，这个服务创建了一个<code>user-change</code>队列，然后告诉<code>MQ</code>当有<code>user-change</code>的消息时，请把消息给我放到<code>queue</code>中。这样，当用户中心的<code>user</code>发生变更时，便会在向<code>MQ</code>推送一条<code>topic</code>为<code>user-change</code>的消息，<code>MQ</code>则会将此消息交给账单服务的消息队列</p>\n<ul>\n<li><code>exchange</code></li>\n</ul>\n<p>交换机，生产者生产的消息到达的第一站，根据分发规则，匹配查询表中的<code>routing key</code>分发消息到消息队列中</p>\n<ul>\n<li><code>group</code></li>\n</ul>\n<p>消息组，同一服务集群内各个节点成为一组，默认使用<code>spring.application.name</code>作为组名</p>\n<ul>\n<li><code>share</code></li>\n</ul>\n<p>消息共享，同一消息组内是否共享消息<br />\n<a name=\"wMYLs\"></a></p>\n<h3 id=\"32-消息结构\">3.2 消息结构</h3>\n<p>每一个消息要有以下几个属性：</p>\n<ul>\n<li><code>topic</code>：消息主题，用消费者路由消费消息</li>\n<li><code>messageId</code>：消息的唯一标识，用来检索和去重消息</li>\n<li><code>delay</code>：消息延迟时间，单位<code>ms</code></li>\n<li><code>headers</code>：消息头</li>\n<li><code>extContext</code>：扩展参数<br />\n<a name=\"YXb8x\"></a></li>\n</ul>\n<h3 id=\"33-消息发送\">3.3 消息发送</h3>\n<p>提供一系列API，保证业务需求：</p>\n<ul>\n<li>简单消息发送</li>\n<li>延迟消息发送</li>\n<li>消息属性配置</li>\n<li>支持消息扩展</li>\n<li>异步消息发送</li>\n<li>支持异步发送回调</li>\n<li>发布确认机制<br />\n<a name=\"XzG8V\"></a></li>\n</ul>\n<h3 id=\"34-消息订阅\">3.4 消息订阅</h3>\n<p>最大程度简化复杂配置，只关注<code>topic</code>，无关队列/交换机，一般业务场景只需要消息生产者和消费者约定好<code>topic</code>，即可完成消息订阅与消费。</p>\n<ul>\n<li>自动声明队列</li>\n<li>自动声明交换机</li>\n<li>自动绑定订阅关系</li>\n<li>支持默认消息分组</li>\n<li>支持消息组内共享</li>\n<li>多数据源</li>\n<li>自定义队列属性<br />\n<a name=\"yZsIv\"></a></li>\n</ul>\n<h3 id=\"35-消息消费\">3.5 消息消费</h3>\n<p>消息消费要最大灵活度的支持消息解析、消费配置：</p>\n<ul>\n<li>支持广泛消息体解析，<code>payload</code>解码</li>\n<li>自动映射属性值</li>\n<li>自定义指定消费方法</li>\n<li>消费确认<br />\n<a name=\"zunqt\"></a></li>\n</ul>\n<h3 id=\"36-延迟消息\">3.6 延迟消息</h3>\n<p>延迟消息的实现基于<code>rabbitmq</code>的<code>rabbitmq_delayed_message_exchange</code>插件。内部实现：</p>\n<ul>\n<li>自动创建延迟交换机</li>\n<li>自动创建延迟队列</li>\n<li>自动路由消息<br />\n<a name=\"tGKbB\"></a></li>\n</ul>\n<h3 id=\"37-消息可靠性\">3.7 消息可靠性</h3>\n<p>消息可靠性从以下几点来保证：</p>\n<ul>\n<li>消息持久化</li>\n</ul>\n<p>对于<code>RabbitMQ</code>，默认情况下为了性能考虑，消息是不持久化的。但是这样会导致消息在服务器重启后丢失，这在我们大多数场景下都是不可接受的。<br />优先使用异步持久化来进行消息持久化，来避免同步持久化的性能问题。同步使用发布确认模式，来防止刷盘前服务重启导致内存中的短时间内的数据丢失问题。</p>\n<ul>\n<li>发布者确认</li>\n</ul>\n<p>发布确认模式需要手动开启。通过开启发布确认，来避免我们消息发布后，<code>broker</code>没有正确的处理该消息而导致消息丢失。开启发布确认后，<code>broker</code>会在接收到消息并成功处理后返回一个<code>ACK</code>。来保证我们发送的消息并不会丢失。</p>\n<ul>\n<li>消费者确认</li>\n</ul>\n<p><code>RabbitMQ</code>的消费确认模型有两种，自动确认和手动确认。自动确认是消费者接收或拉取到消息后，就会自动确认消息已被消费，然后从指定队列中删除，但是此时如果消费者并没有成功处理该消息，而此时队列中的消息已经被删除不会被重新投递，这就意味着消息丢失了。而我们通过采用手动确认模式，只要代码没有问题，基本上不会导致消息丢失。<br />\n<a name=\"qt91I\"></a></p>\n<h2 id=\"4-工作模式\">4. 工作模式</h2>\n<p><a name=\"Qh5ZA\"></a></p>\n<h3 id=\"41-单组\">4.1 单组</h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1649408301190-065ebf6a-de9e-4d03-bef2-1c2317f79de4.png\" alt=\"image.png\" /><br />\n<a name=\"hv4qg\"></a></p>\n<h3 id=\"42-延迟\">4.2 延迟</h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1649408263543-9f32b6a5-b899-48cf-ad85-950bb751d7c5.png\" alt=\"image.png\" /><br />\n<a name=\"wDJjC\"></a></p>\n<h3 id=\"43-共享\">4.3 共享</h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1649408379843-48ad7d04-870d-4471-aad1-c8fec2715f4b.png#clientId=u28f44485-d7fa-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=353&amp;id=u97d10f7e&amp;name=image.png&amp;originHeight=706&amp;originWidth=2364&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=147510&amp;status=done&amp;style=none&amp;taskId=u973fb8ca-3573-4e93-a8ed-6cdf6e9eea5&amp;title=&amp;width=1182\" alt=\"image.png\" /><br />\n<a name=\"RmsjJ\"></a></p>\n<h3 id=\"44-多组\">4.4 多组</h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1649408222523-5ae6699f-2f7b-4fc2-82b0-7c2f57eeb226.png#clientId=u28f44485-d7fa-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=515&amp;id=u350b7ce2&amp;name=image.png&amp;originHeight=1030&amp;originWidth=2376&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=705949&amp;status=done&amp;style=none&amp;taskId=u9624804c-b47d-45cd-bf77-d9c571a4341&amp;title=&amp;width=1188\" alt=\"image.png\" /></p>\n', 1, '', 0, 0, 1, '2022-08-05 14:10:33', '2022-08-05 14:10:33');
INSERT INTO `tb_article` VALUES (274, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=628', 'A001-消息队列客户端V1.0.0-使用手册', '<p>| --- | --- | --- |<br />\n| <strong>更新日期</strong> | 2022年04月19日 | <strong>作        者</strong> | 张留杨 |<br />\n| <strong>保密等级</strong> | C | <strong>开放范围</strong> | 研发测试部 |</p>\n<p><strong>版本历史</strong></p>\n<table>\n<thead>\n<tr><th><strong>版        本</strong></th><th><strong>更新日期</strong></th><th><strong>作        者</strong></th><th><strong>备注</strong></th></tr>\n</thead>\n<tbody>\n<tr><td>1.0.0</td><td>2022年04月08日</td><td>张留杨</td><td>新建文档</td></tr>\n<tr><td>1.1.0</td><td>2022年04月19日</td><td>张留杨</td><td>增加消息存储文档说明</td></tr>\n</tbody>\n</table>\n<p>本客户端最大的特点就是无需关注队列、交换机等配置，只需通过指定<code>topic</code>即可完成消息的发送与消费。<br />\n<a name=\"FEATURE\"></a></p>\n<h2 id=\"1-支持功能\">1. 支持功能</h2>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;支持自动配置</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;支持消息自动解析</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;支持消息分组消费</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;支持消息共享</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;支持延时队列</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;支持深度自定义配置</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;支持消息发布确认</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;支持消息消费确认</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;支持消息异步回调</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;支持多数据源</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;消息存储</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;消费重新次数超限</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;简单指标监控<br />\n<a name=\"UPGRADE\"></a></li>\n</ul>\n<h2 id=\"2-版本记录\">2. 版本记录</h2>\n<ul>\n<li>\n<p><code>1.0.0</code></p>\n<ul>\n<li>支持基本的消息队列功能</li>\n</ul>\n</li>\n<li>\n<p><code>1.1.0</code></p>\n<ul>\n<li>支持消息存储</li>\n</ul>\n</li>\n<li>\n<p><code>2.0.0</code></p>\n<ul>\n<li><code>Message.getId()</code> 修改为<code>Message.getMessageId()</code></li>\n<li>增加简单指标监控<br />\n<a name=\"g4zG5\"></a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-使用示例\">3. 使用示例</h2>\n<p><a href=\"https://git.ddysq.com/common/example/simple-example/-/tree/master/mqclient-example\"><strong>mqclient-example</strong></a><br />\n<a name=\"FASTSTART\"></a></p>\n<h2 id=\"4-快速开始\">4. 快速开始</h2>\n<p><code>SpringBoot</code>官方提供的<code>starter</code>是以队列为关注点进行消息分发，而此客户端的使用方式是以<code>topic</code>为关注点进行消息分发，无关乎队列。<br />\n<a name=\"3a432485\"></a></p>\n<h3 id=\"41-引入依赖\">4.1 引入依赖</h3>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n   &lt;groupId&gt;com.dindo&lt;/groupId&gt;\n   &lt;artifactId&gt;mq-client&lt;/artifactId&gt;\n   &lt;version&gt;2.0.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p><a name=\"ed6e9acd\"></a></p>\n<h3 id=\"42-配置\">4.2 配置</h3>\n<pre><code class=\"language-yaml\">spring:\n  mq:\n    rabbit:\n      client:\n        default:\n          host: 192.168.88.200\n          port: 5672\n          username: admin\n          password: admin\n          virtualHost: /\n</code></pre>\n<p>更多配置如下</p>\n<pre><code class=\"language-yaml\">spring:\n  mq:\n    rabbit:\n      client:\n        default:\n          host: 192.168.88.200\n          port: 5672\n          username: admin\n          password: admin\n          virtualHost: /\n          supportDelayed: true\n          codecId: JSON\n          connection:\n            connectionTimeout: 3000\n            maxConnection: 10\n            minIdle: 10\n            minIdleTime: 30000\n            readBufferSize: 1048576\n            writeBufferSize: 1048576\n          ioThread:\n            threadCount: 10\n            queueSize: -1\n            threadName: rabbitmq-io-thread\n          producerThread:\n            threadCount: 10\n            queueSize: -1\n            threadName: rabbitmq-producer-thread\n          consumerThread:\n            threadCount: 10\n            queueSize: -1\n            threadName: rabbitmq-consumer-thread\n          publisher:\n            exchange:\n              name: dindo-cloud\n          consumer:\n            exchange:\n              name: dindo-cloud\n            channel:\n              basicQos: 100\n            queue:\n              durable: true\n              maxLength: 1000000\n              maxLengthBytes: 1073741824\n</code></pre>\n<p><a name=\"6b9a2d1b\"></a></p>\n<h3 id=\"43-开启自动配置\">4.3 开启自动配置</h3>\n<p>在启动类上增加<code>@EnableRabbitMqAutoConfiguration</code>注解</p>\n<pre><code class=\"language-java\">import com.dindo.mqclient.anno.rabbit.EnableRabbitMqAutoConfiguration;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\n@EnableRabbitMqAutoConfiguration\npublic class TestMqclinetApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(TestMqclinetApplication.class, args);\n    }\n    \n}\n</code></pre>\n<p><a name=\"8b7e3591\"></a></p>\n<h3 id=\"44-发布消息\">4.4 发布消息</h3>\n<p>在生产者的业务程序中，注入<code>MqClient</code></p>\n<pre><code class=\"language-java\">import com.dindo.mqclient.MqClient;\n\n@Resource\nprivate MqClient defaultMqClient;\n</code></pre>\n<p>消息实体实现<code>Message</code>接口</p>\n<pre><code class=\"language-java\">package com.example.testmqclinet.test;\n\nimport com.dindo.mqclient.message.Message;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.util.UUID;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class UserChangeMessage implements Message {\n\n    private String name;\n\n    private int age;\n\n    private boolean man;\n\n    /**\n     * getId\n     *\n     * @return {@link String}\n     */\n    @Override\n    public String getMessageId() {\n        return UUID.randomUUID().toString();\n    }\n\n}\n</code></pre>\n<p>然后直接调用该类的<code>publish</code>方法发送即可</p>\n<pre><code class=\"language-java\">defaultMqClient.publish(&quot;dindo-userChange&quot;, new UserChangeMessage(&quot;dindo&quot;, 10, true));\n</code></pre>\n<p>其中存在多个重载的方法。</p>\n<pre><code class=\"language-java\">public interface MqClient {\n\n    /**\n     * 发布消息\n     *\n     * @param topic   Topic\n     * @param message 消息\n     * @return {@link CallbackFuture}&lt;{@link MessageContext}&gt;\n     */\n    default &lt;T extends Message&gt; CallbackFuture&lt;MessageContext&gt; publish(String topic, T message);\n\n    /**\n     * 发布消息\n     *\n     * @param topic      Topic\n     * @param message    消息\n     * @param persistent 是否持久化\n     * @return {@link CallbackFuture}&lt;{@link MessageContext}&gt;\n     */\n    default &lt;T extends Message&gt; CallbackFuture&lt;MessageContext&gt; publish(String topic, T message, boolean persistent);\n\n    /**\n     * 发布消息\n     *\n     * @param topic   Topic\n     * @param message 消息\n     * @param delay   延迟时间(Unit:ms)\n     * @return {@link CallbackFuture}&lt;{@link MessageContext}&gt;\n     */\n    default &lt;T extends Message&gt; CallbackFuture&lt;MessageContext&gt; publish(String topic, T message, long delay);\n\n    /**\n     * 发布消息\n     *\n     * @param topic   Topic\n     * @param message 消息\n     * @param prop    消息配置\n     * @return {@link CallbackFuture}&lt;{@link MessageContext}&gt;\n     */\n    &lt;T extends Message&gt; CallbackFuture&lt;MessageContext&gt; publish(String topic, T message, MessageProp prop);\n\n}\n</code></pre>\n<p><a name=\"7cd9bafb\"></a></p>\n<h3 id=\"45-接收消息\">4.5 接收消息</h3>\n<p>消费者需要在消息处理类上添加<code>@MqSubscriber(topics = {&quot;dindo-userChange&quot;})</code>注解，指定要监听<code>topics</code>和客户端名称即可。如果没有显示的指定客户端名称，则使用<code>defaultMqClien</code><br />当消息处理类中有多个方法时，需要<code>@ConsumerMethod</code>标记具体消费方法</p>\n<pre><code class=\"language-java\">package com.example.testmqclinet.test;\n\nimport com.dindo.mqclient.anno.ConsumerMethod;\nimport com.dindo.mqclient.anno.MqSubscriber;\nimport com.dindo.mqclient.enums.Ack;\nimport lombok.CustomLog;\nimport lombok.Data;\n\n@CustomLog\n@MqSubscriber(topics = {&quot;dindo-userChange&quot;})\npublic class UserChangeMesageHandler {\n\n    @ConsumerMethod\n    public Ack handle(UserChangeMessage userChangeMessage) {\n        logger.info(&quot;user-change:{}&quot;, userChangeMessage);\n      \n        return Ack.ACCEPT;\n    }\n\n}\n</code></pre>\n<p>如果对于特定消息特殊需求，可在消息处理类上增加<code>@RabbitMqConsumerConfig</code>注解，显示指定配置，如果没有指定则使用全局配置</p>\n<pre><code class=\"language-java\">import com.dindo.mqclient.anno.ConsumerMethod;\nimport com.dindo.mqclient.anno.MqSubscriber;\nimport com.dindo.mqclient.anno.rabbit.RabbitMqConsumerConfig;\nimport lombok.Data;\n\n@RabbitMqConsumerConfig(\n        channel = @RabbitMqConsumerConfig.ChannelConfig(basicQos = 1000),\n        queue = @RabbitMqConsumerConfig.QueueConfig(durable = false, maxLength = 100000, maxLengthBytes = 1024),\n        exchange = @RabbitMqConsumerConfig.ExchangeConfig(name = &quot;dindo-cloud&quot;)\n)\n@MqSubscriber(topics = {&quot;dindo-userChange&quot;, &quot;dindo-userRegister&quot;})\npublic class UserChangeMessageHandler {}\n</code></pre>\n<p><a name=\"c00d8d17\"></a></p>\n<h3 id=\"46-发送延迟消息\">4.6 发送延迟消息</h3>\n<p>要使用延时队列，必须安装插件<code>rabbitmq_delayed_message_exchange</code>，要发送延时消息，配置文件需要开启<code>supportDelayed</code>配置</p>\n<pre><code class=\"language-yaml\">spring:\n  mq:\n    rabbit:\n      client:\n        default:\n        	# 当前数据源是否支持发送延时消息。开启开配置后，默认会创建两个交换机。其中一个普通交换机，一个延时交换机\n          supportDelayed: true\n</code></pre>\n<p>发送延时消息的方式相比之前，仅仅增加一个延时时间。其中延时时长的单位为<code>毫秒</code></p>\n<pre><code class=\"language-java\">//发送一个延时时长为10s的消息\ndefaultMqClient.publish(&quot;testmqclient&quot;, new UserChangeMessage(&quot;dindo&quot;, 10, true), 10000);\n</code></pre>\n<p><a name=\"3927a816\"></a></p>\n<h3 id=\"47-多数据源\">4.7 多数据源</h3>\n<p>多数据源与单数据源配置属性相同，在配置文件中声明即可</p>\n<pre><code class=\"language-yaml\">spring:\n  mq:\n    rabbit:\n      client:\n        default:\n          host: 192.168.88.200\n          port: 5672\n          username: admin\n          password: admin\n          virtualHost: /\n          supportDelayed: true\n        bill:\n          host: 192.168.88.200\n          port: 5672\n          username: admin\n          password: admin\n          virtualHost: /\n          supportDelayed: true\n</code></pre>\n<p><a name=\"154067c4\"></a></p>\n<h4 id=\"471-发布消息\">4.7.1 发布消息</h4>\n<p>首先注入<code>MqClient</code>，与单数据源的唯一区别就是<code>bean</code>的名称。默认向Spring容器中添加的实现类名称为<code>“${数据源名称}MqClient”</code><br />以上面的配置文件为例，默认的<code>bean</code>名称为 <code>defaultMqClient</code> 和 <code>billMqClient</code></p>\n<pre><code class=\"language-java\">import com.dindo.mqclient.MqClient;\n\n@Resource\nprivate MqClient defaultMqClient;\n\n@Resource\nprivate MqClient billMqClient;\n</code></pre>\n<p>其他操作同单数据源<br />\n<a name=\"6e3ee716\"></a></p>\n<h4 id=\"472-接收消息\">4.7.2 接收消息</h4>\n<p>接收消息与单数据源基本一致，唯一的区别是在<code>@MqSubscriber</code>中指定<code>clientName</code>属性，指定当前从哪个数据源进行消费。</p>\n<pre><code class=\"language-java\">import com.dindo.mqclient.anno.MqSubscriber;\n\n@MqSubscriber(topics = {&quot;dindo-userChange&quot;}, clientName = &quot;bill&quot;)\npublic class UserChangeMessageHandler {}\n</code></pre>\n<p><a name=\"821f84c4\"></a></p>\n<h3 id=\"48-消息分组\">4.8 消息分组</h3>\n<p>消息分组是指对多个消费者进行分组消费，比如用户中心发送了一条消息，账单和停车都需要进行消费，这里账单是一组、停车是一组<br />系统默认使用<code>spring.application.name</code>作为分组名称，用户可在消息消费类上指定<code>@MqSubscriber</code>属性中<code>group = &quot;bill&quot;</code>即可</p>\n<pre><code class=\"language-java\">import com.dindo.mqclient.anno.MqSubscriber;\n\n@MqSubscriber(topics = {&quot;dindo-userChange&quot;}, group = &quot;bill&quot;)\npublic class UserChangeMessageHandler {}\n</code></pre>\n<p><a name=\"3ea986e3\"></a></p>\n<h3 id=\"49-消息共享\">4.9 消息共享</h3>\n<p>消息共享是指同一组内进行消息共享，也就是同一个消费者集群内各个节点均进行消息消费<br />比如账单服务发送了一条<code>topic</code>为<code>flush_cache</code>的消息，需要停车服务进行消费进行刷新系统缓存，而此时停车服务部署了三个副本，如果按照正常方式进行消息消费时，这三个副本进行消息竞争，也就是只有一个副本能够消费到消息进行刷新系统缓存，而其它两个副本没有竞争到消息进行消费。消息共享就是为了解决此类问题，从而让三个副本都可以消费到消息。</p>\n<p>实现消息共享只需要在消息消费类上指定<code>@MqSubscriber</code>属性中<code>share = true</code>即可</p>\n<pre><code class=\"language-java\">import com.dindo.mqclient.anno.MqSubscriber;\n\n@MqSubscriber(topics = {&quot;dindo-userChange&quot;}, share = true)\npublic class UserChangeMessageHandler {}\n</code></pre>\n<p><a name=\"1cf195ea\"></a></p>\n<h3 id=\"410-异步回调\">4.10 异步回调</h3>\n<p>支持在消息发布时对<code>callback</code>的操作</p>\n<pre><code class=\"language-java\">CallbackFuture&lt;MessageContext&gt; callbackFuture = defaultMqClient.publish(&quot;dindo-userChange&quot;, new UserChangeMessage(&quot;dindo&quot;, 10, true));\n\nFutureCallback&lt;MessageContext&gt; futureCallback = new FutureCallback&lt;MessageContext&gt;() {\n    @Override\n    public void complete(MessageContext result, Throwable ex, int status) {\n        logger.info(&quot;消息发送完成&quot;);\n    }\n    @Override\n    public void success(MessageContext result) {\n        logger.info(&quot;消息发送成功&quot;);\n    }\n    @Override\n    public void failed(Throwable ex) {\n        logger.info(&quot;消息发送失败&quot;);\n    }\n    @Override\n    public void cancelled() {\n        logger.info(&quot;消息发送已取消&quot;);\n    }\n};\n\n// 添加回调\ncallbackFuture.addCallback(futureCallback);\n\n// 移除回调\ncallbackFuture.removeCallback(futureCallback);\n</code></pre>\n<p><a name=\"78f3f5e6\"></a></p>\n<h3 id=\"411-消息持久化存储\">4.11 消息持久化存储</h3>\n<p><code>since：1.1.0</code></p>\n<p>提供了<code>com.dindo.mqclient.store.MessageRepository</code>消息存储接口，实现此接口自定义消息存储方式。</p>\n<pre><code class=\"language-java\">import com.dindo.mqclient.store.MessageRepository;\n\npublic class LoggerMessageRepository implements MessageRepository {\n\n    /**\n     * 保存消息\n     *\n     * @param message 要保存的消息\n     */\n    @Override\n    public void save(MessageEntity message) {\n        logger.info(&quot;持久化消息 [{}]&quot;, message);\n    }\n\n    /**\n     * 根据条件查询指定状态的消息\n     *\n     * @param topic  topic\n     * @param status 消息状态\n     * @param offset 起始位置\n     * @param limit  查询数量\n     * @return {@link List}&lt;{@link MessageEntity}&gt;\n     */\n    @Override\n    public List&lt;MessageEntity&gt; select(String topic, MessageStatus status, int offset, int limit) {\n        return null;\n    }\n\n    /**\n     * 更新消息状态\n     *\n     * @param topic  消息topic\n     * @param id     消息标识\n     * @param status 要更新的消息状态\n     */\n    @Override\n    public void updateStatus(String topic, String id, MessageStatus status) {\n\n    }\n}\n</code></pre>\n<p>在配置文件中指定持久化bean。</p>\n<pre><code class=\"language-yaml\">spring:\n  mq:\n    rabbit:\n      client:\n        default:\n          host: 192.168.88.200\n          port: 5672\n          username: admin\n          password: admin\n          virtualHost: /\n          supportDelayed: true\n          repositoryId: loggerMessageRepository\n</code></pre>\n<p>注意：开启消息持久化后，将自动确认接收消息，忽略<code>return ack</code>，且处理异常不会重新入队。<br />\n<a name=\"pG61r\"></a></p>\n<h3 id=\"412-简单指标监控\">4.12 简单指标监控</h3>\n<p><code>since：2.0.0</code><br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1653371629244-b0cbd76f-e235-4592-b0a0-6f6865fbd01a.png#clientId=u115fbe2a-9d5f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=174&amp;id=u7a99c1f4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=348&amp;originWidth=2620&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1163269&amp;status=done&amp;style=none&amp;taskId=u2fc61536-f08b-4e5e-b5d8-09dbc7fac8c&amp;title=&amp;width=1310\" alt=\"image.png\" /></p>\n<pre><code>2022-05-24 13:51:58.323 DEBUG 31123 --- [llMqClient-MQ监控] c.d.m.rabbit.SimpleMetricsCollector      : [MQ-billMqClient][MONITOR] 连接数: 2, 通道数: 2, 消息发布数: 0, 消息消费数: 0, 消费成功数: 0, 消费失败数: 0\n2022-05-24 13:52:27.916 DEBUG 31123 --- [ltMqClient-MQ监控] c.d.m.rabbit.SimpleMetricsCollector      : [MQ-defaultMqClient][MONITOR] 连接数: 2, 通道数: 1, 消息发布数: 0, 消息消费数: 0, 消费成功数: 0, 消费失败数: 0\n2022-05-24 13:52:28.330 DEBUG 31123 --- [llMqClient-MQ监控] c.d.m.rabbit.SimpleMetricsCollector      : [MQ-billMqClient][MONITOR] 连接数: 2, 通道数: 2, 消息发布数: 0, 消息消费数: 0, 消费成功数: 0, 消费失败数: 0\n</code></pre>\n', 1, '', 0, 0, 1, '2022-08-05 14:10:38', '2022-08-05 14:10:38');
INSERT INTO `tb_article` VALUES (275, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4543', 'A004-分布式锁-设计文档', '<p>| --- | --- | --- |<br />\n| <strong>更新日期</strong> | 2022年04月20日 | <strong>作        者</strong> | 张留杨 |<br />\n| <strong>保密等级</strong> | C | <strong>开放范围</strong> | 研发测试部 |</p>\n<p><strong>版本历史</strong></p>\n<table>\n<thead>\n<tr><th><strong>版        本</strong></th><th><strong>更新日期</strong></th><th><strong>作        者</strong></th><th><strong>备注</strong></th></tr>\n</thead>\n<tbody>\n<tr><td>1.0.0</td><td>2022年04月20日</td><td>张留杨</td><td>新建文档</td></tr>\n<tr><td> </td><td> </td><td> </td><td> </td></tr>\n</tbody>\n</table>\n<p><a name=\"ANR0d\"></a></p>\n<h2 id=\"业务背景\">业务背景</h2>\n<p>在多线程的环境下，为了保证一个代码块在同一时间只能由一个线程访问，Java中我们一般可以使用<code>JVM</code>的<code>synchronized</code>语法，或者使用<code>JDK</code>的<code>Lock</code>来保证，这实际上是本地锁的方式。但是现在公司都是分布式架构，在分布式环境下，如何保证不同节点的线程同步执行呢？实际上，对于分布式场景，我们可以使用分布式锁，它是控制分布式系统之间互斥访问共享资源的一种方式。<br />比如说在一个分布式系统中，多台机器上部署了多个服务，当客户端一个用户发起一个数据插入请求时，如果没有分布式锁机制保证，那么那多台机器上的多个服务可能进行并发插入操作，导致数据重复插入，对于某些不允许有多余数据的业务来说，这就会造成问题。而分布式锁机制就是为了解决类似这类问题，保证多个服务之间互斥的访问共享资源，如果一个服务抢占了分布式锁，其他服务没获取到锁，就不进行后续操作。<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1650434799023-586cd12e-f44c-48a8-b6f2-17d6309adce6.png#clientId=u29c8c0e4-7a84-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=535&amp;id=u7082f5de&amp;name=image.png&amp;originHeight=1070&amp;originWidth=1798&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=217522&amp;status=done&amp;style=none&amp;taskId=ubaef535e-222d-4975-9964-81a841c8321&amp;title=&amp;width=899\" alt=\"image.png\" /><br />\n<a name=\"C93Wg\"></a></p>\n<h2 id=\"解决问题\">解决问题</h2>\n<p>主要解决bladex提供的分布式锁的一些问题，支持一些新特性，以及优化一些逻辑。<br />\n<a name=\"xmmQi\"></a></p>\n<h3 id=\"颗粒度\">颗粒度</h3>\n<p>目前blade提供的分布式锁是基于aop代理的，锁的颗粒度为方法/参数级别。我们还需要更小的颗粒度，如行级别。<br />\n<a name=\"rnFdp\"></a></p>\n<h3 id=\"锁类型\">锁类型</h3>\n<p>目前提供了两种锁类型，公平锁、可重入锁。还需要比如：读锁、写锁。<br />\n<a name=\"Ns1fL\"></a></p>\n<h3 id=\"失败策略\">失败策略</h3>\n<p>目前没有提供比如：加锁超时策略、锁释放超时策略<br />\n<a name=\"d5KXL\"></a></p>\n<h3 id=\"全局配置\">全局配置</h3>\n<p>提供一些全局配置，比如：全局锁超时、释放时间<br />\n<a name=\"OXfxZ\"></a></p>\n<h2 id=\"设计目标\">设计目标</h2>\n<p>分布式锁一般有如下的特点：</p>\n<ul>\n<li>互斥性： 同一时刻只能有一个线程持有锁</li>\n<li>可重入性： 同一节点上的同一个线程如果获取了锁之后能够再次获取锁</li>\n<li>锁超时：和<code>J.U.C</code>中的锁一样支持锁超时，防止死锁</li>\n<li>高性能和高可用： 加锁和解锁需要高效，同时也需要保证高可用，防止分布式锁失效</li>\n<li>具备阻塞和非阻塞性：能够及时从阻塞状态中被唤醒<br />\n<a name=\"kIOlm\"></a></li>\n</ul>\n<h2 id=\"实现方式\">实现方式</h2>\n<p><a href=\"https://redis.io/docs/reference/patterns/distributed-locks/\">https://redis.io/docs/reference/patterns/distributed-locks/</a><br />基于<code>Redisson</code>3.17.0<br />\n<a name=\"et2u9\"></a></p>\n<h2 id=\"支持功能\">�支持功能</h2>\n<p><a name=\"kqJDY\"></a></p>\n<h3 id=\"服务器类型\">服务器类型</h3>\n<ul>\n<li>单点</li>\n<li>集群</li>\n<li>哨兵</li>\n<li>主从<br />\n<a name=\"ODMf9\"></a></li>\n</ul>\n<h3 id=\"锁类型-1\">锁类型</h3>\n<ul>\n<li><strong>可重入锁（默认）</strong></li>\n<li>公平锁</li>\n<li>读锁</li>\n<li>写锁<br />\n<a name=\"UENTd\"></a></li>\n</ul>\n<h3 id=\"锁颗粒度\">锁颗粒度</h3>\n<ul>\n<li>方法级别</li>\n<li>参数级别</li>\n<li>行代码级别<br />\n<a name=\"Yr0VE\"></a></li>\n</ul>\n<h3 id=\"使用方式\">使用方式</h3>\n<ul>\n<li>声明式</li>\n<li>编程式<br />\n<a name=\"CN55M\"></a></li>\n</ul>\n<h2 id=\"工作模式\">工作模式</h2>\n<p><a name=\"TKXaL\"></a></p>\n<h3 id=\"声明式\">声明式</h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1650511778926-f3a10abc-9b91-4bd4-a14e-80d381f51e38.png#clientId=u1df323f5-0778-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=793&amp;id=u75260282&amp;name=image.png&amp;originHeight=1586&amp;originWidth=1380&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=851850&amp;status=done&amp;style=none&amp;taskId=ufcaf8624-ef64-4834-b59b-98d3471cb2e&amp;title=&amp;width=690\" alt=\"image.png\" /><br />\n<a name=\"G5s5b\"></a></p>\n<h3 id=\"编程式\">编程式</h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1650512891949-c710ed81-49ba-452f-9712-8523d27b0813.png#clientId=u1df323f5-0778-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=485&amp;id=ube155fe8&amp;name=image.png&amp;originHeight=970&amp;originWidth=1366&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=459822&amp;status=done&amp;style=none&amp;taskId=u5f488c65-d795-494e-acb5-ca73baeaf68&amp;title=&amp;width=683\" alt=\"image.png\" /></p>\n', 1, '', 0, 0, 1, '2022-08-05 14:10:50', '2022-08-05 14:10:50');
INSERT INTO `tb_article` VALUES (276, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8788', 'A003-数据权限-需求分析', '<p>| --- | --- | --- |<br />\n| <strong>更新日期</strong> | 2022年04月18日 | <strong>作        者</strong> | 张留杨 |<br />\n| <strong>保密等级</strong> | C | <strong>开放范围</strong> | 研发测试部 |</p>\n<p><strong>版本历史</strong></p>\n<table>\n<thead>\n<tr><th><strong>版        本</strong></th><th><strong>更新日期</strong></th><th><strong>作        者</strong></th><th><strong>备注</strong></th></tr>\n</thead>\n<tbody>\n<tr><td>1.0.0</td><td>2022年04月18日</td><td>张留杨</td><td>新建文档</td></tr>\n<tr><td> </td><td> </td><td> </td><td> </td></tr>\n</tbody>\n</table>\n<p><a name=\"E0oFl\"></a></p>\n<h2 id=\"应用场景\">应用场景</h2>\n<p>数据权限的应用场景主要是针对列表数据的权限过滤，也就是同一列表控制不同权限的用户显示不同的行数据，比如：南区销售总监只能看到南区的销售数据；北区总监看到北区的销售数据；总经理能看到所有销售数据。简单来讲，数据权限就是“用户是否能够查看数据”，主要是为了业务系统的信息安全考虑，不同的人，在不同的场景下，所能看到的数据范围也不一样。<br />\n<a name=\"KkgBu\"></a></p>\n<h2 id=\"基础数据权限\">基础数据权限</h2>\n<p><a name=\"YUGKe\"></a></p>\n<h3 id=\"对象级权限\">对象级权限</h3>\n<p>基础数据权限通常会承载到一个权限媒介上，比如说权限集，职能等。他通常包括两部分，对象级权限与字段级权限。<br />简单来讲，对象级权限可以控制到一个用户是否能够看到某一个业务菜单或者业务Tab，也就是说用户甚至可以不知道系统中有这一类的数据。对象级权限的设计会包含下面几部分。</p>\n<table>\n<thead>\n<tr><th><strong>权限</strong></th><th><strong>描述</strong></th><th><strong>权限类型</strong></th></tr>\n</thead>\n<tbody>\n<tr><td>查询</td><td>用户可以查看记录</td><td>单一权限</td></tr>\n<tr><td>创建</td><td>用户可以查看并创建记录</td><td>单一权限</td></tr>\n<tr><td>删除</td><td>用户可以查看并删除记录</td><td>单一权限</td></tr>\n<tr><td>修改</td><td>用户可以查看并修改记录</td><td>单一权限</td></tr>\n<tr><td>查询所有关联</td><td>查询所有相关记录</td><td>覆盖权限</td></tr>\n<tr><td>修改所有关联</td><td>修改所有相关记录</td><td>覆盖权限</td></tr>\n</tbody>\n</table>\n<p>关于“查询所有关联”和 “修改所有关联”，它的权限优先级是要高于其他权限规则。比如商机、订单、报价单等业务对象都关联了客户，那么如果在客户上设置了“查询所有关联”的话，就会覆盖掉具体关联业务实体设置的对象级权限。<br />\n<a name=\"D7ArV\"></a></p>\n<h3 id=\"字段级权限\">字段级权限</h3>\n<p>根据业务需要，即使可以看到某个业务对象，但也需要对某些隐私字段做数据权限处理。 例如：联系人电话、薪水等信息，不会对所有人开放。</p>\n<table>\n<thead>\n<tr><th><strong>权限</strong></th><th><strong>描述</strong></th><th><strong>权限类型</strong></th></tr>\n</thead>\n<tbody>\n<tr><td>无权限</td><td>用户不能读取和编辑此字段</td><td>覆盖权限</td></tr>\n<tr><td>只读</td><td>用户可以读取但不能编辑此字段</td><td>覆盖权限</td></tr>\n<tr><td>编辑</td><td>用户可以读取和编辑此字段</td><td>覆盖权限</td></tr>\n</tbody>\n</table>\n<p>如果有包含页面布局的相关设置，那么字段级权限设置，要覆盖掉布局的设置。<br />\n<a name=\"DD4aJ\"></a></p>\n<h2 id=\"记录级数据权限\">记录级数据权限</h2>\n<p>其实对于很多业务系统来说，可能上面的基础数据权限设计已经能够满足大部分数据权限场景了，但问题是有一类“特殊场景”解决不了。例如：**某“一部分”数据，只允许“一部分”人查看。**几乎所有复杂的数据权限设计，都是为了解决这个问题。<br />\n<a name=\"rvixY\"></a></p>\n<h3 id=\"系统默认权限\">系统默认权限</h3>\n<p>要想解决 某“一部分”数据，只允许“一部分”人操作，理论上那就意味着每一条数据都应该可以被控制。那么每一个用户与每一条数据之间到底是什么关系，是业务系统需要回答的第一个问题。<br />通常来讲，系统默认权限应该是“最严格的”，“唯一”的“限制”数据权限的方式，其他的记录级数据权限，应该是在系统默认权限的基础上，增加额外的数据权限。<br />比如最极端的限制条件，所有的业务数据都是不可见的。 当然对于某些公司来讲，一些数据是全员可见的，比如像公告、通讯录、社区帖子等类型的数据。<br />系统默认权限如果需要修改，应该要受到严格的控制流程管理，毕竟这是整个数据权限架构中，唯一的限制。<br />\n<a name=\"XrpwB\"></a></p>\n<h3 id=\"记录所属人\">记录所属人</h3>\n<p>通常来说，如果一个用户拥有某个业务实体创建对象的权限，那么针对这条特定的记录，用户创建完成记录后，会自动变为这条记录的所属人(owner)。<br />在系统默认权限的基础上，记录的所属人就属于一种新增的数据权限，可以对这个用户进行查看操作(可进行的操作应该基于基础数据权限)。<br />由于业务的需要，记录会在不同的用户之间进行数据转移的操作(transfer ownership)，所以记录所属人，不一定是记录的创建人。</p>\n<blockquote>\n<p>还有一种例外情况，一条记录不属于某个特定的用户。在有些公司的业务中，会有类似公海池、队列等记录分配器功能。那么在分配记录之前，这些记录也是可以属于这些分配器的。相关功能的成员可以在列表视图中看到这些分配器中的记录数据，并进行所属人认领的操作（更多详细内容，我会更新在后续的公海池设计当中）。</p>\n</blockquote>\n<p><a name=\"gT6MK\"></a></p>\n<h3 id=\"部门相关部门\">部门/相关部门</h3>\n<p>每个企业的组织架构都会区分部门，那么就有一个非常自然的需求场景：看到本部门以及下级部门相关的所有数据。<br />一种比较简单的做法，就是在创建数据的时候，自动将数据关联到创建用户的所属部门上。还有一些情况，有些公司的数据是由专门的团队负责创建的，那么针对于这些数据，就需要可以变更数据的所属部门的能力。<br />随着业务的不断发展，可能会遇到跨部门数据查看的需求，也就是说，一个用户有主要的所属部门，以及根据数据权限需要而设置的多个相关部门。<br />\n<a name=\"T69Db\"></a></p>\n<h3 id=\"直属负责人助理\">直属负责人/助理</h3>\n<p>在传统的组织架构中，除了部门层级之间的数据共享需求之外，还有人员汇报关系线。<br />通常的做法，就是在为每一个用户，指定一个直属上级负责人，直属上级负责人会被赋予所有下属层级的相同数据权限。为了管理方便，也可以为直属负责人设置助理，助理与直属负责人具备相同的数据权限，这样更灵活的让不同的用户能够跳脱出公司组织架构的束缚。<br />\n<a name=\"n6Qgs\"></a></p>\n<h3 id=\"岗位层级\">岗位层级</h3>\n<p>使用部门权限体系会带来一个问题，企业的组织架构往往与业务的架构是不一致的。而且业务架构会经常变化，而结构变化对于数据权限控制来讲，是一个挑战。<br />岗位层级，可以根据数据权限需要，将一个用户或者一组用户放在同样的岗位下。这样的话，在创建岗位的同时，也可以很好的了解公司架构到底应该以什么样的形式组织在一起更高效。可以从上至下的设置岗位层级，比如说最高层岗位叫CEO，可以查看整个组织的数据。然后以事业部总经理或者地区负责人的岗位，继续向下细分，查看各自岗位下的数据。<br />岗位层级权限还有一个更加强大的能力，就是<strong>岗位与数据之间可以是 m:n 关系</strong>，也就是说同一条数据可以同时共享给多个岗位，满足更加复杂的数据共享场景。<strong>岗位层级的设计，可以将数据与用户解绑，这在人员变动，业务调整时，可以很方便的做数据共享的变更。</strong></p>\n<table>\n<thead>\n<tr><th><strong>解决问题</strong></th><th><strong>需求场景</strong></th></tr>\n</thead>\n<tbody>\n<tr><td>上下级管理关系权限</td><td>上级岗位管理中，需要看到所有下级岗位的数据</td></tr>\n<tr><td>向上级汇报数据</td><td>随时可以根据岗位关系，汇总所有下级数据，向上汇报</td></tr>\n<tr><td>不同组织结构的数据隔离</td><td>不同的下级组织单元之间不需要数据共享</td></tr>\n<tr><td>相同角色的数据隔离</td><td>相同智能角色，需要有不同的数据共享权限</td></tr>\n</tbody>\n</table>\n<p><a name=\"SzoQj\"></a></p>\n<h3 id=\"共享规则\">共享规则</h3>\n<p>对于数据权限还有一类更加接近直觉的设计方式，也就是别搞那些花里胡哨的概念，我就是要把“这一部分”数据，共享给“那一部分”人。换句话来讲，如果上面的权限设计体系统统不能满足业务场景，可不可以提供一种直接的数据共享方式。<br />“共享规则”的设计方案可能是一种解决思路。通常来讲，共享规则解决了两类场景：</p>\n<ul>\n<li>把特定用户的数据，共享给特定用户。</li>\n<li>把符合特定条件的数据，共享给特定用户。</li>\n</ul>\n<p>当然这里面的“特定用户”，不仅仅只用户本身，所有包含用户的容器概念元素(部门、群组、角色等)，应该都包含在内。</p>\n<table>\n<thead>\n<tr><th><strong>解决问题</strong></th><th><strong>需求场景</strong></th></tr>\n</thead>\n<tbody>\n<tr><td>跨组织架构分支数据共享</td><td>产品线A的管理层，希望能够看到所有购买过产品A的客户数据</td></tr>\n<tr><td>同级角色部分数据共享</td><td>A部门的线索数据对所有A部门的销售人员可见</td></tr>\n<tr><td>虚拟群组数据共享</td><td>将新市场产品相关的数据，共享给新市场业务虚拟小组</td></tr>\n</tbody>\n</table>\n<p><a name=\"MBTZZ\"></a></p>\n<h3 id=\"手工共享\">手工共享</h3>\n<p>共享规则虽然方便，但解决不了一类更要命的数据权限场景，有些共享场景是没有办法提前可以预想的，是随机的，是随时随地的。其实这种场景的前提条件就决定了权限设计的方式，既然规则不行，那就手工来指定好了。<br />手工共享的数据权限设计，完全是基于记录所属人的自由意志，记录所属人认为数据应该共享给谁，就共享给谁好了。需要注意的是，当记录的所属关系发生变更时，那么手工共享关系应该直接解除。记录所属人也需要可以随时查看和修改，当前这条数据的手工共享情况。<br />\n<a name=\"O8hJQ\"></a></p>\n<h3 id=\"团队成员\">团队成员</h3>\n<p>手工共享的确可以解决非常态化规则的数据权限场景，但麻烦的是，共享关系会随着记录所属人的所属关系转移，而全部丢失。对于一条记录来讲，如果大部分需要共享的用户不会经常发生变动，可以尝试使用团队成员的方式来进行手工共享。<br />记录所属人或者有记录编辑权限的团队成员，可以同时添加其他用户作为这条记录的团队成员，记录会对所有团队成员共享。这样即使记录所属人发生变化，其他的团队成员会仍然保留与此条记录的数据共享关系。团队成员除了支持用户外，也需要支持部门，群组才能更灵活的支撑单条数据的共享。<br />\n<a name=\"bO8AY\"></a></p>\n<h3 id=\"群组共享\">群组共享</h3>\n<p>团队成员共享方案，能够解决大部分需要灵活配置的单条数据共享场景，但操作比较繁琐。如果需要频繁共享给一个虚拟组织团队，就需要在每一条数据上添加若干个，相同的团队成员，效率很低。<br /><strong>群组就会很好地解决这个问题，若几个用户之间需要经常共享数据，那么可以将用户们用群组圈起来，记录的所属人，可以通过将自己创建的、符合条件的数据，自动共享到若干群组中，用户也可以通过手动共享的方式，将某条数据共享到群组中。</strong><br />而只有群组成员才能看到群组中的数据，群组一般分为公用群组和私用群组。</p>\n<ul>\n<li>公用群组是整个公司都能看到的群组，任何人都可以将数据共享到公用群组中。</li>\n<li>私用群组是每个人独立创建的，只有群组成员可以将数据共享到私用群组中。</li>\n</ul>\n<p>群组应该是可以支持嵌套关系的，比如：用户、角色、岗位、群组本身，都是可以是群组的一员。当然处于性能的考虑，最好对类似群组套群组的这种方式，做一个层级上的限制。群组与数据的关系应该是多对多的，也就是说，同样一条数据，可以在不同的群组中做共享。<br />群组数据的共享应该是独立的，通过类似其他岗位层级，直属上级相关的其他权限，是无法突破群组成员限制的。也就是说UserA是群组成员，可以看到群组的数据，但UserA的上司由于不是群组成员，所以看不到群组的数据。<br />\n<a name=\"oLhGe\"></a></p>\n<h3 id=\"区域层级\">区域层级</h3>\n<p>对于大型企业应用场景，经常会出现销售、产品、服务分属于不同的业务单元，但需要根据不同的规则共享客户等相关资源。那么就可以创建多个区域层级，让同一个客户按照不同的层级结构共享给各个不同的业务单元。<br />与岗位层级类似，区域层级通常应用于地盘资源管理的数据权限划分，通过多个不同的区域维度规则，如地区、客户等级、行业、产品线。相应的数据在创建/编辑后，可以自动进入到符合规则的区域。<br />通过一些级联跟随分配的设置，数据下的相关数据也可以同时进入到相同区域，比如客户下的订单，订单下的回款单等。数据进入到区域后，区域成员就可以看到数据了。<br />一般来讲，区域权限分为2级，Object、Hirerachy。</p>\n<ul>\n<li>Object 业务对象级权限，说的是一个区域成员针对于具体的业务对象，是什么权限。比如针对于客户，是查看还是编辑?</li>\n<li>Hirerachy 层级权限，是说针对于业务实体，除了本级区域的权限，是否也具备下级区域的权限。</li>\n</ul>\n<p>针对于单个区域，若有业务需要，也可以添加 Record 级别的权限，类似于记录所属人。<br />针对于每一个区域，也可以设置这个区域的记录负责人（Territory Record Owner），这样对于基于区域管理的业务属性来讲，可以将记录做到最灵活的配置。<br />\n<a name=\"zkXUb\"></a></p>\n<h2 id=\"权限媒介\">权限媒介</h2>\n<p><a name=\"o6ky3\"></a></p>\n<h3 id=\"自身属性\">自身属性</h3>\n<p>权限媒介在自身属性上，分为三种类型：</p>\n<ul>\n<li><strong>Owner</strong></li>\n</ul>\n<p>独立媒介，比如记录所属人，岗位层级。</p>\n<ul>\n<li>\n<p>可以自主的满足所有的权限结构；</p>\n</li>\n<li>\n<p>可以包含其他权限体系。</p>\n</li>\n<li>\n<p><strong>Child</strong></p>\n</li>\n</ul>\n<p>子媒介，比如群组，区域。</p>\n<ul>\n<li>\n<p>可以自主的满足所有的权限结构；</p>\n</li>\n<li>\n<p>可以被特定的Owner媒介包含；</p>\n</li>\n<li>\n<p>可以包含其他权限体系。</p>\n</li>\n<li>\n<p><strong>Element</strong></p>\n</li>\n</ul>\n<p>原子媒介，比如助理/直属上级从属于部门层级。</p>\n<ul>\n<li>可以理解为内部权限媒介；</li>\n<li>仅可以包含其他原子媒介。</li>\n</ul>\n<p>权限媒介的自身属性类型可以帮助我们认识到，权限体系的设计是整体的，而不是混乱的。一个媒介已经被定为成Element，就不要同时还具备Owner的属性，不然可能虽然一时解决了问题，但今后的扩展会无比艰难。<br />\n<a name=\"ocgn9\"></a></p>\n<h3 id=\"使用场景\">使用场景</h3>\n<p>权限媒介在使用场景上，分为两种类型：</p>\n<ul>\n<li><strong>有规则的</strong></li>\n</ul>\n<p>比如共享规则，岗位层级。</p>\n<ul>\n<li>\n<p>根据公司的业务需要，总结出来的数据共享场景；</p>\n</li>\n<li>\n<p>可节省大量的权限共享设置成本。</p>\n</li>\n<li>\n<p><strong>无规则的</strong></p>\n</li>\n</ul>\n<p>比如团队成员，手工共享。</p>\n<ul>\n<li>人为认定的数据权限共享场景，提前无法认知；</li>\n<li>规则设置成本，超过了使用成本。</li>\n</ul>\n<p>权限媒介的使用场景类型，可以帮助我们认识到，权限的灵活性，要把“人”的判断纳入到整个体系中来。过高的设置成本不但会加大业务的复杂度，而且也会让“人”失去控制感。</p>\n', 1, '', 0, 0, 1, '2022-08-05 14:10:54', '2022-08-05 14:10:54');
INSERT INTO `tb_article` VALUES (277, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1014', 'A004-分布式锁-使用手册', '<p>| --- | --- | --- |<br />\n| <strong>更新日期</strong> | 2022年04月21日 | <strong>作        者</strong> | 张留杨 |<br />\n| <strong>保密等级</strong> | C | <strong>开放范围</strong> | 研发测试部 |</p>\n<p><strong>版本历史</strong></p>\n<table>\n<thead>\n<tr><th><strong>版        本</strong></th><th><strong>更新日期</strong></th><th><strong>作        者</strong></th><th><strong>备注</strong></th></tr>\n</thead>\n<tbody>\n<tr><td>1.0.0</td><td>2022年04月21日</td><td>张留杨</td><td>新建文档</td></tr>\n<tr><td> </td><td> </td><td> </td><td> </td></tr>\n</tbody>\n</table>\n<p>基于<code>Redisson</code>实现的分布式锁。<br />\n<a name=\"qqj8q\"></a></p>\n<h2 id=\"1-支持功能\">1. 支持功能</h2>\n<ul>\n<li><strong>服务器类型</strong></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;单点</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;集群</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;哨兵</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;主从</li>\n<li><strong>锁类型</strong></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;<strong>可重入锁（默认）</strong></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;公平锁</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;读锁</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;写锁</li>\n<li><strong>锁颗粒度</strong></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;方法级别</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;参数级别</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;行代码级别</li>\n<li><strong>使用方式</strong></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;声明式</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;编程式<br />\n<a name=\"7e3fd13d\"></a></li>\n</ul>\n<h2 id=\"2-版本记录\">2. 版本记录</h2>\n<ul>\n<li><code>**1.0.0-SANPSHOT**</code><br />支持分布式锁功能<br />\n<a name=\"4a532e14\"></a></li>\n</ul>\n<h2 id=\"3-使用示例\">3. 使用示例</h2>\n<p><a href=\"https://git.ddysq.com/common/example/simple-example/-/tree/master/global-lock-example\"><strong>global-lock-example</strong></a><br />\n<a name=\"c182e73c\"></a></p>\n<h2 id=\"4-快速开始\">4. 快速开始</h2>\n<p><a name=\"RqpqG\"></a></p>\n<h3 id=\"41-引入依赖\">4.1 引入依赖</h3>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n  &lt;groupId&gt;com.dindo&lt;/groupId&gt;\n  &lt;artifactId&gt;global-lock&lt;/artifactId&gt;\n  &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p><a name=\"15c64aa0\"></a></p>\n<h3 id=\"42-配置文件\">4.2 配置文件</h3>\n<pre><code class=\"language-yaml\">dindo:\n  global-lock:\n    address: redis://192.168.88.200:6389\n    password: 123456\n</code></pre>\n<p><strong>更多配置：</strong></p>\n<pre><code class=\"language-yaml\">dindo:\n  global-lock:\n    address: redis://192.168.88.200:6389\n    password: 123456\n    codec: org.redisson.codec.JsonJacksonCodec\n    database: 15\n    lease-time: 60\n    wait-time: 60\n    prefix: dindo.global-lock\n    pool:\n      size: 20\n      min-idle: 1\n      idle-timeout: 60000\n      command-timeout: 500\n      connection-timeout: 30000\n    cluster:\n      nodes:\n        - redis://192.168.88.200:6379\n        - redis://192.168.88.200:6389\n        - redis://192.168.88.200:6399\n    sentinel:\n      master: mymaster\n      nodes:\n        - redis://192.168.88.200:6379\n        - redis://192.168.88.200:6389\n        - redis://192.168.88.200:6399\n    master-slave:\n      master: redis://192.168.88.200:6379\n      slaves:\n        - redis://192.168.88.200:6379\n        - redis://192.168.88.200:6389\n        - redis://192.168.88.200:6399\n</code></pre>\n<p><strong>特别说明：</strong></p>\n<ul>\n<li>无特别需求只需配置<code>address</code>和<code>password</code>即可</li>\n<li>目前集群、哨兵、主从模式由于部署对应模式，暂无验证<br />\n<a name=\"e0e966e2\"></a></li>\n</ul>\n<h3 id=\"43-声明式\">4.3 声明式</h3>\n<p>使用方式就是在方法上添加<code>@GlobalLock</code>的注解即可，其中各个参数说明如下：</p>\n<ul>\n<li><code>name</code> 锁名称\n<ul>\n<li>如果不指定<code>name</code>参数，那么生成的<code>redis</code>的<code>key</code>为&quot;<code>${dindo.global-lock.prefix}:包名.方法名-参数</code>&quot;</li>\n<li>如果指定name参数，那么生成的<code>redis</code>的<code>key</code>为&quot;<code>${dindo.global-lock.prefix}:name-参数</code>&quot;</li>\n</ul>\n</li>\n<li><code>keys</code> 自定义的业务<code>key</code>，也就是可以根据业务参数进行加锁</li>\n<li><code>lockType</code> 锁类型，默认可重入锁（<code>LockType.REENTRANT</code>）</li>\n<li><code>waitTime</code> 获取锁的等待时长（默认为<code>Long.MIN_VALUE</code>）</li>\n<li><code>leaseTime</code> 上锁以后多少秒自动解锁（默认为<code>Long.MIN_VALUE</code>）</li>\n<li><code>lockTimeoutStrategy</code> 获取锁超时时执行的策略，默认为任何动作也不做，直接执行业务逻辑。<br />强烈建议使用<code>LockTimeoutStrategy.FAST_FAIL</code>,即获取锁失败抛异常</li>\n<li><code>customLockTimeoutStrategy</code> 自定义的获取锁超时执行的策略</li>\n<li><code>releaseTimeoutStrategy</code> 释放锁时已超时的处理策略，同样默认情况下任何动作也不执行</li>\n<li><code>customReleaseTimeoutStrategy</code> 自定义释放锁时已超时的处理策略<br />\n<a name=\"46ffd77e\"></a></li>\n</ul>\n<h4 id=\"431-锁定单业务key\">4.3.1 锁定单业务key</h4>\n<pre><code class=\"language-java\">import com.dindo.globallock.annotation.GlobalLock;\nimport com.dindo.globallock.enums.LockTimeoutStrategy;\n\n@GetMapping(&quot;useSingleKeyLock/{name}&quot;)\n@GlobalLock(keys = &quot;#name&quot;, leaseTime = 2, lockTimeoutStrategy = LockTimeoutStrategy.FAST_FAIL)\npublic String useSingleKeyLock(@PathVariable String name){\n        return&quot;success&quot;;\n        }\n</code></pre>\n<p><a name=\"bdac88f8\"></a></p>\n<h4 id=\"432-锁定多业务key\">4.3.2 锁定多业务key</h4>\n<pre><code class=\"language-java\">import com.dindo.globallock.annotation.GlobalLock;\nimport com.dindo.globallock.enums.LockTimeoutStrategy;\n\n@GetMapping(&quot;useMultiKeyLock/{name}&quot;)\n@GlobalLock(keys = {&quot;#name&quot;, &quot;\'hello\'&quot;}, leaseTime = 2, lockTimeoutStrategy = LockTimeoutStrategy.FAST_FAIL)\npublic String useMultiKeyLock(@PathVariable String name){\n        return&quot;success&quot;;\n        }\n\n\n@GetMapping(&quot;useSingleKeyLock2&quot;)\n@GlobalLock(keys = {&quot;#name1&quot;, &quot;name2&quot;}, leaseTime = 2, lockTimeoutStrategy = LockTimeoutStrategy.FAST_FAIL)\npublic String useMultiKeyLock(String name1,String name2){\n        return&quot;success&quot;;\n        }\n\n\n@GetMapping(&quot;useSingleKeyLock3&quot;)\n@GlobalLock(keys = {&quot;#user.name&quot;, &quot;user.age&quot;}, leaseTime = 2, lockTimeoutStrategy = LockTimeoutStrategy.FAST_FAIL)\npublic String useMultiKeyLock(User user){\n        return&quot;success&quot;;\n        }\n\nstatic class User {\n  String name;\n  Integer age;\n}\n</code></pre>\n<p><a name=\"3be84a92\"></a></p>\n<h4 id=\"433-注解锁定\">4.3.3 注解锁定</h4>\n<pre><code class=\"language-java\">import com.dindo.globallock.annotation.GlobalLock;\nimport com.dindo.globallock.annotation.LockKey;\nimport com.dindo.globallock.enums.LockTimeoutStrategy;\n\n@GetMapping(&quot;useAnnotationKeyLock/{name}/{age}&quot;)\n@GlobalLock(leaseTime = 2, lockTimeoutStrategy = LockTimeoutStrategy.FAST_FAIL)\npublic String useAnnotationKeyLock(@PathVariable(&quot;name&quot;) @LockKey String name,@PathVariable(&quot;age&quot;) @LockKey Integer age){\n        return&quot;success&quot;;\n        }\n</code></pre>\n<p><a name=\"d1293d22\"></a></p>\n<h4 id=\"434-指定key前缀\">4.3.4 指定key前缀</h4>\n<pre><code class=\"language-java\">import com.dindo.globallock.annotation.GlobalLock;\nimport com.dindo.globallock.annotation.LockKey;\nimport com.dindo.globallock.enums.LockTimeoutStrategy;\n\n\n@GetMapping(&quot;usePrefixLock&quot;)\n@GlobalLock(name = &quot;usePrefixLock&quot;, lockTimeoutStrategy = LockTimeoutStrategy.FAST_FAIL)\npublic String usePrefixLock(@LockKey String name){\n        return&quot;success&quot;;\n        }\n</code></pre>\n<p><a name=\"922527b4\"></a></p>\n<h3 id=\"44-编程式\">4.4 编程式</h3>\n<pre><code class=\"language-java\">import com.dindo.globallock.provider.LockProvider;\nimport com.dindo.globallock.enums.LockType;\n\n@Resource\nprivate LockProvider lockProvider;\n\n@GetMapping(&quot;useProgrammaticallyLock&quot;)\npublic void useProgrammaticallyLock()throws Exception{\n\n        String lock=lockProvider.lock(&quot;useProgrammaticallyLock&quot;,LockType.REENTRANT,()-&gt;{\n\n        ThreadUtil.sleep(5,TimeUnit.SECONDS);\n\n        return&quot;success&quot;;\n\n        });\n\n        System.out.println(lock);\n        }\n</code></pre>\n<p><strong>重载方法：</strong></p>\n<pre><code class=\"language-java\">public interface LockProvider {\n\n  /**\n   * 加锁\n   *\n   * @param lockName       锁名称\n   * @param businessWorker 要执行的业务逻辑\n   * @return {@link T}\n   * @throws Exception 异常\n   */\n  default &lt;T&gt; T lock(String lockName, AcquiredLockWorker&lt;T&gt; businessWorker) throws Exception {\n    return this.lock(lockName, LockType.REENTRANT, businessWorker, 60, 60);\n  }\n\n  /**\n   * 加锁\n   *\n   * @param lockName       锁名称\n   * @param businessWorker 要执行的业务逻辑\n   * @param waitTime       等待时间\n   * @param leaseTime      租赁时间\n   * @return {@link T}\n   * @throws Exception 异常\n   */\n  default &lt;T&gt; T lock(String lockName, AcquiredLockWorker&lt;T&gt; businessWorker, long waitTime, long leaseTime) throws Exception {\n    return this.lock(lockName, LockType.REENTRANT, businessWorker, waitTime, leaseTime);\n  }\n\n  /**\n   * 加锁\n   *\n   * @param lockName       锁名称\n   * @param lockType       锁类型\n   * @param businessWorker 要执行的业务逻辑\n   * @return {@link T}\n   * @throws Exception 异常\n   */\n  default &lt;T&gt; T lock(String lockName, LockType lockType, AcquiredLockWorker&lt;T&gt; businessWorker) throws Exception {\n    return this.lock(lockName, lockType, businessWorker, 60, 60);\n  }\n\n  /**\n   * 加锁\n   *\n   * @param lockName       锁名称\n   * @param lockType       锁类型\n   * @param businessWorker 要执行的业务逻辑\n   * @param waitTime       等待时间\n   * @param leaseTime      租赁时间\n   * @return {@link T}\n   * @throws Exception 异常\n   */\n  &lt;T&gt; T lock(String lockName, LockType lockType, AcquiredLockWorker&lt;T&gt; businessWorker, long waitTime, long leaseTime) throws Exception;\n\n}\n</code></pre>\n', 1, '', 0, 0, 1, '2022-08-05 14:11:05', '2022-08-05 14:11:05');
INSERT INTO `tb_article` VALUES (278, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=9712', 'A005-自动加载-设计文档', '<p>| --- | --- | --- |<br />\n| <strong>更新日期</strong> | 2022年05月05日 | <strong>作        者</strong> | 张留杨 |<br />\n| <strong>保密等级</strong> | C | <strong>开放范围</strong> | 研发测试部 |</p>\n<p><strong>版本历史</strong></p>\n<table>\n<thead>\n<tr><th><strong>版        本</strong></th><th><strong>更新日期</strong></th><th><strong>作        者</strong></th><th><strong>备注</strong></th></tr>\n</thead>\n<tbody>\n<tr><td>1.0.0</td><td>2022年05月05日</td><td>张留杨</td><td>新建文档</td></tr>\n<tr><td> </td><td> </td><td> </td><td> </td></tr>\n</tbody>\n</table>\n<p><a name=\"ANR0d\"></a></p>\n<h2 id=\"业务背景\">业务背景</h2>\n', 1, '', 0, 0, 1, '2022-08-05 14:11:13', '2022-08-05 14:11:13');
INSERT INTO `tb_article` VALUES (279, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7665', 'A005-自动加载-使用手册', '<p>| --- | --- | --- |<br />\n| <strong>更新日期</strong> | 2022年05月05日 | <strong>作        者</strong> | 张留杨 |<br />\n| <strong>保密等级</strong> | C | <strong>开放范围</strong> | 研发测试部 |</p>\n<p><strong>版本历史</strong></p>\n<table>\n<thead>\n<tr><th><strong>版        本</strong></th><th><strong>更新日期</strong></th><th><strong>作        者</strong></th><th><strong>备注</strong></th></tr>\n</thead>\n<tbody>\n<tr><td>1.0.0</td><td>2022年05月05日</td><td>张留杨</td><td>新建文档</td></tr>\n<tr><td> </td><td> </td><td> </td><td> </td></tr>\n</tbody>\n</table>\n<p><a name=\"2f1c76f0\"></a></p>\n<h2 id=\"支持功能\">支持功能</h2>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;根据项目来自动加载所需策略实现</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;自动配置功能</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;提供基于注解的策略绑定加载器实现</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"checked\" disabled=\"disabled\" readonly=\"readonly\" />&nbsp;提供基于数据库的策略绑定加载器实现<br />\n<a name=\"gVCX1\"></a></li>\n</ul>\n<h2 id=\"版本记录\">版本记录</h2>\n<ul>\n<li>\n<p><code>**1.0.0-SANPSHOT**</code></p>\n<p>提供基于数据库的策略绑定加载机制<br />	提供基于注解的策略绑定加载机制<br />	提供自动配置功能<br />\n<a name=\"SOD9n\"></a></p>\n</li>\n</ul>\n<h2 id=\"使用示例\">使用示例</h2>\n<p><a href=\"https://git.ddysq.com/common/example/simple-example/-/tree/master/auto-loader-example\">auto-loader-example</a><br />\n<a name=\"nvuzj\"></a></p>\n<h2 id=\"快速开始\">快速开始</h2>\n<p><a name=\"62a1e713\"></a></p>\n<h3 id=\"引入依赖\">引入依赖</h3>\n<pre><code class=\"language-xml\">\n&lt;dependency&gt;\n  &lt;groupId&gt;com.dindo&lt;/groupId&gt;\n  &lt;artifactId&gt;auto-loader&lt;/artifactId&gt;\n  &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p><a name=\"U4CBu\"></a></p>\n<h3 id=\"配置文件\">配置文件</h3>\n<pre><code class=\"language-yaml\">auto-loader:\n	# 默认基于注解扫描的策略绑定加载器\n  support: defaultAnnotationScanStrategyBindingLoader\n  # 默认基于数据库的策略绑定加载器\n  # support: defaultDatabaseStrategyBindingLoader\n  # 自定义策略绑定加载器\n  # support: customStrategyBindingLoader\n</code></pre>\n<p><strong>特别说明：</strong></p>\n<ul>\n<li>使用注解扫描加载器只需在代码中显式声明即可</li>\n<li>使用数据库加载器需要引入<code>spring-boot-starter-jdbc</code> <code>mysql-connector-java</code>依赖。<br />\n<a name=\"Xtlah\"></a></li>\n</ul>\n<h3 id=\"策略提供\">策略提供</h3>\n<p><code>com.dindo.StrategyBinding.provider.StrategyProvider</code><br />所有的具体使用策略使用<code>StrategyProvider.apply</code>方法获取。</p>\n<pre><code class=\"language-java\">/**\n * 应用\n *\n * @param projectId    项目标识\n * @param strategyType 策略类型\n * @return {@link T}\n */\npublic &lt;T&gt; T apply(String projectId, Class&lt;T&gt; strategyType);\n</code></pre>\n<p><a name=\"50c40474\"></a></p>\n<h3 id=\"基于注解加载器\">基于注解加载器</h3>\n<p><a name=\"e80749d1\"></a></p>\n<h4 id=\"创建接口类\">创建接口类</h4>\n<pre><code class=\"language-java\">package com.dindo.example.autoloader.spi.annotation;\n\n/**\n * 简单打印spi\n *\n * @author zhangliuyang\n * @date 2022/04/29\n * @since 1.0.0\n */\npublic interface BasedOnAnnotationLoaderSpi {\n\n    /**\n     * 打印\n     *\n     * @param content 内容\n     */\n    void print(String content);\n\n}\n</code></pre>\n<p><a name=\"83b65d64\"></a></p>\n<h4 id=\"创建接口实现类策略一\">创建接口实现类策略一</h4>\n<pre><code class=\"language-java\">package com.dindo.example.autoloader.spi.annotation.strategy;\n\nimport com.dindo.autoloader.annotation.StrategyBinding;\nimport com.dindo.example.autoloader.spi.annotation.BasedOnAnnotationLoaderSpi;\nimport org.springframework.stereotype.Component;\n\n/**\n * 控制台打印策略\n *\n * @author zhangliuyang\n * @date 2022/04/29\n * @since 1.0.0\n */\n@StrategyBinding({&quot;2&quot;, &quot;4&quot;, &quot;6&quot;, &quot;8&quot;, &quot;10&quot;})\n@Component\npublic class ConsolePrintStrategy implements BasedOnAnnotationLoaderSpi {\n\n    /**\n     * 打印\n     *\n     * @param content 内容\n     */\n    @Override\n    public void print(String content) {\n        System.out.println(content);\n    }\n\n}\n</code></pre>\n<p><a name=\"4d0dae28\"></a></p>\n<h4 id=\"创建接口实现类策略二\">创建接口实现类策略二</h4>\n<pre><code class=\"language-java\">package com.dindo.example.autoloader.spi.annotation.strategy;\n\nimport com.dindo.autoloader.annotation.StrategyBinding;\nimport com.dindo.example.autoloader.spi.annotation.BasedOnAnnotationLoaderSpi;\nimport com.dindo.plugin.core.lang.log.Logger;\nimport com.dindo.plugin.core.lang.log.LoggerFactory;\nimport org.springframework.stereotype.Component;\n\n/**\n * 日志打印策略\n *\n * @author zhangliuyang\n * @date 2022/04/29\n * @since 1.0.0\n */\n@StrategyBinding({&quot;1&quot;, &quot;3&quot;, &quot;5&quot;, &quot;7&quot;, &quot;9&quot;})\n@Component\npublic class LoggerPrintStrategy implements BasedOnAnnotationLoaderSpi {\n\n   private static final Logger logger = LoggerFactory.getLogger(LoggerPrintStrategy.class);\n\n    /**\n     * 打印\n     *\n     * @param content 内容\n     */\n    @Override\n    public void print(String content) {\n        logger.info(content);\n    }\n\n}\n</code></pre>\n<p><strong>注意：</strong></p>\n<ul>\n<li>根据需求创建对应数量的接口实现策略类</li>\n<li>每个接口实现策略类上增加<code>@Component</code>或<code>@Service</code>注解，或通过其它方式确保类被注册到<code>Spring IOC</code>容器中</li>\n<li>每个接口实现策略类上增加<code>@StrategyBinding</code>注解，<code>value</code>为对应项目标识，或其它用来获取对应策略的标记</li>\n<li><code>@StrategyBinding</code>注解<code>value</code>为数组，可配置多个，但注意同一接口下实现类不能配置相同<br />\n<a name=\"8a237b03\"></a></li>\n</ul>\n<h4 id=\"开启配置\">开启配置</h4>\n<pre><code class=\"language-yaml\">auto-loader:\n  support: defaultAnnotationScanStrategyBindingLoader\n</code></pre>\n<p><a name=\"a653042e\"></a></p>\n<h4 id=\"使用方式\">使用方式</h4>\n<pre><code class=\"language-java\">import com.dindo.autoloader.provider.StrategyProvider;\n\n@Resource\nprivate StrategyProvider strategyProvider;\n\n\n@GetMapping(&quot;test-annotation/{projectId}/{content}&quot;)\npublic String testAnnotationAutoLoader(@PathVariable(&quot;projectId&quot;) String projectId,\n                                       @PathVariable(&quot;content&quot;) String content\n) {\n    BasedOnAnnotationLoaderSpi loaderSpi = strategyProvider.apply(projectId, BasedOnAnnotationLoaderSpi.class);\n    loaderSpi.print(content);\n  \n    return &quot;success&quot;;\n}\n</code></pre>\n<p><a name=\"22fd0193\"></a></p>\n<h3 id=\"基于数据库加载器\">基于数据库加载器</h3>\n<p><a name=\"62a1e713-1\"></a></p>\n<h4 id=\"引入依赖-1\">引入依赖</h4>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n		&lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;\n		&lt;version&gt;2.2.12.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n		&lt;groupId&gt;mysql&lt;/groupId&gt;\n		&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n		&lt;version&gt;8.0.22&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p><a name=\"289c9d6f\"></a></p>\n<h4 id=\"增加配置\">增加配置</h4>\n<pre><code class=\"language-yaml\">spring:\n  datasource:\n    url: jdbc:mysql://192.168.88.199:3406/auto_loader?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;transformedBitIsBoolean=true&amp;tinyInt1isBit=false&amp;allowMultiQueries=true&amp;serverTimezone=GMT%2B8&amp;allowPublicKeyRetrieval=true\n    username: root\n    password: ddhlok.COM\n    driver-class-name: com.mysql.cj.jdbc.Driver\n</code></pre>\n<p><a name=\"e80749d1-1\"></a></p>\n<h4 id=\"创建接口类-1\">创建接口类</h4>\n<pre><code class=\"language-java\">package com.dindo.example.autoloader.spi.database;\n\n/**\n * 基于数据库加载器spi\n *\n * @author zhangliuyang\n * @date 2022/04/29\n * @since 1.0.0\n */\npublic interface BasedOnDatabaseLoaderSpi {\n\n    /**\n     * 打印\n     *\n     * @param content 内容\n     */\n    void print(String content);\n\n}\n</code></pre>\n<p><a name=\"83b65d64-1\"></a></p>\n<h4 id=\"创建接口实现类策略一-1\">创建接口实现类策略一</h4>\n<pre><code class=\"language-java\">package com.dindo.example.autoloader.spi.database.strategy;\n\nimport com.dindo.example.autoloader.spi.database.BasedOnDatabaseLoaderSpi;\nimport com.dindo.plugin.core.lang.log.Logger;\nimport com.dindo.plugin.core.lang.log.LoggerFactory;\nimport org.springframework.stereotype.Component;\n\n/**\n * 错误级别打印策略\n *\n * @author zhangliuyang\n * @date 2022/04/29\n * @since 1.0.0\n */\n@Component\npublic class ErrorLevelPrintStrategy implements BasedOnDatabaseLoaderSpi {\n\n    private static final Logger logger = LoggerFactory.getLogger(ErrorLevelPrintStrategy.class);\n\n    /**\n     * 打印\n     *\n     * @param content 内容\n     */\n    @Override\n    public void print(String content) {\n        logger.error(content);\n    }\n\n}\n</code></pre>\n<p><a name=\"4d0dae28-1\"></a></p>\n<h4 id=\"创建接口实现类策略二-1\">创建接口实现类策略二</h4>\n<pre><code class=\"language-java\">package com.dindo.example.autoloader.spi.database.strategy;\n\nimport com.dindo.example.autoloader.spi.database.BasedOnDatabaseLoaderSpi;\nimport com.dindo.plugin.core.lang.log.Logger;\nimport com.dindo.plugin.core.lang.log.LoggerFactory;\nimport org.springframework.stereotype.Component;\n\n/**\n * 警告级别打印策略\n *\n * @author zhangliuyang\n * @date 2022/04/29\n * @since 1.0.0\n */\n@Component\npublic class WarnLevelPrintStrategy implements BasedOnDatabaseLoaderSpi {\n\n    private static final Logger logger = LoggerFactory.getLogger(WarnLevelPrintStrategy.class);\n\n    /**\n     * 打印\n     *\n     * @param content 内容\n     */\n    @Override\n    public void print(String content) {\n        logger.warn(content);\n    }\n\n}\n</code></pre>\n<p><strong>注意：</strong></p>\n<ul>\n<li>根据需求创建对应数量的接口实现策略类</li>\n<li>每个接口实现策略类上增加<code>@Component</code>或<code>@Service</code>注解，或通过其它方式确保类被注册到SpringIOC容器中<br />\n<a name=\"8a237b03-1\"></a></li>\n</ul>\n<h4 id=\"开启配置-1\">开启配置</h4>\n<pre><code class=\"language-yaml\">auto-loader:\n  support: defaultDatabaseStrategyBindingLoader\n</code></pre>\n<p><a name=\"a653042e-1\"></a></p>\n<h4 id=\"使用方式-1\">使用方式</h4>\n<pre><code class=\"language-java\">import com.dindo.autoloader.provider.StrategyProvider;\n\n@Resource\nprivate StrategyProvider strategyProvider;\n\n\n@GetMapping(&quot;test-database/{projectId}/{content}&quot;)\npublic String testDatabaseAutoLoader(@PathVariable(&quot;projectId&quot;) String projectId,\n                                     @PathVariable(&quot;content&quot;) String content\n) {\n    BasedOnDatabaseLoaderSpi loaderSpi = strategyProvider.apply(projectId, BasedOnDatabaseLoaderSpi.class);\n\n    loaderSpi.print(content);\n\n    return &quot;success&quot;;\n}\n</code></pre>\n<p><a name=\"ed6090f1\"></a></p>\n<h3 id=\"自定义加载器\">自定义加载器</h3>\n<p><a name=\"0528c8fb\"></a></p>\n<h4 id=\"实现策略绑定加载器接口\">实现策略绑定加载器接口</h4>\n<pre><code class=\"language-java\">package com.dindo.example.autoloader.spi.custom;\n\nimport com.dindo.autoloader.load.StrategyBindingLoader;\nimport com.dindo.autoloader.model.StrategyBinding;\nimport com.dindo.example.autoloader.spi.custom.strategy.PrefixAppendStrategy;\nimport com.dindo.example.autoloader.spi.custom.strategy.SuffixAppendStrategy;\nimport org.springframework.stereotype.Component;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 自定义策略绑定加载器\n *\n * @author zhangliuyang\n * @date 2022/04/29\n * @since 1.0.0\n */\n@Component\npublic class CustomStrategyBindingLoader implements StrategyBindingLoader {\n\n    /**\n     * 加载\n     *\n     * @return {@link List}&lt;{@link StrategyBinding}&gt;\n     */\n    @Override\n    public List&lt;StrategyBinding&gt; load() {\n        List&lt;StrategyBinding&gt; strategyBindings = new ArrayList&lt;&gt;();\n\n        int i = 0;\n        while (i &lt; 10) {\n            i++;\n            StrategyBinding strategyBinding = new StrategyBinding();\n            strategyBinding.setClassName(BasedOnCustomLoaderSpi.class.getName());\n            strategyBinding.setProjectId(String.valueOf(i));\n            if (i % 2 == 0) {\n                strategyBinding.setStrategyName(SuffixAppendStrategy.class.getName());\n            } else {\n                strategyBinding.setStrategyName(PrefixAppendStrategy.class.getName());\n            }\n\n            strategyBindings.add(strategyBinding);\n        }\n\n\n        return strategyBindings;\n    }\n\n}\n</code></pre>\n<p><strong>注意：</strong></p>\n<ul>\n<li>需要将自定义加载器注入到<code>Spring IOC</code>容器中</li>\n<li><code>bean</code>名称为<code>customStrategyBindingLoader</code></li>\n<li>以上知识示例，只要确保<code>return</code>一个正确的<code>List&lt;StrategyBinding&gt;</code>数据即可<br />\n<a name=\"e80749d1-2\"></a></li>\n</ul>\n<h4 id=\"创建接口类-2\">创建接口类</h4>\n<pre><code class=\"language-java\">package com.dindo.example.autoloader.spi.custom;\n\n/**\n * 基于自定义加载器spi\n *\n * @author zhangliuyang\n * @date 2022/04/29\n * @since 1.0.0\n */\npublic interface BasedOnCustomLoaderSpi {\n\n    /**\n     * 附加\n     *\n     * @param content 内容\n     * @return {@link String}\n     */\n    String append(String content);\n\n}\n</code></pre>\n<p><a name=\"83b65d64-2\"></a></p>\n<h4 id=\"创建接口实现类策略一-2\">创建接口实现类策略一</h4>\n<pre><code class=\"language-java\">package com.dindo.example.autoloader.spi.custom.strategy;\n\nimport com.dindo.example.autoloader.spi.custom.BasedOnCustomLoaderSpi;\nimport org.springframework.stereotype.Service;\n\n/**\n * 前缀附加策略\n *\n * @author zhangliuyang\n * @date 2022/04/29\n * @since 1.0.0\n */\n@Service\npublic class PrefixAppendStrategy implements BasedOnCustomLoaderSpi {\n\n    /**\n     * 附加\n     *\n     * @param content 内容\n     * @return {@link String}\n     */\n    @Override\n    public String append(String content) {\n        return &quot;prefix&quot; + content;\n    }\n\n}\n</code></pre>\n<p><a name=\"4d0dae28-2\"></a></p>\n<h4 id=\"创建接口实现类策略二-2\">创建接口实现类策略二</h4>\n<pre><code class=\"language-java\">package com.dindo.example.autoloader.spi.custom.strategy;\n\nimport com.dindo.example.autoloader.spi.custom.BasedOnCustomLoaderSpi;\nimport org.springframework.stereotype.Service;\n\n/**\n * 后缀附加策略\n *\n * @author zhangliuyang\n * @date 2022/04/29\n * @since 1.0.0\n */\n@Service\npublic class SuffixAppendStrategy implements BasedOnCustomLoaderSpi {\n\n    /**\n     * 附加\n     *\n     * @param content 内容\n     * @return {@link String}\n     */\n    @Override\n    public String append(String content) {\n        return content + &quot;suffix&quot;;\n    }\n\n}\n</code></pre>\n<p><strong>注意：</strong></p>\n<ul>\n<li>根据需求创建对应数量的接口实现策略类</li>\n<li>每个接口实现策略类上增加<code>@Component</code>或<code>@Service</code>注解，或通过其它方式确保类被注册到SpringIOC容器中<br />\n<a name=\"8a237b03-2\"></a></li>\n</ul>\n<h4 id=\"开启配置-2\">开启配置</h4>\n<pre><code class=\"language-yaml\">auto-loader:\n  support: customStrategyBindingLoader\n</code></pre>\n<p><a name=\"a653042e-2\"></a></p>\n<h4 id=\"使用方式-2\">使用方式</h4>\n<pre><code class=\"language-java\">import com.dindo.autoloader.provider.StrategyProvider;\n\n@Resource\nprivate StrategyProvider strategyProvider;\n\n\n@GetMapping(&quot;test-custom/{projectId}/{content}&quot;)\npublic String testCustomAutoLoader(@PathVariable(&quot;projectId&quot;) String projectId,\n                                   @PathVariable(&quot;content&quot;) String content\n) {\n    BasedOnCustomLoaderSpi loaderSpi = strategyProvider.apply(projectId, BasedOnCustomLoaderSpi.class);\n\n    return loaderSpi.append(content);\n}\n</code></pre>\n', 1, '', 0, 0, 1, '2022-08-05 14:11:17', '2022-08-05 14:11:17');
INSERT INTO `tb_article` VALUES (280, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=261', 'A006-分布式链路追踪-设计文档', '<p>| --- | --- | --- |<br />\n| <strong>更新日期</strong> | 2022年05月18日 | <strong>作        者</strong> | 张留杨 |<br />\n| <strong>保密等级</strong> | C | <strong>开放范围</strong> | 研发测试部 |</p>\n<p><strong>版本历史</strong></p>\n<table>\n<thead>\n<tr><th><strong>版        本</strong></th><th><strong>更新日期</strong></th><th><strong>作        者</strong></th><th><strong>备注</strong></th></tr>\n</thead>\n<tbody>\n<tr><td>1.0.0</td><td>2022年05月18日</td><td>张留杨</td><td>新建文档</td></tr>\n<tr><td> </td><td> </td><td> </td><td> </td></tr>\n</tbody>\n</table>\n<p><a name=\"lU1UC\"></a></p>\n<h2></h2>\n<p><a name=\"koLt2\"></a></p>\n<h2 id=\"skywalking工作模式\">SkyWalking 工作模式</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/12958500/1636436657387-c63c3df1-9787-4fc6-ab10-6551d78a7ba3.png#clientId=u0a0d1d33-4e3a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=541&amp;id=u7b0899e4&amp;margin=%5Bobject%20Object%5D&amp;name=%E5%9B%BE%E7%89%87.png&amp;originHeight=874&amp;originWidth=1086&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=49309&amp;status=done&amp;style=none&amp;taskId=u160e4030-7e1d-4919-a897-c7c88b98b42&amp;title=&amp;width=672\" alt=\"图片.png\" /><br />\n<a name=\"Co8KL\"></a></p>\n<h2 id=\"skywalking高可用模式\">Skywalking高可用模式</h2>\n<p><a name=\"KrhGr\"></a></p>\n<h3 id=\"skywalking-server-oap集群模式\">Skywalking-server-oap集群模式</h3>\n<ul>\n<li>使用nacos作为集群注册中心</li>\n<li>使用nacos作为动态配置中心</li>\n<li>使用elasticsearch7作为数据存储中心<br />\n<a name=\"S9afW\"></a></li>\n</ul>\n<h3 id=\"elasticsearch7集群模式\">Elasticsearch7集群模式</h3>\n<p>不采用已有elasticsearch业务集群，防止流量溢出，导致业务异常。</p>\n<ul>\n<li>基于eck部署elasticsearch集群<br />\n<a name=\"sehCZ\"></a></li>\n</ul>\n<h2 id=\"skywalking-agent\">skywalking-agent</h2>\n<ul>\n<li>基础镜像中增加agent代理</li>\n<li>启动命令中增加agent命令<br />\n<a name=\"xQYts\"></a></li>\n</ul>\n<h2 id=\"traceid\">traceId</h2>\n<ul>\n<li>tool包中增加相关依赖</li>\n<li>tool包中增加tid日志格式</li>\n</ul>\n', 1, '', 0, 0, 1, '2022-08-05 14:11:28', '2022-08-05 14:11:28');
INSERT INTO `tb_article` VALUES (281, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=433', 'A006-分布式链路追踪-接入手册', '<p>| --- | --- | --- |<br />\n| <strong>更新日期</strong> | 2022年05月18日 | <strong>作        者</strong> | 张留杨 |<br />\n| <strong>保密等级</strong> | C | <strong>开放范围</strong> | 研发测试部 |</p>\n<p><strong>版本历史</strong></p>\n<table>\n<thead>\n<tr><th><strong>版        本</strong></th><th><strong>更新日期</strong></th><th><strong>作        者</strong></th><th><strong>备注</strong></th></tr>\n</thead>\n<tbody>\n<tr><td>1.0.0</td><td>2022年05月18日</td><td>张留杨</td><td>新建文档</td></tr>\n<tr><td> </td><td> </td><td> </td><td> </td></tr>\n</tbody>\n</table>\n<p><a name=\"acyZY\"></a></p>\n<h2 id=\"1-修改dockerfile\">1. 修改<code>Dockerfile</code></h2>\n<ul>\n<li><strong>修改基础镜像</strong></li>\n</ul>\n<pre><code class=\"language-dockerfile\">FROM registry.cn-beijing.aliyuncs.com/ddysq/openjdk:1.0.0 \n</code></pre>\n<ul>\n<li><strong>修改启动命令�</strong></li>\n</ul>\n<pre><code class=\"language-dockerfile\">ENTRYPOINT [&quot;/usr/lib/jvm/java-1.8.0/bin/java&quot;, &quot;-javaagent:/root/app/apache-skywalking-apm-bin/skywalking-agent.jar&quot;, &quot;-Djava.security.egd=file:/dev/./urandom&quot;, &quot;-Xms4096m&quot;, &quot;-Xmx4096m&quot;, &quot;-Xss1m&quot;, &quot;-XX:+HeapDumpOnOutOfMemoryError&quot;, &quot;-Xmaxjitcodesize100m&quot;, &quot;-XX:+PrintGCDetails&quot;, &quot;-XX:+PrintGC&quot;, &quot;-XX:+DisableExplicitGC&quot;, &quot;-Xloggc:/data/nfs/gc.log&quot;, &quot;-XX:HeapDumpPath=/data/nfs/dump.hprof&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]\n</code></pre>\n<p><strong>注意：</strong></p>\n<blockquote>\n<p>启动命令中<code>&quot;-Xms4096m&quot;, &quot;-Xmx4096m&quot;</code>内存限制，可根据服务具体情况进行修改。</p>\n</blockquote>\n<p><a name=\"D4Vzk\"></a></p>\n<h2 id=\"2-增加环境变量\">2. 增加环境变量</h2>\n<ul>\n<li><code>SW_AGENT_NAME = **${Your_ApplicationName}**</code></li>\n<li>引入配置集：<code>skywalking-oap</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652944174356-b4de908f-13b3-4af6-87ae-9f3e9930b5f7.png#clientId=u44a15242-ca61-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=385&amp;id=uda0a65c8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=770&amp;originWidth=2364&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=460868&amp;status=done&amp;style=none&amp;taskId=u488f99b6-8889-42f8-9402-c9a2212dd5a&amp;title=&amp;width=1182\" alt=\"image.png\" /><br /><strong>注意：</strong></p>\n<blockquote>\n<p><code>**${Your_ApplicationName}**</code>为各应用名称。</p>\n</blockquote>\n<p><a name=\"VaDaZ\"></a></p>\n<h2><br /></h2>\n', 1, '', 0, 0, 1, '2022-08-05 14:11:28', '2022-08-05 14:11:28');
INSERT INTO `tb_article` VALUES (282, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5439', 'A006-分布式链路追踪-技术选型', '<p>| --- | --- | --- |<br />\n| <strong>更新日期</strong> | 2022年05月18日 | <strong>作        者</strong> | 张留杨 |<br />\n| <strong>保密等级</strong> | C | <strong>开放范围</strong> | 研发测试部 |</p>\n<p><strong>版本历史</strong></p>\n<table>\n<thead>\n<tr><th><strong>版        本</strong></th><th><strong>更新日期</strong></th><th><strong>作        者</strong></th><th><strong>备注</strong></th></tr>\n</thead>\n<tbody>\n<tr><td>1.0.0</td><td>2022年05月18日</td><td>张留杨</td><td>新建文档</td></tr>\n<tr><td> </td><td> </td><td> </td><td> </td></tr>\n</tbody>\n</table>\n<p><a name=\"xrpap\"></a></p>\n<h2 id=\"1-背景介绍\">1. 背景介绍</h2>\n<p>随着微服务架构的流行，一次请求往往需要涉及到多个服务，需要一些可以帮助理解系统行为、用于分析性能问题的工具，以便发生故障的时候，能够快速定位和解决问题。<br />单体架构中可以使用 <code>AOP</code> 在调用具体的业务逻辑前后分别打印一下时间即可计算出整体的调用时间，使用 <code>AOP</code> 来 <code>catch</code> 住异常也可知道是哪里的调用导致的异常。而针对于一个大型的几十个、几百个微服务构成的微服务架构系统，通常会遇到下面一些问题，比如：</p>\n<ul>\n<li>如何串联整个调用链路，快速定位问题？</li>\n<li>如何缕清各个微服务之间的依赖关系？</li>\n<li>如何进行各个微服务接口的性能分折？</li>\n<li>如何跟踪整个业务流程的调用处理顺序？<br />\n<a name=\"bBwWB\"></a></li>\n</ul>\n<h2 id=\"2-实现原理\">2. 实现原理</h2>\n<ul>\n<li>一个完整请求链路的追踪<code>ID</code>（<code>traceid</code>）用于查出本次请求调用的所有服务，每一次服务调用的跨度<code>ID</code>（<code>spanid</code>）用来记录调用顺序</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/2371410/1652842594012-cb82765e-abcb-4907-b4ed-13e68a2f8769.jpeg#clientId=u214049cf-2397-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=349&amp;id=u6dde8854&amp;margin=%5Bobject%20Object%5D&amp;originHeight=712&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufc8f4c4e-8dab-406c-a5ae-0e6490a9e04&amp;title=&amp;width=530\" alt=\"\" /></p>\n<ul>\n<li>上游服务<code>parenetid</code>用来记录调用的层级关系</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/2371410/1652842593909-dba03b9d-dc9b-4329-815b-8d395b66ff15.jpeg#clientId=u214049cf-2397-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=261&amp;id=ue24ba9c9&amp;margin=%5Bobject%20Object%5D&amp;originHeight=500&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7afd7896-b167-494f-a687-73f935efbcf&amp;title=&amp;width=563\" alt=\"\" /></p>\n<ul>\n<li>调用时间<code>timestamp</code>，把请求发出、接收、处理的时间都记录下来，计算业务处理耗时和网络耗时，然后用可视化界面展示出来每个调用链路，性能，故障</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/2371410/1652842593791-9e62e845-45fe-4ce7-bef1-d6dbc0f5b162.jpeg#clientId=u214049cf-2397-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=394&amp;id=u53d10cd1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=734&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udb09e6d6-8ebe-4bf2-b095-f26cf2239db&amp;title=&amp;width=580\" alt=\"\" /><br /><img src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/2371410/1652842594200-45225b83-995b-46a0-b1b9-e6f33b60625d.jpeg#clientId=u214049cf-2397-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=254&amp;id=u28f040a5&amp;margin=%5Bobject%20Object%5D&amp;originHeight=500&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufec10c6c-9dda-4d09-9088-32919ea0032&amp;title=&amp;width=548\" alt=\"\" /></p>\n<ul>\n<li>还可以记录一些其他信息，比如发起调用服务名称、被调服务名称、返回结果、<code>IP</code>、调用服务的名称等，最后，我们再把相同<code>spanid</code>的信息合成一个大的<code>span</code>块，就完成了一个完整的调用链。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/2371410/1652842593812-bd68525f-4460-4e16-bfb2-61a3eb8bdf35.jpeg#clientId=u214049cf-2397-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=562&amp;id=u65606278&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1114&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u64bd325b-1619-46f6-91e5-181b78867df&amp;title=&amp;width=545\" alt=\"\" /><br />\n<a name=\"WrMri\"></a></p>\n<h2 id=\"3-方案比较\">3. 方案比较</h2>\n<p>目前主流的链路追踪工具：<code>Google</code>的<code>Dapper</code>，阿里的鹰眼，大众点评的<code>CAT</code>，<code>Twitter</code>的<code>Zipkin</code>，<code>LINE</code>的<code>pinpoint</code>，国产的<code>skywalking</code>。</p>\n<ul>\n<li><code>**Zipkin**</code><strong>：</strong><code>Twitter</code>开源的调用链分析工具，目前基于<code>springcloud sleuth</code>得到了广泛的使用，特点是轻量，使用部署简单。</li>\n<li><code>**Pinpoint**</code>：韩国人开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，<code>UI</code>功能强大，接入端无代码侵入。</li>\n<li><code>**Skywalking**</code>：国产的优秀<code>APM</code>组件，是一个基于字节码注入的调用链分析，对<code>JAVA</code>分布式应用程序集群的业务运行情况进行追踪、告警和分析的系统。特点是支持多种插件，<code>UI</code>功能较强，接入端无代码侵入。目前已加入<code>Apache</code>孵化器。</li>\n<li><code>**CAT**</code>：大众点评开源的基于编码和配置的调用链分析，应用监控分析，日志采集，监控报警等一系列的监控平台工具。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652843847948-7c38bd42-0989-4907-a324-698399d242f8.png#clientId=u214049cf-2397-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=762&amp;id=uae0bcf5f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1524&amp;originWidth=1914&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=239396&amp;status=done&amp;style=none&amp;taskId=u915bf686-80e7-4b78-b907-6c95a635bd4&amp;title=&amp;width=957\" alt=\"image.png\" /><br /><strong>主要对比项 ：</strong></p>\n<ul>\n<li><strong>探针的性能</strong></li>\n</ul>\n<p>主要是<code>agent</code>对服务的吞吐量、<code>CPU</code>和内存的影响。微服务的规模和动态性使得数据收集的成本大幅度提高。 <code>skywalking</code>的探针对吞吐量的影响最小，<code>zipkin</code>的吞吐量居中。<code>pinpoint</code>的探针对吞吐量的影响较为明显。</p>\n<ul>\n<li><code>**collector**</code><strong>的可扩展性</strong></li>\n</ul>\n<p>能够水平扩展以便支持大规模服务器集群。 <code>zipkin</code>支持多个实例订阅<code>MQ</code>，异步消费监控信息。<code>skywalking</code>支持单机和集群模式，使用<code>gRPC</code>通信。</p>\n<ul>\n<li><strong>全面的调用链路数据分析</strong></li>\n</ul>\n<p>提供代码级别的可见性以便轻松定位失败点和瓶颈。 zipkin的链路监控粒度到接口级别。<code>skywalking</code> 支持众多的中间件、框架、类库。<code>pinpoint</code>数据分析最完备，提供代码级别的可见性以便轻松定位失败点和瓶颈。</p>\n<ul>\n<li><strong>对于开发透明，容易开关</strong></li>\n</ul>\n<p>添加新功能而无需修改代码，容易启用或者禁用。 <code>Zipkin</code>它要求在需要时修改代码。<code>skywalking</code>和<code>pinpoint</code>基于字节码增强的方式，不需要修改代码，并且可以收集到字节码中的更多精确的信息 。</p>\n<ul>\n<li><strong>完整的调用链应用拓扑</strong></li>\n</ul>\n<p>自动检测应用拓扑，帮助你搞清楚应用的架构。 <code>pinpoint</code>界面显示的更加丰富，具体到调用的<code>DB</code>名，<code>zipkin</code>的拓扑局限于服务于服务之间 。<br />\n<a name=\"Nn9ss\"></a></p>\n<h2 id=\"4-性能对比\">4. 性能对比</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652844333326-a2ed5a82-8a17-4d1e-aeed-e08e215a2aa5.png#clientId=u214049cf-2397-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u301bc83c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=369&amp;originWidth=708&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u71611395-26cc-4329-8765-36c9dd84614&amp;title=\" alt=\"\" /><br />图中蓝色代表未使用 <code>SkyWalking</code> 的表现，橙色代表使用了 <code>SkyWalking</code> 的表现，以上是在 <code>TPS</code> 为 <code>5000</code> 的情况下测出的数据，可以看出，不论是 <code>CPU</code>，内存，还是响应时间，使用 <code>SkyWalking</code> 带来的性能损耗几乎可以忽略不计。<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652844295092-8bff8a14-0860-42a3-bbed-a344768f47ad.png#clientId=u214049cf-2397-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=221&amp;id=u0156f5db&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=374&amp;originWidth=1240&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=290781&amp;status=done&amp;style=none&amp;taskId=u26782719-6a7f-42d5-afb4-8c8e3a583cb&amp;title=&amp;width=732\" alt=\"image.png\" /><br />模拟了三种并发用户：500，750，1000。使用** **jmeter 测试，每个线程发送30个请求，设置等待响应时间为10ms。使用的采样率为1，即100%。<code>pinpoint</code>默认的采样率为20，即50%，通过设置agent的配置文件改为100%。<code>zipkin</code>默认也是1。组合起来，一共有12种。<br />从上表可以看出，在三种链路监控组件中，<code>skywalking</code>的探针对吞吐量的影响最小，<code>zipkin</code>的吞吐量居中。<code>pinpoint</code>的探针对吞吐量的影响较为明显，在500并发用户时，测试服务的吞吐量从1385降低到774，影响很大。然后再看下<code>CPU</code>和<code>memory</code>的影响，在内部服务器进行的压测，对<code>CPU</code>和<code>memory</code>的影响都差不多在10%之内。<br />\n<a name=\"oDfGq\"></a></p>\n<h2 id=\"5-skywalking-简介\">5. SkyWalking 简介</h2>\n<p>分布式系统的应用程序性能监视工具，专为微服务、云原生架构和基于容器（Docker、K8s、Mesos）架构而设计。专门为微服务架构和云原生架构系统而设计并且支持分布式链路追踪的APM系统。通过加载探针以非侵入式的方式收集应用调用链路信息，并对采集的调用链路信息进行分析，生成应用间关系和服务间关系以及服务指标。目前支持多种语言，其中包括Java，.Net Core，Node.js和Go语言。<br />\n<a name=\"qtaJ1\"></a></p>\n<h2 id=\"6-skywalking-主要功能特性\">6. Skywalking 主要功能特性</h2>\n<ul>\n<li>多种监控手段，可以通过语言探针和service mesh获得监控的数据；</li>\n<li>支持多种语言自动探针，包括 Java，.NET Core 和 Node.JS；</li>\n<li>轻量高效，无需大数据平台和大量的服务器资源；</li>\n<li>模块化，UI、存储、集群管理都有多种机制可选；</li>\n<li>支持告警；</li>\n<li>优秀的可视化解决方案；<br />\n<a name=\"MXS4k\"></a></li>\n</ul>\n<h2 id=\"7-skywalking-架构\">7. Skywalking 架构</h2>\n<p>Skywalking 逻辑上分为四部分： 探针、 平台后端、存储和用户界面。<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652665754831-53509734-e9b9-4015-90b0-0e920ff519ba.png#clientId=u214049cf-2397-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=444&amp;id=jFrT8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=888&amp;originWidth=1928&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=749242&amp;status=done&amp;style=none&amp;taskId=u42d111ac-337f-46e0-82f5-fed741d743c&amp;title=&amp;width=964\" alt=\"image.png\" /></p>\n<ul>\n<li><strong>探针</strong>：基于不同的来源可能是不一样的， 但作用都是收集数据, 将数据格式化为 SkyWalking 适用的格式。</li>\n<li><strong>平台后端</strong>：支持数据聚合， 数据分析以及驱动数据流从探针到用户界面的流程。分析包括 Skywalking 原生追踪和性能指标以及第三方来源，包括 Istio 及 Envoy telemetry， Zipkin 追踪格式化等。 甚至可以使用 Observability Analysis Language 对原生度量指标 和 用于扩展度量的计量系统自定义聚合分析。</li>\n<li><strong>存储</strong>：通过开放的插件化的接口存放 SkyWalking 数据。可以选择一个既有的存储系统，ElasticSearch， H2 或 MySQL 集群。也可以选择自己实现一个存储系统。</li>\n<li>**UI：**一个基于接口高度定制化的Web系统，用户可以可视化查看和管理 SkyWalking 数据。</li>\n</ul>\n', 1, '', 0, 0, 1, '2022-08-05 14:11:28', '2022-08-05 14:11:28');
INSERT INTO `tb_article` VALUES (283, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=9215', 'A007-流量控制-设计文档', '<p>| --- | --- | --- |<br />\n| <strong>隔离策略</strong> | 信号量隔离（并发控制） | 线程池隔离/信号量隔离 | 信号量隔离 |<br />\n| <strong>熔断降级策略</strong> | 基于慢调用比例、异常比例、异常数 | 基于异常比例 | 基于异常比例、响应时间 |<br />\n| <strong>实时统计实现</strong> | 滑动窗口（LeapArray） | 滑动窗口（基于 RxJava） | Ring Bit Buffer |<br />\n| <strong>动态规则配置</strong> | 支持近十种动态数据源 | 支持多种数据源 | 有限支持 |<br />\n| <strong>扩展性</strong> | 多个扩展点 | 插件的形式 | 接口的形式 |<br />\n| <strong>基于注解的支持</strong> | 支持 | 支持 | 支持 |<br />\n| <strong>单机限流</strong> | 基于 QPS，支持基于调用关系的限流 | 有限的支持 | Rate Limiter |<br />\n| <strong>集群流控</strong> | 支持 | 不支持 | 不支持 |<br />\n| <strong>流量整形</strong> | 支持预热模式与匀速排队控制效果 | 不支持 | 简单的 Rate Limiter 模式 |<br />\n| <strong>系统自适应保护</strong> | 支持 | 不支持 | 不支持 |<br />\n| <strong>热点识别/防护</strong> | 支持 | 不支持 | 不支持 |<br />\n| <strong>多语言支持</strong> | Java/Go/C++ | Java | Java |<br />\n| <strong>Service Mesh 支持</strong> | 支持 Envoy/Istio | 不支持 | 不支持 |<br />\n| <strong>控制台</strong> | 提供开箱即用的控制台，可配置规则、实时监控、机器发现等 | 简单的监控查看 | 不提供控制台，可对接其它监控系统 |</p>\n', 1, '', 0, 0, 1, '2022-08-05 14:11:31', '2022-08-05 14:11:31');
INSERT INTO `tb_article` VALUES (284, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7078', 'A006-分布式链路追踪-使用手册', '<p>| --- | --- | --- |<br />\n| <strong>更新日期</strong> | 2022年05月23日 | <strong>作者</strong> | 张留杨 |<br />\n| <strong>保密等级</strong> | C | <strong>开放范围</strong> | 研发测试部 |</p>\n<p><strong>版本历史</strong></p>\n<table>\n<thead>\n<tr><th><strong>版本</strong></th><th><strong>更新日期</strong></th><th><strong>作者</strong></th><th><strong>备注</strong></th></tr>\n</thead>\n<tbody>\n<tr><td>1.0.0</td><td>2022年05月23日</td><td>张留杨</td><td>新建文档</td></tr>\n<tr><td> </td><td> </td><td> </td><td> </td></tr>\n</tbody>\n</table>\n<p><a name=\"QPsq0\"></a></p>\n<h2 id=\"1-模块介绍\">1. 模块介绍</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1653267496226-dff332ac-255a-486a-b37a-c97eda29394e.png#clientId=u994f2922-b4ce-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=652&amp;id=uda1ab0a9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1304&amp;originWidth=2764&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=986055&amp;status=done&amp;style=none&amp;taskId=u6a24df0c-0841-403f-ba05-c93ace6fd6d&amp;title=&amp;width=1382\" alt=\"image.png\" /></p>\n<ul>\n<li>**仪表盘：**监控全局、服务、实例、<code>endpoint</code>几个维度的运行状态。</li>\n<li>**拓扑图：**以拓扑图的方式展现服务直接的关系，并以此为入口查看告警、调用链、服务状态等信息</li>\n<li>**追踪：**以接口列表的方式展现，追踪接口内部调用过程，可以通过<code>traceid</code>查询，进行分布式集群的日志查看及问题排查。</li>\n<li>**性能剖析：**单独端点进行采样分析，并可查看堆栈信息。</li>\n<li>**日志：**包括了<code>browser</code>与<code>service</code>日志集合。</li>\n<li>**告警：**触发告警的告警列表，包括实例，请求超时等。<br />\n<a name=\"oIjgX\"></a></li>\n</ul>\n<h2 id=\"2-仪表盘\">2. 仪表盘</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1653273383805-81df89c9-aa89-4809-8714-1aea5cde8082.png#clientId=u994f2922-b4ce-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=696&amp;id=u9f1d4238&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1392&amp;originWidth=2910&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=355848&amp;status=done&amp;style=none&amp;taskId=u688bb01c-0b3b-4257-aedd-c08c827925c&amp;title=&amp;width=1455\" alt=\"image.png\" /></p>\n<ul>\n<li>第一栏：监控、数据库、容器、<code>vm</code></li>\n<li>第二栏：可以选择某个维度展示不同服务/实例/端点的数据</li>\n<li>第三栏：展示的不同维度，全局、服务、实例、端点的面板。<br />\n<a name=\"q5VO0\"></a></li>\n</ul>\n<h3 id=\"21-apm\">2.1 APM</h3>\n<p><a name=\"xK3N5\"></a></p>\n<h4 id=\"211-global\">2.1.1 Global</h4>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1653273616860-10cdabfe-081f-4750-bf30-c4f694c53f71.png#clientId=u994f2922-b4ce-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=696&amp;id=u49c635a1&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1392&amp;originWidth=2908&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=350463&amp;status=done&amp;style=none&amp;taskId=u40f56317-0306-4b52-b644-6a5b1436328&amp;title=&amp;width=1454\" alt=\"image.png\" /></p>\n<ul>\n<li><code>**Services load(CPM-callsperminute)**</code>：服务平均每分钟请求数。</li>\n<li><code>**Slow Services(ms)**</code>：慢响应服务，单位<code>ms</code>。</li>\n<li><code>**Un-Health services(Apdex)**</code><strong>：</strong><code>Apdex</code>性能指标，<code>1</code>为满分。</li>\n<li><code>**Slow Endpoints(ms)**</code>：全局维度的慢响应端点(<code>API</code>)。例如一个接口，是全局<code>TopN</code>的数据，通过这个可以观测平台性能情况。</li>\n<li><code>**Global Response Latency(percentileinms)**</code>：全局响应延迟百分位数统计，单位<code>ms</code>。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1653274112652-792c16d9-a136-4267-8b57-ab8f223e6990.png#clientId=u994f2922-b4ce-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=317&amp;id=u37a9a7f6&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=634&amp;originWidth=1474&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=308121&amp;status=done&amp;style=none&amp;taskId=u3cc6ca8f-ba97-4984-a733-039df8d87ee&amp;title=&amp;width=737\" alt=\"image.png\" /><br />\n:::warning<br />\n表示采集样本中某些值的占比，<code>Skywalking</code>有<code>**P50、P75、P90、P95、P99**</code>一些列值。<br /><strong>图中的</strong><code>**P99:950**</code><strong>表示</strong><code>**99%**</code><strong>请求的响应时间在</strong><code>**950ms**</code>**以内。**而<code>99%</code>一般用于抛掉一些极端值，表示绝大多数请求。<br />\n:::</p>\n<ul>\n<li><code>**GlobalHeatmap**</code>：服务响应时间热力分布图，根据时间段内不同响应时间的数量显示颜色深度<br />\n:::warning<br />\n可译为热力图、热度图都可以，<strong>图中颜色越深，表示请求数越多</strong>，这和<code>GitHubContributions</code>很像，<code>commit</code>越多，颜色越深。横坐标是响应时间，鼠标放上去，可以看到具体的数量。通过热力图，一方面可以直观感受平台的整体流量，另一方面也可以感受整体性能。<br />\n:::<br />\n<a name=\"sRJQL\"></a></li>\n</ul>\n<h4 id=\"212-service\">2.1.2 Service</h4>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1653274978834-ed8ed449-e42b-4af2-977a-8cde071db035.png#clientId=u994f2922-b4ce-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=697&amp;id=ua39fe55d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1394&amp;originWidth=2888&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=437120&amp;status=done&amp;style=none&amp;taskId=u9a029635-7c65-4b4c-93da-3d685efb4d4&amp;title=&amp;width=1444\" alt=\"image.png\" /></p>\n<ul>\n<li><code>**Service Apdex**</code>**(数字)：**当前服务的评分</li>\n<li><code>**Service Apdex**</code>**(折线图)：**一段时间内<code>Apdex</code>评分</li>\n<li><code>**Service Avg Response Times(ms)**</code>：平均响应延时，单位<code>ms</code></li>\n<li><code>**Service Response Time Percentile**</code>：百分比响应延时，参考<code>GlobalResponseLatency(percentileinms)</code></li>\n<li><code>**Successful Rate**</code>**(数字)：**请求成功率</li>\n<li><code>**Successful Rate**</code>**(折线图)：**一段时间的请求成功率</li>\n<li><code>**Servce Load(CPM/PPM)**</code>**(数字)：**每分钟请求数，</li>\n<li><code>**Servce Load(CPM/PPM)**</code>**(折线图)：**不同时间的每分钟请求数</li>\n<li><code>**Service Throughput(Bytes)**</code>**：**该指标只适用于TCP服务。当前服务的吞吐量。</li>\n<li><code>**Servce Instances Load(CPM/PPM)**</code>**：**每个服务实例的每分钟请求数</li>\n<li><code>**Show Service Instance**</code>**：**每个服务实例的最大延时</li>\n<li><code>**Service Instance Successful Rate**</code>**：**每个服务实例的请求成功率<br />\n<a name=\"jxwGP\"></a></li>\n</ul>\n<h4 id=\"213-instance\">2.1.3 Instance</h4>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1653275294229-9b9f19ef-6ba4-4371-aa80-016dd166e000.png#clientId=u994f2922-b4ce-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=696&amp;id=u648fe9db&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1392&amp;originWidth=2884&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1289747&amp;status=done&amp;style=none&amp;taskId=u6d7a714f-883e-494a-b0f7-2804092c7cc&amp;title=&amp;width=1442\" alt=\"image.png\" /></p>\n<ul>\n<li><code>**Service Instance Load(CPM/PPM)**</code>**：**当前实例的每分钟请求数</li>\n<li><code>**Service Instance Throughput(Bytes)**</code>**：**该指标只适用于<code>TCP</code>服务。当前服务实例的吞吐量。</li>\n<li><code>**Service Instance Successful Rate(%)**</code>**：**当前实例的请求成功率</li>\n<li><code>**Service Instance Latency(ms)**</code>**：**当前实例的响应延时</li>\n<li><code>**JVM CPU(Java Service)**</code><strong>：</strong><code>jvm</code>占用<code>CPU</code>的百分比</li>\n<li><code>**JVM Memory(Java Service)**</code><strong>：</strong><code>JVM</code>内存占用大小，单位<code>m</code>，包括堆内存，与堆外内存(直接内存)</li>\n<li><code>**JVM GC Time(ms)**</code><strong>：</strong><code>JVM</code>垃圾回收时间，包含<code>YGC</code>和<code>OGC</code></li>\n<li><code>**JVM GC Count**</code><strong>：</strong><code>JVM</code>垃圾回收次数，包含<code>YGC``和``OGC</code></li>\n<li><code>**JVM Thread Count**</code><strong>：</strong><code>JavaService</code></li>\n<li>其他参数为<code>.net</code>的东西<br />\n<a name=\"cyvyU\"></a></li>\n</ul>\n<h4 id=\"214-endpoint\">2.1.4 Endpoint</h4>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1653276505270-a231f708-9659-41ba-9af3-af020abe445c.png#clientId=ud391c3da-c71d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=694&amp;id=u6e8414e6&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1388&amp;originWidth=2894&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=968596&amp;status=done&amp;style=none&amp;taskId=u08fedf25-9ab2-4019-852f-7c39d915100&amp;title=&amp;width=1447\" alt=\"image.png\" /><br /><strong>整体端点：</strong></p>\n<ul>\n<li><code>**Endpoint Load in Current Service(CPM/PPM)**</code>：每个端点(<code>API</code>)每分钟请求数</li>\n<li><code>**Slow Endpoints in Current Service(ms)**</code>：每个端点(<code>API</code>)的最慢响应请求时间，单位<code>ms</code></li>\n<li><code>**Successful Rate in Current Service(%)**</code>：每个端点(<code>API</code>)的请求成功率</li>\n</ul>\n<p><strong>某个端点：</strong></p>\n<ul>\n<li><code>**Endpoint Load**</code>：当前端点每个时间段的请求数据</li>\n<li><code>**Endpoint Avg Response Time**</code>：当前端点每个时间段的请求行响应时间</li>\n<li><code>**Endpoint Response Time Percentile(ms)**</code>：当前端点每个时间段的响应时间占比</li>\n<li><code>**Endpoint Successful Rate(%)**</code>：当前端点每个时间段的请求成功率<br />\n<a name=\"VwSf5\"></a></li>\n</ul>\n<h3 id=\"22-database\">2.2 Database</h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1653276711652-7d2a8c89-5332-44c1-9e5d-175f16eefb05.png#clientId=ud391c3da-c71d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=650&amp;id=u28adb791&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1300&amp;originWidth=2744&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1103098&amp;status=done&amp;style=none&amp;taskId=uf5ccf8a4-9320-4a8f-8ce4-a58691b15c3&amp;title=&amp;width=1372\" alt=\"image.png\" /></p>\n<ul>\n<li><code>**Database Avg Response Time(ms)**</code>：当前数据库事件平均响应时间，单位ms</li>\n<li><code>**Database Access Successful Rate(%)**</code>：当前数据库访问成功率</li>\n<li><code>**Database Traffic(CPM：CallsPerMinute)**</code>：当前数据库每分钟请求数</li>\n<li><code>**Database Access Latency Percentile(ms)**</code>：数据库不同比例的响应时间，单位ms</li>\n<li><code>**Slow Statements(ms)**</code>：前N个慢查询，单位ms</li>\n<li><code>**All Database Loads(CPM：CallsPerMinute)**</code>：所有数据库中请求量排序</li>\n<li><code>**Un-Health Databases**</code>：所有数据库不健康排名，请求成功率排名，失败最多的请求在最上。<br />\n<a name=\"tCpRf\"></a></li>\n</ul>\n<h2 id=\"3-拓扑图\">3. 拓扑图</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1653276893318-dae806e6-13a3-4b3d-9683-e1defe15e98a.png#clientId=ud391c3da-c71d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=648&amp;id=u8a340e8f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1296&amp;originWidth=2756&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=909368&amp;status=done&amp;style=none&amp;taskId=u687effb9-b54a-4fdf-aca0-6341f1c4d21&amp;title=&amp;width=1378\" alt=\"image.png\" /></p>\n<ul>\n<li><code>**AllGroups**</code>**：**选择服务组</li>\n<li><code>**AllServices**</code>**：**选择服务</li>\n<li><code>**CreateGroup**</code>**：**创建新的服务组</li>\n<li>**服务引用拓扑图：**展示服务之间的调用关系，以及服务器的健康状态。<br />\n<a name=\"MApOW\"></a></li>\n</ul>\n<h3 id=\"31-实例信息面板\">3.1 实例信息面板</h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1653277055775-75eed823-1826-4d2a-b6b2-d2a75034e9fe.png#clientId=ud391c3da-c71d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=423&amp;id=uf7e2ad8a&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=846&amp;originWidth=1392&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=542291&amp;status=done&amp;style=none&amp;taskId=u2f9d7627-e47a-46e4-9102-4c4b8b3dc37&amp;title=&amp;width=696\" alt=\"image.png\" /><br /><strong>1-服务调用追踪</strong><br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1653277187770-a85d44b7-1a8b-445d-9f6e-847b89063ced.png#clientId=ud391c3da-c71d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=453&amp;id=u523fac11&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=906&amp;originWidth=1834&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1040232&amp;status=done&amp;style=none&amp;taskId=u06573b1b-5cec-4d11-ba94-30a950691b7&amp;title=&amp;width=917\" alt=\"image.png\" /></p>\n<ul>\n<li>当前服务：可选择具体服务</li>\n<li>当前端点：可选择具体端点</li>\n<li>当前深度：可以选择展示的调用深度</li>\n<li>平均响应时间</li>\n<li>平均吞吐量</li>\n<li>平均<code>SLA</code></li>\n<li>相应百分比</li>\n</ul>\n<p><strong>2-告警面板</strong><br /><strong>3-追踪信息面板</strong><br /><strong>4-服务实力性能状态面板</strong><br /><strong>5-Endpoint(API)面板</strong><br />\n<a name=\"xomOb\"></a></p>\n<h2 id=\"4-追踪\">4. 追踪</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1653277555830-4ab1b2a2-737e-4547-b532-2c810e123bbf.png#clientId=ud391c3da-c71d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=650&amp;id=uf463cb4d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1300&amp;originWidth=2734&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1060461&amp;status=done&amp;style=none&amp;taskId=ue807f5b1-83fc-47f5-b951-a46c0a301d9&amp;title=&amp;width=1367\" alt=\"image.png\" /><br />我们可以使用<code>trace</code>功能进行链路追踪，可以看见一个请求都走了那些服务中间件。并且能够看见各个服务器，某个端点某个步骤的耗时。<br />\n<a name=\"wgtnW\"></a></p>\n<h2 id=\"5-性能剖析\">5. 性能剖析</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1653284595073-58030964-c4e0-424b-85d4-d973767b6336.png#clientId=ud391c3da-c71d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=0.97&amp;from=paste&amp;height=471&amp;id=u7d5fa919&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=942&amp;originWidth=1917&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=111297&amp;status=done&amp;style=none&amp;taskId=u5c907ef4-0c21-4a38-86ba-fc338c49981&amp;title=&amp;width=959\" alt=\"image.png\" /><br />性能剖析主要的工作就是对不同的端点进行采样，然后提供一个更加详细的分析结果。<br />\n<a name=\"jNq5G\"></a></p>\n<h2 id=\"6-日志\">6. 日志</h2>\n<p>未启用<br />\n<a name=\"Q5cRF\"></a></p>\n<h2 id=\"7-告警\">7. 告警</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1653285880116-be4d4d3b-38eb-4354-b97e-42c7742761f5.png#clientId=ud391c3da-c71d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=696&amp;id=u86bf5af5&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1392&amp;originWidth=2896&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=794586&amp;status=done&amp;style=none&amp;taskId=ub2f659b6-e62d-4254-a0f3-c4708f7c834&amp;title=&amp;width=1448\" alt=\"image.png\" /><br /><strong>已配置告警规则：</strong></p>\n<ul>\n<li>服务的平均响应时间在最近10分钟内有3分钟超过1秒</li>\n<li>服务的成功率在最近10分钟内有2分钟低于80％</li>\n<li>实例的平均响应时间在最近10分钟内有2分钟超过1秒</li>\n<li>数据库的平均响应时间在最近10分钟内有2分钟超过1秒</li>\n<li>端点的平均响应时间在最近10分钟内有2分钟超过1秒</li>\n<li>服务在最近10分钟内有2分钟超过1秒平均响应时间超过1秒并且成功率低于80％<br />\n<a name=\"NApja\"></a></li>\n</ul>\n<h2 id=\"8-名词解释\">8. 名词解释</h2>\n<ul>\n<li><code>**CPM/PPM**</code>**：**对于<code>HTTP1/2</code>、<code>gRPC</code>、<code>RPC</code>服务，这意味着每分钟调用数(<code>CPM：CallsPerMinute</code>)，对于TCP服务，这意味着每分钟包数(<code>PPM：PacketsPerMinute</code>)</li>\n<li><code>**Endpoint**</code>**：**表示具体的服务，例如一个接口或一个定时任务。</li>\n<li>**标签：**我们可以通过<code>core/default/searchableTracesTages</code>中配置标记。<br />\n<a name=\"Fq48n\"></a></li>\n</ul>\n<h2 id=\"9-特殊说明\">9. 特殊说明</h2>\n<blockquote>\n<p><strong>如果监控平台正常启动，监控项目也接入，但是就是没有数据，请看看是否是时区问题。</strong></p>\n</blockquote>\n<p><a name=\"tEdiV\"></a></p>\n<h2 id=\"10-访问地址\">10. 访问地址</h2>\n<blockquote>\n<p><a href=\"http://t.monitor.ddysq.com/\">http://t.monitor.ddysq.com/</a><br />\nskywalking<br />\nDiSky2022#@ingDOYun#</p>\n</blockquote>\n<p><a name=\"GKma3\"></a></p>\n<h2 id=\"11-参考资料\">11. 参考资料</h2>\n', 1, '', 0, 0, 1, '2022-08-05 14:11:31', '2022-08-09 17:14:07');
INSERT INTO `tb_article` VALUES (285, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1289', '分布式链路追踪-部署文档', '<p><a name=\"Y8sbB\"></a></p>\n<h2 id=\"skywalking-oap\" tabindex=\"-1\">skywalking-oap</h2>\n<p><a name=\"AfmGs\"></a></p>\n<h3 id=\"%E5%88%9B%E5%BB%BAconfigmap\" tabindex=\"-1\">创建configmap</h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652862344954-0cd023f4-a4ae-46bf-ab11-78469c6a819b.png\" alt=\"image.png\" /></p>\n<pre><code class=\"language-properties\">SW_CLUSTER=nacos\nSW_SERVICE_NAME=skywalking_oap_cluster\nSW_CLUSTER_NACOS_HOST_PORT=localhost:8848\nSW_CLUSTER_NACOS_NAMESPACE=skywalking\nSW_CLUSTER_NACOS_USERNAME=nacos\nSW_CLUSTER_NACOS_PASSWORD=nacos\n\nSW_CORE_RECORD_DATA_TTL=2\nSW_CORE_METRICS_DATA_TTL=3\n\nSW_SERVICE_NAME_MAX_LENGTH=70\nSW_INSTANCE_NAME_MAX_LENGTH=70\nSW_ENDPOINT_NAME_MAX_LENGTH=150\n\nSW_STORAGE=elasticsearch7\nSW_NAMESPACE=sw\nSW_STORAGE_ES_CLUSTER_NODES=127.0.0.1:9200\nSW_STORAGE_ES_HTTP_PROTOCOL=http\nSW_STORAGE_ES_INDEX_REPLICAS_NUMBER=1\n\nSW_CONFIGURATION=nacos\nSW_CONFIG_NACOS_SERVER_ADDR=127.0.0.1\nSW_CONFIG_NACOS_SERVER_PORT=8848\nSW_CONFIG_NACOS_SERVER_GROUP=DEFAULT_GROUP\nSW_CONFIG_NACOS_SERVER_NAMESPACE=skywalking\nSW_CONFIG_NACOS_PERIOD=60\nSW_CONFIG_NACOS_USERNAME=nacos\nSW_CONFIG_NACOS_PASSWORD=nacos\n</code></pre>\n<p><a name=\"d9Cei\"></a></p>\n<h3 id=\"%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8\" tabindex=\"-1\">创建应用</h3>\n<ul>\n<li>应用名称：<code>skywalking-oap</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652863430299-0e62b2ee-c1ae-4230-8df9-f45d3a9389ca.png#clientId=ub62f643a-96c1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=570&amp;id=u5d14c0ea&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1140&amp;originWidth=2432&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=635385&amp;status=done&amp;style=none&amp;taskId=u79718975-24a6-4d57-aa09-1836728ed84&amp;title=&amp;width=1216\" alt=\"image.png\" /><br />\n<a name=\"YcfOB\"></a></p>\n<h3 id=\"%E9%83%A8%E7%BD%B2%E8%AE%BE%E7%BD%AE\" tabindex=\"-1\">部署设置</h3>\n<ul>\n<li>部署名称：<code>skywalking-oap</code></li>\n<li>副本数：<code>3</code></li>\n<li>升级策略：滚动升级</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652863404032-90a9827e-e5dc-464a-ae21-b33d8eb212ee.png#clientId=ub62f643a-96c1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=350&amp;id=u0e8a5f4f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=700&amp;originWidth=2348&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=118268&amp;status=done&amp;style=none&amp;taskId=u85d31eb4-4595-4e64-9f5c-a9e363043f5&amp;title=&amp;width=1174\" alt=\"image.png\" /><br />\n<a name=\"eaNrx\"></a></p>\n<h3 id=\"%E5%AE%B9%E5%99%A8%E8%AE%BE%E7%BD%AE\" tabindex=\"-1\">容器设置</h3>\n<ul>\n<li>镜像名称：<code>apache/skywalking-oap-server:8.6.0-es7</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652863558024-12d9c574-399c-4a66-aa85-70390862c539.png#clientId=ub62f643a-96c1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=491&amp;id=u824283e5&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=982&amp;originWidth=2356&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=199961&amp;status=done&amp;style=none&amp;taskId=u219ed051-7bb5-4d2d-b09c-d2a8fb847ef&amp;title=&amp;width=1178\" alt=\"image.png\" /></p>\n<ul>\n<li>CPU限制：<code>1C</code></li>\n<li>内存限制：<code>2G</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652863618060-4ad4d5f4-a431-49a2-9b98-c0e7c09d2b47.png#clientId=ub62f643a-96c1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=436&amp;id=u7146eab1&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=872&amp;originWidth=2348&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=174932&amp;status=done&amp;style=none&amp;taskId=ud0f7f610-0287-4168-b324-41b186daf6d&amp;title=&amp;width=1174\" alt=\"image.png\" /></p>\n<ul>\n<li>环境变量\n<ul>\n<li>配置集：<code>skywalking-oap</code></li>\n<li>字段引用：<code>SW_CORE_REST_HOST=status.podIP</code></li>\n<li>字段引用：<code>SW_CORE_GRPC_HOST=status.podIP</code></li>\n<li>自定义输入：<code>JAVA_OPTS=-Xms2g -Xmx2g</code></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652863676843-fa8b4ec0-d345-4718-8c46-35ee73db7d60.png#clientId=ub62f643a-96c1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=389&amp;id=uf8a74ca3&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=778&amp;originWidth=2328&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=486832&amp;status=done&amp;style=none&amp;taskId=u42694fdc-4674-40c5-bf5b-006f7414886&amp;title=&amp;width=1164\" alt=\"image.png\" /></p>\n<ul>\n<li>容器端口\n<ul>\n<li>11800/TCP</li>\n<li>12800/TCP</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652863894167-eff53a19-f0f6-4e73-b286-6d7fba4d4ff6.png#clientId=ub62f643a-96c1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=223&amp;id=u2b62c2a6&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=446&amp;originWidth=2356&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=221243&amp;status=done&amp;style=none&amp;taskId=ucee18b89-a8c4-40db-9f38-855345c5ce7&amp;title=&amp;width=1178\" alt=\"image.png\" /></p>\n<ul>\n<li>健康检查\n<ul>\n<li>存活检查\n<ul>\n<li>检查方式：<code>TCP</code></li>\n<li>端口：<code>12800</code></li>\n<li>初始化等待时间：<code>15</code></li>\n<li>超时时间：<code>1</code></li>\n<li>检测间隔时间：<code>20</code></li>\n<li>最小检查失败次数：<code>15</code></li>\n<li>最小检查成功次数：<code>1</code></li>\n</ul>\n</li>\n<li>就绪检查\n<ul>\n<li>检查方式：<code>TCP</code></li>\n<li>端口：<code>12800</code></li>\n<li>初始化等待时间：<code>15</code></li>\n<li>超时时间：<code>1</code></li>\n<li>检测间隔时间：<code>20</code></li>\n<li>最小检查失败次数：<code>3</code></li>\n<li>最小检查成功次数：<code>1</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652864163893-eef1ada9-a541-4368-b238-bb91261dff30.png#clientId=ub62f643a-96c1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=526&amp;id=u4c0deb29&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1052&amp;originWidth=2420&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=192743&amp;status=done&amp;style=none&amp;taskId=u9f6a30e4-cecd-42c5-8a35-23910cac41b&amp;title=&amp;width=1210\" alt=\"image.png\" /><br />\n<a name=\"KEzYB\"></a></p>\n<h3 id=\"%E6%9C%8D%E5%8A%A1%E8%AE%BE%E7%BD%AE\" tabindex=\"-1\">服务设置</h3>\n<ul>\n<li>关联工作负载：<code>skywalking-oap</code></li>\n<li>服务名称：<code>skywalking-oap</code></li>\n<li>服务类型：<code>集群IP</code></li>\n<li>服务端口\n<ul>\n<li><code>11800/11800/TCP</code></li>\n<li><code>12800/12800/TCP</code></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652864347517-812535e8-643d-4e22-8cfe-09df84e2464c.png#clientId=ub62f643a-96c1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=520&amp;id=uebb8b4bc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1040&amp;originWidth=2448&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=200021&amp;status=done&amp;style=none&amp;taskId=u8bf3d3c1-5e53-4137-bb21-0e59d6b06f8&amp;title=&amp;width=1224\" alt=\"image.png\" /><br />\n<a name=\"NB6LB\"></a></p>\n<h2 id=\"skywalking-ui\" tabindex=\"-1\">skywalking-ui</h2>\n<p><a name=\"jEUIZ\"></a></p>\n<h3 id=\"%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8-1\" tabindex=\"-1\">创建应用</h3>\n<ul>\n<li>应用名称：<code>skywalking-ui</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652864584319-f34d2597-2311-49c7-8274-4634e52461d0.png#clientId=ub62f643a-96c1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=484&amp;id=u7fb9a759&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=968&amp;originWidth=2434&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=155606&amp;status=done&amp;style=none&amp;taskId=u04e28d2d-d0ca-4070-b3af-29e98d3af71&amp;title=&amp;width=1217\" alt=\"image.png\" /><br />\n<a name=\"z138l\"></a></p>\n<h3 id=\"%E9%83%A8%E7%BD%B2%E8%AE%BE%E7%BD%AE-1\" tabindex=\"-1\">部署设置</h3>\n<ul>\n<li>部署名称：<code>skywalking-ui</code></li>\n<li>副本数：<code>2</code></li>\n<li>升级策略：滚动升级</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652864698197-6aae35fc-60ff-4156-a7d7-c7c33b35016f.png#clientId=ub62f643a-96c1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=340&amp;id=u186c8035&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=680&amp;originWidth=2248&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=113414&amp;status=done&amp;style=none&amp;taskId=uc9e98553-59a9-4bc6-a76d-bcabe6a21f9&amp;title=&amp;width=1124\" alt=\"image.png\" /><br />\n<a name=\"vj4Sl\"></a></p>\n<h3 id=\"%E5%AE%B9%E5%99%A8%E8%AE%BE%E7%BD%AE-1\" tabindex=\"-1\">容器设置</h3>\n<ul>\n<li>镜像名称：<code>apache/skywalking-ui:8.5.0</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652864793806-912c7850-e70a-44a6-bbd0-d1d97f60cd2f.png#clientId=ub62f643a-96c1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=333&amp;id=u3b237523&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=666&amp;originWidth=2356&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=136264&amp;status=done&amp;style=none&amp;taskId=u13308fd5-8a56-4a8d-9e88-b2d243fec81&amp;title=&amp;width=1178\" alt=\"image.png\" /></p>\n<ul>\n<li>CPU限制：<code>1C</code></li>\n<li>内存限制：<code>2G</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652864853344-c82fe3d2-7f15-44d3-a458-2c20a666f865.png#clientId=ub62f643a-96c1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=341&amp;id=uc068d120&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=682&amp;originWidth=2332&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=145423&amp;status=done&amp;style=none&amp;taskId=u3a72e763-a836-44e5-844a-c77398a29f7&amp;title=&amp;width=1166\" alt=\"image.png\" /></p>\n<ul>\n<li>环境变量：<code>SW_OAP_ADDRESS=skywalking-oap:12800</code></li>\n<li>容器端口：<code>8080/TCP</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652864983577-64509730-ccbd-4076-92ef-d1a9fa55f326.png#clientId=ub62f643a-96c1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=382&amp;id=ucabbbaad&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=764&amp;originWidth=2340&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=148175&amp;status=done&amp;style=none&amp;taskId=u5db1782c-c74b-43f3-a624-a2815b2aefe&amp;title=&amp;width=1170\" alt=\"image.png\" /><br />\n<a name=\"yBgIC\"></a></p>\n<h3 id=\"%E6%9C%8D%E5%8A%A1%E8%AE%BE%E7%BD%AE-1\" tabindex=\"-1\">服务设置</h3>\n<ul>\n<li>关联工作负载：<code>skywalking-ui</code></li>\n<li>服务名称：<code>skywalking-ui</code></li>\n<li>服务类型：<code>集群IP</code></li>\n<li>服务端口：<code>80/8080/TCP</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2371410/1652865107676-408e9c7e-05b9-468d-9643-e4209c9e415c.png#clientId=ub62f643a-96c1-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=512&amp;id=uf2d5bc6f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1024&amp;originWidth=2428&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=203341&amp;status=done&amp;style=none&amp;taskId=ue27f358d-2aa0-4e22-92f6-7a5411df429&amp;title=&amp;width=1214\" alt=\"image.png\" /><br />\n<a name=\"Ykf4N\"></a></p>\n<h2 id=\"skywalking-agent\" tabindex=\"-1\">skywalking-agent</h2>\n<ul>\n<li>创建<code>skywalking-agent</code>配置集</li>\n</ul>\n<pre><code class=\"language-properties\">SW_AGENT_NAMESPACE=dindo-test\nSW_AGENT_CLASS_CACHE_MODE=MEMORY\nSW_LOGGING_LEVEL=INFO\nSW_BACKEND_SERVICE=skywalking-oap:11800\nSW_MOUNT_FOLDERS=plugins,activations\nSW_JDBC_TRACE_SQL_PARAMETERS=false\nSW_SPRINGMVC_COLLECT_HTTP_PARAMS=false\nSW_HTTPCLIENT_COLLECT_HTTP_PARAMS=false\nSW_LOGGING_FILE_NAME=skywalking-api.log\nSW_AGENT_TRACE_IGNORE_PATH=/actuator/**,/nacos/**,/api/core/heartbeat/probe,{GET}/api/core/heartbeat/probe,UndertowDispatch\nSW_AGENT_SAMPLE=500\n</code></pre>\n<p><a name=\"K3Kxf\"></a></p>\n<h2 id=\"elasticsearch\" tabindex=\"-1\">elasticsearch</h2>\n<ul>\n<li><code>**elasticsearch.yml**</code></li>\n</ul>\n<pre><code class=\"language-yaml\">cluster.name: skywalking-es7-cluster\nnode.name: skywalking-es7-cluster-node-1\npath.data: /data/ddserver/skywalking-es7-cluster/node-1/data\npath.logs: /data/ddserver/skywalking-es7-cluster/node-1/logs\nbootstrap.memory_lock: false\nnetwork.host: 172.16.33.4\nhttp.port: 19200\ndiscovery.seed_hosts: [&quot;172.16.33.4&quot;]\ncluster.initial_master_nodes: [&quot;skywalking-es7-cluster-node-1&quot;]\nhttp.cors.enabled: true\nhttp.cors.allow-origin: &quot;*&quot;\nhttp.cors.allow-methods: OPTIONS, HEAD, GET, POST, PUT, DELETE\nhttp.cors.allow-headers: &quot;X-Requested-With, Content-Type, Content-Length, X-User&quot;\n</code></pre>\n<ul>\n<li><code>**jvm.options**</code></li>\n</ul>\n<pre><code class=\"language-\">-Xms512m\n-Xmx512m\n</code></pre>\n<p><a name=\"fBTLt\"></a></p>\n<h2 id=\"%E5%91%8A%E8%AD%A6%E9%85%8D%E7%BD%AE\" tabindex=\"-1\">告警配置</h2>\n<ul>\n<li><code>**alarm-settings.yml**</code></li>\n</ul>\n<pre><code class=\"language-yaml\">rules:\n  service_resp_time_rule:\n    metrics-name: service_resp_time\n    op: &quot;&gt;&quot;\n    threshold: 1000\n    period: 10\n    count: 3\n    silence-period: 5\n    message: 服务【{name}】的平均响应时间在最近10分钟内有3分钟超过1秒\n  service_sla_rule:\n    metrics-name: service_sla\n    op: &quot;&lt;&quot;\n    threshold: 8000\n    period: 10\n    count: 2\n    silence-period: 3\n    message: 服务【{name}】的成功率在最近10分钟内有2分钟低于80％\n  service_instance_resp_time_rule:\n    metrics-name: service_instance_resp_time\n    op: &quot;&gt;&quot;\n    threshold: 1000\n    period: 10\n    count: 2\n    silence-period: 5\n    message: 实例【{name}】的平均响应时间在最近10分钟内有2分钟超过1秒\n  database_access_resp_time_rule:\n    metrics-name: database_access_resp_time\n    threshold: 1000\n    op: &quot;&gt;&quot;\n    period: 10\n    count: 2\n    message: 数据库【{name}】的平均响应时间在最近10分钟内有2分钟超过1秒\n  endpoint_relation_resp_time_rule:\n    metrics-name: endpoint_relation_resp_time\n    threshold: 1000\n    op: &quot;&gt;&quot;\n    period: 10\n    count: 2\n    message: 端点【{name}】的平均响应时间在最近10分钟内有2分钟超过1秒\ncomposite-rules:\n  comp_rule:\n    expression: service_resp_time_rule &amp;&amp; service_sla_rule\n    message: 服务【{name}】在最近10分钟内有2分钟超过1秒平均响应时间超过1秒并且成功率低于80％\n\nwechatHooks:\n  textTemplate: |-\n    {\n      &quot;msgtype&quot;: &quot;text&quot;,\n      &quot;text&quot;: {\n        &quot;content&quot;: &quot;&lt;&lt;测试环境&gt;&gt;SkyWalking 告警: \\n %s.&quot;\n      }\n    }\n  webhooks:\n    - https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=656acdd2-cae5-439b-9a72-fc347092204f\n</code></pre>\n', 1, '', 0, 0, 1, '2022-08-05 14:11:31', '2022-08-05 15:40:14');
INSERT INTO `tb_article` VALUES (286, 1, 15, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8998', '消息队列客户端-MQTT', '<p><a name=\"AAFKl\"></a></p>\n<h2 id=\"1.-mqtt%E7%AE%80%E4%BB%8B\" tabindex=\"-1\">1. MQTT简介</h2>\n<p><code>MQTT</code>（<code>MessageQueuingTelemetryTransport</code>，消息队列遥测传输协议）是一种基于发布/订阅（<code>publish</code>/<code>subscribe</code>）模式的“轻量级”通讯协议，该协议构建于<code>TCP/IP</code>协议上，由IBM在1999年发布。<br />MQTT最大优点在于，作为一种低开销、低带宽占用的即时通讯协议，<strong>可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务</strong>。使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p>\n<blockquote>\n<p><code>TCP/IP</code>参考模型可以分为四层：应用层、传输层、网络层、链路层。<code>TCP</code>和<code>UDP</code>位于传输层，应用层常见的协议有<code>HTTP</code>、<code>FTP</code>、<code>SSH</code>等。<code>**MQTT**</code><strong>协议运行于</strong><code>**TCP**</code>**之上，属于应用层协议，**因此只要是支持<code>TCP/IP</code>协议栈的地方，都可以使用<code>MQTT</code>。</p>\n</blockquote>\n<p><a name=\"OsNP2\"></a></p>\n<h2 id=\"2.-mqtt%E7%89%B9%E6%80%A7\" tabindex=\"-1\">2. MQTT特性</h2>\n<ul>\n<li>使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合；</li>\n<li>对负载内容屏蔽的消息传输；</li>\n<li>使用<code>TCP/IP</code>提供网络连接；</li>\n<li>小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量；</li>\n<li>使用<code>LastWill</code>和<code>Testament</code>特性（最后遗嘱）通知有关各方客户端异常中断的机制。<br />\n<a name=\"GDjPd\"></a></li>\n</ul>\n<h2 id=\"3.-mqtt%E6%9C%AF%E8%AF%AD\" tabindex=\"-1\">3. MQTT术语</h2>\n<p><a name=\"OlGfa\"></a></p>\n<h3 id=\"3.1-%E5%BA%94%E7%94%A8%E6%B6%88%E6%81%AFapplicationmessage\" tabindex=\"-1\">3.1 应用消息<code>ApplicationMessage</code></h3>\n<ul>\n<li><code>MQTT</code>协议通过网络传输应用数据；</li>\n<li>应用消息通过<code>MQTT</code>传输时，它们有关联的服务质量（<code>QoS</code>）和主题（<code>Topic</code>）。<br />\n<a name=\"HaivK\"></a></li>\n</ul>\n<h3 id=\"3.2-%E5%AE%A2%E6%88%B7%E7%AB%AFclient\" tabindex=\"-1\">3.2 客户端<code>Client</code></h3>\n<p>使用<code>MQTT</code>的程序或设备。客户端总是通过网络连接到服务端。它可以：</p>\n<ul>\n<li>发布应用消息给其它相关的客户端；</li>\n<li>订阅以请求接受相关的应用消息；</li>\n<li>取消订阅以移除接受应用消息的请求；</li>\n<li>从服务端断开连接。<br />\n<a name=\"C429T\"></a></li>\n</ul>\n<h3 id=\"3.3-%E6%9C%8D%E5%8A%A1%E7%AB%AFserver\" tabindex=\"-1\">3.3 服务端<code>Server</code></h3>\n<p>一个程序或设备，作为发送消息的客户端和请求订阅的客户端之间的中介。它可以：</p>\n<ul>\n<li>服务端接受来自客户端的网络连接；</li>\n<li>接受客户端发布的应用消息；</li>\n<li>处理客户端的订阅和取消订阅请求；</li>\n<li>转发应用消息给符合条件的已订阅客户端。<br />\n<a name=\"VFTs7\"></a></li>\n</ul>\n<h3 id=\"3.4-%E8%AE%A2%E9%98%85subscription\" tabindex=\"-1\">3.4 订阅<code>Subscription</code></h3>\n<ul>\n<li>订阅包含一个主题过滤器（<code>TopicFilter</code>）和一个最大的服务质量（<code>QoS</code>）等级；</li>\n<li>订阅与单个会话（<code>Session</code>）关联；</li>\n<li>会话可以包含多于一个的订阅。会话的每个订阅都有一个不同的主题过滤器。<br />\n<a name=\"Zco3s\"></a></li>\n</ul>\n<h3 id=\"3.5-%E4%B8%BB%E9%A2%98%E5%90%8Dtopicname\" tabindex=\"-1\">3.5 主题名<code>TopicName</code></h3>\n<ul>\n<li>附加在应用消息上的一个标签，服务端已知且与订阅匹配；</li>\n<li>服务端发送应用消息的一个副本给每一个匹配的客户端订阅。<br />\n<a name=\"hTgTD\"></a></li>\n</ul>\n<h3 id=\"3.6-%E4%B8%BB%E9%A2%98%E8%BF%87%E6%BB%A4%E5%99%A8topicfilter\" tabindex=\"-1\">3.6 主题过滤器<code>TopicFilter</code></h3>\n<ul>\n<li>订阅中包含的一个表达式，用于表示相关的一个或多个主题；</li>\n<li>主题过滤器可以使用通配符。<br />\n<a name=\"BqggD\"></a></li>\n</ul>\n<h3 id=\"3.7-%E4%BC%9A%E8%AF%9Dsession\" tabindex=\"-1\">3.7 会话<code>Session</code></h3>\n<ul>\n<li>客户端和服务端之间的状态交互；</li>\n<li>一些会话持续时长与网络连接一样，另一些可以在客户端和服务端的多个连续网络连接间扩展。<br />\n<a name=\"hvOVw\"></a></li>\n</ul>\n<h3 id=\"3.8-%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87mqttcontrolpacket\" tabindex=\"-1\">3.8 控制报文<code>MQTTControlPacket</code></h3>\n<ul>\n<li>通过网络连接发送的信息数据包；</li>\n<li><code>MQTT</code>规范定义了十四种不同类型的控制报文，其中一个（<code>PUBLISH</code>报文）用于传输应用消息。<br />\n<a name=\"tlXSd\"></a></li>\n</ul>\n<h2 id=\"4.-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%BB%E9%A2%98\" tabindex=\"-1\">4. 什么是主题</h2>\n<p><code>MQTT</code>协议通过网络传输应用消息，应用消息通过<code>MQTT</code>传输时，它们有关联的服务质量（<code>QoS</code>）和主题（<code>Topic</code>）。主题本质上是一个字符串，<code>MQTT</code>协议规定主题是<code>UTF-8</code>编码的字符串，这意味着，主题过滤器和主题名的比较可以通过比较编码后的<code>UTF-8</code>字节或解码后的<code>Unicode</code>字符。<br />\n<a name=\"C6KM0\"></a></p>\n<h3 id=\"4.1-%E4%B8%BB%E9%A2%98%E5%90%8D%E5%92%8C%E4%B8%BB%E9%A2%98%E8%BF%87%E6%BB%A4%E5%99%A8\" tabindex=\"-1\">4.1 主题名和主题过滤器</h3>\n<p><a name=\"pndec\"></a></p>\n<h4 id=\"4.1.1-%E4%B8%BB%E9%A2%98%E5%90%8D\" tabindex=\"-1\">4.1.1 主题名</h4>\n<ul>\n<li>附加在应用消息上的一个标签，服务端已知且与订阅匹配。</li>\n<li>服务端发送应用消息的一个副本给每一个匹配的客户端订阅。<br />\n<a name=\"m0o3S\"></a></li>\n</ul>\n<h4 id=\"4.1.2-%E4%B8%BB%E9%A2%98%E8%BF%87%E6%BB%A4%E5%99%A8\" tabindex=\"-1\">4.1.2 主题过滤器</h4>\n<ul>\n<li>订阅中包含的一个表达式，用于表示相关的一个或多个主题。主题过滤器可以使用通配符。</li>\n<li>如果订阅的主题过滤器与消息的主题名匹配，应用消息会被发送给每一个匹配的客户端订阅。</li>\n<li>主题资源可以是管理员在服务端预先定义好的，也可以是服务端收到第一个订阅或使用那个主题名的应用消息时动态添加的。</li>\n<li>服务端可以使用一个安全组件有选择地授权客户端使用某个主题资源。<br />\n<a name=\"yGSLd\"></a></li>\n</ul>\n<h3 id=\"4.2-%E4%B8%BB%E9%A2%98%E5%92%8C%E4%B8%BB%E9%A2%98%E8%BF%87%E6%BB%A4%E5%99%A8%E5%91%BD%E5%90%8D%E7%9A%84%E8%A7%84%E5%88%99\" tabindex=\"-1\">4.2 主题和主题过滤器命名的规则</h3>\n<p><code>MQTT</code>协议中规定了主题是一段<code>UTF-8</code>编码的字符串，主题需要满足以下规则：</p>\n<ul>\n<li>所有的主题名和主题过滤器必须至少包含一个字符。</li>\n<li>主题名和主题过滤器是大小写敏感的。<code>ACCOUNTS</code>和<code>Accounts</code>是不同的主题名。</li>\n<li>主题名和主题过滤器可以包含空格字符。<code>Accountspayable</code>是合法的主题名</li>\n<li>主题名或主题过滤器以前置或后置斜杠<code>/</code>区分。<code>/finance</code>和<code>finance</code>是不同的。</li>\n<li>只包含斜杠<code>/</code>的主题名或主题过滤器是合法的。</li>\n<li>主题名和主题过滤器不能包含<code>null</code>字符(<code>UnicodeU+0000</code>)。</li>\n<li>主题名和主题过滤器是<code>UTF-8</code>编码字符串，除了不能超过<code>UTF-8</code>编码字符串的长度限制之外，主题名或主题过滤器的层级数量没有其它限制。<br />\n<a name=\"c6T7x\"></a></li>\n</ul>\n<h3 id=\"4.3-%E4%B8%BB%E9%A2%98%E5%B1%82%E7%BA%A7\" tabindex=\"-1\">4.3 主题层级</h3>\n<p><a name=\"lgmbP\"></a></p>\n<h4 id=\"4.3.1-%E4%B8%BB%E9%A2%98%E5%B1%82%E7%BA%A7%E5%88%86%E9%9A%94%E7%AC%A6\" tabindex=\"-1\">4.3.1 主题层级分隔符</h4>\n<p>斜杠（<code>“/”U+002F</code>）用于分割主题的每个层级，为主题名提供一个分层结构。分隔符用于将结构化引入主题名。如果存在分隔符，它将主题名分割为多个主题层级，是消息主题层级设计中很重要的符号。比方说：<code>aaa/bbb</code>、<code>aaa/bbb/ccc</code>和<code>aaa/bbb/ccc/ddd</code>这样的消息主题格式，是一个层层递进的关系，可通过多层通配符同时匹配两者，或者单层通配符只匹配一个。这在现实场景中，可以应用到：公司的部门层级推送、国家城市层级推送等包含层级关系的场景。<br /><code>MQTT</code>订阅报文包含一个主题过滤器（<code>TopicFilter</code>）和一个最大的服务质量（<code>QoS</code>）等级。订阅的主题过滤器可以包含特殊的通配符，允许客户端一次订阅多个主题。当客户端订阅指定的主题过滤器包含两种通配符时，主题层级分隔符就很有用了。主题层级分隔符可以出现在主题过滤器或主题名字的任何位置。相邻的主题层次分隔符表示一个零长度的主题层级。</p>\n<blockquote>\n<p>主题过滤器中可以使用通配符，但是主题名不能使用通配符。单层通配符和多层通配符只能用于订阅(<code>subscribe</code>)消息而不能用于发布(<code>publish</code>)消息，层级分隔符两种情况下均可使用。</p>\n</blockquote>\n<p><a name=\"uk0f5\"></a></p>\n<h4 id=\"4.3.2-%E5%A4%9A%E5%B1%82%E9%80%9A%E9%85%8D%E7%AC%A6\" tabindex=\"-1\">4.3.2 多层通配符</h4>\n<p>井字符号（<code>“#”U+0023</code>）是用于匹配主题中任意层级的通配符。多层通配符表示它的父级和任意数量的子层级。</p>\n<p>例如，如果客户端订阅主题<code>sport/tennis/player1/#</code>，它会收到使用下列主题名发布的消息：</p>\n<ul>\n<li><code>sport/tennis/player1</code></li>\n<li><code>sport/tennis/player1/ranking</code></li>\n<li><code>sport/tennis/player1/score/wimbledon</code></li>\n</ul>\n<p>因为多层通配符包括它自己的父级，所以<code>sport/#</code>也匹配单独的<code>sport</code>主题名，<code>sport/tennis/player1/#</code>也可以匹配<code>sport/tennis/player1</code>。</p>\n<p>单独的多层通配符<code>#</code>是有效的，它会收到所有的应用消息。</p>\n<p>多层通配符必须单独指定，或者跟在主题层级分隔符后面。多层通配符必须是主题过滤器的最后一个字符。因此，<code>sport/tennis#</code>和<code>sport/tennis/#/ranking</code>都是无效的多层通配符。<br />\n<a name=\"r9qtl\"></a></p>\n<h4 id=\"4.3.3-%E5%8D%95%E5%B1%82%E9%80%9A%E9%85%8D%E7%AC%A6\" tabindex=\"-1\">4.3.3 单层通配符</h4>\n<p>加号(<code>“+”U+002B</code>)是只能用于单个主题层级匹配的通配符。例如，<code>sport/tennis/</code>+匹配<code>sport/tennis/player1</code>和<code>sport/tennis/player2</code>，但是不匹配<code>sport/tennis/player1/ranking</code>。同时，由于单层通配符只能匹配一个层级，<code>sport/</code>+不匹配<code>sport</code>但是却匹配<code>sport/</code>。</p>\n<p>在主题过滤器的任意层级都可以使用单层通配符，包括第一个和最后一个层级，可以在主题过滤器中的多个层级中使用它，也可以和多层通配符一起使用，<code>+</code>、<code>+/tennis/#</code>、<code>sport/+/player1</code>都有有效的。在使用单层通配符时，单层通配符占据过滤器的整个层级，<code>sport+</code>是无效的。</p>\n<p><a name=\"JS1jZ\"></a></p>\n<h4 id=\"4.3.4-%E4%BB%A5%5C%24%E5%BC%80%E5%A4%B4%E7%9A%84%E4%B8%BB%E9%A2%98\" tabindex=\"-1\">4.3.4 以<code>\\$</code>开头的主题</h4>\n<p>服务端不能将<code>$</code>字符开头的主题名匹配通配符（<code>#</code>或``+）开头的主题过滤器，订阅<code>#</code>的客户端不会收到任何发布到以<code>$</code>开头主题的消息，订阅<code>+/monitor/Clients</code>的客户端也不会收到任何发布到<code>$SYS/monitor/Clients</code>的消息。服务端应该阻止客户端使用这种主题名与其他客户端交换消息，客户端注意不能使用<code>$</code>字符开头的主题。</p>\n<p>服务端实现可以将<code>$</code>开头的主题名用作其他目的。,例如<code>$SYS/</code>被广泛用作包含服务器特定信息或控制接口的主题的前缀。订阅<code>$SYS/#</code>的客户端会收到发布到以<code>$SYS/</code>开头主题的消息，订阅<code>$SYS/monitor/+</code>的客户端会收到发布到<code>$SYS/monitor/Clients</code>主题的消息，如果客户端想同时接受以<code>$SYS/</code>开头主题的消息和不以<span class=\'katex-error\' title=\'ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 17: …头主题的消息，它需要同时订阅`#̲`和`\'>开头主题的消息，它需要同时订阅`#`和`</span>SYS/#`。</p>\n<p><a name=\"wlFGn\"></a></p>\n<h4 id=\"4.3.5-%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90\" tabindex=\"-1\">4.3.5 举个例子</h4>\n<p>比如我们用传感器监视家里的卧室、客厅以及厨房的温度、湿度和空气质量，可以设计一下几个主题：</p>\n<ul>\n<li><code>myhome/bedroom/temperature</code></li>\n<li><code>myhome/bedroom/humidity</code></li>\n<li><code>myhome/bedroom/airquality</code></li>\n<li><code>myhome/livingroom/temperature</code></li>\n<li><code>myhome/livingroom/humidity</code></li>\n<li><code>myhome/livingroom/airquality</code></li>\n<li><code>myhome/kitchen/temperature</code></li>\n<li><code>myhome/kitchen/humidity</code></li>\n<li><code>myhome/kitchen/airquality</code></li>\n</ul>\n<p>当我们想获取卧室的所有数据时，可以订阅<code>myhome/bedroom+</code>主题，当我们想获取三个房间的温度数据的时候，可以订阅<code>myhome/+/temperature</code>主题，当我们想获取所有的数据的时候，可以订阅<code>myhome/#</code>或者<code>#</code>。<br />\n<a name=\"bWtlN\"></a></p>\n<h2 id=\"5.-%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F\" tabindex=\"-1\">5. 消息服务质量</h2>\n<p><a name=\"CrIs8\"></a></p>\n<h3 id=\"5.1-qos0\" tabindex=\"-1\">5.1 <code>QoS0</code></h3>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/de4a58b44021150560ff5179be21ec31.png\" alt=\"image.png\" /><br />\n<a name=\"FMmvB\"></a></p>\n<h3 id=\"5.2-qos1\" tabindex=\"-1\">5.2 <code>QoS1</code></h3>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/b1ff19e125a38da6f80b4780b62e3485.png\" alt=\"image.png\" /><br />\n<a name=\"bB7xV\"></a></p>\n<h3 id=\"5.3-qos-2\" tabindex=\"-1\">5.3 <code>QoS 2</code></h3>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/0b93c14210ca840643b1df1307b61d47.png\" alt=\"image.png\" /></p>\n<ul>\n<li><code>PUBREC</code>消息</li>\n</ul>\n<p>发布收到。是对<code>QoS</code>级别为<code>2</code>的<code>PUBLISH</code>消息的响应。它是<code>QoS</code>级别<code>2</code>协议流的第二个消息。<code>PUBREC</code>消息由服务器响应来自发布端的<code>PUBLISH</code>消息，或订阅端响应来自服务器的<code>PUBLISH</code>消息。发布端或服务器收到<code>PUBREC</code>消息时，会响应<code>PUBREL</code>消息。</p>\n<ul>\n<li><code>PUBREL</code>消息</li>\n</ul>\n<p>发布释放。是从发布端对<code>PUBREC</code>的响应，或从服务器对订阅端<code>PUBREC</code>消息的响应。这是<code>QoS</code>级别<code>2</code>协议流中第三个消息。当服务器从发布者收到<code>PUBREL</code>消息时，服务器会将<code>PUBLISH</code>消息发送到订阅端，并发送<code>PUBCOMP</code>消息到发布端。当订阅端收到来自服务器的消息<code>PUBREL</code>时，使得消息可用于应用程序并将<code>PUBCOMP</code>消息发送到服务器。</p>\n<ul>\n<li><code>PUBCOMP</code>消息</li>\n</ul>\n<p>发布完成。是服务器对来自发布端的<code>PUBREL</code>消息的响应，或订阅者对来自服务器的<code>PUBREL</code>消息的响应。它是<code>QoS</code>级别<code>2</code>协议流程中的第四个也是最后一个消息。当发布端收到<code>PUBCOMP</code>消息时，它会丢弃原始消息，因为它已经将消息发给了服务器。<br />\n<a name=\"GsByB\"></a></p>\n<h3 id=\"5.4-%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F\" tabindex=\"-1\">5.4 特别注意</h3>\n<p>需要注意的是<code>MQTT</code>发布与订阅操作中的<code>QoS</code>代表了不同的含义：</p>\n<ul>\n<li>发布时的<code>QoS</code>表示消息发送到<code>MQTT</code>服务器使用的<code>QoS</code>等级；</li>\n<li>订阅时的<code>QoS</code>表示<code>MQTTBroker</code>向自己转发消息时可以使用的最大<code>QoS</code>等级。</li>\n</ul>\n<p><strong>需要保障发送与订阅的</strong><code>**QoS**</code><strong>一致，才能确保最终收到的消息是固定的</strong><code>**QoS**</code><strong>等级</strong>，否则会出现消费降级的情况。例如：<code>A</code>发送的消息<code>QoS</code>为<code>2</code>，B订阅的消息<code>QoS</code>为<code>1</code>，则最终接收到消息的<code>QoS</code>为<code>1</code>。<br />\n<a name=\"zGDYh\"></a></p>\n<h2 id=\"6.-%E4%BF%9D%E7%95%99%E6%B6%88%E6%81%AF%E5%92%8C%E6%9C%80%E5%90%8E%E9%81%97%E5%98%B1\" tabindex=\"-1\">6. 保留消息和最后遗嘱</h2>\n<p><a name=\"mxacK\"></a></p>\n<h3 id=\"6.1-%E4%BF%9D%E7%95%99%E6%B6%88%E6%81%AF\" tabindex=\"-1\">6.1 保留消息</h3>\n<p><code>RetainedMessages</code>。<code>MQTT</code>中，无论是发布还是订阅都不会有任何触发事件。1个<code>Topic</code>只有唯一的<code>retain</code>消息，<code>Broker</code>会保存每个<code>Topic</code>的最后一条<code>retain</code>消息。发布消息时把<code>retain</code>设置为<code>true</code>，即为保留信息。每个<code>Client</code>订阅<code>Topic</code>后会立即读取到<code>retain</code>消息。如果需要删除<code>retain</code>消息，可以发布一个空的<code>retain</code>消息，因为每个新的<code>retain</code>消息都会覆盖最后一个<code>retain</code>消息。<br />\n<a name=\"HSAaV\"></a></p>\n<h3 id=\"6.2-%E6%9C%80%E5%90%8E%E9%81%97%E5%98%B1\" tabindex=\"-1\">6.2 最后遗嘱</h3>\n<p><code>LastWill&amp;Testament</code>。<code>MQTT</code>本身就是为信号不稳定的网络设计的，所以难免一些客户端会无故的和<code>Broker</code>断开连接。当客户端连接到<code>Broker</code>时，可以指定<code>LWT</code>，<code>Broker</code>会定期检测客户端是否有异常。当客户端异常掉线时，<code>Broker</code>就往连接时指定的<code>Topic</code>里推送当时指定的<code>LWT</code>消息。</p>\n<p>=“HSAaV”&gt;</a></p>\n<h3 id=\"6.2-%E6%9C%80%E5%90%8E%E9%81%97%E5%98%B1-1\" tabindex=\"-1\">6.2 最后遗嘱</h3>\n<p><code>LastWill&amp;Testament</code>。<code>MQTT</code>本身就是为信号不稳定的网络设计的，所以难免一些客户端会无故的和<code>Broker</code>断开连接。当客户端连接到<code>Broker</code>时，可以指定<code>LWT</code>，<code>Broker</code>会定期检测客户端是否有异常。当客户端异常掉线时，<code>Broker</code>就往连接时指定的<code>Topic</code>里推送当时指定的<code>LWT</code>消息。</p>\n', 1, '', 0, 0, 1, '2022-08-09 10:23:28', '2022-08-09 17:25:13');
INSERT INTO `tb_article` VALUES (287, 1, 15, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3198', '物联网消息队列客户端-MQTT-基本功能实现', '<p></p>\n<h2 id=\"1.-%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD\" tabindex=\"-1\">1. 主要实现功能</h2>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" checked=\"\" disabled=\"\" type=\"checkbox\"> 自动配置</li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" checked=\"\" disabled=\"\" type=\"checkbox\"> 消息自动解析</li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" checked=\"\" disabled=\"\" type=\"checkbox\"> 消息分组共享订阅</li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" checked=\"\" disabled=\"\" type=\"checkbox\"> 消息不分组共享订阅</li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" checked=\"\" disabled=\"\" type=\"checkbox\"> 消息排它订阅</li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" checked=\"\" disabled=\"\" type=\"checkbox\"> 延时发布</li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" checked=\"\" disabled=\"\" type=\"checkbox\"> 多数据源</li>\n</ul>\n<h2 id=\"4.-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B\" tabindex=\"-1\">4. 快速开始</h2>\n<p><a name=\"3a432485\"></a></p>\n<h3 id=\"4.1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96\" tabindex=\"-1\">4.1 引入依赖</h3>\n<pre><code class=\"language-xml\">    &lt;dependency&gt;\n            &lt;groupId&gt;org.eclipse.paho&lt;/groupId&gt;\n            &lt;artifactId&gt;org.eclipse.paho.client.mqttv3&lt;/artifactId&gt;\n            &lt;version&gt;1.2.5&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p><a name=\"ed6e9acd\"></a></p>\n<h3 id=\"4.2-%E9%85%8D%E7%BD%AE\" tabindex=\"-1\">4.2 配置</h3>\n<pre><code class=\"language-yaml\">spring:\n  mqtt:\n    emq:\n      client:\n        # 多数据源客户端名称，默认default\n        default:\n          # broker地址\n          host: 127.0.0.1\n          # 端口\n          port: 31883\n          # 用户名\n          username: admin\n          # 密码\n          password: 123456\n</code></pre>\n<p>更多配置如下</p>\n<pre><code class=\"language-yaml\">spring:\n  mqtt:\n    emq:\n      client:\n        # 多数据源客户端名称，默认default\n        default:\n          # broker地址\n          host: 127.0.0.1\n          # 端口\n          port: 31883\n          # 用户名\n          username: admin\n          # 密码\n          password: 123456\n          # 客户端标识，需保持全局唯一\n          client-id: parking_server\n          # 是否清除session\n          clean-session: false\n          # 连接超时时间，单位秒\n          connection-timeout: 10\n          # 心跳间隔时间，单位秒\n          keep-alive-interval: 10\n          # 全局消息质量\n          global-qos: 1\n          # 重新连接之间等待的最长时间\n          maxReconnect-delay: 128000\n          # 是否自动重新连接\n          automatic-reconnect: true\n          # 最大消息并发数量，超过此数量并发时可能会丢消息\n          maxInflight: 1000\n</code></pre>\n<p><a name=\"6b9a2d1b\"></a></p>\n<h3 id=\"4.3-%E5%BC%80%E5%90%AF%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE\" tabindex=\"-1\">4.3 开启自动配置</h3>\n<p>在启动类上增加<code>@EnableRabbitMqAutoConfiguration</code>注解</p>\n<pre><code class=\"language-java\">import com.demo.mqttclient.anno.EnableEmqAutoConfiguration;\n\n\n@SpringBootApplication\n@EnableEmqAutoConfiguration\npublic class TestApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(TestApplication.class, args);\n    }\n\n}\n</code></pre>\n<p><a name=\"8b7e3591\"></a></p>\n<h3 id=\"4.4-%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF\" tabindex=\"-1\">4.4 发布消息</h3>\n<p>在生产者的业务程序中，注入<code>MQTTClient</code></p>\n<pre><code class=\"language-java\">import com.demo.mqttclient.MQTTClient;\n\n@Resource\nprivate MQTTClient defaultMQTTClient;\n</code></pre>\n<p>为了兼容第三方及优化内部使用逻辑，所以内置提供了两种消息发送方式。<br />\n<a name=\"glVxx\"></a></p>\n<h4 id=\"4.4.1-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81\" tabindex=\"-1\">4.4.1 第三方消息发送</h4>\n<pre><code class=\"language-java\">public String publishHeartbeatReply() {\n    HeartbeatReplyMessage heartbeatReplyMessage = new HeartbeatReplyMessage();\n    heartbeatReplyMessage.setCmd(32896);\n    heartbeatReplyMessage.setExpire(1605252875L);\n    heartbeatReplyMessage.setDevid(&quot;095437323930030130523933&quot;);\n    heartbeatReplyMessage.setServer_time(&quot;1605252875&quot;);\n\n    defaultMQTTClient.publish2ThirdParty(&quot;npt/park/type1/dev/095437323930030130523933&quot;, 1, heartbeatReplyMessage);\n\n    return &quot;success&quot;;\n}\n</code></pre>\n<p><a name=\"aYfMo\"></a></p>\n<h4 id=\"4.4.2-%E5%86%85%E9%83%A8%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81\" tabindex=\"-1\">4.4.2 内部消息发送</h4>\n<p>消息实体实现<code>Message</code>接口</p>\n<pre><code class=\"language-java\">package com.example.test.message;\n\nimport com.demo.mqttclient.MQTTMessage;\nimport lombok.Data;\n\nimport java.util.UUID;\n\n@Data\npublic class demoMessage implements MQTTMessage {\n    \n    private String msgId = UUID.randomUUID().toString();\n    \n    private String name;\n    \n    private String gender;\n    \n    @Override\n    public String getMsgId() {\n        return this.msgId;\n    }\n    \n}\n</code></pre>\n<p>然后直接调用该类的<code>publish</code>方法发送即可</p>\n<pre><code class=\"language-java\">@GetMapping(&quot;demo/publish&quot;)\npublic String demoPublish() {\n    demoMessage demoMessage = new demoMessage();\n    demoMessage.setName(&quot;点都&quot;);\n    demoMessage.setGender(&quot;xx&quot;);\n\n    defaultMQTTClient.publish(&quot;demo/topic&quot;, demoMessage);\n\n    return &quot;success&quot;;\n}\n</code></pre>\n<p>其中存在多个重载的方法。</p>\n<pre><code class=\"language-java\">package com.demo.mqttclient;\n\nimport com.demo.mqttclient.enums.ShareModelEnum;\nimport com.demo.plugin.core.lang.json.JSONUtil;\nimport org.eclipse.paho.client.mqttv3.MqttMessage;\n\n/**\n * mqtt客户端\n *\n * @author zhangliuyang\n * @date 2022/07/18\n * @since 1.0.0\n */\npublic interface MQTTClient {\n\n    /**\n     * 启动客户端\n     */\n    void start();\n\n    /**\n     * 关闭客户端\n     */\n    void close();\n\n    /**\n     * 发布\n     *\n     * @param topic   主题\n     * @param message 消息\n     */\n    default &lt;T extends MQTTMessage&gt; void publish(String topic, T message) {\n        this.publish(topic, message, 1);\n    }\n\n    /**\n     * 发布\n     *\n     * @param topic   主题\n     * @param message 消息\n     * @param qos     消息质量\n     */\n    default &lt;T extends MQTTMessage&gt; void publish(String topic, T message, int qos) {\n        this.publish(topic, message, qos, 0);\n    }\n\n    /**\n     * 发布\n     *\n     * @param topic   主题\n     * @param message 消息\n     * @param qos     消息质量\n     * @param delay   延迟时间[unit:s, max:4294967s, condition: &gt; 0]\n     */\n    default &lt;T extends MQTTMessage&gt; void publish(String topic, T message, int qos, long delay) {\n        this.publish(topic, message, qos, delay, false);\n    }\n\n    /**\n     * 发布\n     *\n     * @param topic    主题\n     * @param message  消息\n     * @param qos      消息质量\n     * @param delay    延迟时间[unit:s, max:4294967s, condition: &gt; 0]\n     * @param retained 保留消息\n     */\n    default &lt;T extends MQTTMessage&gt; void publish(String topic, T message, int qos, long delay, boolean retained) {\n        MQTTMessageContext mqttMessageContext = new MQTTMessageContext();\n        mqttMessageContext.setId(message.getMsgId());\n        mqttMessageContext.setPayload(JSONUtil.write(message));\n        mqttMessageContext.setQos(qos);\n        mqttMessageContext.setDelay(delay);\n        mqttMessageContext.setRetained(retained);\n        mqttMessageContext.setTimestamp(System.currentTimeMillis());\n\n        this.publish(topic, mqttMessageContext);\n    }\n\n    /**\n     * 发布\n     *\n     * @param topic          主题\n     * @param messageContext 消息上下文\n     */\n    void publish(String topic, MQTTMessageContext messageContext);\n\n    /**\n     * 发送到第三方\n     *\n     * @param topic   主题\n     * @param message 消息\n     */\n    default void publish2ThirdParty(String topic, Object message) {\n        this.publish2ThirdParty(topic, 1, message);\n    }\n\n    /**\n     * 发送到第三方\n     *\n     * @param topic   主题\n     * @param qos     消息质量\n     * @param message 消息\n     */\n    default void publish2ThirdParty(String topic, int qos, Object message) {\n        this.publish2ThirdParty(topic, qos, message, Constant.DEFAULT_CHARSET.name());\n    }\n\n    /**\n     * 发送到第三方\n     *\n     * @param topic       主题\n     * @param qos         消息质量\n     * @param message     消息\n     * @param charsetName 字符集名称\n     */\n    default void publish2ThirdParty(String topic, int qos, Object message, String charsetName) {\n        this.publish2ThirdParty(topic, qos, message, charsetName, 0);\n    }\n\n    /**\n     * publish2第三方\n     *\n     * @param topic       主题\n     * @param qos         qos\n     * @param message     消息\n     * @param charsetName 字符集名称\n     * @param delay       延迟时间\n     */\n    default void publish2ThirdParty(String topic, int qos, Object message, String charsetName, long delay) {\n        this.publish2ThirdParty(topic, qos, message, charsetName, delay, false);\n    }\n\n    /**\n     * publish2第三方\n     *\n     * @param topic       主题\n     * @param qos         qos\n     * @param message     消息\n     * @param charsetName 字符集名称\n     * @param delay       延迟时间\n     * @param retained    是否保留消息\n     */\n    default void publish2ThirdParty(String topic, int qos, Object message, String charsetName, long delay, boolean retained) {\n        this.publish2ThirdParty(topic, qos, JSONUtil.toString(message).getBytes(charsetName), delay, retained);\n    }\n\n    /**\n     * 发送到第三方\n     *\n     * @param topic   主题\n     * @param payload 有效载荷\n     */\n    default void publish2ThirdParty(String topic, byte[] payload) {\n        this.publish2ThirdParty(topic, 1, payload, 0);\n    }\n\n    /**\n     * 发送到第三方\n     *\n     * @param topic   主题\n     * @param qos     消息质量\n     * @param payload 有效载荷\n     */\n    default void publish2ThirdParty(String topic, int qos, byte[] payload) {\n        this.publish2ThirdParty(topic, qos, payload, 0);\n    }\n\n    /**\n     * 发送到第三方\n     *\n     * @param topic   主题\n     * @param qos     消息质量\n     * @param payload 有效载荷\n     * @param delay   延迟时间\n     */\n    default void publish2ThirdParty(String topic, int qos, byte[] payload, long delay) {\n        this.publish2ThirdParty(topic, qos, payload, delay, false);\n    }\n\n    /**\n     * 发送到第三方\n     *\n     * @param topic    主题\n     * @param qos      消息质量\n     * @param payload  有效载荷\n     * @param delay    延迟时间\n     * @param retained 是否保留消息\n     */\n    default void publish2ThirdParty(String topic, int qos, byte[] payload, long delay, boolean retained) {\n        MqttMessage mqttMessage = new MqttMessage();\n        mqttMessage.setPayload(payload);\n        mqttMessage.setQos(qos);\n        mqttMessage.setRetained(retained);\n\n        this.publish2ThirdParty(topic, delay, mqttMessage);\n    }\n\n    /**\n     * 发送到第三方\n     *\n     * @param topic       主题\n     * @param mqttMessage mqtt消息\n     * @param delay       延迟时间\n     */\n    void publish2ThirdParty(String topic, long delay, MqttMessage mqttMessage);\n\n    /**\n     * 订阅\n     *\n     * @param topic          主题\n     * @param qos            消息质量\n     * @param shareModel     共享模型\n     * @param groupName      分组名称\n     * @param exclusive      排它\n     * @param messageHandler 消息处理程序\n     */\n    void subscribe(String topic, int qos, ShareModelEnum shareModel, String groupName, boolean exclusive, MessageHandler messageHandler);\n\n}\n</code></pre>\n<p><a name=\"7cd9bafb\"></a></p>\n<h3 id=\"4.5-%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF\" tabindex=\"-1\">4.5 接收消息</h3>\n<p>消费者需要在消息处理类上添加<code>@MQTTSubscriber(topics = {&quot;npt/park/type1/server/10010&quot;})</code>注解，指定要监听<code>topics</code>和客户端名称即可。如果没有显示的指定客户端名称，则使用<code>defaultMQTTClient</code>，使用<code>qos</code>执行订阅消息质量。<br />当消息处理类中有多个<code>public</code>方法时，需要<code>@MQTTConsumerMethod</code>标记具体消费方法</p>\n<pre><code class=\"language-java\">package com.example.test.handler;\n\nimport com.demo.mqttclient.MessageHandler;\nimport com.demo.mqttclient.anno.MQTTConsumerMethod;\nimport com.demo.mqttclient.anno.MQTTSubscriber;\nimport com.demo.mqttclient.enums.ShareModelEnum;\nimport com.demo.plugin.core.lang.json.JSONUtil;\nimport com.example.test.message.DeviceStartMessage;\nimport com.example.test.message.PlateRecognitionReportMessage;\nimport lombok.extern.slf4j.Slf4j;\nimport org.eclipse.paho.client.mqttv3.MqttMessage;\n\nimport java.util.Map;\n\n\n@Slf4j\n@MQTTSubscriber(topics = ParkingMessageHandler.TOPIC, qos = 1, share = ShareModelEnum.GROUP_SHARE)\npublic class ParkingMessageHandler {\n\n    public static final String TOPIC = &quot;npt/park/type1/server/10010&quot;;\n\n    public static final String CMD_KEY = &quot;cmd&quot;;\n\n    @MQTTConsumerMethod\n    public void handle(Map&lt;String, Object&gt; message) {\n        log.info(&quot;handle:{}&quot;, message);\n        if (message.containsKey(CMD_KEY)) {\n            Integer cmd = (Integer) message.get(CMD_KEY);\n\n            switch (cmd) {\n                case 129:\n                    handleDeviceStartMessage(message);\n                    break;\n                case 140:\n                    handlePlateRecognitionReportMessage(message);\n                    break;\n                default:\n                    log.warn(&quot;不支持此cmd:[{}]&quot;, cmd);\n                    break;\n            }\n        } else {\n            log.warn(&quot;消息消费异常&quot;);\n        }\n    }\n\n    private void handleDeviceStartMessage(Map&lt;String, Object&gt; message) {\n        DeviceStartMessage deviceStartMessage = JSONUtil.toObject(JSONUtil.toString(message), DeviceStartMessage.class);\n        log.info(&quot;接收到设备启动消息:{}&quot;, deviceStartMessage);\n    }\n\n    private void handlePlateRecognitionReportMessage(Map&lt;String, Object&gt; message) {\n        PlateRecognitionReportMessage plateRecognitionReportMessage = JSONUtil.toObject(JSONUtil.toString(message), PlateRecognitionReportMessage.class);\n        log.info(&quot;接收到车牌上报识别消息:{}&quot;, plateRecognitionReportMessage);\n    }\n\n}\n</code></pre>\n<p><a name=\"c00d8d17\"></a></p>\n<h3 id=\"4.6-%E5%8F%91%E9%80%81%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF\" tabindex=\"-1\">4.6 发送延迟消息</h3>\n<p>要发送延迟消息，需要先开启<code>emq</code>延迟发布配置。<br />发送延时消息的方式相比之前，仅仅增加一个延时时间。其中延时时长的单位为<code>秒</code>，最大为<code>4294967</code>秒</p>\n<pre><code class=\"language-java\">//发送一个延时时长为10s的消息\ndefaultMQTTClient.publish2ThirdParty(&quot;npt/park/type1/dev/095437323930030130523933&quot;, 1, heartbeatReplyMessage, 10);\n</code></pre>\n<p><a name=\"mbY3o\"></a></p>\n<h3 id=\"4.7-%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90\" tabindex=\"-1\">4.7 多数据源</h3>\n<p>多数据源与单数据源配置属性相同，在配置文件中声明即可</p>\n<pre><code class=\"language-yaml\">spring:\n  mqtt:\n    emq:\n      client:\n        # 多数据源客户端名称，默认default\n        default:\n          # broker地址\n          host: 127.0.0.1\n          # 端口\n          port: 31883\n          # 用户名\n          username: admin\n          # 密码\n          password: 123456\n        # 多数据源客户端名称\n        parking:\n          # broker地址\n          host: 127.0.0.1\n          # 端口\n          port: 31883\n          # 用户名\n          username: admin\n          # 密码\n          password: 123456\n</code></pre>\n<p><a name=\"154067c4\"></a></p>\n<h4 id=\"4.7.1-%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF\" tabindex=\"-1\">4.7.1 发布消息</h4>\n<p>首先注入<code>MQTTClient</code>，与单数据源的唯一区别就是<code>bean</code>的名称。默认向<code>Spring</code>容器中添加的实现类名称为<code>“${数据源名称}MQTTClient”</code><br />以上面的配置文件为例，默认的<code>bean</code>名称为 <code>defaultMQTTClient</code> 和 <code>billMQTTClient</code></p>\n<pre><code class=\"language-java\">import com.demo.mqttclient.MQTTClient;\n\n@Resource\nprivate MQTTClient defaultMQTTClient;\n\n@Resource\nprivate MQTTClient billMQTTClient;\n</code></pre>\n<p>其他操作同单数据源<br />\n<a name=\"6e3ee716\"></a></p>\n<h4 id=\"4.7.2-%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF\" tabindex=\"-1\">4.7.2 接收消息</h4>\n<p>接收消息与单数据源基本一致，唯一的区别是在<code>@MQTTSubscriber</code>中指定<code>clientName</code>属性，指定当前从哪个数据源进行消费。</p>\n<pre><code class=\"language-java\">import com.demo.mqttclient.anno.MQTTSubscriber;\n\n@MQTTSubscriber(topics = {&quot;npt/park/type1/server/10010&quot;}, clientName = &quot;parking&quot;)\npublic class ParkingMessageHandler {}\n</code></pre>\n<p><a name=\"821f84c4\"></a></p>\n<h3 id=\"4.8-%E5%88%86%E7%BB%84%E5%85%B1%E4%BA%AB%E8%AE%A2%E9%98%85\" tabindex=\"-1\">4.8 分组共享订阅</h3>\n<p>系统默认使用<code>spring.application.name</code>作为分组名称，用户可在消息消费类上指定<code>@MQTTSubscriber</code>属性中<code>groupName = &quot;group_name&quot;</code>即可</p>\n<pre><code class=\"language-java\">import com.demo.mqttclient.anno.MQTTSubscriber;\n\n@MQTTSubscriber(topics = ParkingMessageHandler.TOPIC, qos = 1, share = ShareModelEnum.GROUP_SHARE, groupName = &quot;group_name&quot;)\npublic class ParkingMessageHandler {}\n</code></pre>\n<p><a name=\"3ea986e3\"></a></p>\n<h3 id=\"4.9-%E4%B8%8D%E5%88%86%E7%BB%84%E5%85%B1%E4%BA%AB%E8%AE%A2%E9%98%85\" tabindex=\"-1\">4.9 不分组共享订阅</h3>\n<p>只需要在消息消费类上指定<code>@MQTTSubscriber</code>属性中<code>share = ShareModelEnum.UN_GROUP_SHARE</code>即可。</p>\n<pre><code class=\"language-java\">import com.demo.mqttclient.anno.MQTTSubscriber;\n\n@MQTTSubscriber(topics = ParkingMessageHandler.TOPIC, qos = 1, share = ShareModelEnum.UN_GROUP_SHARE)\npublic class ParkingMessageHandler {}\n</code></pre>\n<p><a name=\"Ie5JJ\"></a></p>\n<h3 id=\"4.10-%E6%8E%92%E5%AE%83%E8%AE%A2%E9%98%85\" tabindex=\"-1\">4.10 排它订阅</h3>\n<p>只需要在消息消费类上指定<code>@MQTTSubscriber</code>属性中<code>exclusive = true</code>即可，开启排它订阅时，默认关闭共享订阅。</p>\n<pre><code class=\"language-java\">import com.demo.mqttclient.anno.MQTTSubscriber;\n\n@MQTTSubscriber(topics = ParkingMessageHandler.TOPIC, qos = 1, exclusive = true)\npublic class ParkingMessageHandler {}\n</code></pre>\n', 1, '', 0, 0, 1, '2022-08-09 17:03:35', '2022-08-09 17:06:59');
INSERT INTO `tb_article` VALUES (288, 1, 11, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=5734', '分布式链路追踪-常用技术选型', '<p></p>\n<p><a name=\"xrpap\"></a></p>\n<h2 id=\"1.-%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D\" tabindex=\"-1\">1. 背景介绍</h2>\n<p>随着微服务架构的流行，一次请求往往需要涉及到多个服务，需要一些可以帮助理解系统行为、用于分析性能问题的工具，以便发生故障的时候，能够快速定位和解决问题。<br />单体架构中可以使用 <code>AOP</code> 在调用具体的业务逻辑前后分别打印一下时间即可计算出整体的调用时间，使用 <code>AOP</code> 来 <code>catch</code> 住异常也可知道是哪里的调用导致的异常。而针对于一个大型的几十个、几百个微服务构成的微服务架构系统，通常会遇到下面一些问题，比如：</p>\n<ul>\n<li>如何串联整个调用链路，快速定位问题？</li>\n<li>如何缕清各个微服务之间的依赖关系？</li>\n<li>如何进行各个微服务接口的性能分折？</li>\n<li>如何跟踪整个业务流程的调用处理顺序？<br />\n<a name=\"bBwWB\"></a></li>\n</ul>\n<h2 id=\"2.-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\" tabindex=\"-1\">2. 实现原理</h2>\n<ul>\n<li>一个完整请求链路的追踪<code>ID</code>（<code>traceid</code>）用于查出本次请求调用的所有服务，每一次服务调用的跨度<code>ID</code>（<code>spanid</code>）用来记录调用顺序</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/73100d59934a095a5fe89b8025894cf8.jpeg\" alt=\"\" /></p>\n<ul>\n<li>上游服务<code>parenetid</code>用来记录调用的层级关系</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/e57838c43effafd2db93a0643467b036.jpeg\" alt=\"\" /></p>\n<ul>\n<li>调用时间<code>timestamp</code>，把请求发出、接收、处理的时间都记录下来，计算业务处理耗时和网络耗时，然后用可视化界面展示出来每个调用链路，性能，故障</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/aa38c5f7981162a812a1c7ec081d1ebc.jpeg\" alt=\"\" /><br /><img src=\"https://img-blog.csdnimg.cn/img_convert/edc98d6679bee0ef25ca25a0061cf531.jpeg\" alt=\"\" /></p>\n<ul>\n<li>还可以记录一些其他信息，比如发起调用服务名称、被调服务名称、返回结果、<code>IP</code>、调用服务的名称等，最后，我们再把相同<code>spanid</code>的信息合成一个大的<code>span</code>块，就完成了一个完整的调用链。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/280a2184ce6acdb621c06b97829fe2b9.jpeg\" alt=\"\" /><br />\n<a name=\"WrMri\"></a></p>\n<h2 id=\"3.-%E6%96%B9%E6%A1%88%E6%AF%94%E8%BE%83\" tabindex=\"-1\">3. 方案比较</h2>\n<p>目前主流的链路追踪工具：<code>Google</code>的<code>Dapper</code>，阿里的鹰眼，大众点评的<code>CAT</code>，<code>Twitter</code>的<code>Zipkin</code>，<code>LINE</code>的<code>pinpoint</code>，国产的<code>skywalking</code>。</p>\n<ul>\n<li><code>**Zipkin**</code><strong>：</strong><code>Twitter</code>开源的调用链分析工具，目前基于<code>springcloud sleuth</code>得到了广泛的使用，特点是轻量，使用部署简单。</li>\n<li><code>**Pinpoint**</code>：韩国人开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，<code>UI</code>功能强大，接入端无代码侵入。</li>\n<li><code>**Skywalking**</code>：国产的优秀<code>APM</code>组件，是一个基于字节码注入的调用链分析，对<code>JAVA</code>分布式应用程序集群的业务运行情况进行追踪、告警和分析的系统。特点是支持多种插件，<code>UI</code>功能较强，接入端无代码侵入。目前已加入<code>Apache</code>孵化器。</li>\n<li><code>**CAT**</code>：大众点评开源的基于编码和配置的调用链分析，应用监控分析，日志采集，监控报警等一系列的监控平台工具。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/8eb65317d9256d8fab489a21dc289bac.png\" alt=\"image.png\" /></p>\n<ul>\n<li><strong>探针的性能</strong></li>\n</ul>\n<p>主要是<code>agent</code>对服务的吞吐量、<code>CPU</code>和内存的影响。微服务的规模和动态性使得数据收集的成本大幅度提高。 <code>skywalking</code>的探针对吞吐量的影响最小，<code>zipkin</code>的吞吐量居中。<code>pinpoint</code>的探针对吞吐量的影响较为明显。</p>\n<ul>\n<li><code>**collector**</code><strong>的可扩展性</strong></li>\n</ul>\n<p>能够水平扩展以便支持大规模服务器集群。 <code>zipkin</code>支持多个实例订阅<code>MQ</code>，异步消费监控信息。<code>skywalking</code>支持单机和集群模式，使用<code>gRPC</code>通信。</p>\n<ul>\n<li><strong>全面的调用链路数据分析</strong></li>\n</ul>\n<p>提供代码级别的可见性以便轻松定位失败点和瓶颈。 zipkin的链路监控粒度到接口级别。<code>skywalking</code> 支持众多的中间件、框架、类库。<code>pinpoint</code>数据分析最完备，提供代码级别的可见性以便轻松定位失败点和瓶颈。</p>\n<ul>\n<li><strong>对于开发透明，容易开关</strong></li>\n</ul>\n<p>添加新功能而无需修改代码，容易启用或者禁用。 <code>Zipkin</code>它要求在需要时修改代码。<code>skywalking</code>和<code>pinpoint</code>基于字节码增强的方式，不需要修改代码，并且可以收集到字节码中的更多精确的信息 。</p>\n<ul>\n<li><strong>完整的调用链应用拓扑</strong></li>\n</ul>\n<p>自动检测应用拓扑，帮助你搞清楚应用的架构。 <code>pinpoint</code>界面显示的更加丰富，具体到调用的<code>DB</code>名，<code>zipkin</code>的拓扑局限于服务于服务之间 。<br />\n<a name=\"Nn9ss\"></a></p>\n<h2 id=\"4.-%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94\" tabindex=\"-1\">4. 性能对比</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/556aa6a8ed0ab44840a7d157d45298f7.png\" alt=\"\" /><br />\n<a name=\"oDfGq\"></a></p>\n<h2 id=\"5.-skywalking-%E7%AE%80%E4%BB%8B\" tabindex=\"-1\">5. SkyWalking 简介</h2>\n<p>分布式系统的应用程序性能监视工具，专为微服务、云原生架构和基于容器（Docker、K8s、Mesos）架构而设计。专门为微服务架构和云原生架构系统而设计并且支持分布式链路追踪的APM系统。通过加载探针以非侵入式的方式收集应用调用链路信息，并对采集的调用链路信息进行分析，生成应用间关系和服务间关系以及服务指标。目前支持多种语言，其中包括Java，.Net Core，Node.js和Go语言。<br />\n<a name=\"qtaJ1\"></a></p>\n<h2 id=\"6.-skywalking-%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7\" tabindex=\"-1\">6. Skywalking 主要功能特性</h2>\n<ul>\n<li>多种监控手段，可以通过语言探针和service mesh获得监控的数据；</li>\n<li>支持多种语言自动探针，包括 Java，.NET Core 和 Node.JS；</li>\n<li>轻量高效，无需大数据平台和大量的服务器资源；</li>\n<li>模块化，UI、存储、集群管理都有多种机制可选；</li>\n<li>支持告警；</li>\n<li>优秀的可视化解决方案；<br />\n<a name=\"MXS4k\"></a></li>\n</ul>\n<h2 id=\"7.-skywalking-%E6%9E%B6%E6%9E%84\" tabindex=\"-1\">7. Skywalking 架构</h2>\n<p>Skywalking 逻辑上分为四部分： 探针、 平台后端、存储和用户界面。<br /><img src=\"https://img-blog.csdnimg.cn/img_convert/d9424dd2d176ba186c9d2d941dbcb0c7.png\" alt=\"image.png\" /></p>\n<ul>\n<li><strong>探针</strong>：基于不同的来源可能是不一样的， 但作用都是收集数据, 将数据格式化为 SkyWalking 适用的格式。</li>\n<li><strong>平台后端</strong>：支持数据聚合， 数据分析以及驱动数据流从探针到用户界面的流程。分析包括 Skywalking 原生追踪和性能指标以及第三方来源，包括 Istio 及 Envoy telemetry， Zipkin 追踪格式化等。 甚至可以使用 Observability Analysis Language 对原生度量指标 和 用于扩展度量的计量系统自定义聚合分析。</li>\n<li><strong>存储</strong>：通过开放的插件化的接口存放 SkyWalking 数据。可以选择一个既有的存储系统，ElasticSearch， H2 或 MySQL 集群。也可以选择自己实现一个存储系统。</li>\n<li>**UI：**一个基于接口高度定制化的Web系统，用户可以可视化查看和管理 SkyWalking 数据。<br />\nsticSearch， H2 或 MySQL 集群。也可以选择自己实现一个存储系统。</li>\n<li>**UI：**一个基于接口高度定制化的Web系统，用户可以可视化查看和管理 SkyWalking 数据。</li>\n</ul>\n', 1, '', 0, 0, 1, '2022-08-09 17:03:37', '2022-08-09 17:05:52');
INSERT INTO `tb_article` VALUES (289, 1, 14, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=8016', '分布式链路追踪- SkyWalking使用手册', '<p><a name=\"QPsq0\"></a></p>\n<h2 id=\"1.-%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D\" tabindex=\"-1\">1. 模块介绍</h2>\n<p><img src=\"https://file.henaumcw.top/blog/image.png\" alt=\"image\" /></p>\n<ul>\n<li>**仪表盘：**监控全局、服务、实例、<code>endpoint</code>几个维度的运行状态。</li>\n<li>**拓扑图：**以拓扑图的方式展现服务直接的关系，并以此为入口查看告警、调用链、服务状态等信息</li>\n<li>**追踪：**以接口列表的方式展现，追踪接口内部调用过程，可以通过<code>traceid</code>查询，进行分布式集群的日志查看及问题排查。</li>\n<li>**性能剖析：**单独端点进行采样分析，并可查看堆栈信息。</li>\n<li>**日志：**包括了<code>browser</code>与<code>service</code>日志集合。</li>\n<li>**告警：**触发告警的告警列表，包括实例，请求超时等。<br />\n<a name=\"oIjgX\"></a></li>\n</ul>\n<h2 id=\"2.-%E4%BB%AA%E8%A1%A8%E7%9B%98\" tabindex=\"-1\">2. 仪表盘</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/120b827d055f4f7eb0b09202a6ab85cb.png\" alt=\"image.png\" /></p>\n<ul>\n<li>第一栏：监控、数据库、容器、<code>vm</code></li>\n<li>第二栏：可以选择某个维度展示不同服务/实例/端点的数据</li>\n<li>第三栏：展示的不同维度，全局、服务、实例、端点的面板。<br />\n<a name=\"q5VO0\"></a></li>\n</ul>\n<h3 id=\"2.1-apm\" tabindex=\"-1\">2.1 APM</h3>\n<p><a name=\"xK3N5\"></a></p>\n<h4 id=\"2.1.1-global\" tabindex=\"-1\">2.1.1 Global</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/b85d560952e0e450778726c4a866b672.png\" alt=\"image.png\" /></p>\n<ul>\n<li><code>**Services load(CPM-callsperminute)**</code>：服务平均每分钟请求数。</li>\n<li><code>**Slow Services(ms)**</code>：慢响应服务，单位<code>ms</code>。</li>\n<li><code>**Un-Health services(Apdex)**</code><strong>：</strong><code>Apdex</code>性能指标，<code>1</code>为满分。</li>\n<li><code>**Slow Endpoints(ms)**</code>：全局维度的慢响应端点(<code>API</code>)。例如一个接口，是全局<code>TopN</code>的数据，通过这个可以观测平台性能情况。</li>\n<li><code>**Global Response Latency(percentileinms)**</code>：全局响应延迟百分位数统计，单位<code>ms</code>。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3523f6c2eb316363ec0288485eac0184.png\" alt=\"image.png\" /><br />\n:::warning<br />\n表示采集样本中某些值的占比，<code>Skywalking</code>有<code>**P50、P75、P90、P95、P99**</code>一些列值。<br /><strong>图中的</strong><code>**P99:950**</code><strong>表示</strong><code>**99%**</code><strong>请求的响应时间在</strong><code>**950ms**</code>**以内。**而<code>99%</code>一般用于抛掉一些极端值，表示绝大多数请求。<br />\n:::</p>\n<ul>\n<li><code>**GlobalHeatmap**</code>：服务响应时间热力分布图，根据时间段内不同响应时间的数量显示颜色深度<br />\n:::warning<br />\n可译为热力图、热度图都可以，<strong>图中颜色越深，表示请求数越多</strong>，这和<code>GitHubContributions</code>很像，<code>commit</code>越多，颜色越深。横坐标是响应时间，鼠标放上去，可以看到具体的数量。通过热力图，一方面可以直观感受平台的整体流量，另一方面也可以感受整体性能。<br />\n:::<br />\n<a name=\"sRJQL\"></a></li>\n</ul>\n<h4 id=\"2.1.2-service\" tabindex=\"-1\">2.1.2 Service</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/720a1bb993bfd80c95cbf6db13caf199.png\" alt=\"image.png\" /></p>\n<ul>\n<li><code>**Service Apdex**</code>**(数字)：**当前服务的评分</li>\n<li><code>**Service Apdex**</code>**(折线图)：**一段时间内<code>Apdex</code>评分</li>\n<li><code>**Service Avg Response Times(ms)**</code>：平均响应延时，单位<code>ms</code></li>\n<li><code>**Service Response Time Percentile**</code>：百分比响应延时，参考<code>GlobalResponseLatency(percentileinms)</code></li>\n<li><code>**Successful Rate**</code>**(数字)：**请求成功率</li>\n<li><code>**Successful Rate**</code>**(折线图)：**一段时间的请求成功率</li>\n<li><code>**Servce Load(CPM/PPM)**</code>**(数字)：**每分钟请求数，</li>\n<li><code>**Servce Load(CPM/PPM)**</code>**(折线图)：**不同时间的每分钟请求数</li>\n<li><code>**Service Throughput(Bytes)**</code>**：**该指标只适用于TCP服务。当前服务的吞吐量。</li>\n<li><code>**Servce Instances Load(CPM/PPM)**</code>**：**每个服务实例的每分钟请求数</li>\n<li><code>**Show Service Instance**</code>**：**每个服务实例的最大延时</li>\n<li><code>**Service Instance Successful Rate**</code>**：**每个服务实例的请求成功率<br />\n<a name=\"jxwGP\"></a></li>\n</ul>\n<h4 id=\"2.1.3-instance\" tabindex=\"-1\">2.1.3 Instance</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/b9d483bd6e380d4b83c9b02e949278c9.png\" alt=\"image.png\" /></p>\n<ul>\n<li><code>**Service Instance Load(CPM/PPM)**</code>**：**当前实例的每分钟请求数</li>\n<li><code>**Service Instance Throughput(Bytes)**</code>**：**该指标只适用于<code>TCP</code>服务。当前服务实例的吞吐量。</li>\n<li><code>**Service Instance Successful Rate(%)**</code>**：**当前实例的请求成功率</li>\n<li><code>**Service Instance Latency(ms)**</code>**：**当前实例的响应延时</li>\n<li><code>**JVM CPU(Java Service)**</code><strong>：</strong><code>jvm</code>占用<code>CPU</code>的百分比</li>\n<li><code>**JVM Memory(Java Service)**</code><strong>：</strong><code>JVM</code>内存占用大小，单位<code>m</code>，包括堆内存，与堆外内存(直接内存)</li>\n<li><code>**JVM GC Time(ms)**</code><strong>：</strong><code>JVM</code>垃圾回收时间，包含<code>YGC</code>和<code>OGC</code></li>\n<li><code>**JVM GC Count**</code><strong>：</strong><code>JVM</code>垃圾回收次数，包含<code>YGC``和``OGC</code></li>\n<li><code>**JVM Thread Count**</code><strong>：</strong><code>JavaService</code></li>\n<li>其他参数为<code>.net</code>的东西<br />\n<a name=\"cyvyU\"></a></li>\n</ul>\n<h4 id=\"2.1.4-endpoint\" tabindex=\"-1\">2.1.4 Endpoint</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/7e0bfe56a96a445782481cf033d5a968.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li><code>**Endpoint Load in Current Service(CPM/PPM)**</code>：每个端点(<code>API</code>)每分钟请求数</li>\n<li><code>**Slow Endpoints in Current Service(ms)**</code>：每个端点(<code>API</code>)的最慢响应请求时间，单位<code>ms</code></li>\n<li><code>**Successful Rate in Current Service(%)**</code>：每个端点(<code>API</code>)的请求成功率</li>\n</ul>\n<p><strong>某个端点：</strong></p>\n<ul>\n<li><code>**Endpoint Load**</code>：当前端点每个时间段的请求数据</li>\n<li><code>**Endpoint Avg Response Time**</code>：当前端点每个时间段的请求行响应时间</li>\n<li><code>**Endpoint Response Time Percentile(ms)**</code>：当前端点每个时间段的响应时间占比</li>\n<li><code>**Endpoint Successful Rate(%)**</code>：当前端点每个时间段的请求成功率<br />\n<a name=\"VwSf5\"></a></li>\n</ul>\n<h3 id=\"2.2-database\" tabindex=\"-1\">2.2 Database</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3fcff212930ef42e9708bab859f66231.png\" alt=\"image.png\" /></p>\n<ul>\n<li><code>**Database Avg Response Time(ms)**</code>：当前数据库事件平均响应时间，单位ms</li>\n<li><code>**Database Access Successful Rate(%)**</code>：当前数据库访问成功率</li>\n<li><code>**Database Traffic(CPM：CallsPerMinute)**</code>：当前数据库每分钟请求数</li>\n<li><code>**Database Access Latency Percentile(ms)**</code>：数据库不同比例的响应时间，单位ms</li>\n<li><code>**Slow Statements(ms)**</code>：前N个慢查询，单位ms</li>\n<li><code>**All Database Loads(CPM：CallsPerMinute)**</code>：所有数据库中请求量排序</li>\n<li><code>**Un-Health Databases**</code>：所有数据库不健康排名，请求成功率排名，失败最多的请求在最上。<br />\n<a name=\"tCpRf\"></a></li>\n</ul>\n<h2 id=\"3.-%E6%8B%93%E6%89%91%E5%9B%BE\" tabindex=\"-1\">3. 拓扑图</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/f577279d3897544b83fee89be492d34d.png\" alt=\"image.png\" /></p>\n<ul>\n<li><code>**AllGroups**</code>**：**选择服务组</li>\n<li><code>**AllServices**</code>**：**选择服务</li>\n<li><code>**CreateGroup**</code>**：**创建新的服务组</li>\n<li>**服务引用拓扑图：**展示服务之间的调用关系，以及服务器的健康状态。<br />\n<a name=\"MApOW\"></a></li>\n</ul>\n<h3 id=\"3.1-%E5%AE%9E%E4%BE%8B%E4%BF%A1%E6%81%AF%E9%9D%A2%E6%9D%BF\" tabindex=\"-1\">3.1 实例信息面板</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/f9b59d5b6d39ddd738db1d1fcda5abdd.png\" alt=\"image.png\" /></p>\n<ul>\n<li>当前服务：可选择具体服务</li>\n<li>当前端点：可选择具体端点</li>\n<li>当前深度：可以选择展示的调用深度</li>\n<li>平均响应时间</li>\n<li>平均吞吐量</li>\n<li>平均<code>SLA</code></li>\n<li>相应百分比</li>\n</ul>\n<p><strong>2-告警面板</strong><br /><strong>3-追踪信息面板</strong><br /><strong>4-服务实力性能状态面板</strong><br /><strong>5-Endpoint(API)面板</strong><br />\n<a name=\"xomOb\"></a></p>\n<h2 id=\"4.-%E8%BF%BD%E8%B8%AA\" tabindex=\"-1\">4. 追踪</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/9eb0b2416a82ab6ae2d9cf9fdc42cced.png\" alt=\"image.png\" /><br />\n<a name=\"wgtnW\"></a></p>\n<h2 id=\"5.-%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90\" tabindex=\"-1\">5. 性能剖析</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/060c76f1f3ce65548e6cf73712045005.png\" alt=\"image.png\" /><br />\n<a name=\"jNq5G\"></a></p>\n<h2 id=\"6.-%E6%97%A5%E5%BF%97\" tabindex=\"-1\">6. 日志</h2>\n<p>未启用<br />\n<a name=\"Q5cRF\"></a></p>\n<h2 id=\"7.-%E5%91%8A%E8%AD%A6\" tabindex=\"-1\">7. 告警</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/ec2101f6414d533324aac8659615d2c1.png\" alt=\"image.png\" /></p>\n<ul>\n<li>服务的平均响应时间在最近10分钟内有3分钟超过1秒</li>\n<li>服务的成功率在最近10分钟内有2分钟低于80％</li>\n<li>实例的平均响应时间在最近10分钟内有2分钟超过1秒</li>\n<li>数据库的平均响应时间在最近10分钟内有2分钟超过1秒</li>\n<li>端点的平均响应时间在最近10分钟内有2分钟超过1秒</li>\n<li>服务在最近10分钟内有2分钟超过1秒平均响应时间超过1秒并且成功率低于80％<br />\n<a name=\"NApja\"></a></li>\n</ul>\n<h2 id=\"8.-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A\" tabindex=\"-1\">8. 名词解释</h2>\n<ul>\n<li><code>**CPM/PPM**</code>**：**对于<code>HTTP1/2</code>、<code>gRPC</code>、<code>RPC</code>服务，这意味着每分钟调用数(<code>CPM：CallsPerMinute</code>)，对于TCP服务，这意味着每分钟包数(<code>PPM：PacketsPerMinute</code>)</li>\n<li><code>**Endpoint**</code>**：**表示具体的服务，例如一个接口或一个定时任务。</li>\n<li>**标签：**我们可以通过<code>core/default/searchableTracesTages</code>中配置标记。<br />\n<a name=\"Fq48n\"></a></li>\n</ul>\n<h2 id=\"9.-%E7%89%B9%E6%AE%8A%E8%AF%B4%E6%98%8E\" tabindex=\"-1\">9. 特殊说明</h2>\n<blockquote>\n<p><strong>如果监控平台正常启动，监控项目也接入，但是就是没有数据，请看看是否是时区问题。</strong></p>\n</blockquote>\n', 1, '', 0, 0, 1, '2022-08-09 17:13:05', '2022-08-09 17:24:29');
INSERT INTO `tb_article` VALUES (290, 1, 16, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7312', '360壁纸API接口', '<ul>\n<li><a href=\"#category\">获取壁纸类别</a></li>\n<li><a href=\"#category-images\">获取某类别下的壁纸</a></li>\n<li><a href=\"#keywords\">按关键字搜索壁纸</a></li>\n<li><a href=\"#search-hot\">获取今日热门搜索</a></li>\n</ul>\n<h2 id=\"category\">获取壁纸类别</h2>\n<p>url：<a href=\"http://wallpaper.apc.360.cn/index.php?c=WallPaperAndroid&amp;a=getAllCategories\" target=\"_blank\">http://wallpaper.apc.360.cn/index.php?c=WallPaperAndroid&amp;a=getAllCategories</a></p>\n<p>url 示例：<a href=\"http://wallpaper.apc.360.cn/index.php?c=WallPaperAndroid&amp;a=getAllCategories\" target=\"_blank\"><code>http://wallpaper.apc.360.cn/index.php?c=WallPaperAndroid&amp;a=getAllCategories</code></a></p>\n<p>json 示例：</p>\n<pre><code>{\n&quot;errno&quot;: &quot;0&quot;,\n&quot;errmsg&quot;: &quot;正常&quot;,\n&quot;consume&quot;: &quot;10&quot;,\n&quot;total&quot;: &quot;16&quot;,\n&quot;data&quot;: [\n    {\n        &quot;id&quot;: &quot;36&quot;,\n        &quot;name&quot;: &quot;4K专区&quot;,\n        &quot;totalcnt&quot;: &quot;2704&quot;,\n        &quot;create_time&quot;: &quot;2015-12-08 13:50:44&quot;,\n        &quot;displaytype&quot;: &quot;&quot;,\n        &quot;tempdata&quot;: &quot;&quot;\n    },\n    {\n        &quot;id&quot;: &quot;6&quot;,\n        &quot;name&quot;: &quot;美女模特&quot;,\n        &quot;totalcnt&quot;: &quot;3905&quot;,\n        &quot;create_time&quot;: &quot;2011-10-29 17:49:27&quot;,\n        &quot;displaytype&quot;: &quot;&quot;,\n        &quot;tempdata&quot;: &quot;&quot;\n    },\n    {\n        &quot;id&quot;: &quot;30&quot;,\n        &quot;name&quot;: &quot;爱情美图&quot;,\n        &quot;totalcnt&quot;: &quot;2305&quot;,\n        &quot;create_time&quot;: &quot;2012-11-23 10:49:25&quot;,\n        &quot;displaytype&quot;: &quot;&quot;,\n        &quot;tempdata&quot;: &quot;&quot;\n    },\n    {\n        &quot;id&quot;: &quot;9&quot;,\n        &quot;name&quot;: &quot;风景大片&quot;,\n        &quot;totalcnt&quot;: &quot;8185&quot;,\n        &quot;create_time&quot;: &quot;2011-11-02 16:33:34&quot;,\n        &quot;displaytype&quot;: &quot;&quot;,\n        &quot;tempdata&quot;: &quot;&quot;\n    },\n    {\n        &quot;id&quot;: &quot;15&quot;,\n        &quot;name&quot;: &quot;小清新&quot;,\n        &quot;totalcnt&quot;: &quot;6922&quot;,\n        &quot;create_time&quot;: &quot;2011-12-15 18:47:03&quot;,\n        &quot;displaytype&quot;: &quot;&quot;,\n        &quot;tempdata&quot;: &quot;&quot;\n    },\n    {\n        &quot;id&quot;: &quot;26&quot;,\n        &quot;name&quot;: &quot;动漫卡通&quot;,\n        &quot;totalcnt&quot;: &quot;6818&quot;,\n        &quot;create_time&quot;: &quot;2012-07-27 17:17:42&quot;,\n        &quot;displaytype&quot;: &quot;&quot;,\n        &quot;tempdata&quot;: &quot;&quot;\n    },\n    {\n        &quot;id&quot;: &quot;11&quot;,\n        &quot;name&quot;: &quot;明星风尚&quot;,\n        &quot;totalcnt&quot;: &quot;4316&quot;,\n        &quot;create_time&quot;: &quot;2011-11-02 17:38:58&quot;,\n        &quot;displaytype&quot;: &quot;&quot;,\n        &quot;tempdata&quot;: &quot;&quot;\n    },\n    {\n        &quot;id&quot;: &quot;14&quot;,\n        &quot;name&quot;: &quot;萌宠动物&quot;,\n        &quot;totalcnt&quot;: &quot;2722&quot;,\n        &quot;create_time&quot;: &quot;2011-12-15 18:23:27&quot;,\n        &quot;displaytype&quot;: &quot;&quot;,\n        &quot;tempdata&quot;: &quot;&quot;\n    },\n    {\n        &quot;id&quot;: &quot;5&quot;,\n        &quot;name&quot;: &quot;游戏壁纸&quot;,\n        &quot;totalcnt&quot;: &quot;2041&quot;,\n        &quot;create_time&quot;: &quot;2011-10-29 17:49:12&quot;,\n        &quot;displaytype&quot;: &quot;&quot;,\n        &quot;tempdata&quot;: &quot;&quot;\n    },\n    {\n        &quot;id&quot;: &quot;12&quot;,\n        &quot;name&quot;: &quot;汽车天下&quot;,\n        &quot;totalcnt&quot;: &quot;1757&quot;,\n        &quot;create_time&quot;: &quot;2011-12-13 18:59:40&quot;,\n        &quot;displaytype&quot;: &quot;&quot;,\n        &quot;tempdata&quot;: &quot;&quot;\n    },\n    {\n        &quot;id&quot;: &quot;10&quot;,\n        &quot;name&quot;: &quot;炫酷时尚&quot;,\n        &quot;totalcnt&quot;: &quot;4828&quot;,\n        &quot;create_time&quot;: &quot;2011-11-02 17:10:53&quot;,\n        &quot;displaytype&quot;: &quot;&quot;,\n        &quot;tempdata&quot;: &quot;&quot;\n    },\n    {\n        &quot;id&quot;: &quot;22&quot;,\n        &quot;name&quot;: &quot;军事天地&quot;,\n        &quot;totalcnt&quot;: &quot;665&quot;,\n        &quot;create_time&quot;: &quot;2012-05-29 15:10:04&quot;,\n        &quot;displaytype&quot;: &quot;&quot;,\n        &quot;tempdata&quot;: &quot;&quot;\n    },\n    {\n        &quot;id&quot;: &quot;16&quot;,\n        &quot;name&quot;: &quot;劲爆体育&quot;,\n        &quot;totalcnt&quot;: &quot;1174&quot;,\n        &quot;create_time&quot;: &quot;2011-12-30 11:37:49&quot;,\n        &quot;displaytype&quot;: &quot;&quot;,\n        &quot;tempdata&quot;: &quot;&quot;\n    },\n    {\n        &quot;id&quot;: &quot;32&quot;,\n        &quot;name&quot;: &quot;纹理&quot;,\n        &quot;totalcnt&quot;: &quot;333&quot;,\n        &quot;create_time&quot;: &quot;2013-03-18 13:58:21&quot;,\n        &quot;displaytype&quot;: &quot;&quot;,\n        &quot;tempdata&quot;: &quot;&quot;\n    },\n    {\n        &quot;id&quot;: &quot;35&quot;,\n        &quot;name&quot;: &quot;文字控&quot;,\n        &quot;totalcnt&quot;: &quot;926&quot;,\n        &quot;create_time&quot;: &quot;2014-09-25 18:35:57&quot;,\n        &quot;displaytype&quot;: &quot;&quot;,\n        &quot;tempdata&quot;: &quot;&quot;\n    },\n    {\n        &quot;id&quot;: &quot;1&quot;,\n        &quot;name&quot;: &quot;限时壁纸&quot;,\n        &quot;totalcnt&quot;: &quot;204&quot;,\n        &quot;create_time&quot;: &quot;2014-09-25 18:20:40&quot;,\n        &quot;displaytype&quot;: &quot;&quot;,\n        &quot;tempdata&quot;: &quot;&quot;\n    }\n]\n</code></pre>\n<p>}</p>\n<p>解析：</p>\n<ul>\n<li><code>total</code>：返回数据数量</li>\n<li><code>data</code>：返回的数据\n<ul>\n<li><code>name</code>：类别名</li>\n<li><code>id</code>：</li>\n<li><code>totalcnt</code>：该类别壁纸数量</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"category-images\">获取某类别下的壁纸</h2>\n<p>url：<a href=\"http://wallpaper.apc.360.cn/index.php?c=WallPaperAndroid&amp;a=getAppsByCategory\" target=\"_blank\">http://wallpaper.apc.360.cn/index.php?c=WallPaperAndroid&amp;a=getAppsByCategory</a></p>\n<p>其他拼接参数：</p>\n<ul>\n<li><code>cid</code>：类别id,类别已知：</li>\n</ul>\n<pre><code class=\"language-\">1：每日精选\n\n5：游戏\n\n6：美女\n\n9：风景\n\n10：视觉创意\n\n11：明星影视\n\n12：汽车\n\n14：萌宠动物\n\n15：小清新\n\n16：体育\n\n22：军事\n\n26：动漫卡通\n\n30：情感\n\n35：文字\n\n\n\n\n\n</code></pre>\n<ul>\n<li><code>start</code>：跳过的记录数</li>\n<li><code>count</code>：返回的数量</li>\n</ul>\n<p>url 示例：<a href=\"http://wallpaper.apc.360.cn/index.php?c=WallPaperAndroid&amp;a=getAppsByCategory&amp;cid=9&amp;start=0&amp;count=99\" target=\"_blank\"><code>http://wallpaper.apc.360.cn/index.php?c=WallPaperAndroid&amp;a=getAppsByCategory&amp;cid=9&amp;start=0&amp;count=99</code></a></p>\n<p>json 示例：</p>\n<pre><code>{\n&quot;errno&quot;: &quot;0&quot;,\n&quot;errmsg&quot;: &quot;正常&quot;,\n&quot;consume&quot;: &quot;6&quot;,\n&quot;total&quot;: &quot;8185&quot;,\n&quot;data&quot;: [\n    {\n        &quot;pid&quot;: &quot;319229&quot;,\n        &quot;cid&quot;: &quot;9&quot;,\n        &quot;dl_cnt&quot;: &quot;0&quot;,\n        &quot;c_t&quot;: &quot;2018-05-02 10:10:54&quot;,\n        &quot;imgcut&quot;: &quot;0&quot;,\n        &quot;url&quot;: &quot;http://p16.qhimg.com/t01d7effbff8a01b127.jpg&quot;,\n        &quot;tempdata&quot;: &quot;&quot;,\n        &quot;fav_total&quot;: &quot;9319&quot;\n    },\n    {\n        &quot;pid&quot;: &quot;319146&quot;,\n        &quot;cid&quot;: &quot;9&quot;,\n        &quot;dl_cnt&quot;: &quot;0&quot;,\n        &quot;c_t&quot;: &quot;2018-04-27 10:06:11&quot;,\n        &quot;imgcut&quot;: &quot;0&quot;,\n        &quot;url&quot;: &quot;http://p17.qhimg.com/t018bb2253d2df00838.jpg&quot;,\n        &quot;tempdata&quot;: &quot;&quot;,\n        &quot;fav_total&quot;: &quot;6425&quot;\n    },\n    {\n        &quot;pid&quot;: &quot;319145&quot;,\n        &quot;cid&quot;: &quot;9&quot;,\n        &quot;dl_cnt&quot;: &quot;0&quot;,\n        &quot;c_t&quot;: &quot;2018-04-27 10:05:44&quot;,\n        &quot;imgcut&quot;: &quot;0&quot;,\n        &quot;url&quot;: &quot;http://p19.qhimg.com/t018d05d2327c2f4bec.jpg&quot;,\n        &quot;tempdata&quot;: &quot;&quot;,\n        &quot;fav_total&quot;: &quot;7093&quot;\n    },\n    {\n        &quot;pid&quot;: &quot;319144&quot;,\n        &quot;cid&quot;: &quot;9&quot;,\n        &quot;dl_cnt&quot;: &quot;0&quot;,\n        &quot;c_t&quot;: &quot;2018-04-27 10:05:01&quot;,\n        &quot;imgcut&quot;: &quot;0&quot;,\n        &quot;url&quot;: &quot;http://p19.qhimg.com/t012864214a3c106fbc.jpg&quot;,\n        &quot;tempdata&quot;: &quot;&quot;,\n        &quot;fav_total&quot;: &quot;5866&quot;\n    },\n    {\n        &quot;pid&quot;: &quot;319143&quot;,\n        &quot;cid&quot;: &quot;9&quot;,\n        &quot;dl_cnt&quot;: &quot;0&quot;,\n        &quot;c_t&quot;: &quot;2018-04-27 10:04:37&quot;,\n        &quot;imgcut&quot;: &quot;0&quot;,\n        &quot;url&quot;: &quot;http://p17.qhimg.com/t01d7f7956cc1be4821.jpg&quot;,\n        &quot;tempdata&quot;: &quot;&quot;,\n        &quot;fav_total&quot;: &quot;5997&quot;\n    }\n]\n</code></pre>\n<p>}</p>\n<p>解析：</p>\n<ul>\n<li><code>total</code>：返回数据数量</li>\n<li><code>data</code>：返回的数据\n<ul>\n<li><code>pid</code>：</li>\n<li><code>cid</code>：类别ID</li>\n<li><code>url</code>：壁纸地址</li>\n<li><code>fav_total</code>：收藏数</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"keywords\">按关键字搜索壁纸</h2>\n<p>url：<a href=\"http://wallpaper.apc.360.cn/index.php?c=WallPaper&amp;a=search\" target=\"_blank\">http://wallpaper.apc.360.cn/index.php?c=WallPaper&amp;a=search</a></p>\n<p>其他拼接参数：</p>\n<ul>\n<li><code>kw</code>：关键字</li>\n<li><code>start</code>：跳过的记录数</li>\n<li><code>count</code>：返回的数量</li>\n</ul>\n<p>url 示例：<a href=\"http://wallpaper.apc.360.cn/index.php?c=WallPaper&amp;a=search&amp;start=0&amp;count=99&amp;kw=%E6%AF%95%E4%B8%9A&amp;start=0&amp;count=99\" target=\"_blank\"><code>http://wallpaper.apc.360.cn/index.php?c=WallPaper&amp;a=search&amp;start=0&amp;count=99&amp;kw=%E6%AF%95%E4%B8%9A&amp;start=0&amp;count=99</code></a></p>\n<p>json 示例：</p>\n<pre><code>{\n&quot;errno&quot;: &quot;0&quot;,\n&quot;errmsg&quot;: &quot;success&quot;,\n&quot;consume&quot;: &quot;0&quot;,\n&quot;total&quot;: &quot;97&quot;,\n&quot;data&quot;: [\n    {\n        &quot;id&quot;: &quot;305990&quot;,\n        &quot;class_id&quot;: &quot;35&quot;,\n        &quot;resolution&quot;: &quot;1920x1200&quot;,\n        &quot;url_mobile&quot;: &quot;http://p18.qhimg.com/t017489cbb76a02bf66.jpg&quot;,\n        &quot;url&quot;: &quot;http://p18.qhimg.com/bdr/__85/t017489cbb76a02bf66.jpg&quot;,\n        &quot;url_thumb&quot;: &quot;http://p18.qhimg.com/t017489cbb76a02bf66.jpg&quot;,\n        &quot;url_mid&quot;: &quot;http://p18.qhimg.com/t017489cbb76a02bf66.jpg&quot;,\n        &quot;download_times&quot;: &quot;0&quot;,\n        &quot;imgcut&quot;: &quot;0&quot;,\n        &quot;tag&quot;: &quot;_全部_ _category_文字_  _category_毕业季_ _category_伤感_ _category_文字控_&quot;,\n        &quot;create_time&quot;: &quot;2017-06-16 13:30:06&quot;,\n        &quot;update_time&quot;: &quot;2017-06-16 13:33:07&quot;,\n        &quot;utag&quot;: &quot;文字 毕业季 伤感&quot;,\n        &quot;tempdata&quot;: &quot;&quot;,\n        &quot;rdata&quot;: [],\n        &quot;img_1600_900&quot;: &quot;http://p18.qhimg.com/bdm/1600_900_85/t017489cbb76a02bf66.jpg&quot;,\n        &quot;img_1440_900&quot;: &quot;http://p18.qhimg.com/bdm/1440_900_85/t017489cbb76a02bf66.jpg&quot;,\n        &quot;img_1366_768&quot;: &quot;http://p18.qhimg.com/bdm/1366_768_85/t017489cbb76a02bf66.jpg&quot;,\n        &quot;img_1280_800&quot;: &quot;http://p18.qhimg.com/bdm/1280_800_85/t017489cbb76a02bf66.jpg&quot;,\n        &quot;img_1280_1024&quot;: &quot;http://p18.qhimg.com/bdm/1280_1024_85/t017489cbb76a02bf66.jpg&quot;,\n        &quot;img_1024_768&quot;: &quot;http://p18.qhimg.com/bdm/1024_768_85/t017489cbb76a02bf66.jpg&quot;\n    },\n    {\n        &quot;id&quot;: &quot;306106&quot;,\n        &quot;class_id&quot;: &quot;35&quot;,\n        &quot;resolution&quot;: &quot;1920x1200&quot;,\n        &quot;url_mobile&quot;: &quot;http://p16.qhimg.com/t01b31a7859ecc52066.jpg&quot;,\n        &quot;url&quot;: &quot;http://p16.qhimg.com/bdr/__85/t01b31a7859ecc52066.jpg&quot;,\n        &quot;url_thumb&quot;: &quot;http://p16.qhimg.com/t01b31a7859ecc52066.jpg&quot;,\n        &quot;url_mid&quot;: &quot;http://p16.qhimg.com/t01b31a7859ecc52066.jpg&quot;,\n        &quot;download_times&quot;: &quot;0&quot;,\n        &quot;imgcut&quot;: &quot;0&quot;,\n        &quot;tag&quot;: &quot;_全部_ _category_文字_  _category_毕业季_ _category_伤感_ _category_文字控_&quot;,\n        &quot;create_time&quot;: &quot;2017-06-20 13:12:50&quot;,\n        &quot;update_time&quot;: &quot;2017-06-20 13:12:50&quot;,\n        &quot;utag&quot;: &quot;文字 毕业季 伤感&quot;,\n        &quot;tempdata&quot;: &quot;&quot;,\n        &quot;rdata&quot;: [],\n        &quot;img_1600_900&quot;: &quot;http://p16.qhimg.com/bdm/1600_900_85/t01b31a7859ecc52066.jpg&quot;,\n        &quot;img_1440_900&quot;: &quot;http://p16.qhimg.com/bdm/1440_900_85/t01b31a7859ecc52066.jpg&quot;,\n        &quot;img_1366_768&quot;: &quot;http://p16.qhimg.com/bdm/1366_768_85/t01b31a7859ecc52066.jpg&quot;,\n        &quot;img_1280_800&quot;: &quot;http://p16.qhimg.com/bdm/1280_800_85/t01b31a7859ecc52066.jpg&quot;,\n        &quot;img_1280_1024&quot;: &quot;http://p16.qhimg.com/bdm/1280_1024_85/t01b31a7859ecc52066.jpg&quot;,\n        &quot;img_1024_768&quot;: &quot;http://p16.qhimg.com/bdm/1024_768_85/t01b31a7859ecc52066.jpg&quot;\n    }\n]\n</code></pre>\n<p>}</p>\n<p>解析：</p>\n<ul>\n<li><code>total</code>：返回数据数量</li>\n<li><code>data</code>：返回的数据\n<ul>\n<li><code>id</code>：壁纸id</li>\n<li><code>tag</code>：所属的壁纸类别名称</li>\n<li><code>utag</code>：壁纸tags</li>\n<li><code>fav_total</code>：收藏数</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"search-hot\">获取今日热门搜索</h2>\n<p>url：<a href=\"http://openbox.mobilem.360.cn/html/api/wallpaperhot.html\" target=\"_blank\">http://openbox.mobilem.360.cn/html/api/wallpaperhot.html</a></p>\n<p>json 示例：</p>\n<pre><code>{\n&quot;error&quot;: 0,\n&quot;end_state&quot;: 1,\n&quot;total&quot;: 11,\n&quot;data&quot;: [\n    &quot;爱情箴言&quot;,\n    &quot;一个人&quot;,\n    &quot;范冰冰&quot;,\n    &quot;温馨&quot;,\n    &quot;阿狸&quot;,\n    &quot;恶搞&quot;,\n    &quot;lomo&quot;,\n    &quot;清纯&quot;,\n    &quot;瓶邪&quot;,\n    &quot;正能量&quot;,\n    &quot;毕业季&quot;,\n    &quot;葫芦娃&quot;,\n    &quot;手写&quot;,\n    &quot;世界杯&quot;,\n    &quot;TFBOYS&quot;,\n    &quot;我是歌手&quot;,\n    &quot;李易峰&quot;,\n    &quot;早安&quot;\n]\n</code></pre>\n<p>}</p>\n<p>解析：</p>\n<ul>\n<li><code>total</code>：返回数据数量</li>\n<li><code>data</code>：返回的数据</li>\n</ul>\n', 1, '', 0, 0, 1, '2022-08-09 17:41:00', '2022-08-09 18:00:02');
INSERT INTO `tb_article` VALUES (291, 1, 16, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1256', '更多电脑和手机高清大图壁纸接口', '<ul>\n<li><a href=\"#vertical\">不分类别获取手机壁纸接口</a></li>\n<li><a href=\"#vertical-category\">获取手机壁纸类别</a></li>\n<li><a href=\"#category-img\">获取某类手机壁纸下壁纸</a></li>\n<li><a href=\"#vertical-comment\">获取手机壁纸评论</a></li>\n<li><a href=\"#get-vertical-img\">下载手机壁纸</a></li>\n<li><a href=\"#pc-category\">获取电脑壁纸类别</a></li>\n<li><a href=\"#category-wallpaper\">获取类别下的电脑壁纸</a></li>\n<li><a href=\"#wallpaper-album\">获取电脑壁纸专辑</a></li>\n<li><a href=\"#album-wallpaper\">获取专辑下的壁纸</a></li>\n<li><a href=\"#get-wallpaper-img\">下载电脑壁纸</a></li>\n</ul>\n<h1 id=\"%E6%89%8B%E6%9C%BA%E5%A3%81%E7%BA%B8%E7%9B%B8%E5%85%B3\" tabindex=\"-1\">手机壁纸相关</h1>\n<h2 id=\"vertical\">不分类别获取壁纸接口</h2>\n<p>url：<a href=\"http://service.picasso.adesk.com/v1/vertical/vertical\" target=\"_blank\">http://service.picasso.adesk.com/v1/vertical/vertical</a></p>\n<p>拼接参数：</p>\n<ul>\n<li><code>limit</code>：返回数量</li>\n<li><code>adult</code>：布尔值，暂时未知</li>\n<li><code>first</code>：数字，如1</li>\n<li><code>skip</code>：略过数量</li>\n<li><code>order</code>：值 <code>hot</code>为favs， <code>new</code></li>\n</ul>\n<p>url 示例：<a href=\"http://service.picasso.adesk.com/v1/vertical/vertical?limit=30&amp;skip=180&amp;adult=false&amp;first=0&amp;order=hot\" target=\"_blank\"><code>http://service.picasso.adesk.com/v1/vertical/vertical?limit=30&amp;skip=180&amp;adult=false&amp;first=0&amp;order=hot</code></a></p>\n<p>json 示例：</p>\n<pre><code>{\n&quot;msg&quot;: &quot;success&quot;,\n&quot;res&quot;: {\n    &quot;vertical&quot;: [\n        {\n            &quot;preview&quot;: &quot;http://img5.adesk.com/595de628e7bce77b95a5968f&quot;,\n            &quot;thumb&quot;: &quot;http://img5.adesk.com/595de628e7bce77b95a5968f?imageMogr2/thumbnail/!350x540r/gravity/Center/crop/350x540&quot;,\n            &quot;img&quot;: &quot;http://img5.adesk.com/595de628e7bce77b95a5968f?imageMogr2/thumbnail/!720x1280r/gravity/Center/crop/720x1280&quot;,\n            &quot;views&quot;: 0,\n            &quot;cid&quot;: [\n                &quot;4e4d610cdf714d2966000002&quot;\n            ],\n            &quot;ncos&quot;: 10,\n            &quot;rank&quot;: 221797,\n            &quot;url&quot;: [\n            ],\n            &quot;tag&quot;: [\n                &quot;海&quot;,\n                &quot;海浪&quot;,\n                &quot;蓝色&quot;,\n                &quot;风景&quot;,\n                &quot;沙滩&quot;\n            ],\n            &quot;rule&quot;: &quot;?imageMogr2/thumbnail/!$&lt;Width&gt;x$&lt;Height&gt;r/gravity/Center/crop/$&lt;Width&gt;x$&lt;Height&gt;&quot;,\n            &quot;wp&quot;: &quot;http://img5.adesk.com/595de628e7bce77b95a5968f&quot;,\n            &quot;xr&quot;: false,\n            &quot;cr&quot;: false,\n            &quot;favs&quot;: 1725,\n            &quot;atime&quot;: 1500618604,\n            &quot;id&quot;: &quot;595de628e7bce77b95a5968f&quot;,\n            &quot;store&quot;: &quot;qiniu&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        }\n    ]\n},\n&quot;code&quot;: 0\n</code></pre>\n<p>}</p>\n<p>解析：</p>\n<ul>\n<li><code>msg</code>：响应信息</li>\n<li><code>res</code>：返回的数据\n<ul>\n<li><code>vertical</code>：返回的壁纸数据\n<ul>\n<li><code>preview</code>：壁纸地址</li>\n<li><code>thumb</code>：小缩略图地址</li>\n<li><code>img</code>：大缩略图地址</li>\n<li><code>views</code>：查看数</li>\n<li><code>cid</code>：所属的类别ID</li>\n</ul>\n</li>\n<li><code>rank</code>：点赞数</li>\n<li><code>tag</code>：壁纸标签</li>\n<li><code>rule</code>：返回不同大小壁纸规则</li>\n<li><code>wp</code>：手机版下载地址</li>\n<li><code>favs</code>：收藏数</li>\n<li><code>atime</code>：创建时间（单位：秒）</li>\n<li><code>id</code>：ID</li>\n<li><code>store</code>：云服务器地址</li>\n<li><code>desc</code>：描述</li>\n</ul>\n</li>\n<li><code>code</code>：返回码</li>\n</ul>\n<h2 id=\"vertical-category\">获取手机壁纸类别</h2>\n<p>url：<a href=\"http://service.picasso.adesk.com/v1/vertical/category\" target=\"_blank\">http://service.picasso.adesk.com/v1/vertical/category</a></p>\n<p>拼接参数：</p>\n<ul>\n<li><code>adult</code>：布尔值，暂时未知</li>\n<li><code>first</code>：数字，如1</li>\n</ul>\n<p>url 示例：<a href=\"http://service.picasso.adesk.com/v1/vertical/category?adult=false&amp;first=1\" target=\"_blank\"><code>http://service.picasso.adesk.com/v1/vertical/category?adult=false&amp;first=1</code></a></p>\n<p>json 示例：</p>\n<pre><code>{\n&quot;msg&quot;: &quot;success&quot;,\n&quot;res&quot;: {\n    &quot;category&quot;: [\n        {\n            &quot;ename&quot;: &quot;girl&quot;,\n            &quot;atime&quot;: 1291266021,\n            &quot;name&quot;: &quot;美女&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/57e7155894e5cc60a375f653&quot;,\n            &quot;sn&quot;: 1,\n            &quot;nimgs&quot;: 0,\n            &quot;uid&quot;: null,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;4e4d610cdf714d2966000000&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        },\n        {\n            &quot;ename&quot;: &quot;animation&quot;,\n            &quot;atime&quot;: 1291266057,\n            &quot;name&quot;: &quot;动漫&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/57e1111069401b6ca3675092&quot;,\n            &quot;sn&quot;: 2,\n            &quot;nimgs&quot;: 0,\n            &quot;uid&quot;: null,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;4e4d610cdf714d2966000003&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        },\n        {\n            &quot;ename&quot;: &quot;landscape&quot;,\n            &quot;atime&quot;: 1291266049,\n            &quot;name&quot;: &quot;风景&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/57e9b82f94e5cc0a9e3e4148&quot;,\n            &quot;sn&quot;: 3,\n            &quot;nimgs&quot;: 0,\n            &quot;uid&quot;: null,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;4e4d610cdf714d2966000002&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        },\n        {\n            &quot;ename&quot;: &quot;game&quot;,\n            &quot;atime&quot;: 1300683934,\n            &quot;name&quot;: &quot;游戏&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/57e4719c94e5cc3320a842d6&quot;,\n            &quot;sn&quot;: 4,\n            &quot;nimgs&quot;: 0,\n            &quot;uid&quot;: null,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;4e4d610cdf714d2966000007&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        },\n        {\n            &quot;ename&quot;: &quot;text&quot;,\n            &quot;atime&quot;: 1359601742,\n            &quot;name&quot;: &quot;文字&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/57e3a91869401b37277ebd8f&quot;,\n            &quot;sn&quot;: 5,\n            &quot;nimgs&quot;: 0,\n            &quot;uid&quot;: null,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;5109e04e48d5b9364ae9ac45&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        },\n        {\n            &quot;ename&quot;: &quot;vision&quot;,\n            &quot;atime&quot;: null,\n            &quot;name&quot;: &quot;视觉&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/57e374d094e5cc14c62ac7ff&quot;,\n            &quot;sn&quot;: 6,\n            &quot;nimgs&quot;: 0,\n            &quot;uid&quot;: null,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;4fb479f75ba1c65561000027&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        },\n        {\n            &quot;ename&quot;: &quot;emotion&quot;,\n            &quot;atime&quot;: null,\n            &quot;name&quot;: &quot;情感&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/57e9b7f994e5cc0a9e3e3fdb&quot;,\n            &quot;sn&quot;: 7,\n            &quot;nimgs&quot;: 0,\n            &quot;uid&quot;: null,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;4ef0a35c0569795756000000&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        },\n        {\n            &quot;ename&quot;: &quot;creative&quot;,\n            &quot;atime&quot;: null,\n            &quot;name&quot;: &quot;设计&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/57e4aacc94e5cc3204926349&quot;,\n            &quot;sn&quot;: 8,\n            &quot;nimgs&quot;: 0,\n            &quot;uid&quot;: null,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;4fb47a195ba1c60ca5000222&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        },\n        {\n            &quot;ename&quot;: &quot;celebrity&quot;,\n            &quot;atime&quot;: 1359601746,\n            &quot;name&quot;: &quot;明星&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/57d6291794e5cc1662ab12b4&quot;,\n            &quot;sn&quot;: 9,\n            &quot;nimgs&quot;: 0,\n            &quot;uid&quot;: null,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;5109e05248d5b9368bb559dc&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        },\n        {\n            &quot;ename&quot;: &quot;stuff&quot;,\n            &quot;atime&quot;: null,\n            &quot;name&quot;: &quot;物语&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/57e3cab494e5cc4d4267546b&quot;,\n            &quot;sn&quot;: 10,\n            &quot;nimgs&quot;: 0,\n            &quot;uid&quot;: null,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;4fb47a465ba1c65561000028&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        },\n        {\n            &quot;ename&quot;: &quot;art&quot;,\n            &quot;atime&quot;: null,\n            &quot;name&quot;: &quot;艺术&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/57e3ad7794e5cc0dfd73401e&quot;,\n            &quot;sn&quot;: 11,\n            &quot;nimgs&quot;: 0,\n            &quot;uid&quot;: null,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;4ef0a3330569795757000000&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        },\n        {\n            &quot;ename&quot;: &quot;man&quot;,\n            &quot;atime&quot;: 1298251540,\n            &quot;name&quot;: &quot;男人&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/57e3cb3594e5cc4d426756e2&quot;,\n            &quot;sn&quot;: 12,\n            &quot;nimgs&quot;: 0,\n            &quot;uid&quot;: null,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;4e4d610cdf714d2966000006&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        },\n        {\n            &quot;ename&quot;: &quot;cartoon&quot;,\n            &quot;atime&quot;: 1291266067,\n            &quot;name&quot;: &quot;卡通&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/57e8655394e5cc322c85cffc&quot;,\n            &quot;sn&quot;: 13,\n            &quot;nimgs&quot;: 0,\n            &quot;uid&quot;: null,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;4e4d610cdf714d2966000004&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        },\n        {\n            &quot;ename&quot;: &quot;machine&quot;,\n            &quot;atime&quot;: 1297756191,\n            &quot;name&quot;: &quot;机械&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/57e7696794e5cc15c9e09423&quot;,\n            &quot;sn&quot;: 13,\n            &quot;nimgs&quot;: 0,\n            &quot;uid&quot;: null,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;4e4d610cdf714d2966000005&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        },\n        {\n            &quot;ename&quot;: &quot;cityscape&quot;,\n            &quot;atime&quot;: null,\n            &quot;name&quot;: &quot;城市&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/57e4e2e094e5cc2b50ce3664&quot;,\n            &quot;sn&quot;: 14,\n            &quot;nimgs&quot;: 0,\n            &quot;uid&quot;: null,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;4fb47a305ba1c60ca5000223&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        },\n        {\n            &quot;ename&quot;: &quot;animal&quot;,\n            &quot;atime&quot;: 1291266042,\n            &quot;name&quot;: &quot;动物&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/57e6971394e5cc5209e89a1f&quot;,\n            &quot;sn&quot;: 16,\n            &quot;nimgs&quot;: 0,\n            &quot;uid&quot;: null,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;4e4d610cdf714d2966000001&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        },\n        {\n            &quot;ename&quot;: &quot;sport&quot;,\n            &quot;atime&quot;: null,\n            &quot;name&quot;: &quot;运动&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/57e07cf794e5cc4c8af92a51&quot;,\n            &quot;sn&quot;: 17,\n            &quot;nimgs&quot;: 0,\n            &quot;uid&quot;: null,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;4ef0a34e0569795757000001&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        },\n        {\n            &quot;ename&quot;: &quot;movie&quot;,\n            &quot;atime&quot;: null,\n            &quot;name&quot;: &quot;影视&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/57e3abb994e5cc0a2560e021&quot;,\n            &quot;sn&quot;: 18,\n            &quot;nimgs&quot;: 0,\n            &quot;uid&quot;: null,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;4e58c2570569791a19000000&quot;,\n            &quot;desc&quot;: &quot;&quot;\n        }\n    ]\n},\n&quot;code&quot;: 0\n</code></pre>\n<p>}</p>\n<p>解析：</p>\n<ul>\n<li><code>msg</code>：响应信息</li>\n<li><code>res</code>：返回的数据\n<ul>\n<li><code>category</code>：返回的分类数据\n<ul>\n<li><code>ename</code>：英文名</li>\n<li><code>atime</code>：创建时间</li>\n<li><code>name</code>：中文名</li>\n<li><code>cover</code>：封面</li>\n<li><code>id</code>：ID</li>\n<li><code>desc</code>：描述</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>code</code>：返回码</li>\n</ul>\n<h2 id=\"category-img\">获取某类手机壁纸下壁纸</h2>\n<p>url：<a href=\"http://service.picasso.adesk.com/v1/vertical/category/\" target=\"_blank\">http://service.picasso.adesk.com/v1/vertical/category/</a> + 类别ID</p>\n<p>拼接参数与解析均与<code>手机壁纸接口</code>一致</p>\n<p>url 示例：<a href=\"http://service.picasso.adesk.com/v1/vertical/category/4e4d610cdf714d2966000003/vertical?limit=30&amp;adult=false&amp;first=1&amp;order=new\" target=\"_blank\"><code>http://service.picasso.adesk.com/v1/vertical/category/4e4d610cdf714d2966000003/vertical?limit=30&amp;adult=false&amp;first=1&amp;order=new</code></a></p>\n<h2 id=\"vertical-comment\">获取手机壁纸评论</h2>\n<p>url：<a href=\"http://service.picasso.adesk.com/v2/vertical/vertical/\" target=\"_blank\">http://service.picasso.adesk.com/v2/vertical/vertical/</a> + 壁纸ID +/comment</p>\n<p>url 示例：<a href=\"http://service.picasso.adesk.com/v2/vertical/vertical/5ab8a9c4e7bce7356a197a07/comment\" target=\"_blank\"><code>http://service.picasso.adesk.com/v2/vertical/vertical/5ab8a9c4e7bce7356a197a07/comment</code></a></p>\n<p>json 示例：</p>\n<pre><code>{\n&quot;msg&quot;: &quot;success&quot;,\n&quot;res&quot;: {\n    &quot;comment&quot;: [\n        {\n            &quot;reply_user&quot;: {\n            },\n            &quot;reply_meta&quot;: {\n            },\n            &quot;content&quot;: &quot;赋册了那个男头整好一对&quot;,\n            &quot;isup&quot;: false,\n            &quot;user&quot;: {\n                &quot;gcid&quot;: &quot;&quot;,\n                &quot;name&quot;: &quot;呐&quot;,\n                &quot;title&quot;: [\n                ],\n                &quot;gender&quot;: 1,\n                &quot;follower&quot;: 0,\n                &quot;avatar&quot;: &quot;http://wx.qlogo.cn/mmopen/vi_32/87rAP06gwZRdu0bsJxArlyMSbCmkWZdL4XbHJutOYrU7AtibEoQcSRXiaNceetPGXy4KYryWtEZzFYwiauuCZ52Lw/0&quot;,\n                &quot;viptime&quot;: 1514605739,\n                &quot;following&quot;: 0,\n                &quot;isvip&quot;: false,\n                &quot;id&quot;: &quot;5a470cab2549593c6feff4c5&quot;\n            },\n            &quot;atime&quot;: 1523412606,\n            &quot;id&quot;: &quot;5acd6e7e042208758c4fdbe9&quot;,\n            &quot;size&quot;: 1\n        },\n        {\n            &quot;reply_user&quot;: {\n                &quot;gcid&quot;: &quot;&quot;,\n                &quot;name&quot;: &quot;卍野念玉秋声雨卍&quot;,\n                &quot;gender&quot;: 0,\n                &quot;follower&quot;: 0,\n                &quot;avatar&quot;: &quot;http://q.qlogo.cn/qqapp/100428621/440684AEB14435F6BB257E8843139849/100&quot;,\n                &quot;viptime&quot;: 1508053370,\n                &quot;following&quot;: 1,\n                &quot;isvip&quot;: false,\n                &quot;id&quot;: &quot;59e3117a9a1aa3405bfddbd8&quot;\n            },\n            &quot;reply_meta&quot;: {\n                &quot;parent_id&quot;: &quot;5acb29e19a1aa320b09b52fd&quot;,\n                &quot;comment_id&quot;: &quot;5acb29e19a1aa320b09b52fd&quot;,\n                &quot;uid&quot;: &quot;59e3117a9a1aa3405bfddbd8&quot;\n            },\n            &quot;content&quot;: &quot;看我收藏&quot;,\n            &quot;isup&quot;: false,\n            &quot;user&quot;: {\n                &quot;gcid&quot;: &quot;&quot;,\n                &quot;name&quot;: &quot;▪ D ▪&quot;,\n                &quot;title&quot;: [\n                ],\n                &quot;gender&quot;: 0,\n                &quot;follower&quot;: 0,\n                &quot;avatar&quot;: &quot;http://q.qlogo.cn/qqapp/100428621/8080E8F27C400BF30CC2ACEC2E2459E9/100&quot;,\n                &quot;viptime&quot;: 978278400,\n                &quot;following&quot;: 1,\n                &quot;isvip&quot;: false,\n                &quot;id&quot;: &quot;54d3847c174cf15a4c95eb48&quot;\n            },\n            &quot;atime&quot;: 1523326825,\n            &quot;id&quot;: &quot;5acc1f6904220875bde01eb2&quot;,\n            &quot;size&quot;: 2\n        },\n        {\n            &quot;reply_user&quot;: {\n            },\n            &quot;reply_meta&quot;: {\n            },\n            &quot;content&quot;: &quot;另一半呢？&quot;,\n            &quot;isup&quot;: false,\n            &quot;user&quot;: {\n                &quot;gcid&quot;: &quot;&quot;,\n                &quot;name&quot;: &quot;卍野念玉秋声雨卍&quot;,\n                &quot;title&quot;: [\n                ],\n                &quot;gender&quot;: 0,\n                &quot;follower&quot;: 0,\n                &quot;avatar&quot;: &quot;http://q.qlogo.cn/qqapp/100428621/440684AEB14435F6BB257E8843139849/100&quot;,\n                &quot;viptime&quot;: 1508053370,\n                &quot;following&quot;: 1,\n                &quot;isvip&quot;: false,\n                &quot;id&quot;: &quot;59e3117a9a1aa3405bfddbd8&quot;\n            },\n            &quot;atime&quot;: 1523263969,\n            &quot;id&quot;: &quot;5acb29e19a1aa320b09b52fd&quot;,\n            &quot;size&quot;: 3\n        },\n        {\n            &quot;reply_user&quot;: {\n            },\n            &quot;reply_meta&quot;: {\n            },\n            &quot;content&quot;: &quot;情头&quot;,\n            &quot;isup&quot;: false,\n            &quot;user&quot;: {\n                &quot;gcid&quot;: &quot;&quot;,\n                &quot;name&quot;: &quot;无幻&quot;,\n                &quot;title&quot;: [\n                ],\n                &quot;gender&quot;: 0,\n                &quot;follower&quot;: 0,\n                &quot;avatar&quot;: &quot;http://q.qlogo.cn/qqapp/100428621/E6517D0DC78EA100B9C7AB3AC1AF05BE/100&quot;,\n                &quot;viptime&quot;: 1490668360,\n                &quot;following&quot;: 0,\n                &quot;isvip&quot;: false,\n                &quot;id&quot;: &quot;58d9cb482549595a962cd5b5&quot;\n            },\n            &quot;atime&quot;: 1523186209,\n            &quot;id&quot;: &quot;5ac9fa2104220875bde0146b&quot;,\n            &quot;size&quot;: 3\n        }\n    ],\n    &quot;hot&quot;: [\n    ],\n    &quot;meta&quot;: {\n        &quot;more&quot;: false\n    },\n    &quot;vertical&quot;: {\n        &quot;isfavor&quot;: false\n    }\n},\n&quot;code&quot;: 0\n</code></pre>\n<p>}</p>\n<p>解析：</p>\n<ul>\n<li><code>msg</code>：响应信息</li>\n<li><code>res</code>：返回的数据\n<ul>\n<li><code>comment</code>：返回的评论数据\n<ul>\n<li><code>reply_user</code>：所回复的评论的发表用户信息</li>\n<li><code>reply_meta</code>：所回复的评论的元数据</li>\n<li><code>content</code>：评论内容</li>\n<li><code>isup</code>：封面</li>\n<li><code>user</code>：\n<ul>\n<li><code>gcid</code>：</li>\n<li><code>name</code>：</li>\n<li><code>title</code>：</li>\n<li><code>gender</code>：</li>\n<li><code>avatar</code>：</li>\n<li><code>follower</code>：</li>\n<li><code>viptime</code>：</li>\n<li><code>following</code>：</li>\n<li><code>isvip</code>：</li>\n<li><code>id</code>：</li>\n</ul>\n</li>\n<li><code>atime</code>：</li>\n<li><code>id</code>：ID</li>\n<li><code>size</code>：点赞数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>code</code>：返回码</li>\n</ul>\n<h2 id=\"get-vertical-img\">下载手机壁纸</h2>\n<p>url：<a href=\"http://img5.adesk.com/\" target=\"_blank\">http://img5.adesk.com/</a> + 壁纸ID</p>\n<h1 id=\"%E7%94%B5%E8%84%91%E5%A3%81%E7%9B%B8%E5%85%B3\" tabindex=\"-1\">电脑壁相关</h1>\n<h2 id=\"pc-category\">获取电脑壁纸类别</h2>\n<p>url：<a href=\"http://service.picasso.adesk.com/v1/wallpaper/category\" target=\"_blank\">http://service.picasso.adesk.com/v1/wallpaper/category</a></p>\n<p>json 示例：</p>\n<pre><code>{\n&quot;msg&quot;: &quot;success&quot;,\n&quot;res&quot;: {\n    &quot;category&quot;: [\n        {\n            &quot;count&quot;: 50741,\n            &quot;ename&quot;: &quot;girl&quot;,\n            &quot;rname&quot;: &quot;美女&quot;,\n            &quot;cover_temp&quot;: &quot;56a964df69401b2866828acb&quot;,\n            &quot;name&quot;: &quot;美女&quot;,\n            &quot;cover&quot;: &quot;http://img5.adesk.com/5ac9b7f3e7bce7251e7c51d6?imageMogr2/thumbnail/!640x480r/gravity/Center/crop/640x480&quot;,\n            &quot;rank&quot;: 1,\n            &quot;filter&quot;: [\n            ],\n            &quot;sn&quot;: 1,\n            &quot;icover&quot;: &quot;564d831f69401b5aed4a86ca&quot;,\n            &quot;atime&quot;: 1291266021,\n            &quot;type&quot;: 1,\n            &quot;id&quot;: &quot;4e4d610cdf714d2966000000&quot;,\n            &quot;picasso_cover&quot;: &quot;5ac9b7f3e7bce7251e7c51d6&quot;\n        },\n        {\n            &quot;count&quot;: 93572,\n            &quot;ename&quot;: &quot;animation&quot;,\n            &quot;rname&quot;: &quot;动漫&quot;,\n            &quot;cover_temp&quot;: &quot;56a221c969401b3f4aa6700a&quot;,\n            &quot;name&quot;: &quot;动漫&quot;,\n            &quot;cover&quot;: &quot;http://img5.adesk.com/5abed1a6e7bce735c2ee06ef?imageMogr2/thumbnail/!640x480r/gravity/Center/crop/640x480&quot;,\n            &quot;rank&quot;: 4,\n            &quot;id&quot;: &quot;4e4d610cdf714d2966000003&quot;,\n            &quot;icover&quot;: &quot;5880889ae7bce7755f3607d9&quot;,\n            &quot;sn&quot;: 2,\n            &quot;atime&quot;: 1291266057,\n            &quot;type&quot;: 1,\n            &quot;filter&quot;: [\n            ],\n            &quot;picasso_cover&quot;: &quot;5abed1a6e7bce735c2ee06ef&quot;\n        },\n        {\n            &quot;count&quot;: 72666,\n            &quot;ename&quot;: &quot;landscape&quot;,\n            &quot;rname&quot;: &quot;风景&quot;,\n            &quot;cover_temp&quot;: &quot;56a770e269401b756c748b28&quot;,\n            &quot;name&quot;: &quot;风景&quot;,\n            &quot;cover&quot;: &quot;http://img5.adesk.com/5ac32b7de7bce7256756a404?imageMogr2/thumbnail/!640x480r/gravity/Center/crop/640x480&quot;,\n            &quot;rank&quot;: 3,\n            &quot;id&quot;: &quot;4e4d610cdf714d2966000002&quot;,\n            &quot;icover&quot;: &quot;58734362e7bce76b93ca2739&quot;,\n            &quot;sn&quot;: 3,\n            &quot;atime&quot;: 1291266049,\n            &quot;type&quot;: 1,\n            &quot;filter&quot;: [\n            ],\n            &quot;picasso_cover&quot;: &quot;5ac32b7de7bce7256756a404&quot;\n        }\n    ]\n},\n&quot;code&quot;: 0\n</code></pre>\n<p>}</p>\n<p>解析：</p>\n<ul>\n<li><code>msg</code>：响应信息</li>\n<li><code>res</code>：返回的数据\n<ul>\n<li><code>category</code>：返回的类别数据\n<ul>\n<li><code>count</code>：总数量</li>\n<li><code>ename</code>：英文名</li>\n<li><code>name</code>：类别中文名</li>\n<li><code>cover</code>：封面</li>\n<li><code>atime</code>：创建时间</li>\n<li><code>id</code>：ID</li>\n<li><code>picasso_cover</code>：封面图ID</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>code</code>：返回码</li>\n</ul>\n<h2 id=\"category-wallpaper\">获取类别下的电脑壁纸</h2>\n<p>url：<a href=\"http://service.picasso.adesk.com/v1/wallpaper/category/+\" target=\"_blank\">http://service.picasso.adesk.com/v1/wallpaper/category/+</a> 类别ID +/wallpaper</p>\n<p>拼接参数与解析与<code>手机壁纸接口</code>类似</p>\n<p>url 示例：<a href=\"http://service.picasso.adesk.com/v1/wallpaper/category/4e4d610cdf714d2966000003/wallpaper?limit=30&amp;adult=false&amp;first=1&amp;order=new\" target=\"_blank\"><code>http://service.picasso.adesk.com/v1/wallpaper/category/4e4d610cdf714d2966000003/wallpaper?limit=30&amp;adult=false&amp;first=1&amp;order=new</code></a></p>\n<p>json 示例：</p>\n<pre><code>{\n&quot;msg&quot;: &quot;success&quot;,\n&quot;res&quot;: {\n    &quot;wallpaper&quot;: [\n        {\n            &quot;views&quot;: 0,\n            &quot;ncos&quot;: 63,\n            &quot;rank&quot;: 28586,\n            &quot;tag&quot;: [\n                &quot;动漫&quot;,\n                &quot;二次元&quot;,\n                &quot;萝莉&quot;,\n                &quot;粉色&quot;,\n                &quot;可爱&quot;\n            ],\n            &quot;wp&quot;: &quot;http://img0.adesk.com/wallpaper?imgid=58808890e7bce774e155766e&quot;,\n            &quot;xr&quot;: true,\n            &quot;cr&quot;: false,\n            &quot;favs&quot;: 899,\n            &quot;atime&quot;: 1486044199,\n            &quot;id&quot;: &quot;58808890e7bce774e155766e&quot;,\n            &quot;desc&quot;: &quot;&quot;,\n            &quot;thumb&quot;: &quot;http://img0.adesk.com/download/58933c27e7bce76a0ab897cf&quot;,\n            &quot;img&quot;: &quot;http://img0.adesk.com/download/58933c27e7bce76a0ab897d9&quot;,\n            &quot;cid&quot;: [\n                &quot;4e4d610cdf714d2966000003&quot;\n            ],\n            &quot;url&quot;: [\n            ],\n            &quot;preview&quot;: &quot;http://img0.adesk.com/download/58933c27e7bce76a0ab897ae&quot;,\n            &quot;store&quot;: &quot;adesk&quot;\n        },\n        {\n            &quot;views&quot;: 0,\n            &quot;ncos&quot;: 16,\n            &quot;rank&quot;: 6673,\n            &quot;tag&quot;: [\n                &quot;动漫&quot;,\n                &quot;二次元&quot;,\n                &quot;风夏&quot;,\n                &quot;少女&quot;,\n                &quot;蓝发&quot;,\n                &quot;耳机&quot;\n            ],\n            &quot;wp&quot;: &quot;http://img0.adesk.com/wallpaper?imgid=58808988e7bce774f46e9d0a&quot;,\n            &quot;xr&quot;: false,\n            &quot;cr&quot;: false,\n            &quot;favs&quot;: 271,\n            &quot;atime&quot;: 1486022615,\n            &quot;id&quot;: &quot;58808988e7bce774f46e9d0a&quot;,\n            &quot;desc&quot;: &quot;&quot;,\n            &quot;thumb&quot;: &quot;http://img0.adesk.com/download/5892e7d7e7bce708ac9434f2&quot;,\n            &quot;img&quot;: &quot;http://img0.adesk.com/download/5892e7d7e7bce708ac9434fb&quot;,\n            &quot;cid&quot;: [\n                &quot;4e4d610cdf714d2966000003&quot;\n            ],\n            &quot;url&quot;: [\n            ],\n            &quot;preview&quot;: &quot;http://img0.adesk.com/download/5892e7d7e7bce708ac9434d0&quot;,\n            &quot;store&quot;: &quot;adesk&quot;\n        }\n    ]\n},\n&quot;code&quot;: 0\n</code></pre>\n<p>}</p>\n<h2 id=\"wallpaper-album\">获取电脑壁纸专辑</h2>\nurl：http://service.picasso.adesk.com/v1/wallpaper/album\n<p>拼接参数与<code>手机壁纸接口</code>类似</p>\n<p>url 示例：<a href=\"http://service.picasso.adesk.com/v1/wallpaper/album?limit=10&amp;adult=false&amp;first=1&amp;order=hot\" target=\"_blank\"><code>http://service.picasso.adesk.com/v1/wallpaper/album?limit=10&amp;adult=false&amp;first=1&amp;order=hot</code></a></p>\n<p>json 示例：</p>\n<pre><code>{\n&quot;msg&quot;: &quot;success&quot;,\n&quot;res&quot;: {\n    &quot;album&quot;: [\n        {\n            &quot;status&quot;: &quot;online&quot;,\n            &quot;ename&quot;: &quot;多啦A梦&quot;,\n            &quot;atime&quot;: 1313732913,\n            &quot;user&quot;: {\n                &quot;gcid&quot;: &quot;&quot;,\n                &quot;name&quot;: &quot;Ipaper&quot;,\n                &quot;gender&quot;: 0,\n                &quot;follower&quot;: 18,\n                &quot;avatar&quot;: &quot;http://img0.adesk.com/download/50f37f0d94e5cc5765e941fd&quot;,\n                &quot;viptime&quot;: 978278400,\n                &quot;following&quot;: 7,\n                &quot;isvip&quot;: false,\n                &quot;id&quot;: &quot;4d5a337c716ec209a5000000&quot;\n            },\n            &quot;name&quot;: &quot;多啦A梦&quot;,\n            &quot;url&quot;: [\n            ],\n            &quot;desc&quot;: &quot;“我可以实现你一个愿望”“那我……想要一个机器猫”&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/53a1020b69401b6f29d91459&quot;,\n            &quot;id&quot;: &quot;4e4df93105697918e6000000&quot;,\n            &quot;tag&quot;: [\n            ],\n            &quot;sn&quot;: 999,\n            &quot;lcover&quot;: &quot;http://img0.adesk.com/download/53a1020b69401b6f29d9145b&quot;,\n            &quot;favs&quot;: 12252,\n            &quot;type&quot;: 1,\n            &quot;isfeed&quot;: false\n        },\n        {\n            &quot;status&quot;: &quot;online&quot;,\n            &quot;ename&quot;: &quot;小动物&quot;,\n            &quot;atime&quot;: 1291266042,\n            &quot;user&quot;: {\n                &quot;gcid&quot;: &quot;&quot;,\n                &quot;name&quot;: &quot;安卓壁纸蛋蛋君&quot;,\n                &quot;gender&quot;: 1,\n                &quot;follower&quot;: 4521,\n                &quot;avatar&quot;: &quot;http://img0.adesk.com/download/53bcf873174cf12dc1add149&quot;,\n                &quot;viptime&quot;: 978278400,\n                &quot;following&quot;: 0,\n                &quot;isvip&quot;: false,\n                &quot;id&quot;: &quot;4d5a2259716ec209a4000000&quot;\n            },\n            &quot;name&quot;: &quot;小动物&quot;,\n            &quot;url&quot;: [\n            ],\n            &quot;desc&quot;: &quot;感谢生命中有他们的温暖陪伴&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/53a16dc569401b6f29dae5c9&quot;,\n            &quot;id&quot;: &quot;4cf727fa716ec22db1000000&quot;,\n            &quot;tag&quot;: [\n            ],\n            &quot;sn&quot;: 999,\n            &quot;lcover&quot;: &quot;http://img0.adesk.com/download/53a16dc569401b6f29dae5cb&quot;,\n            &quot;favs&quot;: 2792,\n            &quot;type&quot;: 1,\n            &quot;isfeed&quot;: false\n        },\n        {\n            &quot;status&quot;: &quot;online&quot;,\n            &quot;ename&quot;: &quot;卡通&quot;,\n            &quot;atime&quot;: 1291266057,\n            &quot;user&quot;: {\n                &quot;gcid&quot;: &quot;&quot;,\n                &quot;name&quot;: &quot;安卓壁纸蛋蛋君&quot;,\n                &quot;gender&quot;: 1,\n                &quot;follower&quot;: 4521,\n                &quot;avatar&quot;: &quot;http://img0.adesk.com/download/53bcf873174cf12dc1add149&quot;,\n                &quot;viptime&quot;: 978278400,\n                &quot;following&quot;: 0,\n                &quot;isvip&quot;: false,\n                &quot;id&quot;: &quot;4d5a2259716ec209a4000000&quot;\n            },\n            &quot;name&quot;: &quot;卡通&quot;,\n            &quot;url&quot;: [\n            ],\n            &quot;desc&quot;: &quot;cartoon, cute little thing&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/53a297d569401b458afca610&quot;,\n            &quot;id&quot;: &quot;4cf72809716ec22daf000001&quot;,\n            &quot;tag&quot;: [\n            ],\n            &quot;sn&quot;: 999,\n            &quot;lcover&quot;: &quot;http://img0.adesk.com/download/53a297d569401b458afca62c&quot;,\n            &quot;favs&quot;: 26111,\n            &quot;type&quot;: 1,\n            &quot;isfeed&quot;: false\n        },\n        {\n            &quot;status&quot;: &quot;online&quot;,\n            &quot;ename&quot;: &quot;机械&quot;,\n            &quot;atime&quot;: 1297756191,\n            &quot;user&quot;: {\n                &quot;gcid&quot;: &quot;&quot;,\n                &quot;name&quot;: &quot;安卓壁纸蛋蛋君&quot;,\n                &quot;gender&quot;: 1,\n                &quot;follower&quot;: 4521,\n                &quot;avatar&quot;: &quot;http://img0.adesk.com/download/53bcf873174cf12dc1add149&quot;,\n                &quot;viptime&quot;: 978278400,\n                &quot;following&quot;: 0,\n                &quot;isvip&quot;: false,\n                &quot;id&quot;: &quot;4d5a2259716ec209a4000000&quot;\n            },\n            &quot;name&quot;: &quot;机械&quot;,\n            &quot;url&quot;: [\n            ],\n            &quot;desc&quot;: &quot;guns,machine,etc&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/53a07f2f69401b6f29d6cef9&quot;,\n            &quot;id&quot;: &quot;4d5a301f716ec20999000004&quot;,\n            &quot;tag&quot;: [\n            ],\n            &quot;sn&quot;: 999,\n            &quot;lcover&quot;: &quot;http://img0.adesk.com/download/53a07f3069401b6f29d6cefb&quot;,\n            &quot;favs&quot;: 2012,\n            &quot;type&quot;: 1,\n            &quot;isfeed&quot;: false\n        },\n        {\n            &quot;status&quot;: &quot;online&quot;,\n            &quot;ename&quot;: &quot;安卓机器人&quot;,\n            &quot;atime&quot;: 1313696307,\n            &quot;user&quot;: {\n                &quot;gcid&quot;: &quot;&quot;,\n                &quot;name&quot;: &quot;安卓壁纸蛋蛋君&quot;,\n                &quot;gender&quot;: 1,\n                &quot;follower&quot;: 4521,\n                &quot;avatar&quot;: &quot;http://img0.adesk.com/download/53bcf873174cf12dc1add149&quot;,\n                &quot;viptime&quot;: 978278400,\n                &quot;following&quot;: 0,\n                &quot;isvip&quot;: false,\n                &quot;id&quot;: &quot;4d5a2259716ec209a4000000&quot;\n            },\n            &quot;name&quot;: &quot;安卓机器人&quot;,\n            &quot;url&quot;: [\n            ],\n            &quot;desc&quot;: &quot;安卓无敌！&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/53a16ff869401b6f29daef2d&quot;,\n            &quot;id&quot;: &quot;4e4d6a3305697911c9000005&quot;,\n            &quot;tag&quot;: [\n            ],\n            &quot;sn&quot;: 999,\n            &quot;lcover&quot;: &quot;http://img0.adesk.com/download/53a16ff869401b6f29daef2f&quot;,\n            &quot;favs&quot;: 2197,\n            &quot;type&quot;: 1,\n            &quot;isfeed&quot;: false\n        },\n        {\n            &quot;status&quot;: &quot;online&quot;,\n            &quot;ename&quot;: &quot;盒子先生&quot;,\n            &quot;atime&quot;: 1313696371,\n            &quot;user&quot;: {\n                &quot;gcid&quot;: &quot;&quot;,\n                &quot;name&quot;: &quot;安卓壁纸蛋蛋君&quot;,\n                &quot;gender&quot;: 1,\n                &quot;follower&quot;: 4521,\n                &quot;avatar&quot;: &quot;http://img0.adesk.com/download/53bcf873174cf12dc1add149&quot;,\n                &quot;viptime&quot;: 978278400,\n                &quot;following&quot;: 0,\n                &quot;isvip&quot;: false,\n                &quot;id&quot;: &quot;4d5a2259716ec209a4000000&quot;\n            },\n            &quot;name&quot;: &quot;盒子先生&quot;,\n            &quot;url&quot;: [\n            ],\n            &quot;desc&quot;: &quot;发现盒子先生的世界 ( ¯ □ ¯ )&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/53a1798a69401b6f29db131a&quot;,\n            &quot;id&quot;: &quot;4e4d6a7305697911c9000006&quot;,\n            &quot;tag&quot;: [\n            ],\n            &quot;sn&quot;: 999,\n            &quot;lcover&quot;: &quot;http://img0.adesk.com/download/53a1798a69401b6f29db131c&quot;,\n            &quot;favs&quot;: 14898,\n            &quot;type&quot;: 1,\n            &quot;isfeed&quot;: false\n        },\n        {\n            &quot;status&quot;: &quot;online&quot;,\n            &quot;ename&quot;: &quot;中国风&quot;,\n            &quot;atime&quot;: 1313697638,\n            &quot;user&quot;: {\n                &quot;gcid&quot;: &quot;&quot;,\n                &quot;name&quot;: &quot;安卓壁纸蛋蛋君&quot;,\n                &quot;gender&quot;: 1,\n                &quot;follower&quot;: 4521,\n                &quot;avatar&quot;: &quot;http://img0.adesk.com/download/53bcf873174cf12dc1add149&quot;,\n                &quot;viptime&quot;: 978278400,\n                &quot;following&quot;: 0,\n                &quot;isvip&quot;: false,\n                &quot;id&quot;: &quot;4d5a2259716ec209a4000000&quot;\n            },\n            &quot;name&quot;: &quot;中国风&quot;,\n            &quot;url&quot;: [\n            ],\n            &quot;desc&quot;: &quot;中国文化，博大精深&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/53a13db669401b6f29da1913&quot;,\n            &quot;id&quot;: &quot;4e4d6f660569791281000000&quot;,\n            &quot;tag&quot;: [\n            ],\n            &quot;sn&quot;: 999,\n            &quot;lcover&quot;: &quot;http://img0.adesk.com/download/53a13db769401b6f29da1915&quot;,\n            &quot;favs&quot;: 22159,\n            &quot;type&quot;: 1,\n            &quot;isfeed&quot;: false\n        },\n        {\n            &quot;status&quot;: &quot;online&quot;,\n            &quot;ename&quot;: &quot;我爱汽车&quot;,\n            &quot;atime&quot;: 1313697740,\n            &quot;user&quot;: {\n                &quot;gcid&quot;: &quot;&quot;,\n                &quot;name&quot;: &quot;安卓壁纸蛋蛋君&quot;,\n                &quot;gender&quot;: 1,\n                &quot;follower&quot;: 4521,\n                &quot;avatar&quot;: &quot;http://img0.adesk.com/download/53bcf873174cf12dc1add149&quot;,\n                &quot;viptime&quot;: 978278400,\n                &quot;following&quot;: 0,\n                &quot;isvip&quot;: false,\n                &quot;id&quot;: &quot;4d5a2259716ec209a4000000&quot;\n            },\n            &quot;name&quot;: &quot;贴地飞行&quot;,\n            &quot;url&quot;: [\n            ],\n            &quot;desc&quot;: &quot;激活细胞的跃动，引爆血液的燃烧&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/53a2c15b69401b45756b47e9&quot;,\n            &quot;id&quot;: &quot;4e4d6fcc0569791281000001&quot;,\n            &quot;tag&quot;: [\n            ],\n            &quot;sn&quot;: 999,\n            &quot;lcover&quot;: &quot;http://img0.adesk.com/download/53a2c15b69401b45756b4806&quot;,\n            &quot;favs&quot;: 7249,\n            &quot;type&quot;: 1,\n            &quot;isfeed&quot;: false\n        },\n        {\n            &quot;status&quot;: &quot;online&quot;,\n            &quot;ename&quot;: &quot;看灰机&quot;,\n            &quot;atime&quot;: 1313697841,\n            &quot;user&quot;: {\n                &quot;gcid&quot;: &quot;&quot;,\n                &quot;name&quot;: &quot;安卓壁纸蛋蛋君&quot;,\n                &quot;gender&quot;: 1,\n                &quot;follower&quot;: 4521,\n                &quot;avatar&quot;: &quot;http://img0.adesk.com/download/53bcf873174cf12dc1add149&quot;,\n                &quot;viptime&quot;: 978278400,\n                &quot;following&quot;: 0,\n                &quot;isvip&quot;: false,\n                &quot;id&quot;: &quot;4d5a2259716ec209a4000000&quot;\n            },\n            &quot;name&quot;: &quot;看灰机&quot;,\n            &quot;url&quot;: [\n            ],\n            &quot;desc&quot;: &quot;看，灰过来了，又灰过去了！&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/53a1753169401b6f29db02ae&quot;,\n            &quot;id&quot;: &quot;4e4d70310569791281000003&quot;,\n            &quot;tag&quot;: [\n            ],\n            &quot;sn&quot;: 999,\n            &quot;lcover&quot;: &quot;http://img0.adesk.com/download/53a1753169401b6f29db02b0&quot;,\n            &quot;favs&quot;: 3950,\n            &quot;type&quot;: 1,\n            &quot;isfeed&quot;: false\n        },\n        {\n            &quot;status&quot;: &quot;online&quot;,\n            &quot;ename&quot;: &quot;山水&quot;,\n            &quot;atime&quot;: 1313697989,\n            &quot;user&quot;: {\n                &quot;gcid&quot;: &quot;&quot;,\n                &quot;name&quot;: &quot;安卓壁纸蛋蛋君&quot;,\n                &quot;gender&quot;: 1,\n                &quot;follower&quot;: 4521,\n                &quot;avatar&quot;: &quot;http://img0.adesk.com/download/53bcf873174cf12dc1add149&quot;,\n                &quot;viptime&quot;: 978278400,\n                &quot;following&quot;: 0,\n                &quot;isvip&quot;: false,\n                &quot;id&quot;: &quot;4d5a2259716ec209a4000000&quot;\n            },\n            &quot;name&quot;: &quot;山水&quot;,\n            &quot;url&quot;: [\n            ],\n            &quot;desc&quot;: &quot;临深而志清 登高而意远&quot;,\n            &quot;cover&quot;: &quot;http://img0.adesk.com/download/53a2994e69401b461bc08dda&quot;,\n            &quot;id&quot;: &quot;4e4d70c50569791387000001&quot;,\n            &quot;tag&quot;: [\n            ],\n            &quot;sn&quot;: 999,\n            &quot;lcover&quot;: &quot;http://img0.adesk.com/download/53a2994e69401b461bc08dfb&quot;,\n            &quot;favs&quot;: 8542,\n            &quot;type&quot;: 1,\n            &quot;isfeed&quot;: false\n        }\n    ],\n    &quot;banner&quot;: [\n        {\n            &quot;value&quot;: {\n                &quot;ename&quot;: &quot;&quot;,\n                &quot;isfeed&quot;: false,\n                &quot;tag&quot;: [\n                ],\n                &quot;id&quot;: &quot;5acc62e8e7bce7251e7c5377&quot;,\n                &quot;top&quot;: 0,\n                &quot;type&quot;: 1,\n                &quot;status&quot;: &quot;online&quot;,\n                &quot;user&quot;: {\n                    &quot;gcid&quot;: &quot;&quot;,\n                    &quot;name&quot;: &quot;蛋蛋君&quot;,\n                    &quot;gender&quot;: 0,\n                    &quot;follower&quot;: 2982,\n                    &quot;avatar&quot;: &quot;http://s.adesk.com/picasso/avatar_default.png&quot;,\n                    &quot;viptime&quot;: 978278400,\n                    &quot;following&quot;: 0,\n                    &quot;isvip&quot;: false,\n                    &quot;id&quot;: &quot;561f6b2194e5cc423617f328&quot;\n                },\n                &quot;favs&quot;: 10,\n                &quot;atime&quot;: 1523344104,\n                &quot;desc&quot;: &quot;毕业季伤感未至，离奇“作品”却是汹汹来袭，毕设内容新奇独特，创作过程却是一波三折，4.13 无刺激，不毕业，《毕业作品》不见不散&quot;,\n                &quot;name&quot;: &quot;【独家】毕业作品&quot;,\n                &quot;url&quot;: [\n                    {\n                        &quot;name&quot;: &quot;点我送票哦！&quot;,\n                        &quot;target&quot;: &quot;https://weibo.com/1977161541/GbsudF1gx?from=page_1006061977161541_profile&amp;wvr=6&amp;mod=weibotime&amp;type=comment&quot;\n                    }\n                ],\n                &quot;cover&quot;: &quot;http://img5.adesk.com/5acc664ee7bce72552e69f12?imageView2/3/h/240&quot;,\n                &quot;lcover&quot;: &quot;http://img5.adesk.com/5acc664ee7bce72552e69f12?imageView2/3/h/720&quot;,\n                &quot;subname&quot;: &quot;&quot;,\n                &quot;sn&quot;: 999\n            },\n            &quot;offtm&quot;: 1523345483,\n            &quot;target&quot;: &quot;5acc62e8e7bce7251e7c5377&quot;,\n            &quot;img&quot;: &quot;5acc684be7bce7251e7c537a&quot;,\n            &quot;new_img&quot;: null,\n            &quot;new_thumb&quot;: &quot;http://img0.adesk.com/download/http://img0.adesk.com/download/5acc684be7bce7251e7c537a&quot;,\n            &quot;oid&quot;: null,\n            &quot;thumb&quot;: &quot;http://img0.adesk.com/download/5acc684be7bce7251e7c537a&quot;,\n            &quot;module&quot;: 5,\n            &quot;_id&quot;: &quot;5acc684be7bce7251e7c537d&quot;,\n            &quot;reco&quot;: &quot;&quot;,\n            &quot;ontm&quot;: 1523345483,\n            &quot;desc&quot;: &quot;&quot;,\n            &quot;atime&quot;: 1523345483,\n            &quot;type&quot;: 7,\n            &quot;id&quot;: &quot;5acc684be7bce7251e7c537d&quot;,\n            &quot;market&quot;: [\n            ],\n            &quot;uid&quot;: &quot;5965cd0be7bce7312ef79fbf&quot;\n        },\n        {\n            &quot;value&quot;: {\n                &quot;status&quot;: &quot;online&quot;,\n                &quot;ename&quot;: &quot;&quot;,\n                &quot;atime&quot;: 1481871292,\n                &quot;url&quot;: [\n                ],\n                &quot;user&quot;: {\n                    &quot;gcid&quot;: &quot;&quot;,\n                    &quot;name&quot;: &quot;兔几&quot;,\n                    &quot;gender&quot;: 1,\n                    &quot;follower&quot;: 6228,\n                    &quot;avatar&quot;: &quot;http://img0.adesk.com/download/5847b5adda76f7450a045ef4&quot;,\n                    &quot;viptime&quot;: 1479363990,\n                    &quot;following&quot;: 0,\n                    &quot;isvip&quot;: false,\n                    &quot;id&quot;: &quot;582d4d9694e5cc1942a88c3e&quot;\n                },\n                &quot;cover&quot;: &quot;http://img5.adesk.com/5acb1a18e7bce72552e69ed5?imageView2/3/h/240&quot;,\n                &quot;name&quot;: &quot;魔卡少女樱&quot;,\n                &quot;tag&quot;: [\n                ],\n                &quot;sn&quot;: 999,\n                &quot;id&quot;: &quot;58538fbc69401b34865ef784&quot;,\n                &quot;lcover&quot;: &quot;http://img5.adesk.com/5acb1a18e7bce72552e69ed5?imageView2/3/h/720&quot;,\n                &quot;favs&quot;: 6733,\n                &quot;type&quot;: 1,\n                &quot;isfeed&quot;: false,\n                &quot;desc&quot;: &quot;木之本樱，是就读于友枝小学的小学4年级学生。与父亲和哥哥3人一起生活。一天，小樱在父亲的书房发现一本奇怪的书。那本书中是会给这个世界带来灾难的“库洛牌”！为了回收散布各处的库洛牌，小樱成为了“魔卡捕获者”并不断奋斗……&quot;\n            },\n            &quot;offtm&quot;: 1518438510,\n            &quot;target&quot;: &quot;58538fbc69401b34865ef784&quot;,\n            &quot;img&quot;: &quot;5a81886ee7bce7259115e72f&quot;,\n            &quot;new_img&quot;: &quot;5a81886ee7bce7259115e732&quot;,\n            &quot;new_thumb&quot;: &quot;http://img0.adesk.com/download/5a81886ee7bce7259115e732&quot;,\n            &quot;oid&quot;: null,\n            &quot;thumb&quot;: &quot;http://img0.adesk.com/download/5a81886ee7bce7259115e72f&quot;,\n            &quot;module&quot;: 5,\n            &quot;_id&quot;: &quot;5a81886ee7bce7259115e735&quot;,\n            &quot;reco&quot;: &quot;&quot;,\n            &quot;ontm&quot;: 1518438510,\n            &quot;desc&quot;: &quot;&quot;,\n            &quot;atime&quot;: 1518438510,\n            &quot;type&quot;: 7,\n            &quot;id&quot;: &quot;5a81886ee7bce7259115e735&quot;,\n            &quot;market&quot;: [\n            ],\n            &quot;uid&quot;: &quot;507b922bcd29911da5b9bea8&quot;\n        }\n    ]\n},\n&quot;code&quot;: 0\n</code></pre>\n<p>}</p>\n<p>解析：</p>\n<ul>\n<li><code>msg</code>：响应信息</li>\n<li><code>res</code>：返回的数据\n<ul>\n<li><code>album</code>：返回的专辑数据\n<ul>\n<li><code>name</code>：专辑名</li>\n<li><code>desc</code>：描述</li>\n<li><code>cover</code>：封面</li>\n<li><code>lcover</code>：大封面</li>\n<li><code>atime</code>：创建时间</li>\n<li><code>favs</code>：收藏数</li>\n<li><code>id</code>：ID</li>\n</ul>\n</li>\n<li><code>banner</code>：返回的banner信息（与专辑无关，是时间的banner）\n<ul>\n<li><code>value</code>：banner宣传的专辑信息</li>\n<li><code>offtm</code>：时间</li>\n<li><code>img</code>：封面图片ID</li>\n<li><code>atime</code>：创建时间</li>\n<li><code>target</code>：所宣传的专辑的ID</li>\n<li><code>thumb</code>：封面图片地址</li>\n<li><code>id</code>：ID</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>code</code>：返回码</li>\n</ul>\n<h2 id=\"album-wallpaper\">获取专辑下的壁纸</h2>\n<p>url：<a href=\"http://service.picasso.adesk.com/v1/wallpaper/album/+\" target=\"_blank\">http://service.picasso.adesk.com/v1/wallpaper/album/+</a> 专辑ID +/wallpaper</p>\n<p>拼接参数、解析与<code>手机壁纸接口</code>类似</p>\n<p>url 示例：<a href=\"http://service.picasso.adesk.com/v1/wallpaper/album/5acc579be7bce7253c78cf9c/wallpaper?limit=30&amp;adult=false&amp;first=1&amp;order=new\" target=\"_blank\"><code>http://service.picasso.adesk.com/v1/wallpaper/album/5acc579be7bce7253c78cf9c/wallpaper?limit=30&amp;adult=false&amp;first=1&amp;order=new</code></a></p>\n<p>json示例：</p>\n<pre><code>{\n&quot;msg&quot;: &quot;success&quot;,\n&quot;res&quot;: {\n    &quot;album&quot;: {\n        &quot;ename&quot;: &quot;&quot;,\n        &quot;isfeed&quot;: false,\n        &quot;tag&quot;: [\n        ],\n        &quot;id&quot;: &quot;5acc579be7bce7253c78cf9c&quot;,\n        &quot;top&quot;: 0,\n        &quot;type&quot;: 1,\n        &quot;status&quot;: &quot;online&quot;,\n        &quot;user&quot;: {\n            &quot;gcid&quot;: &quot;&quot;,\n            &quot;name&quot;: &quot;一念夕雾&quot;,\n            &quot;gender&quot;: 1,\n            &quot;follower&quot;: 13656,\n            &quot;avatar&quot;: &quot;http://img0.adesk.com/download/5ab664ca254959399461b5f7&quot;,\n            &quot;viptime&quot;: 1499843851,\n            &quot;following&quot;: 0,\n            &quot;isvip&quot;: false,\n            &quot;id&quot;: &quot;5965cd0be7bce7312ef79fbf&quot;\n        },\n        &quot;favs&quot;: 74,\n        &quot;atime&quot;: 1523341211,\n        &quot;desc&quot;: &quot;九头龙八一仅16岁就获得了将棋界最强头衔“龙王”，某天他的家中竟突然出现了一名9岁的小学女生雏鹤爱，并且对方还要成为八一的弟子？！在这样的背景下，一场奇妙的同居生活就此开始。&quot;,\n        &quot;name&quot;: &quot;龙王的工作&quot;,\n        &quot;url&quot;: [\n        ],\n        &quot;cover&quot;: &quot;http://img5.adesk.com/5acc73c0e7bce7250515cdcb?imageView2/3/h/240&quot;,\n        &quot;lcover&quot;: &quot;http://img5.adesk.com/5acc73c0e7bce7250515cdcb?imageView2/3/h/720&quot;,\n        &quot;subname&quot;: &quot;&quot;,\n        &quot;sn&quot;: 999\n    },\n    &quot;wallpaper&quot;: [\n    ],\n    &quot;subject&quot;: [\n    ]\n},\n&quot;code&quot;: 0\n</code></pre>\n<p>}</p>\n<h2 id=\"get-wallpaper-img\">下载电脑壁纸</h2>\n<p>url：<a href=\"http://img5.adesk.com/\" target=\"_blank\">http://img5.adesk.com/</a> + 壁纸ID</p>\n', 1, '', 0, 0, 1, '2022-08-09 17:49:02', '2022-08-09 17:59:27');
INSERT INTO `tb_article` VALUES (292, 1, 16, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=2423', '每日一文API接口', '<ul>\n<li><a href=\"#article\">每日一文</a></li>\n<li><a href=\"#someday\">特定某天一文</a></li>\n<li><a href=\"#random\">随机一文</a></li>\n</ul>\n<h2 id=\"article\">每日一文</h2>\n<p>url：<a href=\"https://interface.meiriyiwen.com/article/today?dev=1\" target=\"_blank\"><code>https://interface.meiriyiwen.com/article/today?dev=1</code></a></p>\n<p>json 示例：</p>\n<pre><code>{\n  &quot;data&quot;: {\n    &quot;date&quot;: {\n      &quot;curr&quot;: &quot;20170217&quot;,\n      &quot;prev&quot;: &quot;20170216&quot;,\n      &quot;next&quot;: &quot;20170218&quot;\n    },\n    &quot;author&quot;: &quot;契诃夫&quot;,\n    &quot;title&quot;: &quot;散戏之后&quot;,\n    &quot;digest&quot;: &quot;娜卡.戴莱尼同她母亲从戏园里回来，那天，戏园里演了一出戏名叫《叶甫盖尼.奥涅金》的戏剧。她跑到自己的屋子里去，很快脱去衣服，散开发辫，穿了一&quot;,\n    &quot;content&quot;: &quot;&lt;p&gt;娜卡.戴莱尼同她母亲从戏园里回来，那天，戏园里演了一出戏名叫《叶甫盖尼.奥涅金》的戏剧。她跑到自己的屋子里去，很快脱去衣服，散开发辫，穿了一条短裙和衬衣，坐在桌子旁边，想仿照达吉雅娜的笔调写一封信。&lt;/p&gt;&lt;p&gt;她写道——&lt;/p&gt;&lt;p&gt;“我爱你，可是你不爱我，不爱我！”&lt;/p&gt;&lt;p&gt;她写着写着就笑了起来。&lt;/p&gt;&lt;p&gt;她那时候不过十六岁，她还没有爱上谁，却知道军官戈尔南和学生格罗兹杰夫都很爱她。可自从那天晚上看完戏以后，她对于他们的爱情忽然生出疑惑。做不被人爱的、不幸的人——那多有趣啊！她觉得一个人爱得深，而另一个却很冷淡，是一件很有意思，很动人，并且含着诗味的事情。&lt;/p&gt;&lt;p&gt;在那出戏里，奥涅金以绝不爱人为乐趣，达吉雅娜却老迷着他，因为她很爱他，假如他们能够互相恋爱，享受幸福，那这件事情也就枯涩无味了。&lt;/p&gt;&lt;p&gt;娜卡想起军官戈尔南来，就往下写道：&lt;/p&gt;&lt;p&gt;“你也不用在我面前坚持说你爱我，我也不能够信你。你很聪明，很有学问，很严正；你是绝对的天才，光明的未来正等着你，我却是一个低微的不幸女人，并且你也深知我只会成为你生活上的阻碍。虽然你还在注意我，想着用你自己的理想来迎合我，然而这一定是错误的，现在你一定已经后悔，并且自问道：我为什么要同那姑娘亲热呢？可不过因为你这个人太善良，所以你还不愿意承认呢！……”&lt;/p&gt;&lt;p&gt;娜卡写到这里，觉得自己身世飘零，禁不住就流下泪来，继续写道：&lt;/p&gt;&lt;p&gt;“我很不忍离开我那亲爱的母亲和兄弟，要不然我就披上袈裟，只身遁去，到那人迹不到的地方去另讨生活。那你也就成了自由的人，可以另爱别人了。唉，我还不如一死呢！”&lt;/p&gt;&lt;p&gt;娜卡含着一泡眼泪，也辨别不出写的是什么，只看见桌子上，地板上和顶棚上，一条一条的彩虹不住地在那里摇荡着，仿佛是从三棱镜里看见的一样。她也写不上来，就往椅子背上一靠，想起戈尔南来。&lt;/p&gt;&lt;p&gt;男子真有趣，却真能撩人呀！娜卡想起他们一块儿谈论音乐的时候，他那又温柔，又口吃，并且时常错误的言辞是何等的有趣！他也总是竭力地使自己的嗓音不流露出激烈的声调。在社交场合，即使有冷静的头脑和骄傲的习气，受过高等教育，有着道德高尚的表征，自己的嗜好也不得不收藏在一边。戈尔南也知道这样藏着，可是终有时要流露出来，所以大家都知道他对于音乐十分嗜好。有人不免要不断地议论音乐，或者有不了解音乐的人偏要发出那可笑的言论，他却还保持着常态，好像恐惧胆小似的一句话也不说。他钢琴弹得很好，和真正的钢琴家弹的一样。假如他不做军官，他一定会成为一位有名的音乐家呢。&lt;/p&gt;&lt;p&gt;眼睛里的泪也干了。娜卡回忆起戈尔南曾在音乐会上和她讲过爱情，后来在穿衣架旁边也讲过一次，那时候正徐徐地吹着微风，她又往下继续写道：&lt;/p&gt;&lt;p&gt;“我很高兴你跟格罗兹杰夫认识了，他是一个很聪明的人，你一定也爱他，昨天他在我家里，坐到两点钟才走。那天晚上我们都很快乐，可惜你却没有来。他讲了许多有趣的话。”&lt;/p&gt;&lt;p&gt;娜卡手按在桌上，头枕着手，她的头发遮没了那封信。她记得学生格罗兹杰夫也很爱她，他也应当有一封和戈尔南同样的信才好。不过要怎样给格罗兹杰夫写信呢？不知什么缘故她的胸中忽然掀起了一股的欢乐：起初这股欢乐还小，仿佛在胸问摇荡着一个小橡皮球儿一样，然后那快乐就慢慢地扩大，竟像波浪起伏一样。娜卡也忘记想戈尔南和格罗兹杰夫，因为她的思想已经错乱，可是那快乐却越发地增长起来，从胸脯达到手足四肢，欢乐好像轻微的冷风似的吹进头脑里来，掠着头发过去。她耸着肩膀不住地微笑，连桌子和灯上的玻璃都慢慢地颤动起来，眼泪也进了出来，落在那张信纸上面。她的笑好久没能止住，她想要停止来着。为了表明自己不是无端发笑，她打算赶紧想出一件可笑的事情来。她觉得自己笑得快透不过气来了，赶紧说道：&lt;/p&gt;&lt;p&gt;“这只小狗真可笑！这只小狗真可笑！”&lt;/p&gt;&lt;p&gt;她记起，昨天喝茶后格罗兹杰夫同小狗马克新闹着玩，之后他就讲起一只聪明小狗的故事来：&lt;/p&gt;&lt;p&gt;那只小狗在院子里追赶乌鸦，乌鸦却回头看着它说道：&lt;/p&gt;&lt;p&gt;“哼，你这个坏蛋！”&lt;/p&gt;&lt;p&gt;小狗并不知道那被他追赶的乌鸦是很有学问的，一下子就呆住了，疑惑了好一会儿，然后就狂吠起来。&lt;/p&gt;&lt;p&gt;想到这里，娜卡决然道：“不，我还是爱格罗兹杰夫的好。”说完这话，她立刻把刚才那封信撕掉了。&lt;/p&gt;&lt;p&gt;她开始想着那学生的爱情和自己的爱情，可不料她脑筋里的念头总是摇摆不定。于是她就乱想起来：母亲、街市、铅笔、风琴……她想得很高兴，她认为世界上所有的东西都是好的，美妙的，并且她的欢乐还告诉她说这并不算稀奇，还有更好的在后面。很快春天过去，夏天到来，她就可以同母亲到戈尔比基去，戈尔南也告假往那里去，同她一块儿在花园里闲逛，顺便谈谈心事。格罗兹杰夫也跑来同她一起打棒球和网球，给她讲可笑或奇异的事情。他十分喜欢花园、黑夜、青天和繁星。她重新又耸着肩笑起来，她仿佛觉得室内一阵阵的花香从窗外透将进来，沁人人的心脾。&lt;/p&gt;&lt;p&gt;她走到她前，坐了下来，也不知道那使她沉溺的欢乐是从哪里来的，她目不转睛地瞧着挂在床背后面的神像，喃喃地说道：“上帝！上帝！上帝！”&lt;/p&gt;&quot;,\n    &quot;wc&quot;: 1963\n  }\n}\n</code></pre>\n<p>解析：</p>\n<ul>\n<li><code>date</code>：日期\n<ul>\n<li><code>curr</code>：今日日期，<code>yyyyMMdd</code> 格式</li>\n<li><code>prev</code>：昨日日期，<code>yyyyMMdd</code> 格式</li>\n<li><code>next</code>：明日日期，<code>yyyyMMdd</code> 格式</li>\n</ul>\n</li>\n<li><code>author</code>：作者</li>\n<li><code>titile</code>：标题</li>\n<li><code>digest</code>：首段</li>\n<li><code>content</code>：正文内容</li>\n<li><code>wc</code>：字数(word count)</li>\n</ul>\n<h2 id=\"someday\">特定某天一文</h2>\n<p>url：<a href=\"https://interface.meiriyiwen.com/article/day?dev=1&amp;date=\" target=\"_blank\">https://interface.meiriyiwen.com/article/day?dev=1&amp;date=</a> + 日期</p>\n<p>url 示例：<a href=\"https://interface.meiriyiwen.com/article/day?dev=1&amp;date=20170216\" target=\"_blank\"><code>https://interface.meiriyiwen.com/article/day?dev=1&amp;date=20170216</code></a></p>\n<p>json 示例以及解析同<a href=\"#article\">每日一文</a></p>\n<h2 id=\"random\">随机一文</h2>\n<p>url：<a href=\"https://interface.meiriyiwen.com/article/random?dev=1\" target=\"_blank\">https://interface.meiriyiwen.com/article/random?dev=1</a></p>\n<p>json 示例以及解析同<a href=\"#article\">每日一文</a></p>\n', 1, '', 0, 0, 1, '2022-08-09 17:58:56', '2022-08-09 18:01:12');
INSERT INTO `tb_article` VALUES (293, 1, 17, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=3490', '分布式事务解决方案-Seate描述', '<p></p>\n<h2 id=\"seate\" tabindex=\"-1\">SEATE</h2>\n<blockquote>\n<p>是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</p>\n</blockquote>\n<p><a name=\"quRvK\"></a></p>\n<h3 id=\"seata%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6\" tabindex=\"-1\">Seata核心组件</h3>\n<p><strong>整体的事务逻辑是两阶段提交的模型，主要由三个重要的组件组成：</strong></p>\n<ul>\n<li>TC：Transaction Coordinator 事务协调器，管理全局的分支事务的状态，用于全局性事务的提交和回滚。</li>\n<li>TM：Transaction Manager 事务管理器，用于开启、提交或者回滚【全局事务】。</li>\n<li>RM：Resource Manager 资源管理器，用于分支（即每一个微服务，它是嵌在服务中的）事务上的资源管理，向TC注册分支事务，上报分支事务的状态，接受TC的命令来提交或者回滚分支事务\n<ul>\n<li>传统XA协议实现2PC方案的 RM 是在数据库层，RM本质上就是数据库自身；</li>\n<li>Seata的RM是以jar包的形式嵌入在应用程序里面</li>\n</ul>\n</li>\n</ul>\n<p><strong>TC 为单独部署的 Server 服务端，TM 和 RM 为嵌入到应用中的 Client 客户端</strong><br />\n<a name=\"WHssV\"></a></p>\n<h3 id=\"seata%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86\" tabindex=\"-1\">Seata事务处理</h3>\n<p><a name=\"yN8Gm\"></a></p>\n<h4 id=\"at%E6%A8%A1%E5%BC%8F\" tabindex=\"-1\">AT模式</h4>\n<p>该模式适合的场景：</p>\n<ul>\n<li>基于支持本地 <code>ACID </code>事务的关系型数据库。</li>\n<li>Java 应用，通过 <code>JDBC </code>访问数据库。</li>\n</ul>\n<p><strong>生命周期描述：</strong></p>\n<ul>\n<li>A服务的<code>TM </code>向 <code>TC </code>申请一个全局事务，全局事务创建成功并生成一个全局唯一的 <code>XID</code>。</li>\n<li>A服务的<code>RM</code>向<code>TC</code>注册分支事务</li>\n<li>A服务执行分支事务，对数据库做操作</li>\n<li>A服务开始远程调用B服务，并把<code>XID</code> 在微服务调用链路的上下文中传播。</li>\n<li>A服务会调用B服务，形成调用链接，这也是分布式事务形成的由来。</li>\n<li>B服务的<code>RM</code>向<code>TC</code>注册分支事务，并将其纳入<code>XID</code>对应的全局事务的管辖。</li>\n<li>B服务执行分支事务，向数据库做操作</li>\n<li>B服务又开始调用C服务，又形成一个调用链，这样ABC三个服务形成调用链。</li>\n<li>C服务的<code>RM</code>也向<code>TC</code>注册分支事务，并将其<code>XID</code>纳入全局事务管理中，这样<code>TC</code>会把A、B、C服务串联起来，保证在一个事务里管理。</li>\n<li>全局事务调用链处理完毕，<code>TM </code>根据有无异常向 TC 发起针对 XID 的全局提交<code>(Commit)</code>或回滚<code>(Rollback)</code>决议。</li>\n<li><code>TC </code>调度 <code>XID </code>下管辖的全部分支事务完成提交<code>(Commit)</code>或回滚<code>(Rollback)</code>请求。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5748b66e399f648f9c4250e75f1080e6.png\" alt=\"image.png\" /></p>\n<ul>\n<li>问题：微服务场景下，配置了统一全局异常处理，导致<code>seata</code>在<code>AT</code>模式下无法正常回滚问题。</li>\n<li>原因：服务A调用服务B， 服务B发生异常，由于全局异常处理的存在<code>@ControllerAdvice</code>, <code>seata</code> 无法拦截到B服务的异常，从而导致分布式事务未生效。</li>\n<li>解决思路：配置了全局异常处理，所以<code>rpc</code>一定会有返回值, 所以在每个全局事务方法最后， 需要判断<code>rpc</code>是否发生异常发生异常则抛出 <code>RuntimeException</code>。<br />\n<a name=\"pcV0q\"></a></li>\n</ul>\n<h3 id=\"%E5%9C%BA%E6%99%AF%E5%AE%9E%E4%BE%8B\" tabindex=\"-1\">场景实例</h3>\n<p>简单的用户下单场景，4个子工程分别是<code>**Bussiness**</code><strong>(事务发起者)、</strong><code>**Order**</code><strong>(创建订单)</strong>、<code>**Product**</code><strong>(扣减库存)</strong> 和 <code>**Account**</code><strong>(扣减账户余额)。</strong><br />下图中黄色区域理解为各自独立的微服务被<code>TC</code>纳入了全局事务管理中，整个流程变成了一个原子操作。<br />用户进行下单，需要进行三个业务调用，<code>Bussiness</code>表示的是业务的发起方，也是我们的一个服务，发起了一个全局事务<code>TM</code>，接着调用商品服务开始扣减库存，<code>Bussiness</code>在调用订单服务，订单服务又会调用账户服务。此时假设商品服务扣减库存成功，订单服务创建订单成功，但是账户服务扣减账户余额失败，出现了异常，此时账户服务的<code>RM</code>即分支事务资源管理器向<code>TC</code>事务报告状态产生异常，此时<code>TC</code>会通知其余的<code>RM</code>回滚事务。当所有的<code>RM</code>均正常则提交事务。<img src=\"https://img-blog.csdnimg.cn/img_convert/c67ab87891260082067db393de9ce6b5.png\" alt=\"image.png\" /><br />\n<a name=\"RLENH\"></a></p>\n<h2 id=\"%E6%B6%88%E6%81%AF%E4%BA%8B%E5%8A%A1-%E5%BC%82%E6%AD%A5%E5%9C%BA%E6%99%AF\" tabindex=\"-1\">消息事务-异步场景</h2>\n<p>**描述：**可靠消息模式采用一个可靠的消息中间件作为中介，事物的发起方在完成本地事务后向可靠的消息中间件发起消息，事务消费方在收到消息后处理消息，该方式强调的是双方最终的数据一致性。<br />**流程：**订单服务将消息发送给订单的消息队列，库存服务去监听订阅订单服务的消息队列，并从中消费消息。这种方式需要考虑消息的生产者发送到消息队列，再由消费者去消费消息，中间都有可能因为网络原因导致数据的不一致性。<br /><img src=\"https://img-blog.csdnimg.cn/img_convert/4d8c7213ace2b6c9cb9398ba5018ddad.png\" alt=\"image.png\" /></p>\n<ul>\n<li>本地事务提交后可以使用主动触发方式对本地消息表进行保存与推送。</li>\n<li>库存服务在接收到消息并且处理完业务逻辑后，通过消息确认机制，回复ACK保证消息的消费成功。如果库存服务没有回复ACK，则消息中间件在没收到ACK是将进行重复投递。</li>\n<li>当消息被成功消费，库存服务可以回调一个订单服务的确认API，订单服务从本地消息表中删除或者更新其状态</li>\n<li>在订单服务中，如果重复性把本地消息发到库存服务，则需要消息的消费者（库存服务）提供消息的幂等性支持。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/2dcc738cea159dd24e0ec548582781f0.png\" alt=\"image.png\" /><br />\n<a name=\"NVtsX\"></a></p>\n<h2 id=\"%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%80%89%E6%8B%A9\" tabindex=\"-1\">分布式事务的选择</h2>\n<p><a name=\"XX1bt\"></a></p>\n<h3 id=\"%E5%85%B3%E4%BA%8E%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9A\" tabindex=\"-1\">关于一致性：</h3>\n<p>一致性就是数据保持一致性，在分布式系统中，可以理解为多个节点中的数据的值是一致的，而一致性分为强一致性和弱一致性/最终一致性（本身也是弱一致性的特殊表现形式）。</p>\n<ul>\n<li><strong>强一致性</strong>：是程度最高的一种要求，也是最难实现的。系统中的某个数据被更新后，后续任何对该数据的操作都是及时更新后的值。</li>\n<li><strong>弱一致性</strong>：系统中某个数据被更新后，后续对该数据的操作可能得到更新后得知，也可能是更新前的值，但经过“不一致的时间窗口”后，后续对该数据的操作都是更新后的值。</li>\n<li><strong>最终一致性</strong>：在一段时间后，数据会最终达到一致性状态，这个状态时弱一致性的特殊形式。</li>\n</ul>\n<h3 id=\"%E5%9C%BA%E6%99%AF%E5%AF%B9%E6%AF%94%EF%BC%9A\" tabindex=\"-1\">场景对比：</h3>\n<p>模拟一个简单个新用户注册送福利，即营销拉新活动。用户服务与营销服务作为两个独立的服务，假设选择以seata作为分布式事务的解决方案，此时发生的场景：在用户注册环节或者营销服务发放福利环节任意一个环节出异常，那么都会导致用户的注册失败，这就是很不友好了，我们期望的是尽管营销服务出现问题那么应该不会影响用户的注册，福利可以通过后期补发，所以这种场景，消息事务方案更具有优势。<br />\n<a name=\"gcBeb\"></a></p>\n<h3 id=\"%E6%80%BB%E7%BB%93\" tabindex=\"-1\">总结</h3>\n<p>微服务架构下，最好的分布式数据一致性方案就是尽量避免使用分布式事务，但某些场景是不可避免的，因此我们在强一致与最终一致性之间需要做出选择。不管选哪一种方案，在应用时都要谨慎再思考，除特定的数据强一致性场景外，能不用尽量就不要用。因为无论它们性能如何优越，一旦请求链路加入分布式事务整体效率会几倍的下降，在高并发情况下弊端尤为明显。分布式事务和分布式锁一样，能不用就不用实在要用，使用优先是考虑柔性事务，实在无法满足再考虑刚性事务<br />对于面向C端用户一般推荐使用可靠消息事务模式，如果是同步场景，如管理后台，对一个功能的操作可能涉及到操作多个业务模块，那么可以使用seata。<br />\n对于面向C端用户一般推荐使用可靠消息事务模式，如果是同步场景，如管理后台，对一个功能的操作可能涉及到操作多个业务模块，那么可以使用seata。</p>\n', 1, '', 0, 0, 1, '2022-08-17 08:54:46', '2022-10-26 21:34:53');
INSERT INTO `tb_article` VALUES (294, 1, 17, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=6039', 'MySQL存储过程手册，及创建存储过程：循环为所有表添加字段', '<p>## 存储过程<br />\n有时候仅凭 sql 语句可能达不到想要的数据操作目的，有可能需要写一些方法体，通过循环判断等操作最终达到目的。那么在数据库里实现这种方法体就需要存储过程了，</p>\n<p>存储过程简单来说，就是为以后的使用而保存的一条或多条 MySQL 语句的集合。可将其视为批处理文件。虽然他们的作用不仅限于批处理。</p>\n<p>本文将通过一个实例初步掌握存储过程，当然要深入学习了解的话还是要看教程文档了。</p>\n<h2 id=\"%E7%A4%BA%E4%BE%8B\" tabindex=\"-1\">示例</h2>\n<ul>\n<li>写一个函数，对一个库里所有的表全部添加一个“<strong>status</strong>”状态字段</li>\n<li>删除存储过程</li>\n</ul>\n<pre><code class=\"language-sql\">-- 删除之前存在的存储过程\nDROP PROCEDURE IF EXISTS proc_init_status;\n</code></pre>\n<ul>\n<li>创建存储过程</li>\n</ul>\n<pre><code class=\"language-sql\">-- 1、创建名为proc_init_status的存储过程\nCREATE PROCEDURE proc_init_status()\n-- 开始存储过程\nBEGIN\n-- 自定义变量，控制游标循环变量\nDECLARE end_flag int DEFAULT 0;\n-- 自定义变量my_name\nDECLARE my_name VARCHAR(100);\n--  定义游标并输入结果集\nDECLARE album_curosr CURSOR FOR \n					-- 该sql为查询dindo_custom库中满足custom_form_表前缀，且不存在status字段的所有表名\n					SELECT DISTINCT table_name FROM \n					information_schema.columns \n					WHERE \n					table_schema = &#39;dindo_custom&#39; \n					AND table_name LIKE &#39;custom_form_%&#39;  \n					AND table_name NOT IN (SELECT table_name FROM  \n					information_schema.columns \n					WHERE table_schema = &#39;dindo_custom&#39; \n					AND table_name LIKE &#39;custom_form_%&#39;  \n					AND column_name = &#39;status&#39;);\n\n\n-- 绑定控制变量到游标,游标循环结束自动转1\nDECLARE CONTINUE HANDLER FOR NOT FOUND SET end_flag=1;\n--  打开游标\nOPEN album_curosr;\n-- 遍历游标\nREPEAT\n-- 获取当前游标指针记录，取出值赋给自定义的变量my_name\nFETCH album_curosr INTO my_name;\n\n-- 利用取到的值进行数据库的操作\nSET @stmt = CONCAT(&quot;ALTER TABLE &quot;,my_name ,&quot; ADD COLUMN &#96;status&#96; varchar(20) DEFAULT NULL COMMENT &#39;状态&#39;&quot;);\n-- 定义预处理语句\nprepare stmt FROM @stmt;\n-- 执行预处理语句\nEXECUTE  stmt;\n -- 输出sql\nSELECT @stmt;\n-- 删除(释放)定义\nDEALLOCATE PREPARE stmt;\n-- 根据 end_flag 判断是否结束\nUNTIL end_flag END REPEAT;\n-- 关闭游标\nclose album_curosr;\n-- 结束\nEND;\n\n</code></pre>\n<ul>\n<li>调用存储过程</li>\n</ul>\n<pre><code class=\"language-sql\">-- 2、调用\nCALL proc_init_status();\n</code></pre>\n<h2 id=\"%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90\" tabindex=\"-1\">存储过程语法解析</h2>\n<ul>\n<li>再来一个简单示例</li>\n</ul>\n<pre><code class=\"language-sql\">-- 创建存储过程 \ncreate procedure mypro(in a int,in b int,out sum int) \nbegin \nset sum = a+b; \nend;\n</code></pre>\n<ul>\n<li><code>create procedure</code> 用来创建过程；</li>\n<li><code>mypro</code> 用来定义过程名称；</li>\n<li><code>(in a int,in b int,out sum int)</code> 表示过程的参数，其中 in 表示输入参数，out 表示输出参数。类似于 Java 定义方法时的形参和返回值；</li>\n<li><code>begin</code> 与<code>end</code> 表示过程主体的开始和结束，相当于 Java 定义方法的一对大括号；</li>\n<li><code>call</code>用来调用过程，<code>@s</code> 是用来接收过程输出参数的变量</li>\n</ul>\n<h3 id=\"%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8F%82%E6%95%B0\" tabindex=\"-1\">存储过程的参数</h3>\n<p>MySQL 存储过程的参数用在存储过程的定义，共有三种参数类型：</p>\n<ul>\n<li><code>IN</code> 输入参数：表示调用者向过程传入值（传入值可以是字面量或变量）；</li>\n<li><code>OUT</code> 输出参数：表示过程向调用者传出值(可以返回多个值)（传出值只能是变量）；</li>\n<li><code>INOUT</code>输入输出参数：既表示调用者向过程传入值，又表示过程向调用者传出值（值只能是变量）。<br />\n存储过程根据参数可分为四种类别：</li>\n</ul>\n<p>1).没有参数的过程；<br />\n2).只有输入参数的过程；<br />\n3).只有输出参数的过程；<br />\n4).包含输入和输出参数的过程。</p>\n<h2 id=\"%E5%8F%98%E9%87%8F\" tabindex=\"-1\">变量</h2>\n<p>MySQL 中的存储过程类似 java 中的方法。</p>\n<p>既然如此，在存储过程中也同样可以使用变量。java 中的局部变量作用域是变量所在的方法，而 MySQL 中的局部变量作用域是所在的存储过程。</p>\n<h3 id=\"%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89\" tabindex=\"-1\">变量定义</h3>\n<pre><code>DECLARE variable_name [,variable_name...] datatype [DEFAULT value];\n</code></pre>\n<ul>\n<li>\n<p><code>declare</code>用于声明变量；</p>\n</li>\n<li>\n<p><code>variable_name</code>表示变量名称；</p>\n</li>\n<li>\n<p><code>datatype</code>为 MySQL 的数据类型；</p>\n</li>\n<li>\n<p><code>default</code>用于声明默认值;</p>\n</li>\n<li>\n<p>例如：</p>\n</li>\n</ul>\n<pre><code class=\"language-\"> declare name varchar(20) default ‘macw’;\n</code></pre>\n<h3 id=\"%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC\" tabindex=\"-1\">变量赋值</h3>\n<pre><code>SET 变量名 = 表达式值 [,variable_name = expression ...]\n</code></pre>\n<p>如上面例子的：</p>\n<pre><code class=\"language-sql\">SET @stmt = CONCAT(&quot;ALTER TABLE &quot;,my_name ,&quot; ADD COLUMN &#96;status&#96; varchar(20) DEFAULT NULL COMMENT &#39;状态&#39;&quot;);\n</code></pre>\n<h3 id=\"%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5\" tabindex=\"-1\">流程控制语句</h3>\n<h4 id=\"if-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5\" tabindex=\"-1\">if 条件语句</h4>\n<p><code>IF</code> 语句包含多个条件判断，根据结果为 <code>TRUE</code>、<code>FALSE</code>执行语句，与编程语言中的 <code>if</code>、<code>else if</code>、<code>else</code> 语法类似。</p>\n<p>定义存储过程，输入一个整数，使用 if 语句判断是正数还是负数，代码如下所示：</p>\n<pre><code>-- 创建过程\ncreate procedure mypro2(in num int)\nbegin\nif num&lt;0 then -- 条件开始\nselect \'负数\';\nelseif num=0 then\nselect \'不是正数也不是负数\';\nelse\nselect \'正数\';\nend if;-- 条件结束\nend;\n-- 调用过程\ncall mypro2(-1);\n</code></pre>\n<p>运行结果<br />\n<img src=\"https://img-blog.csdnimg.cn/732d7db639cf47a5bdad31287cb713e2.png\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"case-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5\" tabindex=\"-1\">case 条件语句</h4>\n<p><code>case</code>是另一个条件判断的语句，类似于编程语言中的 <code>choose</code>、<code>when</code>语法。MySQL 中的 <code>case</code>语句有两种语法<br />\n格式。</p>\n<p>定义存储过程，输入一个整数，使用 case 语句判断是正数还是负数，代码如下所示：</p>\n<pre><code>-- 创建过程\ncreate procedure mypro3(in num int)\nbegin\ncase -- 条件开始\nwhen num&lt;0 then select \'负数\';\nwhen num=0 then select \'不是正数也不是负数\';\nelse select \'正数\';\nend case; -- 条件结束\nend;\n-- 调用过程\ncall mypro3(1);\n</code></pre>\n<p>运行结果<br />\n<img src=\"https://img-blog.csdnimg.cn/5c913f304170427394d48d1d8f262498.png\" alt=\"在这里插入图片描述\" /><br />\n定义存储过程，输入一个整数，使用 case 语句判断是 1 还是 2，代码如下所示：</p>\n<pre><code>-- 创建过程\ncreate procedure mypro4(in num int)\nbegin\ncase num -- 条件开始\nwhen 1 then select \'数值是 1\';\nwhen 2 then select \'数值是 2\';\nelse select \'不是 1 也不是 2\';\nend case; -- 条件结束\nend;\n-- 调用过程\ncall mypro4(3);\n</code></pre>\n<blockquote>\n<p>两种 case 语法都可以实现条件判断，但第一种适合范围值判断，而第二种适合确定值判断。</p>\n</blockquote>\n<h4 id=\"while-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\" tabindex=\"-1\">while 循环语句</h4>\n<p><code>while</code>语句的用法和 <code>java</code>中的 <code>while</code>循环类似。</p>\n<p>定义存储过程，使用 while 循环输出 1 到 10 的累加和，代码如下所示：</p>\n<pre><code>-- 创建过程\ncreate procedure mypro5(out sum int)\nbegin\ndeclare num int default 0;\nset sum = 0;\nwhile num&lt;10 do -- 循环开始\nset num = num+1;\nset sum = sum+num;\nend while; -- 循环结束\nend;\n-- 调用过程\ncall mypro5(@sum);\n-- 查询变量值\nselect @sum;\n</code></pre>\n<p>运行结果<br />\n<img src=\"https://img-blog.csdnimg.cn/e847b1d57a544103a94d3aa0ac8c5c35.png\" alt=\"在这里插入图片描述\" /></p>\n<h4 id=\"repeat-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\" tabindex=\"-1\">repeat 循环语句</h4>\n<p><code>repeat</code>语句的用法和 <code>java</code>中的 <code>do…while</code> 语句类似，都是先执行循环操作，再判断条件，区别是 <code>repeat</code>表达<br />\n式值为 <code>false</code>时才执行循环操作，直到表达式值为 <code>true</code>停止。</p>\n<p>定义存储过程，使用 repeat 循环输出 1 到 10 的累加和，代码如下所示：</p>\n<pre><code>-- 创建过程\ncreate procedure mypro6(out sum int)\nbegin\ndeclare num int default 0;\nset sum = 0;\nrepeat-- 循环开始\nset num = num+1;\nset sum = sum+num;\nuntil num&gt;=10\nend repeat; -- 循环结束\nend;\n-- 调用过程\ncall mypro6(@sum);\n-- 查询变量值\nselect @sum;\n</code></pre>\n<p>运行结果</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a6b21acabef04f4c98d87eae606d43fb.png\" alt=\"![image-20210316105241308](https://img-\nblog.csdnimg.cn/img_convert/c3b0937e9b5fcc74344914eff9bf54ae.png)\" /></p>\n<h4 id=\"loop-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\" tabindex=\"-1\">loop 循环语句</h4>\n<p>循环语句，用来重复执行某些语句。</p>\n<p>执行过程中可使用 <code>leave</code>语句或 <code>iterate</code> 跳出循环，也可以嵌套 <code>IF</code>等判断语句。</p>\n<ul>\n<li><code>leave</code>语句效果相当于 java 中的 <code>break</code>，用来终止循环；</li>\n<li><code>iterate</code>语句效果相当于 java 中的 <code>continue</code>，用来结束本次循环操作，进入下一次循环。</li>\n</ul>\n<p>定义存储过程，使用 loop 循环输出 1 到 10 的累加和，代码如下所示：</p>\n<pre><code>-- 创建过程\ncreate procedure mypro7(out sum int)\nbegin\ndeclare num int default 0;\nset sum = 0;\nloop_sum:loop-- 循环开始\nset num = num+1;\nset sum = sum+num;\nif num&gt;=10 then\nleave loop_sum;\nend if;\nend loop loop_sum; -- 循环结束\nend;\n-- 调用过程\ncall mypro7(@sum);\n-- 查询变量值\nselect @sum;\n</code></pre>\n<p>运行结果</p>\n<p><img src=\"https://img-blog.csdnimg.cn/adcc964a85d8472d8977a7e75cd09a89.png\" alt=\"![image-20210316105416021](https://img-\nblog.csdnimg.cn/img_convert/5cd8e3a2638c7f169fae155c8ceb03ba.png)\" /></p>\n<blockquote>\n<p>代码中的 loop_sum 相当于给循环贴个标签，方便多重循环时灵活操作。</p>\n</blockquote>\n<h2 id=\"%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E7%AE%A1%E7%90%86\" tabindex=\"-1\">存储过程的管理</h2>\n<p>存储过程的管理主要包括：显示过程、显示过程源码、删除过程。</p>\n<p>比较简单的方式就是利用 navicat 客户端工具进行管理，鼠标点击操作即可，如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/7a6f6656b9664f05b9d75dd39b7f4cd5.png\" alt=\"在这里插入图片描述\" /></p>\n<h3 id=\"%E6%98%BE%E7%A4%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B\" tabindex=\"-1\">显示存储过程</h3>\n<pre><code>SHOW PROCEDURE STATUS;\n</code></pre>\n<h3 id=\"%E6%98%BE%E7%A4%BA%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B\" tabindex=\"-1\">显示特定数据库的存储过程</h3>\n<pre><code>SHOW PROCEDURE status where db = \'schooldb\';\n</code></pre>\n<h3 id=\"%E6%98%BE%E7%A4%BA%E7%89%B9%E5%AE%9A%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%8C%E8%A6%81%E6%B1%82%E6%98%BE%E7%A4%BA%E5%90%8D%E7%A7%B0%E4%B8%AD%E5%8C%85%E5%90%AB%E2%80%9Cmy%E2%80%9D%E7%9A%84%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B\" tabindex=\"-1\">显示特定模式的存储过程，要求显示名称中包含“my”的存储过程</h3>\n<pre><code>SHOW PROCEDURE status where name like \'%my%\';\n</code></pre>\n<h3 id=\"%E6%98%BE%E7%A4%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E2%80%9Cmypro1%E2%80%9D%E7%9A%84%E6%BA%90%E7%A0%81\" tabindex=\"-1\">显示存储过程“mypro1”的源码</h3>\n<pre><code>SHOW CREATE PROCEDURE mypro1;\n</code></pre>\n<h3 id=\"%E5%88%A0%E9%99%A4%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E2%80%9Cmypro1%E2%80%9D\" tabindex=\"-1\">删除存储过程“mypro1”</h3>\n<pre><code>drop PROCEDURE mypro1;\n</code></pre>\n', 1, '', 0, 0, 1, '2022-08-20 14:40:15', '2022-08-20 14:41:56');
INSERT INTO `tb_article` VALUES (295, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=6853', '边缘计算：一文理解云边端协同架构中的高性能云计算、边缘计算、云边协同', '<p>﻿# 一、引言</p>\n<h2 id=\"1云计算与物联网\">1、云计算与物联网</h2>\n<blockquote>\n<p>通俗来说，在近几十年物联网的飞速发展过程中，经历了从云计算中心与终端物联设备直接交互———<strong>物联网</strong>通过数量惊人的传感器采集到难以计数的数据量，而<strong>云计算</strong>可以对这些海量数据进行智能处理。</p>\n<p>·<br />\n云计算是物联网发展的基石，而物联网又是云计算的最大用户，促进着云计算的发展。二者的融合可谓珠联璧合，相辅相成。在大数据时代，二者的融合将进一步推动数据价值的挖掘，使数据价值进一步显现，促进产业爆发。</p>\n</blockquote>\n<p>然后 <strong>5Ｇ</strong>时代的到来，海量数据的产生与任务计算对现有网络将会产生更加强烈的冲击。基于<strong>Internet</strong> 的云计算虽然提供了对虚拟共享的可配置计算和存储资源的广泛访问和按需访问，是处理海量数据与计算任务的绝佳平台.</p>\n<p><img src=\"https://img-blog.csdnimg.cn/93f4bc2b5f8543afacc6bc17ad1dd946.png\" alt=\"物联网与云计算\" /></p>\n<p>但是对于５Ｇ时代的诸如在线游戏、虚拟现实和超高清视频流等高速访问超低延时的应用和海量终端互联来说，<strong>云计算是无法满足其要求的</strong>。数据是任何正常业务的核心。多年来，前所未有的计算能力和连接设备积累了大量数据，给本已拥挤的互联网造成了巨大压力。这种大量的数据积累会导致带宽和延迟问题。与在客户端或用户计算机上生成数据的传统企业计算不同，<strong>边缘计算</strong>提供了一种更好的替代方案，可以从管理复杂数据转向靠近原始数据源。</p>\n<h2 id=\"2边缘计算\">2、边缘计算</h2>\n<p>与此同时，下一代互联网的关键特征之一是信息越来越多地在本地生成并在<strong>本地消费</strong>，且大量的边缘设备存在可用计算和存储资源。因此，为应对云计算存在的挑战、网络压力和提升用户体验满足业务需求，业界提出将云计算平台迁移至网络边缘，即<strong>边缘计算</strong>。</p>\n<p><strong>边缘计算</strong>通过将计算、存储等能力从云数据中心扩展到离数据源较近的网络边缘而不是集中式服务器或基于云的位置对客户端数据的处理和计算<code>（简而言之，边缘计算使计算资源、数据存储和企业应用程序更接近人们实际消费信息的地方）</code>，并且可支持在网络边缘执行深度学习、强化学习等人工智能算法，避免计算任务从网络边缘传输到远程数据中心的超长网络传输延迟，满足高实时性物联网应用（例如，自动驾驶、无人机、增强现实等）的要求。<br />\n<img src=\"https://img-blog.csdnimg.cn/b5d4b17da26f4ff1a8d1ff785463ff57.png\" alt=\"边缘计算架构图\" /></p>\n<center>图1 边缘计算架构图</center>\n<p><strong>边缘计算</strong>技术还可避免因数据在公网传输、公共数据中心处理所带来的隐私泄露等安全隐患。因此，边缘计算已成为下一代网络发展的关键技术。发掘网络的内在能力。在数据源附近提供边缘服务，以满足在敏捷连接性、实时优化、智能应用、安全性和隐私性方面的关键要求。</p>\n<h2 id=\"二云边协同\">二、云边协同</h2>\n<blockquote>\n<p>当前绝大多数的研究都将云计算和边缘计算隔离开来，分别致力于云计算和边缘计算的架构和系统分析优化层面，较少关注云计算和边缘计算之间的协同问题。近年来物联网和5G通信的发展让大家开始关注到云计算和边缘计算各自存在的优势与劣势，并开始思考二者优势互补的价值所在，即<strong>云边协同</strong>。</p>\n</blockquote>\n<h2 id=\"1云边协同关系\">1、云边协同关系</h2>\n<p>云计算技术以廉价且大量的计算服务器提供了强大的计算能力，可以为用户和应用提供按需访问的丰富计算资源和存储资源。但是，云计算中心通常距离用户和终端较远，导致计算任务传输时间过长，并且如果将海量终端的数据都传输至云计算中心必将造成核心网拥塞，极大地浪费了通信资源。</p>\n<p>因此，云计算并不适合要求低时延、实时操作和高 ＱｏＳ的应用，并且无法支持无缝移动和无处不在的计算覆盖，数据安全性和用户的隐私也不能得到有效保障。</p>\n<p>另一方面，虽然边缘计算将云计算功能扩展到了网络边缘，更加接近终端用户且地理位置分散，可以支持低时延、位置感知、高移动性和高Qos的应用服务。但是，边缘计算单元通常没有充足的计算资源和存储资源来满足海量数据的计算和存储，并且由于边缘节点的低功耗、异构性和功能薄弱单一等约束，服务的质量与可靠性还会受到影响。</p>\n<p>表１从不同的角度总结了云计算和边缘计算的特点和二者的差异<img src=\"https://img-blog.csdnimg.cn/5ee325ff97a949ec9de64b5b5451f748.png\" alt=\"边缘计算与云计算对比\" /><br />\n从表１可以看出云计算和边缘计算是各有优势的，<strong>云计算</strong>的主要优势是海量计算和海量存储、计算效率高、广域覆盖，适合计算密集型、非实时性的计算任务和海量数据的并行计算与存储，能够在长周期维护、业务决策支撑等领域发挥优势，并且计算硬件都集中在云计算中心，实行集中式的管理，因此无需在本地维护计算硬件、数据存储和相关软件。</p>\n<p><strong>边缘计算</strong>的主要优势是广泛分布的边缘节点提供了实时的数据处理，边缘计算的过程是一个以用户和应用为中心的过程，弥补了云计算中时延和移动性的缺陷，适合非计算密集型、实时性、移动性数据的处理分析和实时智能化决策，并且作为一种新的网络范式能够满足５Ｇ 时代计算需求的空前增长和用户体验质量的不断提高，数据的本地化处理相较于云端也更安全。但是，边缘平台的处理性能通常不如云平台，它通常没有足够的内存和处理器来处理大量数据，因此无法执行复杂的操作，例如<strong>深度学习</strong>。<br />\n<img src=\"https://img-blog.csdnimg.cn/3c0e9f2d268f47d4b1ae8d3cf1f7f8b2.png\" alt=\"边缘计算架构图\" /><br />\n因此，通过将网络转发、存储、计算、智 能化数据分析等工作放在边缘处理，将超大规模计算、存储和非时延敏感等任务放在云端，云计算与边缘计算的相互配合实现<strong>云边协同</strong>、全网算力调度和全网统一管控等能力，才能真正实现无处不在的云。</p>\n<h2 id=\"2云边协同的实现\">2、云边协同的实现</h2>\n<p>云边协同即实现边缘计算与云计算的协同联动，共同释放数据价值。<br />\n<img src=\"https://img-blog.csdnimg.cn/539170b4ce0b4bd7808dacc6768b21a9.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>传统的云边协同方式主要是当终端设备产生数据或任务请求后，通过边缘网络将数据上传至边缘服务器，由位于边缘计算中心的边缘服务器执行计算任务。</li>\n<li>计算量较大、复杂度较高的计算任务将由边缘计算中心向上通过核心网迁移至云计算中心。</li>\n<li>待云计算中心完成大数据分析后再将结果和数据存储至云计算中心或将计算结果、优化输出的业务规则、模型通过核心网下发至边缘计算中心，由边缘计算中心向下通过边缘网络将计算结果传输至终端设备。</li>\n<li>边缘根据云计算下发的新业务规则进行业务执行优化处理，由此实现<strong>云边协同</strong>。</li>\n</ul>\n<h2 id=\"3云边协同的应用\">3、云边协同的应用</h2>\n<p>我们生活在智能设备和快速发展的万物互联中的世界。在日常生活中我们早已被边缘计算所包围。<strong>云边协同</strong>的主要应用场景与边缘计算、物联网的应用场景联系紧密，从远程办公室工作到远程手术，从智能手机到智慧城市，从自动驾驶汽车到语音控制设备，一切都得益于边缘云技术。如下主要有：</p>\n<ul>\n<li>\n<p>1、物联网云边协同，<br />\n如智慧交通、自动驾驶汽车。汽车驾驶自动的新时代需要信息、计算、决策等的快速响应。将自动驾驶汽车带到边缘涉及在车辆行驶时实时接收有关速度、交通状况、交通信号、行人、车辆推测、道路状况和其他车辆的信息。边缘计算正在推动自动驾驶汽车的创新，因为边缘计算具有零延迟等优势。这方面的信息延迟可能是危及生命和拯救生命之间的全部区别。</p>\n</li>\n<li>\n<p>2、虚拟现实与游戏。<br />\n在线游戏和虚拟现实的关键要求之一需要高速运行。这些通常与高延迟和延迟问题作斗争，导致游戏玩家反应严重延迟。边缘计算可以通过创建更靠近游戏玩家的边缘服务器来使游戏受益，从而减少延迟并提供丰富且身临其境的游戏体验。</p>\n</li>\n<li>\n<p>3、智慧城市<br />\n智慧城市依赖于海量数据。边缘计算可以为智能城市的所有元素提供动力，包括自动驾驶汽车、智能路灯、智能工厂、智能电网和公共交通，以提高效率进行监控。</p>\n</li>\n<li>\n<p>4、智慧家庭云边协同，如小米智能家居<br />\n通过构建家庭局域网，实现电器控制、安全保护、定时控制、环境检测、场景控制、可视对讲等</p>\n</li>\n<li>\n<p>5、虚拟网络<br />\n如中国电信内容边缘化分发缓存的虚拟网络，能够缓解网络压力，提升视频业务体验、提升内容分发网络节点满足资源弹性伸缩能力。</p>\n</li>\n<li>\n<p>6、安防监控<br />\n实现数据分流、边缘智能、本地决策、实时响应</p>\n</li>\n</ul>\n<h1 id=\"三总结\">三、总结</h1>\n<p>综上所诉，云边协同具体涉及到资源、管理和应用协同等多个层面。为了构建灵活、高效的云边协同计算环境，需要在不同层面实现云计算和边缘计算的协同，以优势互补的方式克服云计算和边缘计算中各自存在的缺点，放大云计算与边缘计算的价值。</p>\n<p>边缘计算至关重要，因为它为改进和创新理念铺平了道路，让企业在企业和工业层面以最大的运营效率、更高的安全性和更好的性能运营。边缘计算在每个垂直行业都是可行的，无论是银行、医疗保健、零售还是采矿。</p>\n<h1 id=\"参考资料\">参考资料</h1>\n<ul>\n<li>[1]李波,侯鹏,牛力,武浩,丁洪伟.基于软件定义网络的云边协同架构研究综述[J].计算机工程与科学,2021,43(02):242-257.</li>\n<li>[2]李启锐. 面向云边端协同的高性能移动边缘计算理论与方法研究[D].广州大学,2021.DOI:10.27040/d.cnki.ggzdu.2021.001232.</li>\n<li><a href=\"https://blog.csdn.net/qq_20173195/article/details/127087411\">什么是边缘计算？边缘计算与云计算的区别?</a></li>\n<li>[4]王宁,鲁法明,包云霞.一种基于云边端协同的智能安全帽设计与实现[J].科技视界,2022(18):11-13.DOI:10.19694/j.cnki.issn2095-2457.2022.18.03.</li>\n</ul>\n', 1, '', 0, 0, 1, '2022-10-17 16:59:40', '2022-10-17 16:59:40');
INSERT INTO `tb_article` VALUES (296, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=7845', '深度学习入门指南，一文理解人工智能领域的深度学习、神经网络', '<p>﻿# 深度学习入门</p>\n<blockquote>\n<p>摘要：<br />\n当你和女朋友在路边手拉手一起约会的时候，你可曾想，你们之间早已碰撞出了一种神秘的智慧–深度学习。恋爱容易，相处不易，不断磨合，打造你们的默契，最终才能决定你们是否在一起。深度学习也一样，输入各种不同的参数，进行训练拟合，最后输出拟合结果。<br />\n恋爱又不易，且学且珍惜！</p>\n</blockquote>\n<p><strong>导言：</strong><br />\n目前人工智能非常火爆，而深度学习则是引领这一火爆现场的“火箭”。于是，有关“深度学习”的论文、书籍和网络博客汗牛充栋，但大多数这类文章都具备“高不成低不就”的特征。对于高手来说，自然是没有问题，他们本身已经具备非常“深度”的学习能力，如果他们想学习有关深度学习的技术，直接找来最新的研究论文阅读就好了。但是，对于低手（初学者）而言，就没有那么容易了，因为他们基础相对薄弱，通常看不太懂。<br />\n于是，我们推出深度学习的入门系列。在这个系列文章中，我们力图用最为通俗易懂、图文并茂的方式，带你入门深度学习。我们都知道，高手从来都是自学出来的。所以，这个深度学习的入门系列，能带给你的是“从入门到精通”，还是“从入门到放弃”，一切都取决你个人的认知。成就你自己的，永远都是你自己，是吧？<br />\n好了，言归正传，下面开始我们的正题。</p>\n<h2 id=\"1-什么是学习\">1. 什么是学习？</h2>\n<p>说到深度学习，我们首先需要知道，什么是学习。<br />\n著名学者<code>赫伯特·西蒙教授（Herbert Simon，1975年图灵奖获得者、1978年诺贝尔经济学奖获得者）</code>曾对“学习”给了一个定义：“如果一个系统，能够通过执行某个过程，就此改进了它的性能，那么这个过程就是学习”。<br />\n大牛就是大牛，永远都是那么言简意赅，一针见血。从西蒙教授的观点可以看出，<code>学习的核心目的，就是改善性能</code>。<br />\n其实对于人而言，这个定义也是适用的。比如，我们现在正在学习“深度学习”的知识，其本质目的就是为了“提升”自己在机器学习上的认知水平。如果我们仅仅是低层次的重复性学习，而没有达到认知升级的目的，那么即使表面看起来非常勤奋，其实我们也仅仅是个“伪学习者”,<br />\n因为我们没有改善性能。</p>\n<h2 id=\"2-什么是机器学习\">2. 什么是机器学习？</h2>\n<p>遵循西蒙教授的观点，对于计算机系统而言，通过运用数据及某种特定的方法（比如统计的方法或推理的方法），来提升机器系统的性能，就是机器学习。<br />\n英雄所见略同。卡内基梅隆大学的Tom Mitchell教授，在他的名作《机器学习》一书中，也给出了更为具体（其实也很抽象）的定义：</p>\n<blockquote>\n<p>对于某类任务（Task，简称T）和某项性能评价准则（Performance，简称P），如果一个计算机程序在T上，以P作为性能的度量，随着很多经验（Experience，简称E）不断自我完善，那么我们称这个计算机程序在从经验E中学习了。</p>\n</blockquote>\n<p>比如说，对于学习围棋的程序AlphaGo，它可以通过和自己下棋获取经验，那么它的任务T就是“参与围棋对弈”；它的性能P就是用“赢得比赛的百分比”来度量。“类似地，学生的任务T就是“上课看书写作业”；它的性能P就是用“期末成绩”来度量”<br />\n因此，Mitchell教授认为，对于一个学习问题，我们需要明确三个特征：任务的类型，衡量任务性能提升的标准以及获取经验的来源。</p>\n<h2 id=\"3-学习的4个象限\">3. 学习的4个象限</h2>\n<p>在前面的文章中，我们已提到，一般说来，人类的知识在两个维度上可分成四类。即从可统计与否上来看，可分为：<code>可统计的和不可统计的</code>。从能否推理上看，可分为:<code>可推理的和不可推理的</code>。<br />\n<img src=\"https://img-blog.csdnimg.cn/20210329155837432.png\" alt=\"在这里插入图片描述\" /></p>\n<p>在横向方向上，对于可推理的，我们都可以通过机器学习的方法，最终可以完成这个推理。传统的机器学习方法，就是试图找到可举一反三的方法，向可推理但不可统计的象限进发（象限Ⅱ）。目前看来，这个象限的研究工作（即基于推理的机器学习）陷入了不温不火的境地，能不能峰回路转，还有待时间的检验。<br />\n而在纵向上，对于可统计的、但不可推理的（即象限Ⅲ），可通过神经网络这种特定的机器学习方法，以期望达到性能提升的目的。目前，基于深度学习的棋类博弈（阿尔法狗）、计算机视觉（猫狗识别）、自动驾驶等等，其实都是在这个象限做出了了不起的成就。<br />\n从图可知，<code>深度学习属于统计学习的范畴</code>。用李航博士的话来说，统计机器学习的对象，其实就是数据。这是因为，对于计算机系统而言，所有的“经验”都是以数据的形式存在的。作为学习的对象，数据的类型是多样的，可以是各种数字、文字、图像、音频、视频，也可以是它们的各种组合。<br />\n统计机器学习，就是从数据出发，提取数据的特征（由谁来提取，是个大是大非问题，下面将给予介绍），抽象出数据的模型，发现数据中的知识，最后又回到数据的分析与预测当中去。</p>\n<h2 id=\"4-机器学习的方法论\">4. 机器学习的方法论</h2>\n<p>这里稍早说明的一点的是，在深度学习中，经常有“end-to-end（端到端）”学习的提法，与之相对应的传统机器学习是“Divide and<br />\nConquer（分而治之）”。这些都是什么意思呢？<br />\n“end-to-<br />\nend”（端到端）说的是，输入的是原始数据（始端），然后输出的直接就是最终目标（末端），中间过程不可知，因此也难以知。比如说，基于深度学习的图像识别系统，输入端是图片的像素数据，而输出端直接就是或猫或狗的判定。这个端到端就是：像素–&gt;判定。<br />\n再比如说，“end-to-<br />\nend”的自动驾驶系统，输入的是前置摄像头的视频信号（其实也就是像素），而输出的直接就是控制车辆行驶指令（方向盘的旋转角度）。这个端到端就是：像素–&gt;指令。<br />\n就此，有人批评深度学习就是一个黑箱（Black<br />\nBox）系统，其性能很好，却不知道为何而好，也就是说，缺乏解释性。其实，这是由于深度学习所处的知识象限决定的。从图1可以看出，深度学习，在本质上，属于可统计不可推理的范畴。“可统计”是很容易理解的，就是说，对于同类数据，它具有一定的统计规律，这是一切统计学习的基本假设。那“不可推理”又是什么概念？其实就是“剪不断、理还乱”的非线性状态了。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2021032915593636.png\" alt=\"在这里插入图片描述\" /></p>\n<p>在哲学上讲，这种非线性状态，是具备了整体性的“复杂系统”，属于复杂性科学范畴。复杂性科学认为，构成复杂系统的各个要素，自成体系，但阡陌纵横，其内部结构难以分割。简单来说，对于复杂系统，1+1≠2，也就是说，一个简单系统，加上另外一个简单系统，其效果绝不是两个系统的简单累加效应，而可能是大于部分之和。因此，我们必须从整体上认识这样的复杂系统。于是，在认知上，就有了从一个系统或状态（end）直接整体变迁到另外一个系统或状态（end）的形态。这就是深度学习背后的方法论。<br />\n与之对应的是“Divide and<br />\nConquer（分而治之）”，其理念正好相反，在哲学它属于“还原主义（reductionism，或称还原论）”。在这种方法论中，有一种“追本溯源”的蕴意包含其内，即一个系统（或理论）无论多复杂，都可以分解、分解、再分解，直到能够还原到逻辑原点。<br />\n在意象上，还原主义就是“1+1=2”，也就是说，一个复杂的系统，都可以由简单的系统简单叠加而成（可以理解为线性系统），如果各个简单系统的问题解决了，那么整体的问题也就得以解决。比如说，很多的经典力学问题，不论形式有多复杂，通过不断的分解和还原，最后都可以通过牛顿的三大定律得以解决。<br />\n经典机器学习（位于第Ⅱ象限），在哲学上，在某种程度上，就可归属于还原主义。传统的机器学习方式，通常是用人类的先验知识，把原始数据预处理成各种特征（feature），然后对特征进行分类。<br />\n然而，这种分类的效果，高度取决于特征选取的好坏。传统的机器学习专家们，把大部分时间都花在如何寻找更加合适的特征上。因此，早期的机器学习专家们非常苦逼，故此，<code>传统的机器学习，其实可以有个更合适的称呼——特征工程（feature engineering）</code>。<br />\n但这种苦逼，也是有好处的。这是因为，这些特征是由人找出来的，自然也就为人所能理解，性能好坏，机器学习专家们可以“冷暖自知”，灵活调整。</p>\n<h2 id=\"5-什么是深度学习\">5. 什么是深度学习</h2>\n<p>再后来，机器学习的专家们发现，<code>可以让神经网络自己学习如何抓取数据的特征，这种学习的方式，效果更佳。</code>于是兴起了特征表示学习（feature<br />\nrepresentation learning）的风潮。这种学习方式，对数据的拟合也更加的灵活好用。于是，人们终于从自寻“特征”的苦逼生活中解脱出来。<br />\n但这种解脱也付出了代价，那就是机器自己学习出来的特征，它们存在于机器空间，完全超越了人类理解的范畴，对人而言，这就是一个黑盒世界。为了让神经网络的学习性能，表现得更好一些，人们只能依据经验，不断地尝试性地进行大量重复的网络参数调整，同样是“苦不堪言”。于是，<code>“人工智能”领域就有这样的调侃：“有多少人工，就有多少智能”。</code><br />\n因此，你可以看到，在这个世界上，存在着一个“麻烦守恒定律”：麻烦不会减少，只会转移。<br />\n再后来，网络进一步加深，出现了多层次的“表示学习”，它把学习的性能提升到另一个高度。<code>这种学习的层次多了，其实也就是套路“深了”。于是，人们就给它取了个特别的名称——Deep Learning（深度学习）。</code><br />\n深度学习的学习对象同样是数据。与传统机器学习所不同的是，它需要大量的数据，<code>也就是“大数据（Big Data）”。</code><br />\n有一个观点，在工业界一度很流行，<code>那就是在大数据条件下，简单的学习模型会比复杂模型更加有效。</code>而简单的模型，最后会趋向于无模型，也就是无理论。例如，早在2008年，美国<br />\n《连线》（Wired）杂志主编克里斯﹒安德森（Chris Anderson）就曾发出“理论的终结（The End of<br />\nTheory）”的惊人断言：“海量数据已经让科学方法成为过去时（The Data Deluge Makes the Scientific Method<br />\nObsolete）”。<br />\n但地平线机器人创始人（前百度深度学习研究院副院长）余凯先生认为，深度学习的惊人进展，是时候促使我们要重新思考这个观点了。也就是说，他认为“大数据+复杂模型”或许能更好地提升学习系统的性能。</p>\n<h2 id=\"6-恋爱中的深度学习\">6. “恋爱”中的深度学习</h2>\n<p>法国科技哲学家伯纳德﹒斯蒂格勒（Bernard<br />\nStiegler）认为，人们以自己的技术和各种物化的工具，作为自己“额外”的器官，不断的成就自己。按照这个观点，其实，在很多场景下，计算机都是人类思维的一种物化形式。换句话说，计算机的思维（比如说各种电子算法），都能找到人类生活实践的影子。<br />\n比如说，现在火热的深度学习，与人们的恋爱过程也有相通之处。在知乎上，就有人（jacky<br />\nyang）以恋爱为例来说明深度学习的思想，倒也非常传神。我们知道，男女恋爱大致可分为三个阶段：<br />\n<code>第一阶段初恋期，相当于深度学习的输入层。</code>妹子吸引你，肯定是有很多因素，比如说脸蛋、身高、身材、性格、学历等等，这些都是输入层的参数。对不同喜好的人，他们对输出结果的期望是不同的，自然他们对这些参数设置的权重也是不一样的。比如，有些人是奔着结婚去的，那么他们对妹子的性格可能给予更高的权重。否则，脸蛋的权重可能会更高。<br />\n<img src=\"https://img-blog.csdnimg.cn/20210329160125361.png\" alt=\"在这里插入图片描述\" /></p>\n<p><code>第二阶段热恋期，对应于深度学习的隐藏层。</code>在这个期间，恋爱双方都要经历各种历练和磨合。清朝湖南湘潭人张灿写了一首七绝：<br />\n<code>书画琴棋诗酒花，当年件件不离他。 而今七事都更变，柴米油盐酱醋茶。</code></p>\n<p>这首诗说的就是，在过日子的洗礼中，各种生活琐事的变迁。恋爱是过日子的一部分，其实也是如此，也需要双方不断磨合。<code>这种磨合中的权重取舍平衡，就相等于深度学习中隐藏层的参数调整，它们需要不断地训练和修正！</code>恋爱双方相处，磨合是非常重要的。要怎么磨合呢？光说“520（我爱你）”，是廉价的。这就给我们程序猿（媛）提个醒，爱她（他），就要多陪陪她（他）。陪陪她（他），就增加了参数调整的机会。参数调整得好，输出的结果才能是你想要的。<br />\n<code>第三阶段稳定期，自然相当于深度学习的输出层。</code>输出结果是否合适，是否达到预期，高度取决于“隐藏层”的参数 “磨合”得怎么样。</p>\n<h1 id=\"人工智能与深度学习\">人工智能与深度学习</h1>\n<blockquote>\n<p>摘要:<br />\n现在的人工智能，大致就是用“硅基大脑”模拟或重现“碳基大脑的过程”。那么，在未来会不会出现“碳硅合一”的大脑或者全面超越人脑的“硅基大脑”呢？专家们的回答是“会的”。而由深度学习引领的人工智能，正在开启这样的时代。</p>\n</blockquote>\n<p>以上，我们仅仅泛泛而谈了机器学习、深度学习等概念，下面，我们将给出它的更加准确的形式化描述。<br />\n我们经常听到人工智能如何如何？深度学习怎样怎样？那么它们之间有什么关系呢？在本小节，我们首先从宏观上谈谈人工智能的“江湖定位”和深度学习的归属。然后再在微观上聊聊机器学习的数学本质是什么？以及我们为什么要用神经网络？</p>\n<h2 id=\"7-人工智能的江湖定位\">7. 人工智能的“江湖定位”</h2>\n<p>宏观上来看， 人类科学和技术的发展，大致都遵循着这样的规律：<code>现象观察、理论提取和人工模拟（或重现）。</code><br />\n人类“观察大脑”的历史由来已久，但由于对大脑缺乏“深入认识”，常常“绞尽脑汁”，也难以“重现大脑”。<br />\n直到上个世纪40年代以后，脑科学、神经科学、心理学及计算机科学等众多学科，取得了一系列重要进展，使得人们对大脑的认识相对“深入”，从而为科研人员从“观察大脑”到“重现大脑”搭起了桥梁，哪怕这个桥梁到现在还仅仅是个并不坚固的浮桥。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210329160743895.png\" alt=\"在这里插入图片描述\" /></p>\n<p>而所谓的“重现大脑”，在某种程度上，就是目前的研究热点——人工智能。简单来讲，人工智能就是为机器赋予人类的智能。<code>由于目前的机器核心部件是由晶体硅构成，所以可称之为“硅基大脑”。而人类的大脑主要由碳水化合物构成，因此可称之为“碳基大脑”。</code><br />\n那么， 现在的人工智能，通俗来讲，大致就是用“硅基大脑”模拟或重现“碳基大脑”。 那么，在未来会不会出现“碳硅合一”的大脑或者全面超越人脑的“硅基大脑”呢？<br />\n有人就认为，在很大程度上，这个答案可能是“会的”！比如说，未来预言大师雷·库兹韦尔（Ray<br />\nKurzweil）就预测，到2045年，人类的“奇点”时刻就会临近。这里的“奇点”是指，人类与其他物种（物体）的相互融合，更确切来说，是硅基智能与碳基智能兼容的那个奇妙时刻。</p>\n<h2 id=\"8-深度学习的归属\">8. 深度学习的归属</h2>\n<p>在当下，虽然深度学习领跑人工智能。但事实上，人工智能研究领域很广，包括机器学习、计算机视觉、专家系统、规划与推理、语音识别、自然语音处理和机器人等。而机器学习又包括<code>深度学习、监督学习、无监督学习</code>等。简单来讲，机器学习是实现人工智能的一种方法，而深度学习仅仅是实现机器学习的一种技术而已。<br />\n<img src=\"https://img-blog.csdnimg.cn/2021032916080478.png\" alt=\"在这里插入图片描述\" /></p>\n<p>需要说明的是，对人工智能做任何形式的划分，都可能是有缺陷的。在图中，人工智能的各类技术分支，彼此泾渭分明，但实际上，它们之间却可能阡陌纵横，比如说深度学习是无监督的。语音识别可以用深度学习的方法来完成。再比如说，图像识别、机器视觉更是当前深度学习的拿手好戏。<br />\n一言蔽之， <code>人工智能的分支并不是一个有序的树，而是一个彼此缠绕的灌木丛。</code><br />\n有时候，一个分藤蔓比另一个分藤蔓生长得快，并且处于显要地位，那么它就是当时的研究热点。<code>深度学习的前生——神经网络的发展，就是这样的几起几落。</code>当下，深度学习如日中天，但会不会也有“虎落平阳被犬欺”的一天呢？从事物的发展规律来看，这一天肯定会到来！<br />\n在上图中，既然我们把深度学习和传统的监督学习和无监督学习单列出来，自然是有一定道理的。这就是因为，深度学习是高度数据依赖型的算法，它的性能通常随着数据量的增加而不断增强，也就是说它的可扩展性（Scalability）显著优于传统的机器学习算法。<br />\n<img src=\"https://img-blog.csdnimg.cn/20210329160845117.png\" alt=\"在这里插入图片描述\" /></p>\n<p>但如果训练数据比较少，深度学习的性能并不见得就比传统机器学习好。其潜在的原因在于，作为复杂系统代表的深度学习算法，只有数据量足够多，才能通过训练，在深度神经网络中，“恰如其分”地将把蕴含于数据之中的复杂模式表征出来。<br />\n不论机器学习，还是它的特例深度学习，在大致上，都存在两个层面的分析：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2021032916085627.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>面向过去（对收集到的历史数据，用作训练），发现潜藏在数据之下的模式，我们称之为<code>描述性分析（Descriptive Analysis）</code>；</li>\n<li>面向未来，基于已经构建的模型，对于新输入数据对象实施预测，我们称之为<code>预测性分析（Predictive Analysis）</code>。</li>\n</ul>\n<p><code>前者主要使用了“归纳”，而后者更侧重于“演绎”</code>。对历史对象的归纳，可以让人们获得新洞察、新知识，而对新对象实施演绎和预测，可以使机器更加智能，或者说让机器的某些性能得以提高。二者相辅相成，均不可或缺。<br />\n在前面的部分，我们给予机器学习的概念性描述，下面我们给出机器学习的形式化定义。</p>\n<h2 id=\"9-机器学习的形式化定义\">9. 机器学习的形式化定义</h2>\n<p>在《未来简史》一书中，尤瓦尔•赫拉利说，根据数据主义的观点，人工智能实际上就是找到一种高效的“电子算法”，用以代替或在某项指标上超越人类的“生物算法”。那么，任何一个“电子算法”都要实现一定的功能（Function），才有意义。<br />\n在计算机术语中，中文将“Function”翻译成“函数”，这个多少有点扯淡，因为它的翻译并没有达到“信达雅”的标准，除了给我们留下一个抽象的概念之外，什么也没有剩下来。但这一称呼已被广为接受，我们也只能“约定俗成”地把“功能”叫做“函数”了。<br />\n根据<code>台湾大学李宏毅博士</code>的说法，所谓机器学习，在形式上，可近似等同于在数据对象中，通过统计或推理的方法，寻找一个适用特定输入和预期输出功能函数。习惯上，我们把输入变量写作大写的X<br />\n，而把输出变量写作大写的Y 。那么所谓的机器学习，在形式上，就是完成如下变换：Y= f(X)</p>\n<p>针对下棋博弈功能，如果输入的是一个围棋的棋谱局势（比如AlphaGO）X，那么Y能输出这个围棋的下一步“最佳”走法。<br />\n<img src=\"https://img-blog.csdnimg.cn/2021032916100311.png\" alt=\"在这里插入图片描述\" /></p>\n<p>类似地，对于具备智能交互功能的系统（比如微软的小冰），当我们给这个函数X输入诸如“How are you？”，那么Y就能输出诸如“I am<br />\nfine，thank you？”等智能的回应。</p>\n<p>每个具体的输入，都是一个实例（instance），它通常由特征空间（feature<br />\nvector）构成。在这里，所有特征向量存在的空间称为特征空间（feature space），特征空间的每一个维度，对应于实例的一个特征。</p>\n<p>但问题来了，这样“好用的”函数并不那么好找。当输入一个猫的图像后，这个函数并不一定就能输出它就是一只猫，可能它会错误地输出为一条狗或一条蛇。</p>\n<p>这样一来，我们就需要构建一个评估体系，来辨别函数的好坏（Goodness）。当然，这中间自然需要训练数据（training<br />\ndata）来“培养”函数的好品质。在第一小节中，我们提到，学习的核心就是性能改善，在下图中，通过训练数据，我们把f1改善为f2的样子，性能（判定的准确度）得以改善了，这就是学习！很自然，这个学习过程如果是在机器上完成的，那就是“机器学习”了。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210329161037720.png\" alt=\"在这里插入图片描述\" /></p>\n<p>具体说来，机器学习要想做得好，需要走好三大步：</p>\n<p>如何找一系列函数来实现预期的功能，这是建模问题。<br />\n如何找出一组合理的评价标准，来评估函数的好坏，这是评价问题。<br />\n如何快速找到性能最佳的函数，这是优化问题（比如说，机器学习中梯度下降法干的就是这个活）。</p>\n<h2 id=\"10-为什么要用神经网络\">10. 为什么要用神经网络？</h2>\n<p>我们知道，深度学习的概念源于人工神经网络的研究。含多隐层的多层感知机就是一种深度学习结构。所以说到深度学习，就不能不提神经网络。<br />\n那么什么是神经网络呢？有关神经网络的定义有很多。这里我们给出芬兰计算机科学家Teuvo<br />\nKohonen的定义（这老爷子以提出“自组织神经网络”而名扬人工智能领域）：“神经网络，是一种由具有自适应性的简单单元构成的广泛并行互联的网络，它的组织结构能够模拟生物神经系统对真实世界所作出的交互反应。”</p>\n<p>在机器学习中，<code>我们常常提到“神经网络”，实际上是指“神经网络学习”</code>。学习是大事，不可忘记！<br />\n那为什么我们要用神经网络学习呢？这个原因说起来，有点“情非得已”。<br />\n我们知道，在人工智能领域，有两大主流门派。第一个门派是<code>符号主义</code>。符号主义的理念是，知识是信息的一种表达形式，人工智能的核心任务，就是处理好知识表示、知识推理和知识运用。这个门派核心方法论是，自顶向下设计规则，然后通过各种推理，逐步解决问题。很多人工智能的先驱（比如CMU的赫伯特•西蒙）和逻辑学家，很喜欢这种方法。但这个门派的发展，目前看来并不太好。未来会不会“峰回路转”，现在还不好说。</p>\n<p>还有一个门派，就是试图编写一个通用模型，然后通过数据训练，不断改善模型中的参数，直到输出的结果符合预期，这个门派就是<code>连接主义</code>。连接主义认为，人的思维就是某些神经元的组合。因此，可以在网络层次上模拟人的认知功能，用人脑的并行处理模式，来表征认知过程。这种受神经科学的启发的网络，被称之人工神经网络（Artificial<br />\nNeural Network，简称ANN）。目前，这个网络的升级版，就是目前非常流行的深度学习。</p>\n<p>前面我们提到，<code>机器学习在本质就是寻找一个好用的函数。而人工神经网络最“牛逼”的地方在于，它可以在理论上证明：只需一个包含足够多神经元的隐藏层，多层前馈网络能以任意精度逼近任意复杂度的连续函数。</code>这个定理也被称之为通用近似定理（Universal<br />\nApproximation<br />\nTheorem）。这里的“Universal”，也有人将其翻译成“万能的”，由此可见，这个定理的能量有多大。换句话说，神经网络可在理论上解决任何问题，这就是目前深度学习能够“牛逼哄哄”最底层的逻辑（当然，大数据+大计算也功不可没，后面还会继续讨论）。</p>\n<h2 id=\"11-小结\">11. 小结</h2>\n<p>在本文中，我们回顾了“机器学习”的核心要素，那就是通过对数据运用，依据统计或推理的方法，让计算机系统的性能得到提升。而深度学习，则是把由人工选取对象特征，变更为通过神经网络自己选取特征，为了提升学习的性能，神经网络的表示学习的层次较多（较深）。</p>\n<p>然后，我们首先谈了谈人工智能的“江湖定位”，然后指出深度学习仅仅是人工智能研究的很小的一个分支，接着我们给出了机器学习的形式化定义。最后我们回答了为什么人工神经网络能“风起云涌”，简单来说，在理论上可以证明，它能以任意精度逼近任意形式的连续函数，而机器学习的本质，不就是要找到一个好用的函数嘛？</p>\n<p>在下小节，我们将深度解读什么是激活函数，什么是卷积？</p>\n<h2 id=\"12-请你思考\">12. 请你思考</h2>\n<p>学完前面的知识，请你思考如下问题（掌握思辨能力，好像比知识本身更重要）：</p>\n<ul>\n<li>在大数据时代，你是赞同科技编辑出生的克里斯﹒安德森的观点呢（仅需简单模型甚至无模型），还是更认可工业界大神余凯先生的观点呢（还是需要复杂模型）？为什么？</li>\n<li>你认可库兹韦尔“到2045年人类的奇点时刻就会临近”的观点吗？为什么？库兹韦尔的预测，属于科学的范畴吗？（提示：可以从波普尔的科学评判的标准——是否具备可证伪性分来析。）</li>\n<li>深度学习的性能，高度依赖性于训练数据量的大小？这个特性是好还是坏？（提示：在《圣经》中有七宗原罪，其中一宗罪就是暴食，而原罪就是“deadly sin”，即死罪。目前，深度学习贪吃数据和能量，能得以改善吗？）<br />\n写下你的心得体会，祝你每天都有进步！</li>\n</ul>\n', 1, '', 0, 0, 1, '2022-10-17 16:59:41', '2022-10-17 16:59:41');
INSERT INTO `tb_article` VALUES (297, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=1962', '人工智能：通俗易懂理解深度学习与神经网络', '<p>﻿# 前言<br />\n初入学习人工智能领域，为方便对该领域有一个快速清晰的认识，因此收集了相关资料并整理了各位前辈们在此领域的研究现状。由浅入深、循序渐进理解什么是深度学习和神经网络，二者的联系和区别是什么，以及什么是人工神经网络、卷积神经网络等。无需技术背景也可以有一个比较全面清晰的认识。同时也介绍一下<code>TensorFlow</code>、<code>Caffe</code>、<code>Pytorch</code>等深度学习框架和目前工业界深度学习应用比较广的领域。</p>\n<h1 id=\"1-人工智能机器学习深度学习\">1. 人工智能、机器学习、深度学习</h1>\n<p>在介绍深度学习之前，先和大家介绍一下AI和Machine Learning，才能理清AI、Machine Learning、Deep Learning三者之间的关系。</p>\n<h2 id=\"11-人工智能是什么\">1.1 人工智能是什么</h2>\n<p>1956年8月，在美国汉诺斯小镇的达特茅斯学院中，几位科学家在会议上正式提出“<code>人工智能</code>”这一概念，这一年也被称为人工智能元年。在此之前，人类已经制造出各类各样的机器如汽车、飞机等，但这些机器都需要经过人来操作使用，无法自己具备操作的能力。科学家探讨能不能制造出一个可以像人类大脑的一样思考的机器，拥有人类的智慧，这就是人工智能。</p>\n<p>同时科学家们也对AI未来的发展畅想了三个阶段：<br />\n<img src=\"https://img-blog.csdnimg.cn/637f6407c65f4a65bfc0c101d157cde9.png\" alt=\"在这里插入图片描述\" /><br />\n大家在电影上看到的各种AI都是强人工智能，但目前我们仍处在弱人工智能阶段，什么时候进入强人工智能阶段未知。强人工智能阶段，机器可以完美媲美人脑，像人类一样有情感地、批判性地去思考。同时可以快速学习，拥有极强的自学能力。</p>\n<p>那么如何实现人工智能，实现人工智能的方法是什么？</p>\n<h2 id=\"12-机器学习是什么\">1.2 机器学习是什么</h2>\n<p>实现人工智能的方法我们统称为“机器学习”。同样是1956年的美国达特茅斯会议上，IBM的工程师Arthur Samuel正式提出“Machine Learning”这个概念，1956年真的是特殊的一年。</p>\n<p>机器学习既是一种实现AI的方法，又是一门研究如何实现AI的学科，你可以理解为和数学、物理一样的学科。机器学习，简单来说就是从历史数据中学习规律，然后将规律应用到未来中。国内大家一致推荐的，南京大学周志华教授的机器学习教材西瓜书里面如此介绍机器学习。<br />\n<img src=\"https://img-blog.csdnimg.cn/b987e5ed7fc94a7383602a3f64994c50.png\" alt=\"机器学习\" /><br />\n机器学习是机器从历史数据中学习规律，来提升系统的某个性能度量。其实人类的行为也是通过学习和模仿得来的，所以我们就希望计算机和人类的学习行为一样，从历史数据和行为中学习和模仿，从而实现AI。</p>\n<p><strong>简单点讲</strong>，大家从小到大都学习过数学，刷过大量的题库。老师和我们强调什么？要学会去总结，从之前做过的题目中，总结经验和方法。总结的经验和方法，可以理解为就是机器学习产出的模型，然后我们再做数学题利用之前总结的经验和方法就可以考更高的分。有些人总结完可以考很高的分，说明他总结的经验和方法是对的，他产出的的模型是一个好模型。</p>\n<p>既然有了机器学习这一方法论，科学家们基于这一方法论，慢慢开始提出各类各样的算法和去解决各种“智能”问题。就像在物理学领域，物理学家们提出各种各样的定理和公式，不断地推动着物理学的进步。牛顿的三大定律奠定了经典力学的基础。而传统机器学习的决策树、贝叶斯、聚类算法等奠定了传统机器学习的基础。</p>\n<h2 id=\"13-深度学习是什么\">1.3 深度学习是什么</h2>\n<p>但是随着研究的不断深入，传统机器学习算法在很多“智能”问题上效果不佳，无法实现真正的“智能”。就像牛顿三大定律，无法解释一些天文现象。在1905年，爱因斯坦提出“相对论”，解释了之前牛顿三大定律无法解释的天文现象。同样2006年，加拿大多伦多大学教授Geoffrey Hinton对传统的神经网络算法进行优化，在此基础上提出了Deep Neural Network的概念，他们在《Science》上发表了一篇Paper，引起Deep Learning在学术界研究的热潮。（paper原文：<a href=\"http://www.cs.toronto.edu/~hinton/science.pdf\">http://www.cs.toronto.edu/~hinton/science.pdf</a>）</p>\n<p>2012年Geoffrey Hinton老爷子的课题组，在参加业界知名的ImageNet图像识别大赛中，构建的CNN网络AlexNet一举夺得冠军，且碾压第二名（SVM方法）。也正是因为该比赛，Deep Learning引起了工业界的关注，迅速将Deep Learning引进到工业界的应用上。深度学习技术解决了很多传统机器学习算法效果不佳的“智能”问题，尤其是图片识别、语音识别和语义理解等。某种程度上，深度学习就是机器学习领域的相对论。</p>\n<p>将人工智能和机器学习带到一个新高度的技术就是：Deep Learning。深度学习是一种机器学习的技术。</p>\n<p>同时大家应该听到过一大堆的“学习”名词：机器学习、深度学习、强化学习等等。在这里面机器学习是“爸爸”，是父节点；其他都是它“儿子”，是子节点。AI、Machine Learning和Deep Learning的关系可以通过下图进行描述。<br />\n<img src=\"https://img-blog.csdnimg.cn/501cc5dc9c52480ba7360d7cb14e7c00.png\" alt=\"机器学习\" /><br />\n让机器实现人工智能是人类的一个美好愿景，而机器学习是实现AI的一种方法论，深度学习是该方法论下一种新的技术，在图像识别、语义理解和语音识别等领域具有优秀的效果。</p>\n<p>那么深度学习到底是一门什么技术？“深度”到底代表什么？</p>\n<h1 id=\"2-深度学习与神经网络\">2. 深度学习与神经网络</h1>\n<h2 id=\"21-生物神经网络\">2.1 生物神经网络</h2>\n<p>介绍深度学习就必须要介绍神经网络，因为深度学习是基于神经网络算法的，其实最开始只有神经网络算法，上文也提到2006年Geoffrey Hinton老爷子提出Deep Learning，核心还是人工神经网络算法，换了一个新的叫法，最基本的算法没有变。学过生物的都知道神经网络是什么？下图是生物神经网络及神经元的基本组成部分。<br />\n<img src=\"https://img-blog.csdnimg.cn/69a9ef96cd1f4d2684f8a69cae5cd082.png\" alt=\"生物神经网络\" /><br />\n人类的大脑可以实现如此复杂的计算和记忆，就完全靠900亿神经元组成的神经网络。那么生物神经网络是如何运作的？可以参照下图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/f2d8dd283f354cb7994e21823d08c89c.png\" alt=\"在这里插入图片描述\" /><br />\n通过神经元接收外界信号，达到一定阈值，触发动作电位，通过突触释放神经递质，可以是兴奋或抑制，影响突触后神经元。通过此实现大脑的计算、记忆、逻辑处理等，进行做出一系列行为等。同时不断地在不同神经元之间构建新的突触连接和对现有突触进行改造，来进行调整。有时候不得不感叹大自然的鬼斧神工，900亿神经元组成的神经网络可以让大脑实现如此复杂的计算和逻辑处理。</p>\n<h2 id=\"22-深度学习概述\">2.2 深度学习概述</h2>\n<p>深度学习（Deep Learning）最早是由 Hinton 等在2015年提出的概念，深度学习作为机器学习的一种，能够胜任许多复杂的任务。它从提出至今已经有了长足的发展，在各个领域和学科有广泛的应用<code>（侯宇青阳等，2017）</code>。<br />\n深度学习可以从广泛的数据中提取特征进行学习，典型的应用有文字识别，语音识别和图像识别，各种新的深度学习网络层出不穷，各个领域的应用也逐渐成熟。在实际应用领域，<code>“深度学习”这一名词指的是训练神经网络，使其学习特征并完成不同任务</code>，而神经网络这一结构也出现了各种各样的分支，但万变不离其宗，神经网络的基本结构和原理总体没有太大变化。作为深度学习的起源，人工神经网络经过了长时间的发展，经过了低谷和高潮发展期，随后出现了<strong>卷积神经网络</strong>，彻底的改变了深度学习领域的格局。</p>\n<h2 id=\"23-人工神经网络\">2.3 人工神经网络</h2>\n<p>科学家们从生物神经网络的运作机制得到启发，构建了人工神经网络。其实人类很多的发明都是从自然界模仿得来的，比如飞机和潜艇等。下图是最经典的MP神经元模型，是1943年由科学家McCulloch和Pitts提出的，他们将神经元的整个工作过程抽象为下述的模型。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d5cf0e0162174687b3512da24358a079.png\" alt=\"人工神经网络\" /></p>\n<ul>\n<li>\n<p><strong>x_1，x_2，x_3，x_n</strong>：模拟生物神经网络中来自其他神经元的输入；</p>\n</li>\n<li>\n<p><strong>ω_1，ω_2，ω_3，ω_n</strong>：模拟生物神经网络中每个神经元对外接收的突触强度不同，所以外界接收的输入乘以一定权重；</p>\n</li>\n<li>\n<p><strong>Σ-Sum</strong>：模拟生物神经网络中神经元对外接收的信号进行累加汇总；</p>\n</li>\n<li>\n<p><strong>Bias</strong>：模拟生物神经网络中神经元的一般敏感性。每个神经元的敏感性不同，所以需要一定的偏差来调整汇总值；</p>\n</li>\n<li>\n<p><strong>Activation Function</strong>：模拟生物神经网络中信号累积到一定程度产生的动作电位，当累积到一定程度就会“激活”动作电位。实际使用时我们一般使用Sigmoid函数；</p>\n</li>\n<li>\n<p><strong>Output</strong>：模拟生物神经网络中神经元对外释放的新的信号；</p>\n</li>\n</ul>\n<p>现在我们知道了最简单的神经元模型，我们该如何使用该模型从历史数据中进行学习，推导出相关模型？</p>\n<p><code>人工神经网络（Artificial Neural Network）是模拟人脑神经细胞工作原理所构造的网络结构</code>，人工神经网络自上世纪 80 年代以来兴起，成为人工智能领域的热点。</p>\n<p>人工神经网络仿照人脑神经系统的工作方式，利用数学模型对神经网络进行抽象化表述，按照不同的方式将其相连接，构建复杂网络。人工神经网络与人类神经相似，是由人工神经元组成的。</p>\n<h3 id=\"231-人工神经元\">2.3.1 人工神经元</h3>\n<p>人工神经元这一概念是由美国神经生理学家Mcculloch和数学家Pitts在1943年提出的，他们提出的人工神经元模型叫做 M-P 神经元<code>（Mcculloch et al.，1943）</code>。人工神经网络的结构为大量神经元相互连接构成，其中的每个神经元被称为一个节点，神经元是人工神经网络中的最小单位。M-P 神经元的结构下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/359f268dc16e42c2ae8ab34aa349e8aa.png\" alt=\"MP神经元结构\" /></p>\n<center>图：M-P神经元结构</venter>\n由上图可以看出 M-P 人工神经元的输入为来自不同神经元的信号 x1，x2和x3，通过神经元的两个函数 g（x）和f（x）进行计算，最后将结果 y进行输出。 \n<p>人工神经网络中每一个神经元都有着特定的计算函数和输出函数，这两个函数分别叫做<strong>整合函数</strong>（Combination Function）和<strong>激活函数</strong>（Activation Function），其中整合函数把来自不同神经元的输入值进行整合计算变为一个综合信号，然后通过激活函数将综合信号进行计算，产生激活信号并将其输出。</p>\n<p>目前常用的整合函数主要分为<strong>加权求和型函数</strong>（Weight Sum Function），此函数被广泛的应用在整合函数中。它将输入值按照不同的权值进行加权求和。计算完成后的结果要经过激活函数的激活，常用的激活函数有<code>阈值函数（Threshold Funtion）</code>，<code>线性函数（Linear Function）</code>，<code>逻辑 S 型函数（Logistic Sigmoid Function）</code>和<code>线性修正单元函数（Rectified Linear Unit Function）</code>，激活函数的目的为对整合函数的结果进行计算生成反馈输出值，将线性关系转化为非线性关系。<br />\n7<br />\n由图1可以看出 M-P 人工神经元的输入为来自不同神经元的信号 x1，x2和x3，通<br />\n过神经元的两个函数 g（x）和f（x）进行计算，最后将结果 y进行输出。<br />\n人工神经网络中每一个神经元都有着特定的计算函数和输出函数，这两个函数分别<br />\n叫做整合函数（Combination Function）和激活函数（Activation Function），其中整合函数<br />\n把来自不同神经元的输入值进行整合计算变为一个综合信号，然后通过激活函数将综合<br />\n信号进行计算，产生激活信号并将其输出。<br />\n目前常用的整合函数主要分为加权求和型函数（Weight Sum Function），此函数被广<br />\n泛的应用在整合函数中。它将输入值按照不同的权值进行加权求和。计算完成后的结果<br />\n要经过激活函数的激活，常用的激活函数有阈值函数（Threshold Funtion），线性函数<br />\n（Linear Function），逻辑 S 型函数（Logistic Sigmoid Function）和线性修正单元函数<br />\n（Rectified Linear Unit Function），激活函数的目的为对整合函数的结果进行计算生成反<br />\n馈输出值，将线性关系转化为非线性关系。</p>\n<h3 id=\"232-人工神经网络模型\">2.3.2 人工神经网络模型</h3>\n<p>神经网络是由神经元相互连接组成的网络，在人工神经网络中根据人工神经元不同的连接方式和信息传递的路径，人工神经网络大致分为两种类型，他们是前馈神经网络（Feedforward Neural Network）和反馈神经网络（Feedback Neural Network）。</p>\n<p>在<strong>前馈神经网络</strong>中，不存在信息的回路，信息的传输是逐层向前的，从前一层神经元到下一层神经元直至输出，在此过程中包括跨层传递，但是不存在信息回流的情况。</p>\n<p>而在<strong>反馈神经网络</strong>中，信息的传递是有回路的，信息可以由输出的位置传递回输入位置。</p>\n<h4 id=\"1前馈神经网络\">（1）前馈神经网络</h4>\n<p>前馈神经网络的结构明了，各层神经元排列规则，每层神经元只接收来自上一层输入值或神经元的输入，只把自己的输出传递给下一层神经元或输出结果，每一层不会收到后续层的反馈信号。前馈神经网络发展较早，由于其结构简单，逻辑性很强，发展速度较快，并且在多种场景都得到了广泛应用。最早的前馈神经网络为Frank Rosenblatt 提出的感知机，它就是一种简单的前馈神经网络。前馈神经网络是一种典型的单向结构，如果将整个前馈网络看作一个整体，那么它就是一个只包含一次处理的包含输入输出的结构。前馈神经网络根据隐含层的数量分为单层前馈网络和多层前馈网络，单层前馈神经网络只包含一个隐含层，神经元之间不存在跨层连接，输入信息经过隐含层直接进入输出层处理输出。而多层前馈神经网络有多个隐含层，多层前馈神经网络中存在跨层传输，多层前馈神经网络的结构如下图所示。<br />\n<img src=\"https://img-blog.csdnimg.cn/f4b723d606f34af9a9e0b44afe81aa49.png\" alt=\"前馈神经网络\" /></p>\n<center>图   多层前馈神经网络 \n<p>由上图可知前馈神经网络结构较为简单，但是通过多层神经元的非线性处理，前馈神经网络有很强的学习能力，可以处理复杂的非线性问题。常见的前馈神经网络有<code>反向传播（Back Propagation）</code>网络，<code>径向基函数（Radial Basis Function）</code>网络和<code>感知机（Perceptron）</code>等。</p>\n<h4 id=\"2反馈神经网络\">（2）反馈神经网络</h4>\n<p>反馈神经网络是一种网络结构中存在回路的神经网络，因为回路的存在使得其结构相比前馈神经网络更加复杂。在反馈神经网络中每一层的输出都可以作为前置神经元的输入，根据此特性反馈神经网络可以根据下层的输出来对本层或上层的参数进行调整，具有很强的优化计算能力。反馈神经网络的构如下图所示。根据下图可知在反馈神经网络中有着反向的数据传递，每层神经元可根据输出和输入的信息进行权值调整等工作，因此反馈神经网络在进行学习时可以不断的对自身的神经元进行调整，使其适合不同的任务，由此反馈神经网络的适应能力较强。但由于反馈神经网络结构中环路的存在，需要给反馈神经网络设置一个结束点或平衡点，即反馈神经网络的某输出达到一定要求后停止后层神经元对前层的反馈，将最终结果输出并结束网络的运行。常见的反馈神经网络有 Jeffrey L. Elman 提出的Elman网络（Elman，1990）和 John J. Hopfield等提出的 Hopfield网络（Hopfield et al.，985），其中 Elman网络的结构类似多层前馈神经网络，但它在隐含层中加了一个承接层，它可以将网络当前时刻隐含层的输出记录，经过延迟后反馈到隐含层的输入；在Hopfield网络中，每一个神经元都是跟其他神经元相互连接的，整个网络处在全连接状态，一个神经元的输出会反馈回它的输入位置，整个网络处在不断的变化中，若整个网络处于逐渐收敛状态，最终它会达到动态平衡，此时的输出值就是稳定的输出。<br />\n<img src=\"https://img-blog.csdnimg.cn/62b9f8791c1a47afa2bfac97f6704099.png\" alt=\"反馈神经网络结构\" /></p>\n<center>反馈神经网络结构图\n<h3 id=\"233人工神经网络原理\">2.3.3人工神经网络原理</h3>\n<p>人工神经网络因为其对复杂问题的较好适应性和学习能力，在各个领域广泛应用。</p>\n<p>人工神经网络的神经元结构决定了非线性问题的处理能力，相较于之前的信息处理方法有了很大的进步，随着科技的不断发展人工神经网络与其他技术逐渐结合有了更深层次的应用。人工神经网络的主要功能是建立解决实际问题的模型，而具体到神经元的角度就是不断地优化神经元的权值。</p>\n<p>人工神经网络的第一步工作就是进行训练，在此步骤中需要的训练数据为输入输出一一对应的，网络根据输入输出信息调整自身的神经元权值，使其不断收敛，直至输出最终模型。但在实际的任务中，有些数据是无法给出确定输出值的，这时需要人工神经网络根据输入和给定的规则进行学习。</p>\n<p>在上述叙述中，给定输入输出数据，让网络进行学习的方法叫做<strong>有监督学习（Supervised Learning）</strong>；而只给定输入数据，再给网络提供学习规则的方法叫做<strong>无监督学习（Supervised Learning）</strong>。</p>\n<p>在有监督学习任务中，最常见的任务是分类和回归。在分类任务中，首先要把分类数据进行分类，每种分类对应不同的标签，将多个分类标签和分类数据作为输出和输入值训练网络，网络在训练过程中会不断通过调整网络权值而找到所给数据和特征标签之间的关系，并向此关系不断收敛，最终给出可以解释分类数据和标签之间的合理模型。</p>\n<p>前苏联学者Vaonik 等提出的支持向量机（Support Vector Machine）是一种有监督学习网络，它是一种可靠的线性分类方法，通过学习训练数据和分类标签，支持向量机会生成一个超平面，以此对数据进行分类（Vaonik et al.，1963）。而在回归任务中，人工神经网络需要根据给定的输入数据和输出数据计算最佳的映射算法，使输入数据能很好的映射到输出数据上。</p>\n<p>无监督学习在处理分析聚类问题中广为应用，无监督学习需要训练数据和给定的规则进行训练，网络根据数据和规则学习数据之间的联系，网络不断收敛直至输出最佳的预测模型，使其符合给定规则。</p>\n<p>在无监督学习中最重要的一条学习规则莫过于 Hebb 等提出的 Hebb 学习规则，它的具体内容为根据网络神经元的输入和输出值来调整神经元权值。按照此规则学习的网络能对数据进行分类，根据对不同数据的认识程度划分类别，此特点与人类的认识能力非常相似。无监督学习的典型应用就是聚类，典型的聚类算法有K均值聚类算法（K-means clustering algorithm），它的规则为计算数据之间的欧氏距离，欧氏距离小的说明两个数据是一类，根据此规则不断计算数据之间的距离，直至完成所有数据的分类。</p>\n<p>人工神经网络为仿照神经系统的工作方式抽象出的人工网络结构，并且具有自适应和自学习功能，但在理论和技术的不断发展中，传统人工神经网络的缺点逐渐显现，例如无法有效处理大规模数据，处理时间过长，而且随着网络程度的加深会出现局部优化和梯度消失问题。2006 年 Hinton 等将人工神经网络的深度加到了 7 层，深度网络的概念产生（Hinton et al.，2006），卷积神经网络也由深度学习网络的发展得到了快速发展。</p>\n<h2 id=\"23-卷积神经网络概述\">2.3 卷积神经网络概述</h2>\n<p>“卷积”（convolution）一词是分析数学中的一种运算，是一种积分变换的方法，使用卷积计算的神经网络就叫做<strong>卷积神经网络（Convolutional Neural Network，CNN）</strong>。</p>\n<p>卷积神经网络大致在上世纪 80 年代起源，1980 年日本学者 Kunihiko Fukushima 提出了Neocognitron 模型（Fukushima，1980），他构造了一个具有特征提取能力的深度神经网络，此网络的功能与卷积神经网络类似，因此被认为是卷积神经网络研究的开始。1987年Alexander Waibel 等提出了时间延迟神经网络（Waibel et al.，1987），是第一个是真正意义上的卷积神经网络。在此之后不断有新的卷积神经网络被提出，随着计算机设备的性能逐渐提高，卷积神经网络的结构逐渐复杂深度不断加深。</p>\n<p>从 2012 年后卷积神经网络的发展速度大幅加快，网络性能逐渐提升，卷积神经网络在语义分割和目标检测等领域得到应用，逐渐成为图像表征学习和表征问题处理的主流方法<code>（严春满等，2021）</code>。卷积神经网络作为人工神经网络的一种，它的大体结构和人工神经网络一致，卷积神经网络在隐藏层之前加入了特征提取的结构，这个结构的主要内容就是卷积神经网络中的卷积和池化等运算。</p>\n<h3 id=\"233-卷积核\">2.3.3 卷积核</h3>\n<p>在图像处理领域，卷积核（Convolution kernel）是在图像处理时分配给像素相邻区域的空间权重矩阵，应用在卷积神经网络的特征提取部分。卷积核通过滑动窗口操作与图像的不同区域逐个进行卷积计算，计算完成后就能更清晰的发现图像中的某些特征。在卷积神经网络中卷积核是卷积层中重要组成部分，卷积核具有卷积核大小，步长等参数，以适应不同的处理任务。</p>\n<h3 id=\"232卷积层\">2.3.2卷积层</h3>\n<p>卷积层在卷积神经网络中的作用为图像特征提取，结构为多组卷积单元组成的卷积集合。在每个卷积单元进行卷积操作时，卷积核会对输入图像进行一遍扫描，输出的图像每一个像素只与输入图像的某一部分有关，而输出图像的尺寸仅与卷积核大小有关，因此在卷积神经网络中一个卷积单元中的参数只有卷积核的参数。基于卷积神经网络卷积层的结构，卷积层有两个最主要的特点，局部连接与权值共享。局部连接是指卷积层中每一层节点仅与它的上层节点的某一部分相连接，权值共享指卷积层中的卷积操作中多组卷积核共用同一组参数。通过局部连接和权值共享，卷积神经网络大大减少了网络参数，相较于全连接的神经网络，卷积神经网络提高了性能，同时避免了过拟合问题，连接数和参数的较少也进一步促进了神经网络深度的拓展。</p>\n<p>输入数据经过卷积层的特征提取后由激活函数进行激活，此时输入图像的特征被较好的保留下来，但这些特征中存在大量冗余信息，因此卷积层的输出会进入池化层，进行下一步的处理。</p>\n<h3 id=\"233池化层\">2.3.3池化层</h3>\n<p>池化层一般位于卷积神经网络中卷积层之后，池化层的主要作用是将来自卷积层的特征信息进行筛选，去除冗余信息，进一步精简特征，从而进一步减少网络参数，提高网络性能。池化层的运算较为简单，它的工作就是对输入特征图进行下采样（Downsampling）操作，池化层常用的池化方法有最大池化（Maximum Pooling）和平均池化（Average Pooling）.</p>\n<h3 id=\"234全连接层\">2.3.4全连接层</h3>\n<p>全连接层相当于前馈人工神经网络中的隐含层，它位于卷积层和池化层之后，全连接层和卷积层的结构非常相似，它的主要组成结构也是卷积单元，全连接层在卷积神经网络中的作用是对特征进行分类。来自池化层的特征图在到达全连接层后，每个特征图会与它相同尺寸的卷积核进行卷积操作，这些特征图经过卷积操作后变成了一个多维向量，将每个向量进行求和操作就得到了特征向量，为了使特征向量具有非线性，在特征向量进入下一层之前还需要经过激活函数的激活。</p>\n<p>在卷积神经网络中往往有不止一层的全连接层，若一个全连接层的前层为全连接层，它会将上层的特征向量与大小为 1×1 的卷积核进行卷积操作，输出本层的特征向量，最终输出的特征向量中的值就代表了输入图像中各种特征的类别。</p>\n<h2 id=\"24-何为深度\">2.4 何为”深度“</h2>\n<p>上文我们已经介绍了人工神经网络经典的MP模型，那么在深度学习里面我们使用的是什么样的神经网络，这个”深度“到底指的是什么？其实就是如下图所示的，输入层和输出层之间加更多的”Hidden Layer“隐藏层，加的越多越”深“。<br />\n<img src=\"https://img-blog.csdnimg.cn/8f5cf05bae2f442bb4c0837e8f813a6c.png\" alt=\"在这里插入图片描述\" /><br />\n最早的MP神经网络实际应用的时候因为训练速度慢、容易过拟合、经常出现梯度消失以及在网络层次比较少的情况下效果并不比其他算法更优等原因，实际应用的很少。中间很长一段时间神经网络算法的研究一直处于停滞状态。人们也尝试模拟人脑结构，中间加入更多的层”Hidden Layer“隐藏层，和人脑一样，输入到输出中间要经历很多层的突触才会产生最终的Output。加入更多层的网络可以实现更加复杂的运算和逻辑处理，效果也会更好。</p>\n<p>但是传统的训练方式也就是我Part 2.2里面介绍的：随机设定参数的初始值，计算当前网络的输出，再根据当前输出和实际Label的差异去更新之前设定的参数，直到收敛。这种训练方式也叫做Back Propagation方式。Back Propagation方式在层数较多的神经网络训练上不适用，经常会收敛到局部最优上，而不是整体最优。同时Back Propagation对训练数据必须要有Label，但实际应用时很多数据都是不存在标签的，比如人脸。</p>\n<p>当人们加入更多的”Hidden Layer“时，如果对所有层同时训练，计算量太大，根本无法训练；如果每次训练一层，偏差就会逐层传递，最终训练出来的结果会严重欠拟合（因为深度网络的神经元和参数太多了）。</p>\n<p>所以一直到2006年，Geoffrey Hinton老爷子提出了一种新的解决方案：<strong>无监督预训练对权值进行初始化+有监督训练微调</strong>。</p>\n<p>归纳一下Deep Learning与传统的神经网络算法最大的三点不同就是：</p>\n<ul>\n<li>\n<p><strong>训练数据</strong>：传统的神经网络算法必须使用有Label的数据，但是Deep Learning下不需要；</p>\n</li>\n<li>\n<p><strong>训练方式不同</strong>：传统使用的是Back Propagation算法，但是Deep Learning使用自下上升非监督学习，再结合自顶向下的监督学习的方式。对于监督学习和非监督学习概念不清楚的读者可以阅读我上文引用的强化学习文章，里面有详细介绍。</p>\n</li>\n<li>\n<p><strong>层数不同</strong>：传统的神经网络算法只有2-3层，再多层训练效果可能就不会再有比较大的提升，甚至会衰减。同时训练时间更长，甚至无法完成训练。但是Deep Learning可以有非常多层的“Hidden Layer”，并且效果很好。</p>\n</li>\n</ul>\n<p>(想了解更多细节的可以阅读：<a href=\"https://blog.csdn.net/zouxy09/article/details/8775518\">https://blog.csdn.net/zouxy09/article/details/8775518</a>)</p>\n<p>不管怎么样Deep Learning也还是在传统神经网络算法基础上演变而来的，它还是一种基于神经网络的算法。今天已经是2021年了，深度学习在很多领域得到了广泛的应用，而且和很多其他学习也结合起来一起使用，比如深度强化学习，有种物理化学专业的赶脚。</p>\n<p>MIT讲解了Deep Learning最新的一些研究和应用，详情可以关注这个B站视频：<a href=\"https://www.bilibili.com/video/BV1vg4y1B7Nz\">https://www.bilibili.com/video/BV1vg4y1B7Nz</a></p>\n<h1 id=\"3-深度学习框架\">3. 深度学习框架</h1>\n<p>大家了解深度学习和神经网络以后，相信大家也经常听到如下的英文单词：<code>Tensorflow</code>、<code>Caffe</code>、<code>Pytorch</code>等，这些都是做什么的了。Tensorflow是Google旗下的开源软件库，里面含有深度学习的各类标准算法API和数据集等，Pytorch是Facebook旗下的开源机器学习库，也包含了大量的深度学习标准算法API和数据集等。Caffe是贾扬清大神在UC Berkeley读博士时开发的深度学习框架，2018年时并入到了Pytorch中。</p>\n<p>因为深度学习发展至今，很多算法都已经是通用的，而且得到过验证的。那么有些公司就希望将一些标准算法一次性开发好，封装起来，后面再使用时直接调用引入即可，不需要再写一遍。就像大家小时候学习英文一样，英文字典有牛津版本的，也有朗文版本的。对于收录的英文单词，英文单词如何使用，如何造句等，已经有了标准的用法。我们只需要查阅这些字典即可，而Tensorflow、Caffe、Pytorch做的其实也就是计算机届的牛津、朗文英文大词典。国内百度目前也有自己的深度学习框架Paddle-Paddle。</p>\n<p>目前一般是学术界用Pytorch较多，Pytorch更适合新手入门，上手快。工业界用Tensorflow较多，更适合工业界的落地和部署等。</p>\n<h1 id=\"4-深度学习在工业界主要应用领域\">4. 深度学习在工业界主要应用领域</h1>\n<p>目前深度学习应用最广泛的就是传统机器学习算法解决不了的领域或者是效果不佳的领域：视觉、自然语言和语音识别领域。当样本数量少的时候，传统机器学习算法还可以通过一些结构化特征组合在一起然后区分出来。比如区分汽车和摩托车，可以通过轮子数量。但对于人脸，千万张人脸相似的太多，已经完全无法通过鼻子、头发、眼睛这些简单的特征组合进行区分。需要探索更多更复杂的特征，组合在一起才能将千万张人脸区分开来。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a1bb9f0e64ec4484b4abe9c302612c50.jpeg#pic_center\" alt=\"深度学习\" /><br />\n所以这时候就需要Deep Learning构建多层神经网络，探索组合更多的特征，才能识别区分千万级别甚至亿万级别的人脸。这在传统神经网络算法和机器学习算法是完全实现不了的。当然实现上述功能，也是因为现阶段有了更多的数据可以进行训练，同时有了更好的算力可以快速完成训练。传统的CPU进行训练，可能训练几个月都训练不出来结果。GPU的出现和改进加速了上述训练过程。</p>\n<p>目前应用最广的一些领域：</p>\n<ul>\n<li>\n<p><strong>CV</strong>（Computer Vision 简称CV）：计算机视觉领域。随处可见的人脸识别、物体识别和文字识别OCR。广泛应用于安防领域，同时零售行业也在通过CV技术实现线下门店的数字化。目前国内头部公司就是CV四小龙：商汤、旷视、云从、依图；</p>\n</li>\n<li>\n<p><strong>NLP</strong>（Natural Language Processing）：自然语言处理领域。目前整体的NLP技术还是不够成熟，无法实现人们设想的机器人可以完全智能对话，机器人目前只能做一些简单的信息提取和检索整合的事情。NLP目前也是最难做的，同样一句话可能会有不同种意思。人有时都很难理解，更何况机器。目前国内头部公司主要是百度和达观；</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/2475e1ace2e743cfb5765863b55093d1.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>\n<p>ASR：语音识别领域。目前国内独一档就是科大讯飞，尤其是能够做到很多地方方言的精准识别。语音识别目前主要主要用在语音客服上，有时候大家接到的推销电话其实背后都是电话机器人打的。电话机器人能够完全和用户进行对话，一定程度上也需要NLP的技术，因为它需要理解用户的意思。</p>\n</li>\n<li>\n<p>Autopilot：自动驾驶其实也是CV的衍生领域，目前世界上做自动驾驶最好的其实还是汽车公司比如特斯拉。因为没有车，自动驾驶想获得训练数据都很困难。没有车，自动驾驶技术想实验都跑不通。目前国内百度差不多算第一档。</p>\n</li>\n<li>\n<p>推荐：传统的推荐都是用GBDT+LR模型来做的，目前深度学习在推荐领域也得到了广泛的应用。</p>\n</li>\n</ul>\n<h1 id=\"5-参考资料\">5. 参考资料</h1>\n<ul>\n<li>[1]黄子琦. 基于深度学习麦穗识别的小麦估产研究[D].山东农业大学,2022.DOI:10.27277/d.cnki.gsdnu.2022.001057.</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/459993916\">https://zhuanlan.zhihu.com/p/459993916</a></li>\n<li>[1]李海洋. 基于图像处理和深度学习的麦穗识别与系统实现[D].河南农业大学,2021.DOI:10.27117/d.cnki.ghenu.2021.000046.</li>\n<li>等</li>\n</ul>\n', 1, '', 0, 0, 1, '2022-10-17 16:59:41', '2022-10-17 16:59:41');
INSERT INTO `tb_article` VALUES (298, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=4578', 'Xrdp：实现Windows通过远程桌面连接远程Linux桌面环境', '<p>﻿# 1、概述</p>\n<blockquote>\n<p>我们知道，我们日常通过<strong>vnc</strong>来远程管理linux图形界面，今天分享一工具<strong>Xrdp</strong>，它是一个开源工具，<strong>允许用户通过Windows RDP访问Linux远程桌面</strong>。 除了Windows RDP之外，xrdp工具还接受来自其他RDP客户端的连接，如FreeRDP，rdesktop和NeutrinoRDP。</p>\n</blockquote>\n<h1 id=\"2安装gnome默认桌面环境\">2、安装GNOME默认桌面环境</h1>\n<p>一般情况下我们安装Centos系统的时候都是使用的命令行模式，但是有些业务场景还是桌面模式看的更清楚，所以我们可以安装桌面环境来更清晰的操作系统，在Centos系统中用到的就是GNOME桌面</p>\n<p>安装命令：</p>\n<pre><code class=\"language-shell\">yum groupinstall &quot;X Window System&quot; -y\nyum group install &quot;GNOME&quot; -y\n</code></pre>\n<p>如果已安装，可以省略这一步</p>\n<h1 id=\"3安装xrdp\">3、安装Xrdp</h1>\n<pre><code class=\"language-shell\">yum install xrdp -y\n</code></pre>\n<p>启动Xrdp服务，并设置开机启动</p>\n<pre><code class=\"language-shell\">systemctl enable xrdp --now\n</code></pre>\n<p>查看Xrdp的启动状态</p>\n<pre><code class=\"language-shell\">systemctl status xrdp\n</code></pre>\n<p>输出如下显示成功<br />\n<img src=\"https://img-blog.csdnimg.cn/67f41a8ccbb14599b29239b3f38a12ca.png\" alt=\"在这里插入图片描述\" /></p>\n<h1 id=\"4配置xrdp\">4、配置Xrdp</h1>\n<p>设置Xrdp使用GNONE，编辑配置文件，添加如下行</p>\n<pre><code class=\"language-shell\">sudo vim /etc/xrdp/xrdp.ini\n</code></pre>\n<p>在文件最后添加如下一行</p>\n<pre><code class=\"language-shell\">exec gnome-session\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/693a0d76be3f4d8da124fe8cb7cff714.png\" alt=\"在这里插入图片描述\" /></p>\n<p>保存后，重启Xrdp服务</p>\n<pre><code class=\"language-shell\">sudo systemctl restart xrdp\n</code></pre>\n<h1 id=\"5配置防火墙如果启用了防火墙的话放行3389端口\">5、配置防火墙（如果启用了防火墙的话），放行3389端口</h1>\n<p>默认情况下，Xrdp监听3389端口<br />\n查询对应端口号</p>\n<pre><code class=\"language-shell\">firewall-cmd --query-port=3389/tcp\n</code></pre>\n<p>如果显示no，则开启<br />\n注意这条命令是 --add,加入端口号，上面那个是query查询端口号</p>\n<pre><code class=\"language-shell\">firewall-cmd --add-port=3389/tcp --permanent\n</code></pre>\n<p>然后重启防火墙</p>\n<pre><code class=\"language-shell\">firewall-cmd --reload\n</code></pre>\n<p>如果使用的是云服务器（如阿里云、华为云），还需要通过安全组规则放行3389端口。</p>\n<h1 id=\"6测试连接\">6、测试连接</h1>\n<p>使用windows自带的远程桌面客户端进行连接<br />\n<img src=\"https://img-blog.csdnimg.cn/12f912f6217b4b3ca70741e6b978c255.png\" alt=\"在这里插入图片描述\" /><br />\n输入Linux的用户名和密码等信息<br />\n<img src=\"https://img-blog.csdnimg.cn/2db89262382b44e9a0e6bccbe5c7b35f.png\" alt=\"在这里插入图片描述\" /></p>\n<p>登录成功<br />\n<img src=\"https://img-blog.csdnimg.cn/eaca1812172d448b94bcc16ea8ff3bb9.png\" alt=\"在这里插入图片描述\" /></p>\n', 1, '', 0, 0, 1, '2022-10-17 16:59:43', '2022-10-17 16:59:43');
INSERT INTO `tb_article` VALUES (299, 1, 1, 'http://api.btstu.cn/sjbz/?lx=m_meizi&time=9944', '边缘计算系统逻辑架构：云、边、端协同，定义及关系', '<p>﻿# 引言<br />\n５Ｇ和物联网时代的到来，海量数据的产生与任务计算对现有网络产生极大的冲击，基于Internet的云计算虽然提供了对虚拟共享的可配置计算和存储资源的广泛访问和按需访问，是处理海量数据与计算任务的绝佳平台，但是对于５Ｇ时代的诸如在线游戏、虚拟现实和超高清视频流等高速访问超低延时的应用和海量终端互联来说，云计算是无法满足其要求的。</p>\n<p>与此同时，下一代互联网的关键特征之一是信息越来越多地在本地生成并在本地消费，且大量的边缘设备存在可用计算和存储资源。因此，为应对云计算存在的挑战、网络压力和提升用户体验满足业务需求，业界提出将云计算平台迁移至网络边缘，即<strong>边缘计算</strong>，发掘网络的内在能力在数据源附近提供边缘服务，以满足在敏捷连接性、实时优化、智能应用、安全性和隐私性方面的关键要求.</p>\n<h1 id=\"1云-边-端架构\">1、“云-边-端”架构</h1>\n<p>在面向新一代信息基础设施的物联网体系架构中，数据处理以及基于数据的智能服务变得越来越重要。<br />\n前两年出现了一个比较热的词，叫做&quot;边缘计算&quot;，<strong>是指把简单的、需要实时计算和分析的过程放到离终端设备更近的地方，以保证数据数据处理的实时性，同时也减少数据传输的风险</strong>。<br />\n最近又出现了一个新的热词，叫做“云边协同”，其含义跟边缘计算相差不是很大，只是强调“云-边-端”这样的架构，终端负责全面感知，边缘负责局部的数据分析和推理，而云端则汇集所有边缘的感知数据、业务数据以及互联网数据，完成对行业以及跨行业的态势感知和分析。</p>\n<ul>\n<li><strong>“云”</strong> 是传统云计算的中心节点，是边缘计算的管控端；</li>\n<li><strong>“边”</strong> 是云计算的边缘侧，分为基础设施边缘和设备边缘；</li>\n<li><strong>“端”</strong> 是终端设备，如手机、智能家电、各类传感器、摄像头等。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/32391d16f05349fdadf159d00d7bc703.jpeg\" alt=\"在这里插入图片描述\" /><br />\n基于AI的智能服务则是贯穿“云-边-端”整个架构，在感知终端，AI技术旨在提高全面感知的敏感性、准确性以及人机交互、物物交互的实时性，同时也可以通过芯片来进行简单的逻辑推理。</p>\n<h3 id=\"在边缘处\">在边缘处</h3>\n<p>AI技术主要负责汇集该域内的局部数据以及相关的业务数据，完成感知数据的分析和推理，并且能够把相关的分析结果或模型传送给感知终端，达到感知终端与边缘云的协同，同时，边缘云与边缘云之间也可以通过联网共享，共享数据、资源、算法等，完成边缘云之间的相互协同。</p>\n<h3 id=\"在云端\">在云端</h3>\n<p>不仅需要提供类似边缘云的云计算相关的存储、计算、网络、安全资源，还需要汇集、融合所有的数据，提供基于全局数据的智能服务，包括智能调度、运维、宏观决策等。</p>\n<p>云中心擅长全局性的、非实时的、长周期的大数据处理与分析，能够在长周期维护、业务决策支撑等领域发挥优势。<br />\n边缘计算更适合局部性、实时、短周期数据的处理与分析，能更好地支撑本地业务的实时智能化决策与执行。<strong>边缘计算与云中心是互补协同的关系</strong>，边云协同将放大边缘计算与云计算的应用价值：边缘计算既靠近执行单元，更是云端所需高价值数据的采集和初步处理单元，可以更好地支撑云端应用；反之，云计算通过大数据分析处理优化输出的业务规则或模型可以下发到边缘侧，边缘计算基于新的业务规则或模型运行。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a4a8627c38c3467ebc4efcdeb4d35034.png\" alt=\"在这里插入图片描述\" /><br />\n从表中可以看出云计算和边缘计算是各有优势的，云计算的主要优势是海量计算和海量存储、计算效率高、广域覆盖，适合计算密集型、非实时性的计算任务和海量数据的并行计算与存储，能够在长周期维护、业务决策支撑等领域发挥优势，并且计算硬件都集中在云计算中心，实行集中式的管理，因此无需在本地维护计算硬件、数据存储和相关软件。</p>\n<p>边缘计算的主要优势是广泛分布的边缘节点提供了实时的数据处理，边缘计算的过程是一个以用户和应用为中心的过程，弥补了云计算中时延和移动性的缺陷，适合非计算密集型、实时性、移动性数据的处理分析和实时智能化决策，并且作为一种新的网络范式能够满足５Ｇ 时代计算需求的空前增长和用户体验质量的不断提高，数据的本地化处理相较于云端也更安全。</p>\n<p>但是，边缘平台的处理性能通常不如云平台，它通常没有足够的内存和处理器来处理大量数据，因此无法执行复杂的操作，例如深度学习</p>\n<p>除了云边协同，由图上图可知，逻辑架构侧重边缘计算系统云、边、端各部分之间的交互和协同，包括云、边协同，边、端协同和云、边、端协同3个部分。<br />\n<img src=\"https://img-blog.csdnimg.cn/d4836006163b4acd8e127b317e2580f4.jpeg\" alt=\"在这里插入图片描述\" /><img src=\"https://img-blog.csdnimg.cn/5040978608234acd9abcfa607f25b6c0.jpeg\" alt=\"请添加图片描述\" /></p>\n<ul>\n<li>1、<strong>云、边协同</strong>：通过云部分Kubernetes的控制节点和边部分KubeEdge所运行的节点共同实现。</li>\n</ul>\n<p><strong>Kubernetes</strong>控制节点沿用云部分原有的数据模型，保持原有的控制、数据流程不变，即KubeEdge所运行的节点在Kubernetes上呈现出来的是一个普通节点。Kubernetes可以像管理普通节点一样管理KubeEdge所运行的节点。<br />\n<strong>KubeEdge</strong>之所以能够运行在资源受限、网络质量不可控的边缘节点上，是因为KubeEdge在Kubernetes控制节点的基础上通过云部分的CloudCore和边缘部分的EdgeCore实现了对Kubernetes云计算编排容器化应用的下沉。<br />\n如下图所示：<br />\n<img src=\"https://img-blog.csdnimg.cn/30ae1ccfe9f544ae8c937c34c570c2c5.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>2、<strong>边、端协同</strong>：通过边部分KubeEdge和端部分EdgeX Foundry共同实现。</li>\n</ul>\n<p><strong>KubeEdge</strong>作为运行在边缘节点的管理程序，负责管理在边缘节点上应用负载的资源、运行状态和故障等。在一些的边缘计算系统中，KubeEdge为EdgeX Foundry服务提供所需的计算资源，同时负责管理EdgeX Foundry端服务的整个生命周期。<br />\n<strong>EdgeX Foundry</strong>是由KubeEdge管理的一套IoT SaaS平台。该平台以微服务的形式管理多种物联网终端设备。同时，EdgeX Foundry可以通过所管理的微服务采集、过滤、存储和挖掘多种物联网终端设备的数据，也可以通过所管理的微服务向多种物联网终端设备下发指令来对终端设备进行控制。<br />\n<img src=\"https://img-blog.csdnimg.cn/0e43e1f8e08848ebbda35cae05f157ba.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>3、<strong>云、边、端协同</strong>：通过云解决方案Kubernetes的控制节点、边缘解决方案KubeEdge和端解决方案EdgeX Foundry共同实现。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/cb094ba85d6e4e288c10fb54037f4b78.jpeg\" alt=\"在这里插入图片描述\" /><br />\n<img src=\"https://img-blog.csdnimg.cn/3b149efe136945058a3840327499170a.png\" alt=\"在这里插入图片描述\" /><br />\n<img src=\"https://img-blog.csdnimg.cn/d482de0b7f334d1185b7f76618dc5fea.png\" alt=\"在这里插入图片描述\" /><img src=\"https://img-blog.csdnimg.cn/3e88fb46292845858e465e55f5ea5450.jpeg\" alt=\"在这里插入图片描述\" /></p>\n<h2 id=\"参考资料\">参考资料</h2>\n<ul>\n<li><a href=\"https://item.jd.com/10032915115196.html\">深入理解边缘计算：云、边、端工作原理与源码分析 崔广章 之江实验室工程师撰写</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/51965926#\">物联网数据分析体系</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/2017375\">详解边缘计算系统逻辑架构：云、边、端协同</a></li>\n<li>基于软件定义网络的云边协同架构研究综述，【文章编号：１００７－１３０Ｘ（２０２１）０２－０２４２－１６】李　波，侯　鹏，牛　力，武　浩，丁洪伟，文章编号：１００７－１３０Ｘ（２０２１）０２－０２４２－１６</li>\n</ul>\n', 1, '', 0, 0, 1, '2022-10-17 16:59:43', '2022-10-17 16:59:43');

SET FOREIGN_KEY_CHECKS = 1;
